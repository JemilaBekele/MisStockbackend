
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model RolePermission
 * 
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model Branch
 * 
 */
export type Branch = $Result.DefaultSelection<Prisma.$BranchPayload>
/**
 * Model Shop
 * 
 */
export type Shop = $Result.DefaultSelection<Prisma.$ShopPayload>
/**
 * Model Store
 * 
 */
export type Store = $Result.DefaultSelection<Prisma.$StorePayload>
/**
 * Model StoreStock
 * 
 */
export type StoreStock = $Result.DefaultSelection<Prisma.$StoreStockPayload>
/**
 * Model ShopStock
 * 
 */
export type ShopStock = $Result.DefaultSelection<Prisma.$ShopStockPayload>
/**
 * Model StockLedger
 * 
 */
export type StockLedger = $Result.DefaultSelection<Prisma.$StockLedgerPayload>
/**
 * Model Log
 * 
 */
export type Log = $Result.DefaultSelection<Prisma.$LogPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model SubCategory
 * 
 */
export type SubCategory = $Result.DefaultSelection<Prisma.$SubCategoryPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model AdditionalPrice
 * 
 */
export type AdditionalPrice = $Result.DefaultSelection<Prisma.$AdditionalPricePayload>
/**
 * Model ProductBatch
 * 
 */
export type ProductBatch = $Result.DefaultSelection<Prisma.$ProductBatchPayload>
/**
 * Model UnitOfMeasure
 * 
 */
export type UnitOfMeasure = $Result.DefaultSelection<Prisma.$UnitOfMeasurePayload>
/**
 * Model Purchase
 * 
 */
export type Purchase = $Result.DefaultSelection<Prisma.$PurchasePayload>
/**
 * Model PurchaseItem
 * 
 */
export type PurchaseItem = $Result.DefaultSelection<Prisma.$PurchaseItemPayload>
/**
 * Model Transfer
 * 
 */
export type Transfer = $Result.DefaultSelection<Prisma.$TransferPayload>
/**
 * Model TransferItem
 * 
 */
export type TransferItem = $Result.DefaultSelection<Prisma.$TransferItemPayload>
/**
 * Model StockCorrection
 * 
 */
export type StockCorrection = $Result.DefaultSelection<Prisma.$StockCorrectionPayload>
/**
 * Model StockCorrectionItem
 * 
 */
export type StockCorrectionItem = $Result.DefaultSelection<Prisma.$StockCorrectionItemPayload>
/**
 * Model Sell
 * 
 */
export type Sell = $Result.DefaultSelection<Prisma.$SellPayload>
/**
 * Model SellItem
 * 
 */
export type SellItem = $Result.DefaultSelection<Prisma.$SellItemPayload>
/**
 * Model SellItemBatch
 * 
 */
export type SellItemBatch = $Result.DefaultSelection<Prisma.$SellItemBatchPayload>
/**
 * Model AddToCart
 * 
 */
export type AddToCart = $Result.DefaultSelection<Prisma.$AddToCartPayload>
/**
 * Model CartItem
 * 
 */
export type CartItem = $Result.DefaultSelection<Prisma.$CartItemPayload>
/**
 * Model Waitlist
 * 
 */
export type Waitlist = $Result.DefaultSelection<Prisma.$WaitlistPayload>
/**
 * Model SellStockCorrection
 * 
 */
export type SellStockCorrection = $Result.DefaultSelection<Prisma.$SellStockCorrectionPayload>
/**
 * Model SellStockCorrectionItem
 * 
 */
export type SellStockCorrectionItem = $Result.DefaultSelection<Prisma.$SellStockCorrectionItemPayload>
/**
 * Model SellStockCorrectionBatch
 * 
 */
export type SellStockCorrectionBatch = $Result.DefaultSelection<Prisma.$SellStockCorrectionBatchPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Status: {
  Active: 'Active',
  Inactive: 'Inactive',
  Suspended: 'Suspended'
};

export type Status = (typeof Status)[keyof typeof Status]


export const StockStatus: {
  Available: 'Available',
  Reserved: 'Reserved',
  Sold: 'Sold',
  Damaged: 'Damaged',
  Returned: 'Returned',
  Disposed: 'Disposed'
};

export type StockStatus = (typeof StockStatus)[keyof typeof StockStatus]


export const StockMovementType: {
  IN: 'IN',
  OUT: 'OUT',
  TRANSFER: 'TRANSFER',
  ADJUSTMENT: 'ADJUSTMENT',
  RETERN: 'RETERN'
};

export type StockMovementType = (typeof StockMovementType)[keyof typeof StockMovementType]


export const PaymentStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const TaxType: {
  PERCENT: 'PERCENT',
  FIXED: 'FIXED'
};

export type TaxType = (typeof TaxType)[keyof typeof TaxType]


export const DiscountType: {
  PERCENT: 'PERCENT',
  FIXED: 'FIXED'
};

export type DiscountType = (typeof DiscountType)[keyof typeof DiscountType]


export const TransferStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type TransferStatus = (typeof TransferStatus)[keyof typeof TransferStatus]


export const TransferEntityType: {
  STORE: 'STORE',
  SHOP: 'SHOP'
};

export type TransferEntityType = (typeof TransferEntityType)[keyof typeof TransferEntityType]


export const StockCorrectionReason: {
  PURCHASE_ERROR: 'PURCHASE_ERROR',
  TRANSFER_ERROR: 'TRANSFER_ERROR',
  EXPIRED: 'EXPIRED',
  DAMAGED: 'DAMAGED',
  MANUAL_ADJUSTMENT: 'MANUAL_ADJUSTMENT'
};

export type StockCorrectionReason = (typeof StockCorrectionReason)[keyof typeof StockCorrectionReason]


export const StockCorrectionStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type StockCorrectionStatus = (typeof StockCorrectionStatus)[keyof typeof StockCorrectionStatus]


export const SaleStatus: {
  NOT_APPROVED: 'NOT_APPROVED',
  PARTIALLY_DELIVERED: 'PARTIALLY_DELIVERED',
  APPROVED: 'APPROVED',
  DELIVERED: 'DELIVERED',
  CANCELLED: 'CANCELLED'
};

export type SaleStatus = (typeof SaleStatus)[keyof typeof SaleStatus]


export const ItemSaleStatus: {
  PENDING: 'PENDING',
  DELIVERED: 'DELIVERED'
};

export type ItemSaleStatus = (typeof ItemSaleStatus)[keyof typeof ItemSaleStatus]


export const SellStockCorrectionStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type SellStockCorrectionStatus = (typeof SellStockCorrectionStatus)[keyof typeof SellStockCorrectionStatus]


export const DocumentType: {
  CONTRACT: 'CONTRACT',
  CV: 'CV',
  REPORT: 'REPORT',
  CERTIFICATE: 'CERTIFICATE',
  ID_CARD: 'ID_CARD',
  PASSPORT: 'PASSPORT',
  LICENSE: 'LICENSE',
  OTHER: 'OTHER',
  Lease: 'Lease'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const NotificationType: {
  SELL_READY_FOR_DELIVERY: 'SELL_READY_FOR_DELIVERY',
  SELL_CANCELLED: 'SELL_CANCELLED',
  Payment: 'Payment',
  Inventory: 'Inventory',
  System: 'System',
  Approval: 'Approval'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const RelatedEntityType: {
  SELL: 'SELL',
  MaintenanceRequest: 'MaintenanceRequest',
  Invoice: 'Invoice',
  PurchaseOrder: 'PurchaseOrder',
  InventoryRequest: 'InventoryRequest'
};

export type RelatedEntityType = (typeof RelatedEntityType)[keyof typeof RelatedEntityType]

}

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type StockStatus = $Enums.StockStatus

export const StockStatus: typeof $Enums.StockStatus

export type StockMovementType = $Enums.StockMovementType

export const StockMovementType: typeof $Enums.StockMovementType

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type TaxType = $Enums.TaxType

export const TaxType: typeof $Enums.TaxType

export type DiscountType = $Enums.DiscountType

export const DiscountType: typeof $Enums.DiscountType

export type TransferStatus = $Enums.TransferStatus

export const TransferStatus: typeof $Enums.TransferStatus

export type TransferEntityType = $Enums.TransferEntityType

export const TransferEntityType: typeof $Enums.TransferEntityType

export type StockCorrectionReason = $Enums.StockCorrectionReason

export const StockCorrectionReason: typeof $Enums.StockCorrectionReason

export type StockCorrectionStatus = $Enums.StockCorrectionStatus

export const StockCorrectionStatus: typeof $Enums.StockCorrectionStatus

export type SaleStatus = $Enums.SaleStatus

export const SaleStatus: typeof $Enums.SaleStatus

export type ItemSaleStatus = $Enums.ItemSaleStatus

export const ItemSaleStatus: typeof $Enums.ItemSaleStatus

export type SellStockCorrectionStatus = $Enums.SellStockCorrectionStatus

export const SellStockCorrectionStatus: typeof $Enums.SellStockCorrectionStatus

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type RelatedEntityType = $Enums.RelatedEntityType

export const RelatedEntityType: typeof $Enums.RelatedEntityType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.branch`: Exposes CRUD operations for the **Branch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branch.findMany()
    * ```
    */
  get branch(): Prisma.BranchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shop`: Exposes CRUD operations for the **Shop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shops
    * const shops = await prisma.shop.findMany()
    * ```
    */
  get shop(): Prisma.ShopDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.store`: Exposes CRUD operations for the **Store** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stores
    * const stores = await prisma.store.findMany()
    * ```
    */
  get store(): Prisma.StoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.storeStock`: Exposes CRUD operations for the **StoreStock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoreStocks
    * const storeStocks = await prisma.storeStock.findMany()
    * ```
    */
  get storeStock(): Prisma.StoreStockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shopStock`: Exposes CRUD operations for the **ShopStock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShopStocks
    * const shopStocks = await prisma.shopStock.findMany()
    * ```
    */
  get shopStock(): Prisma.ShopStockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockLedger`: Exposes CRUD operations for the **StockLedger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockLedgers
    * const stockLedgers = await prisma.stockLedger.findMany()
    * ```
    */
  get stockLedger(): Prisma.StockLedgerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.log`: Exposes CRUD operations for the **Log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.log.findMany()
    * ```
    */
  get log(): Prisma.LogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subCategory`: Exposes CRUD operations for the **SubCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubCategories
    * const subCategories = await prisma.subCategory.findMany()
    * ```
    */
  get subCategory(): Prisma.SubCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.additionalPrice`: Exposes CRUD operations for the **AdditionalPrice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdditionalPrices
    * const additionalPrices = await prisma.additionalPrice.findMany()
    * ```
    */
  get additionalPrice(): Prisma.AdditionalPriceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productBatch`: Exposes CRUD operations for the **ProductBatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductBatches
    * const productBatches = await prisma.productBatch.findMany()
    * ```
    */
  get productBatch(): Prisma.ProductBatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitOfMeasure`: Exposes CRUD operations for the **UnitOfMeasure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitOfMeasures
    * const unitOfMeasures = await prisma.unitOfMeasure.findMany()
    * ```
    */
  get unitOfMeasure(): Prisma.UnitOfMeasureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchase`: Exposes CRUD operations for the **Purchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Purchases
    * const purchases = await prisma.purchase.findMany()
    * ```
    */
  get purchase(): Prisma.PurchaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseItem`: Exposes CRUD operations for the **PurchaseItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseItems
    * const purchaseItems = await prisma.purchaseItem.findMany()
    * ```
    */
  get purchaseItem(): Prisma.PurchaseItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transfer`: Exposes CRUD operations for the **Transfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transfers
    * const transfers = await prisma.transfer.findMany()
    * ```
    */
  get transfer(): Prisma.TransferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transferItem`: Exposes CRUD operations for the **TransferItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransferItems
    * const transferItems = await prisma.transferItem.findMany()
    * ```
    */
  get transferItem(): Prisma.TransferItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockCorrection`: Exposes CRUD operations for the **StockCorrection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockCorrections
    * const stockCorrections = await prisma.stockCorrection.findMany()
    * ```
    */
  get stockCorrection(): Prisma.StockCorrectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockCorrectionItem`: Exposes CRUD operations for the **StockCorrectionItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockCorrectionItems
    * const stockCorrectionItems = await prisma.stockCorrectionItem.findMany()
    * ```
    */
  get stockCorrectionItem(): Prisma.StockCorrectionItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sell`: Exposes CRUD operations for the **Sell** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sells
    * const sells = await prisma.sell.findMany()
    * ```
    */
  get sell(): Prisma.SellDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sellItem`: Exposes CRUD operations for the **SellItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SellItems
    * const sellItems = await prisma.sellItem.findMany()
    * ```
    */
  get sellItem(): Prisma.SellItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sellItemBatch`: Exposes CRUD operations for the **SellItemBatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SellItemBatches
    * const sellItemBatches = await prisma.sellItemBatch.findMany()
    * ```
    */
  get sellItemBatch(): Prisma.SellItemBatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.addToCart`: Exposes CRUD operations for the **AddToCart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AddToCarts
    * const addToCarts = await prisma.addToCart.findMany()
    * ```
    */
  get addToCart(): Prisma.AddToCartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cartItem`: Exposes CRUD operations for the **CartItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CartItems
    * const cartItems = await prisma.cartItem.findMany()
    * ```
    */
  get cartItem(): Prisma.CartItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.waitlist`: Exposes CRUD operations for the **Waitlist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Waitlists
    * const waitlists = await prisma.waitlist.findMany()
    * ```
    */
  get waitlist(): Prisma.WaitlistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sellStockCorrection`: Exposes CRUD operations for the **SellStockCorrection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SellStockCorrections
    * const sellStockCorrections = await prisma.sellStockCorrection.findMany()
    * ```
    */
  get sellStockCorrection(): Prisma.SellStockCorrectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sellStockCorrectionItem`: Exposes CRUD operations for the **SellStockCorrectionItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SellStockCorrectionItems
    * const sellStockCorrectionItems = await prisma.sellStockCorrectionItem.findMany()
    * ```
    */
  get sellStockCorrectionItem(): Prisma.SellStockCorrectionItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sellStockCorrectionBatch`: Exposes CRUD operations for the **SellStockCorrectionBatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SellStockCorrectionBatches
    * const sellStockCorrectionBatches = await prisma.sellStockCorrectionBatch.findMany()
    * ```
    */
  get sellStockCorrectionBatch(): Prisma.SellStockCorrectionBatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.13.0
   * Query Engine version: 361e86d0ea4987e9f53a565309b3eed797a6bcbd
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Role: 'Role',
    Permission: 'Permission',
    RolePermission: 'RolePermission',
    Company: 'Company',
    Branch: 'Branch',
    Shop: 'Shop',
    Store: 'Store',
    StoreStock: 'StoreStock',
    ShopStock: 'ShopStock',
    StockLedger: 'StockLedger',
    Log: 'Log',
    Customer: 'Customer',
    Supplier: 'Supplier',
    Category: 'Category',
    SubCategory: 'SubCategory',
    Product: 'Product',
    AdditionalPrice: 'AdditionalPrice',
    ProductBatch: 'ProductBatch',
    UnitOfMeasure: 'UnitOfMeasure',
    Purchase: 'Purchase',
    PurchaseItem: 'PurchaseItem',
    Transfer: 'Transfer',
    TransferItem: 'TransferItem',
    StockCorrection: 'StockCorrection',
    StockCorrectionItem: 'StockCorrectionItem',
    Sell: 'Sell',
    SellItem: 'SellItem',
    SellItemBatch: 'SellItemBatch',
    AddToCart: 'AddToCart',
    CartItem: 'CartItem',
    Waitlist: 'Waitlist',
    SellStockCorrection: 'SellStockCorrection',
    SellStockCorrectionItem: 'SellStockCorrectionItem',
    SellStockCorrectionBatch: 'SellStockCorrectionBatch',
    Notification: 'Notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "role" | "permission" | "rolePermission" | "company" | "branch" | "shop" | "store" | "storeStock" | "shopStock" | "stockLedger" | "log" | "customer" | "supplier" | "category" | "subCategory" | "product" | "additionalPrice" | "productBatch" | "unitOfMeasure" | "purchase" | "purchaseItem" | "transfer" | "transferItem" | "stockCorrection" | "stockCorrectionItem" | "sell" | "sellItem" | "sellItemBatch" | "addToCart" | "cartItem" | "waitlist" | "sellStockCorrection" | "sellStockCorrectionItem" | "sellStockCorrectionBatch" | "notification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      Branch: {
        payload: Prisma.$BranchPayload<ExtArgs>
        fields: Prisma.BranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findFirst: {
            args: Prisma.BranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findMany: {
            args: Prisma.BranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          create: {
            args: Prisma.BranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          createMany: {
            args: Prisma.BranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          update: {
            args: Prisma.BranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          deleteMany: {
            args: Prisma.BranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          aggregate: {
            args: Prisma.BranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranch>
          }
          groupBy: {
            args: Prisma.BranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchCountArgs<ExtArgs>
            result: $Utils.Optional<BranchCountAggregateOutputType> | number
          }
        }
      }
      Shop: {
        payload: Prisma.$ShopPayload<ExtArgs>
        fields: Prisma.ShopFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          findFirst: {
            args: Prisma.ShopFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          findMany: {
            args: Prisma.ShopFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>[]
          }
          create: {
            args: Prisma.ShopCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          createMany: {
            args: Prisma.ShopCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ShopDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          update: {
            args: Prisma.ShopUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          deleteMany: {
            args: Prisma.ShopDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShopUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShopUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          aggregate: {
            args: Prisma.ShopAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShop>
          }
          groupBy: {
            args: Prisma.ShopGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShopGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopCountArgs<ExtArgs>
            result: $Utils.Optional<ShopCountAggregateOutputType> | number
          }
        }
      }
      Store: {
        payload: Prisma.$StorePayload<ExtArgs>
        fields: Prisma.StoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          findFirst: {
            args: Prisma.StoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          findMany: {
            args: Prisma.StoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          create: {
            args: Prisma.StoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          createMany: {
            args: Prisma.StoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          update: {
            args: Prisma.StoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          deleteMany: {
            args: Prisma.StoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          aggregate: {
            args: Prisma.StoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStore>
          }
          groupBy: {
            args: Prisma.StoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreCountArgs<ExtArgs>
            result: $Utils.Optional<StoreCountAggregateOutputType> | number
          }
        }
      }
      StoreStock: {
        payload: Prisma.$StoreStockPayload<ExtArgs>
        fields: Prisma.StoreStockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreStockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreStockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStockPayload>
          }
          findFirst: {
            args: Prisma.StoreStockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreStockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStockPayload>
          }
          findMany: {
            args: Prisma.StoreStockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStockPayload>[]
          }
          create: {
            args: Prisma.StoreStockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStockPayload>
          }
          createMany: {
            args: Prisma.StoreStockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StoreStockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStockPayload>
          }
          update: {
            args: Prisma.StoreStockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStockPayload>
          }
          deleteMany: {
            args: Prisma.StoreStockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreStockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoreStockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStockPayload>
          }
          aggregate: {
            args: Prisma.StoreStockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoreStock>
          }
          groupBy: {
            args: Prisma.StoreStockGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreStockGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreStockCountArgs<ExtArgs>
            result: $Utils.Optional<StoreStockCountAggregateOutputType> | number
          }
        }
      }
      ShopStock: {
        payload: Prisma.$ShopStockPayload<ExtArgs>
        fields: Prisma.ShopStockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopStockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopStockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopStockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopStockPayload>
          }
          findFirst: {
            args: Prisma.ShopStockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopStockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopStockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopStockPayload>
          }
          findMany: {
            args: Prisma.ShopStockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopStockPayload>[]
          }
          create: {
            args: Prisma.ShopStockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopStockPayload>
          }
          createMany: {
            args: Prisma.ShopStockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ShopStockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopStockPayload>
          }
          update: {
            args: Prisma.ShopStockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopStockPayload>
          }
          deleteMany: {
            args: Prisma.ShopStockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShopStockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShopStockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopStockPayload>
          }
          aggregate: {
            args: Prisma.ShopStockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShopStock>
          }
          groupBy: {
            args: Prisma.ShopStockGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShopStockGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopStockCountArgs<ExtArgs>
            result: $Utils.Optional<ShopStockCountAggregateOutputType> | number
          }
        }
      }
      StockLedger: {
        payload: Prisma.$StockLedgerPayload<ExtArgs>
        fields: Prisma.StockLedgerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockLedgerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLedgerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockLedgerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLedgerPayload>
          }
          findFirst: {
            args: Prisma.StockLedgerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLedgerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockLedgerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLedgerPayload>
          }
          findMany: {
            args: Prisma.StockLedgerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLedgerPayload>[]
          }
          create: {
            args: Prisma.StockLedgerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLedgerPayload>
          }
          createMany: {
            args: Prisma.StockLedgerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StockLedgerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLedgerPayload>
          }
          update: {
            args: Prisma.StockLedgerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLedgerPayload>
          }
          deleteMany: {
            args: Prisma.StockLedgerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockLedgerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StockLedgerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLedgerPayload>
          }
          aggregate: {
            args: Prisma.StockLedgerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockLedger>
          }
          groupBy: {
            args: Prisma.StockLedgerGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockLedgerGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockLedgerCountArgs<ExtArgs>
            result: $Utils.Optional<StockLedgerCountAggregateOutputType> | number
          }
        }
      }
      Log: {
        payload: Prisma.$LogPayload<ExtArgs>
        fields: Prisma.LogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findFirst: {
            args: Prisma.LogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findMany: {
            args: Prisma.LogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          create: {
            args: Prisma.LogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          createMany: {
            args: Prisma.LogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          update: {
            args: Prisma.LogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          deleteMany: {
            args: Prisma.LogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          aggregate: {
            args: Prisma.LogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLog>
          }
          groupBy: {
            args: Prisma.LogGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogCountArgs<ExtArgs>
            result: $Utils.Optional<LogCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      SubCategory: {
        payload: Prisma.$SubCategoryPayload<ExtArgs>
        fields: Prisma.SubCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          findFirst: {
            args: Prisma.SubCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          findMany: {
            args: Prisma.SubCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>[]
          }
          create: {
            args: Prisma.SubCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          createMany: {
            args: Prisma.SubCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SubCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          update: {
            args: Prisma.SubCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          deleteMany: {
            args: Prisma.SubCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          aggregate: {
            args: Prisma.SubCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubCategory>
          }
          groupBy: {
            args: Prisma.SubCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<SubCategoryCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      AdditionalPrice: {
        payload: Prisma.$AdditionalPricePayload<ExtArgs>
        fields: Prisma.AdditionalPriceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdditionalPriceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalPricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdditionalPriceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalPricePayload>
          }
          findFirst: {
            args: Prisma.AdditionalPriceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalPricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdditionalPriceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalPricePayload>
          }
          findMany: {
            args: Prisma.AdditionalPriceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalPricePayload>[]
          }
          create: {
            args: Prisma.AdditionalPriceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalPricePayload>
          }
          createMany: {
            args: Prisma.AdditionalPriceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdditionalPriceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalPricePayload>
          }
          update: {
            args: Prisma.AdditionalPriceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalPricePayload>
          }
          deleteMany: {
            args: Prisma.AdditionalPriceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdditionalPriceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdditionalPriceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalPricePayload>
          }
          aggregate: {
            args: Prisma.AdditionalPriceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdditionalPrice>
          }
          groupBy: {
            args: Prisma.AdditionalPriceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdditionalPriceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdditionalPriceCountArgs<ExtArgs>
            result: $Utils.Optional<AdditionalPriceCountAggregateOutputType> | number
          }
        }
      }
      ProductBatch: {
        payload: Prisma.$ProductBatchPayload<ExtArgs>
        fields: Prisma.ProductBatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductBatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductBatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBatchPayload>
          }
          findFirst: {
            args: Prisma.ProductBatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductBatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBatchPayload>
          }
          findMany: {
            args: Prisma.ProductBatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBatchPayload>[]
          }
          create: {
            args: Prisma.ProductBatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBatchPayload>
          }
          createMany: {
            args: Prisma.ProductBatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductBatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBatchPayload>
          }
          update: {
            args: Prisma.ProductBatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBatchPayload>
          }
          deleteMany: {
            args: Prisma.ProductBatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductBatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductBatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBatchPayload>
          }
          aggregate: {
            args: Prisma.ProductBatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductBatch>
          }
          groupBy: {
            args: Prisma.ProductBatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductBatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductBatchCountArgs<ExtArgs>
            result: $Utils.Optional<ProductBatchCountAggregateOutputType> | number
          }
        }
      }
      UnitOfMeasure: {
        payload: Prisma.$UnitOfMeasurePayload<ExtArgs>
        fields: Prisma.UnitOfMeasureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitOfMeasureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitOfMeasureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurePayload>
          }
          findFirst: {
            args: Prisma.UnitOfMeasureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitOfMeasureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurePayload>
          }
          findMany: {
            args: Prisma.UnitOfMeasureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurePayload>[]
          }
          create: {
            args: Prisma.UnitOfMeasureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurePayload>
          }
          createMany: {
            args: Prisma.UnitOfMeasureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UnitOfMeasureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurePayload>
          }
          update: {
            args: Prisma.UnitOfMeasureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurePayload>
          }
          deleteMany: {
            args: Prisma.UnitOfMeasureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitOfMeasureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnitOfMeasureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurePayload>
          }
          aggregate: {
            args: Prisma.UnitOfMeasureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitOfMeasure>
          }
          groupBy: {
            args: Prisma.UnitOfMeasureGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitOfMeasureGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitOfMeasureCountArgs<ExtArgs>
            result: $Utils.Optional<UnitOfMeasureCountAggregateOutputType> | number
          }
        }
      }
      Purchase: {
        payload: Prisma.$PurchasePayload<ExtArgs>
        fields: Prisma.PurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findFirst: {
            args: Prisma.PurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findMany: {
            args: Prisma.PurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          create: {
            args: Prisma.PurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          createMany: {
            args: Prisma.PurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          update: {
            args: Prisma.PurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          aggregate: {
            args: Prisma.PurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchase>
          }
          groupBy: {
            args: Prisma.PurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseCountAggregateOutputType> | number
          }
        }
      }
      PurchaseItem: {
        payload: Prisma.$PurchaseItemPayload<ExtArgs>
        fields: Prisma.PurchaseItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          findFirst: {
            args: Prisma.PurchaseItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          findMany: {
            args: Prisma.PurchaseItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>[]
          }
          create: {
            args: Prisma.PurchaseItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          createMany: {
            args: Prisma.PurchaseItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PurchaseItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          update: {
            args: Prisma.PurchaseItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          aggregate: {
            args: Prisma.PurchaseItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseItem>
          }
          groupBy: {
            args: Prisma.PurchaseItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseItemCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseItemCountAggregateOutputType> | number
          }
        }
      }
      Transfer: {
        payload: Prisma.$TransferPayload<ExtArgs>
        fields: Prisma.TransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          findFirst: {
            args: Prisma.TransferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          findMany: {
            args: Prisma.TransferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          create: {
            args: Prisma.TransferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          createMany: {
            args: Prisma.TransferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TransferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          update: {
            args: Prisma.TransferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          deleteMany: {
            args: Prisma.TransferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          aggregate: {
            args: Prisma.TransferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransfer>
          }
          groupBy: {
            args: Prisma.TransferGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransferCountArgs<ExtArgs>
            result: $Utils.Optional<TransferCountAggregateOutputType> | number
          }
        }
      }
      TransferItem: {
        payload: Prisma.$TransferItemPayload<ExtArgs>
        fields: Prisma.TransferItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransferItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransferItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload>
          }
          findFirst: {
            args: Prisma.TransferItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransferItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload>
          }
          findMany: {
            args: Prisma.TransferItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload>[]
          }
          create: {
            args: Prisma.TransferItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload>
          }
          createMany: {
            args: Prisma.TransferItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TransferItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload>
          }
          update: {
            args: Prisma.TransferItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload>
          }
          deleteMany: {
            args: Prisma.TransferItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransferItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransferItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload>
          }
          aggregate: {
            args: Prisma.TransferItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransferItem>
          }
          groupBy: {
            args: Prisma.TransferItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransferItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransferItemCountArgs<ExtArgs>
            result: $Utils.Optional<TransferItemCountAggregateOutputType> | number
          }
        }
      }
      StockCorrection: {
        payload: Prisma.$StockCorrectionPayload<ExtArgs>
        fields: Prisma.StockCorrectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockCorrectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockCorrectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockCorrectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockCorrectionPayload>
          }
          findFirst: {
            args: Prisma.StockCorrectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockCorrectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockCorrectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockCorrectionPayload>
          }
          findMany: {
            args: Prisma.StockCorrectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockCorrectionPayload>[]
          }
          create: {
            args: Prisma.StockCorrectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockCorrectionPayload>
          }
          createMany: {
            args: Prisma.StockCorrectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StockCorrectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockCorrectionPayload>
          }
          update: {
            args: Prisma.StockCorrectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockCorrectionPayload>
          }
          deleteMany: {
            args: Prisma.StockCorrectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockCorrectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StockCorrectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockCorrectionPayload>
          }
          aggregate: {
            args: Prisma.StockCorrectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockCorrection>
          }
          groupBy: {
            args: Prisma.StockCorrectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockCorrectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockCorrectionCountArgs<ExtArgs>
            result: $Utils.Optional<StockCorrectionCountAggregateOutputType> | number
          }
        }
      }
      StockCorrectionItem: {
        payload: Prisma.$StockCorrectionItemPayload<ExtArgs>
        fields: Prisma.StockCorrectionItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockCorrectionItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockCorrectionItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockCorrectionItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockCorrectionItemPayload>
          }
          findFirst: {
            args: Prisma.StockCorrectionItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockCorrectionItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockCorrectionItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockCorrectionItemPayload>
          }
          findMany: {
            args: Prisma.StockCorrectionItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockCorrectionItemPayload>[]
          }
          create: {
            args: Prisma.StockCorrectionItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockCorrectionItemPayload>
          }
          createMany: {
            args: Prisma.StockCorrectionItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StockCorrectionItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockCorrectionItemPayload>
          }
          update: {
            args: Prisma.StockCorrectionItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockCorrectionItemPayload>
          }
          deleteMany: {
            args: Prisma.StockCorrectionItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockCorrectionItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StockCorrectionItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockCorrectionItemPayload>
          }
          aggregate: {
            args: Prisma.StockCorrectionItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockCorrectionItem>
          }
          groupBy: {
            args: Prisma.StockCorrectionItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockCorrectionItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockCorrectionItemCountArgs<ExtArgs>
            result: $Utils.Optional<StockCorrectionItemCountAggregateOutputType> | number
          }
        }
      }
      Sell: {
        payload: Prisma.$SellPayload<ExtArgs>
        fields: Prisma.SellFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPayload>
          }
          findFirst: {
            args: Prisma.SellFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPayload>
          }
          findMany: {
            args: Prisma.SellFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPayload>[]
          }
          create: {
            args: Prisma.SellCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPayload>
          }
          createMany: {
            args: Prisma.SellCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SellDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPayload>
          }
          update: {
            args: Prisma.SellUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPayload>
          }
          deleteMany: {
            args: Prisma.SellDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SellUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPayload>
          }
          aggregate: {
            args: Prisma.SellAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSell>
          }
          groupBy: {
            args: Prisma.SellGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellGroupByOutputType>[]
          }
          count: {
            args: Prisma.SellCountArgs<ExtArgs>
            result: $Utils.Optional<SellCountAggregateOutputType> | number
          }
        }
      }
      SellItem: {
        payload: Prisma.$SellItemPayload<ExtArgs>
        fields: Prisma.SellItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellItemPayload>
          }
          findFirst: {
            args: Prisma.SellItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellItemPayload>
          }
          findMany: {
            args: Prisma.SellItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellItemPayload>[]
          }
          create: {
            args: Prisma.SellItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellItemPayload>
          }
          createMany: {
            args: Prisma.SellItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SellItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellItemPayload>
          }
          update: {
            args: Prisma.SellItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellItemPayload>
          }
          deleteMany: {
            args: Prisma.SellItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SellItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellItemPayload>
          }
          aggregate: {
            args: Prisma.SellItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSellItem>
          }
          groupBy: {
            args: Prisma.SellItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.SellItemCountArgs<ExtArgs>
            result: $Utils.Optional<SellItemCountAggregateOutputType> | number
          }
        }
      }
      SellItemBatch: {
        payload: Prisma.$SellItemBatchPayload<ExtArgs>
        fields: Prisma.SellItemBatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellItemBatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellItemBatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellItemBatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellItemBatchPayload>
          }
          findFirst: {
            args: Prisma.SellItemBatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellItemBatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellItemBatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellItemBatchPayload>
          }
          findMany: {
            args: Prisma.SellItemBatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellItemBatchPayload>[]
          }
          create: {
            args: Prisma.SellItemBatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellItemBatchPayload>
          }
          createMany: {
            args: Prisma.SellItemBatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SellItemBatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellItemBatchPayload>
          }
          update: {
            args: Prisma.SellItemBatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellItemBatchPayload>
          }
          deleteMany: {
            args: Prisma.SellItemBatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellItemBatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SellItemBatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellItemBatchPayload>
          }
          aggregate: {
            args: Prisma.SellItemBatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSellItemBatch>
          }
          groupBy: {
            args: Prisma.SellItemBatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellItemBatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.SellItemBatchCountArgs<ExtArgs>
            result: $Utils.Optional<SellItemBatchCountAggregateOutputType> | number
          }
        }
      }
      AddToCart: {
        payload: Prisma.$AddToCartPayload<ExtArgs>
        fields: Prisma.AddToCartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddToCartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddToCartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddToCartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddToCartPayload>
          }
          findFirst: {
            args: Prisma.AddToCartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddToCartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddToCartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddToCartPayload>
          }
          findMany: {
            args: Prisma.AddToCartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddToCartPayload>[]
          }
          create: {
            args: Prisma.AddToCartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddToCartPayload>
          }
          createMany: {
            args: Prisma.AddToCartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AddToCartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddToCartPayload>
          }
          update: {
            args: Prisma.AddToCartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddToCartPayload>
          }
          deleteMany: {
            args: Prisma.AddToCartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddToCartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AddToCartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddToCartPayload>
          }
          aggregate: {
            args: Prisma.AddToCartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddToCart>
          }
          groupBy: {
            args: Prisma.AddToCartGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddToCartGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddToCartCountArgs<ExtArgs>
            result: $Utils.Optional<AddToCartCountAggregateOutputType> | number
          }
        }
      }
      CartItem: {
        payload: Prisma.$CartItemPayload<ExtArgs>
        fields: Prisma.CartItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          findFirst: {
            args: Prisma.CartItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          findMany: {
            args: Prisma.CartItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          create: {
            args: Prisma.CartItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          createMany: {
            args: Prisma.CartItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CartItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          update: {
            args: Prisma.CartItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          deleteMany: {
            args: Prisma.CartItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CartItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          aggregate: {
            args: Prisma.CartItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCartItem>
          }
          groupBy: {
            args: Prisma.CartItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartItemCountArgs<ExtArgs>
            result: $Utils.Optional<CartItemCountAggregateOutputType> | number
          }
        }
      }
      Waitlist: {
        payload: Prisma.$WaitlistPayload<ExtArgs>
        fields: Prisma.WaitlistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WaitlistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WaitlistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistPayload>
          }
          findFirst: {
            args: Prisma.WaitlistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WaitlistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistPayload>
          }
          findMany: {
            args: Prisma.WaitlistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistPayload>[]
          }
          create: {
            args: Prisma.WaitlistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistPayload>
          }
          createMany: {
            args: Prisma.WaitlistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WaitlistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistPayload>
          }
          update: {
            args: Prisma.WaitlistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistPayload>
          }
          deleteMany: {
            args: Prisma.WaitlistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WaitlistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WaitlistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistPayload>
          }
          aggregate: {
            args: Prisma.WaitlistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWaitlist>
          }
          groupBy: {
            args: Prisma.WaitlistGroupByArgs<ExtArgs>
            result: $Utils.Optional<WaitlistGroupByOutputType>[]
          }
          count: {
            args: Prisma.WaitlistCountArgs<ExtArgs>
            result: $Utils.Optional<WaitlistCountAggregateOutputType> | number
          }
        }
      }
      SellStockCorrection: {
        payload: Prisma.$SellStockCorrectionPayload<ExtArgs>
        fields: Prisma.SellStockCorrectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellStockCorrectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellStockCorrectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionPayload>
          }
          findFirst: {
            args: Prisma.SellStockCorrectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellStockCorrectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionPayload>
          }
          findMany: {
            args: Prisma.SellStockCorrectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionPayload>[]
          }
          create: {
            args: Prisma.SellStockCorrectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionPayload>
          }
          createMany: {
            args: Prisma.SellStockCorrectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SellStockCorrectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionPayload>
          }
          update: {
            args: Prisma.SellStockCorrectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionPayload>
          }
          deleteMany: {
            args: Prisma.SellStockCorrectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellStockCorrectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SellStockCorrectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionPayload>
          }
          aggregate: {
            args: Prisma.SellStockCorrectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSellStockCorrection>
          }
          groupBy: {
            args: Prisma.SellStockCorrectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellStockCorrectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SellStockCorrectionCountArgs<ExtArgs>
            result: $Utils.Optional<SellStockCorrectionCountAggregateOutputType> | number
          }
        }
      }
      SellStockCorrectionItem: {
        payload: Prisma.$SellStockCorrectionItemPayload<ExtArgs>
        fields: Prisma.SellStockCorrectionItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellStockCorrectionItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellStockCorrectionItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionItemPayload>
          }
          findFirst: {
            args: Prisma.SellStockCorrectionItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellStockCorrectionItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionItemPayload>
          }
          findMany: {
            args: Prisma.SellStockCorrectionItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionItemPayload>[]
          }
          create: {
            args: Prisma.SellStockCorrectionItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionItemPayload>
          }
          createMany: {
            args: Prisma.SellStockCorrectionItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SellStockCorrectionItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionItemPayload>
          }
          update: {
            args: Prisma.SellStockCorrectionItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionItemPayload>
          }
          deleteMany: {
            args: Prisma.SellStockCorrectionItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellStockCorrectionItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SellStockCorrectionItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionItemPayload>
          }
          aggregate: {
            args: Prisma.SellStockCorrectionItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSellStockCorrectionItem>
          }
          groupBy: {
            args: Prisma.SellStockCorrectionItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellStockCorrectionItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.SellStockCorrectionItemCountArgs<ExtArgs>
            result: $Utils.Optional<SellStockCorrectionItemCountAggregateOutputType> | number
          }
        }
      }
      SellStockCorrectionBatch: {
        payload: Prisma.$SellStockCorrectionBatchPayload<ExtArgs>
        fields: Prisma.SellStockCorrectionBatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellStockCorrectionBatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionBatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellStockCorrectionBatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionBatchPayload>
          }
          findFirst: {
            args: Prisma.SellStockCorrectionBatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionBatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellStockCorrectionBatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionBatchPayload>
          }
          findMany: {
            args: Prisma.SellStockCorrectionBatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionBatchPayload>[]
          }
          create: {
            args: Prisma.SellStockCorrectionBatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionBatchPayload>
          }
          createMany: {
            args: Prisma.SellStockCorrectionBatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SellStockCorrectionBatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionBatchPayload>
          }
          update: {
            args: Prisma.SellStockCorrectionBatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionBatchPayload>
          }
          deleteMany: {
            args: Prisma.SellStockCorrectionBatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellStockCorrectionBatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SellStockCorrectionBatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellStockCorrectionBatchPayload>
          }
          aggregate: {
            args: Prisma.SellStockCorrectionBatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSellStockCorrectionBatch>
          }
          groupBy: {
            args: Prisma.SellStockCorrectionBatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellStockCorrectionBatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.SellStockCorrectionBatchCountArgs<ExtArgs>
            result: $Utils.Optional<SellStockCorrectionBatchCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    role?: RoleOmit
    permission?: PermissionOmit
    rolePermission?: RolePermissionOmit
    company?: CompanyOmit
    branch?: BranchOmit
    shop?: ShopOmit
    store?: StoreOmit
    storeStock?: StoreStockOmit
    shopStock?: ShopStockOmit
    stockLedger?: StockLedgerOmit
    log?: LogOmit
    customer?: CustomerOmit
    supplier?: SupplierOmit
    category?: CategoryOmit
    subCategory?: SubCategoryOmit
    product?: ProductOmit
    additionalPrice?: AdditionalPriceOmit
    productBatch?: ProductBatchOmit
    unitOfMeasure?: UnitOfMeasureOmit
    purchase?: PurchaseOmit
    purchaseItem?: PurchaseItemOmit
    transfer?: TransferOmit
    transferItem?: TransferItemOmit
    stockCorrection?: StockCorrectionOmit
    stockCorrectionItem?: StockCorrectionItemOmit
    sell?: SellOmit
    sellItem?: SellItemOmit
    sellItemBatch?: SellItemBatchOmit
    addToCart?: AddToCartOmit
    cartItem?: CartItemOmit
    waitlist?: WaitlistOmit
    sellStockCorrection?: SellStockCorrectionOmit
    sellStockCorrectionItem?: SellStockCorrectionItemOmit
    sellStockCorrectionBatch?: SellStockCorrectionBatchOmit
    notification?: NotificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    shops: number
    stores: number
    Log: number
    StockLedger: number
    CreatorPurchase: number
    UpdatedPurchase: number
    CreatedTransfer: number
    UpdatedTransfer: number
    StockCorrection: number
    UpdateStockCorrection: number
    Sell: number
    UpdateSell: number
    SellStockCorrection: number
    UpdateSellStockCorrection: number
    AllAddToCart: number
    CreatedAddToCart: number
    AddToCart: number
    waitlists: number
    waitlistsCreated: number
    waitlistsUpdated: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shops?: boolean | UserCountOutputTypeCountShopsArgs
    stores?: boolean | UserCountOutputTypeCountStoresArgs
    Log?: boolean | UserCountOutputTypeCountLogArgs
    StockLedger?: boolean | UserCountOutputTypeCountStockLedgerArgs
    CreatorPurchase?: boolean | UserCountOutputTypeCountCreatorPurchaseArgs
    UpdatedPurchase?: boolean | UserCountOutputTypeCountUpdatedPurchaseArgs
    CreatedTransfer?: boolean | UserCountOutputTypeCountCreatedTransferArgs
    UpdatedTransfer?: boolean | UserCountOutputTypeCountUpdatedTransferArgs
    StockCorrection?: boolean | UserCountOutputTypeCountStockCorrectionArgs
    UpdateStockCorrection?: boolean | UserCountOutputTypeCountUpdateStockCorrectionArgs
    Sell?: boolean | UserCountOutputTypeCountSellArgs
    UpdateSell?: boolean | UserCountOutputTypeCountUpdateSellArgs
    SellStockCorrection?: boolean | UserCountOutputTypeCountSellStockCorrectionArgs
    UpdateSellStockCorrection?: boolean | UserCountOutputTypeCountUpdateSellStockCorrectionArgs
    AllAddToCart?: boolean | UserCountOutputTypeCountAllAddToCartArgs
    CreatedAddToCart?: boolean | UserCountOutputTypeCountCreatedAddToCartArgs
    AddToCart?: boolean | UserCountOutputTypeCountAddToCartArgs
    waitlists?: boolean | UserCountOutputTypeCountWaitlistsArgs
    waitlistsCreated?: boolean | UserCountOutputTypeCountWaitlistsCreatedArgs
    waitlistsUpdated?: boolean | UserCountOutputTypeCountWaitlistsUpdatedArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountShopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStockLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockLedgerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatorPurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedPurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedTransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStockCorrectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockCorrectionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdateStockCorrectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockCorrectionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdateSellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSellStockCorrectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellStockCorrectionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdateSellStockCorrectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellStockCorrectionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAllAddToCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddToCartWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedAddToCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddToCartWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAddToCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddToCartWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWaitlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WaitlistWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWaitlistsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WaitlistWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWaitlistsUpdatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WaitlistWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    permissions: number
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | RoleCountOutputTypeCountPermissionsArgs
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    roles: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | PermissionCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type BranchCountOutputType
   */

  export type BranchCountOutputType = {
    Shop: number
    Store: number
    User: number
    Sell: number
    AddToCart: number
    waitlists: number
  }

  export type BranchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Shop?: boolean | BranchCountOutputTypeCountShopArgs
    Store?: boolean | BranchCountOutputTypeCountStoreArgs
    User?: boolean | BranchCountOutputTypeCountUserArgs
    Sell?: boolean | BranchCountOutputTypeCountSellArgs
    AddToCart?: boolean | BranchCountOutputTypeCountAddToCartArgs
    waitlists?: boolean | BranchCountOutputTypeCountWaitlistsArgs
  }

  // Custom InputTypes
  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchCountOutputType
     */
    select?: BranchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountShopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountStoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountSellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountAddToCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddToCartWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountWaitlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WaitlistWhereInput
  }


  /**
   * Count Type ShopCountOutputType
   */

  export type ShopCountOutputType = {
    ShopStock: number
    StockLedger: number
    SourceTransfer: number
    DestinatTransfer: number
    StockCorrection: number
    AdditionalPrice: number
    SellItem: number
    SellStockCorrectionItem: number
    User: number
    CartItem: number
    waitlists: number
    notifications: number
  }

  export type ShopCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ShopStock?: boolean | ShopCountOutputTypeCountShopStockArgs
    StockLedger?: boolean | ShopCountOutputTypeCountStockLedgerArgs
    SourceTransfer?: boolean | ShopCountOutputTypeCountSourceTransferArgs
    DestinatTransfer?: boolean | ShopCountOutputTypeCountDestinatTransferArgs
    StockCorrection?: boolean | ShopCountOutputTypeCountStockCorrectionArgs
    AdditionalPrice?: boolean | ShopCountOutputTypeCountAdditionalPriceArgs
    SellItem?: boolean | ShopCountOutputTypeCountSellItemArgs
    SellStockCorrectionItem?: boolean | ShopCountOutputTypeCountSellStockCorrectionItemArgs
    User?: boolean | ShopCountOutputTypeCountUserArgs
    CartItem?: boolean | ShopCountOutputTypeCountCartItemArgs
    waitlists?: boolean | ShopCountOutputTypeCountWaitlistsArgs
    notifications?: boolean | ShopCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopCountOutputType
     */
    select?: ShopCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountShopStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopStockWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountStockLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockLedgerWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountSourceTransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountDestinatTransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountStockCorrectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockCorrectionWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountAdditionalPriceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdditionalPriceWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountSellItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellItemWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountSellStockCorrectionItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellStockCorrectionItemWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountCartItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountWaitlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WaitlistWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type StoreCountOutputType
   */

  export type StoreCountOutputType = {
    ProductBatch: number
    StoreStock: number
    StockLedger: number
    Purchase: number
    SourceTransfer: number
    DestinatTransfer: number
    StockCorrection: number
    User: number
    notifications: number
  }

  export type StoreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProductBatch?: boolean | StoreCountOutputTypeCountProductBatchArgs
    StoreStock?: boolean | StoreCountOutputTypeCountStoreStockArgs
    StockLedger?: boolean | StoreCountOutputTypeCountStockLedgerArgs
    Purchase?: boolean | StoreCountOutputTypeCountPurchaseArgs
    SourceTransfer?: boolean | StoreCountOutputTypeCountSourceTransferArgs
    DestinatTransfer?: boolean | StoreCountOutputTypeCountDestinatTransferArgs
    StockCorrection?: boolean | StoreCountOutputTypeCountStockCorrectionArgs
    User?: boolean | StoreCountOutputTypeCountUserArgs
    notifications?: boolean | StoreCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreCountOutputType
     */
    select?: StoreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountProductBatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductBatchWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountStoreStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreStockWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountStockLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockLedgerWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountPurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountSourceTransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountDestinatTransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountStockCorrectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockCorrectionWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    Sell: number
    AddToCart: number
    waitlists: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sell?: boolean | CustomerCountOutputTypeCountSellArgs
    AddToCart?: boolean | CustomerCountOutputTypeCountAddToCartArgs
    waitlists?: boolean | CustomerCountOutputTypeCountWaitlistsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountAddToCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddToCartWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountWaitlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WaitlistWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    Purchase: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Purchase?: boolean | SupplierCountOutputTypeCountPurchaseArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountPurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    products: number
    subCategories: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
    subCategories?: boolean | CategoryCountOutputTypeCountSubCategoriesArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountSubCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubCategoryWhereInput
  }


  /**
   * Count Type SubCategoryCountOutputType
   */

  export type SubCategoryCountOutputType = {
    products: number
  }

  export type SubCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | SubCategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * SubCategoryCountOutputType without action
   */
  export type SubCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoryCountOutputType
     */
    select?: SubCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubCategoryCountOutputType without action
   */
  export type SubCategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    batches: number
    PurchaseItem: number
    TransferItem: number
    StockCorrectionItem: number
    CartItem: number
    AdditionalPrice: number
    SellItem: number
    SellStockCorrectionItem: number
    waitlists: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batches?: boolean | ProductCountOutputTypeCountBatchesArgs
    PurchaseItem?: boolean | ProductCountOutputTypeCountPurchaseItemArgs
    TransferItem?: boolean | ProductCountOutputTypeCountTransferItemArgs
    StockCorrectionItem?: boolean | ProductCountOutputTypeCountStockCorrectionItemArgs
    CartItem?: boolean | ProductCountOutputTypeCountCartItemArgs
    AdditionalPrice?: boolean | ProductCountOutputTypeCountAdditionalPriceArgs
    SellItem?: boolean | ProductCountOutputTypeCountSellItemArgs
    SellStockCorrectionItem?: boolean | ProductCountOutputTypeCountSellStockCorrectionItemArgs
    waitlists?: boolean | ProductCountOutputTypeCountWaitlistsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductBatchWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPurchaseItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountTransferItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountStockCorrectionItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockCorrectionItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCartItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountAdditionalPriceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdditionalPriceWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSellItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSellStockCorrectionItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellStockCorrectionItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountWaitlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WaitlistWhereInput
  }


  /**
   * Count Type ProductBatchCountOutputType
   */

  export type ProductBatchCountOutputType = {
    ShopStock: number
    StoreStock: number
    StockLedger: number
    PurchaseItem: number
    TransferItem: number
    StockCorrectionItem: number
    SellItemBatch: number
    SellStockCorrectionBatch: number
  }

  export type ProductBatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ShopStock?: boolean | ProductBatchCountOutputTypeCountShopStockArgs
    StoreStock?: boolean | ProductBatchCountOutputTypeCountStoreStockArgs
    StockLedger?: boolean | ProductBatchCountOutputTypeCountStockLedgerArgs
    PurchaseItem?: boolean | ProductBatchCountOutputTypeCountPurchaseItemArgs
    TransferItem?: boolean | ProductBatchCountOutputTypeCountTransferItemArgs
    StockCorrectionItem?: boolean | ProductBatchCountOutputTypeCountStockCorrectionItemArgs
    SellItemBatch?: boolean | ProductBatchCountOutputTypeCountSellItemBatchArgs
    SellStockCorrectionBatch?: boolean | ProductBatchCountOutputTypeCountSellStockCorrectionBatchArgs
  }

  // Custom InputTypes
  /**
   * ProductBatchCountOutputType without action
   */
  export type ProductBatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatchCountOutputType
     */
    select?: ProductBatchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductBatchCountOutputType without action
   */
  export type ProductBatchCountOutputTypeCountShopStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopStockWhereInput
  }

  /**
   * ProductBatchCountOutputType without action
   */
  export type ProductBatchCountOutputTypeCountStoreStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreStockWhereInput
  }

  /**
   * ProductBatchCountOutputType without action
   */
  export type ProductBatchCountOutputTypeCountStockLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockLedgerWhereInput
  }

  /**
   * ProductBatchCountOutputType without action
   */
  export type ProductBatchCountOutputTypeCountPurchaseItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemWhereInput
  }

  /**
   * ProductBatchCountOutputType without action
   */
  export type ProductBatchCountOutputTypeCountTransferItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferItemWhereInput
  }

  /**
   * ProductBatchCountOutputType without action
   */
  export type ProductBatchCountOutputTypeCountStockCorrectionItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockCorrectionItemWhereInput
  }

  /**
   * ProductBatchCountOutputType without action
   */
  export type ProductBatchCountOutputTypeCountSellItemBatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellItemBatchWhereInput
  }

  /**
   * ProductBatchCountOutputType without action
   */
  export type ProductBatchCountOutputTypeCountSellStockCorrectionBatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellStockCorrectionBatchWhereInput
  }


  /**
   * Count Type UnitOfMeasureCountOutputType
   */

  export type UnitOfMeasureCountOutputType = {
    products: number
    PurchaseItem: number
    TransferItem: number
    StockLedger: number
    ShopStock: number
    StoreStock: number
    StockCorrectionItem: number
    SellItem: number
    SellStockCorrectionItem: number
    CartItem: number
  }

  export type UnitOfMeasureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | UnitOfMeasureCountOutputTypeCountProductsArgs
    PurchaseItem?: boolean | UnitOfMeasureCountOutputTypeCountPurchaseItemArgs
    TransferItem?: boolean | UnitOfMeasureCountOutputTypeCountTransferItemArgs
    StockLedger?: boolean | UnitOfMeasureCountOutputTypeCountStockLedgerArgs
    ShopStock?: boolean | UnitOfMeasureCountOutputTypeCountShopStockArgs
    StoreStock?: boolean | UnitOfMeasureCountOutputTypeCountStoreStockArgs
    StockCorrectionItem?: boolean | UnitOfMeasureCountOutputTypeCountStockCorrectionItemArgs
    SellItem?: boolean | UnitOfMeasureCountOutputTypeCountSellItemArgs
    SellStockCorrectionItem?: boolean | UnitOfMeasureCountOutputTypeCountSellStockCorrectionItemArgs
    CartItem?: boolean | UnitOfMeasureCountOutputTypeCountCartItemArgs
  }

  // Custom InputTypes
  /**
   * UnitOfMeasureCountOutputType without action
   */
  export type UnitOfMeasureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasureCountOutputType
     */
    select?: UnitOfMeasureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitOfMeasureCountOutputType without action
   */
  export type UnitOfMeasureCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * UnitOfMeasureCountOutputType without action
   */
  export type UnitOfMeasureCountOutputTypeCountPurchaseItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemWhereInput
  }

  /**
   * UnitOfMeasureCountOutputType without action
   */
  export type UnitOfMeasureCountOutputTypeCountTransferItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferItemWhereInput
  }

  /**
   * UnitOfMeasureCountOutputType without action
   */
  export type UnitOfMeasureCountOutputTypeCountStockLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockLedgerWhereInput
  }

  /**
   * UnitOfMeasureCountOutputType without action
   */
  export type UnitOfMeasureCountOutputTypeCountShopStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopStockWhereInput
  }

  /**
   * UnitOfMeasureCountOutputType without action
   */
  export type UnitOfMeasureCountOutputTypeCountStoreStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreStockWhereInput
  }

  /**
   * UnitOfMeasureCountOutputType without action
   */
  export type UnitOfMeasureCountOutputTypeCountStockCorrectionItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockCorrectionItemWhereInput
  }

  /**
   * UnitOfMeasureCountOutputType without action
   */
  export type UnitOfMeasureCountOutputTypeCountSellItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellItemWhereInput
  }

  /**
   * UnitOfMeasureCountOutputType without action
   */
  export type UnitOfMeasureCountOutputTypeCountSellStockCorrectionItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellStockCorrectionItemWhereInput
  }

  /**
   * UnitOfMeasureCountOutputType without action
   */
  export type UnitOfMeasureCountOutputTypeCountCartItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }


  /**
   * Count Type PurchaseCountOutputType
   */

  export type PurchaseCountOutputType = {
    items: number
    StockCorrection: number
  }

  export type PurchaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PurchaseCountOutputTypeCountItemsArgs
    StockCorrection?: boolean | PurchaseCountOutputTypeCountStockCorrectionArgs
  }

  // Custom InputTypes
  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseCountOutputType
     */
    select?: PurchaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemWhereInput
  }

  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeCountStockCorrectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockCorrectionWhereInput
  }


  /**
   * Count Type TransferCountOutputType
   */

  export type TransferCountOutputType = {
    items: number
    StockCorrection: number
  }

  export type TransferCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | TransferCountOutputTypeCountItemsArgs
    StockCorrection?: boolean | TransferCountOutputTypeCountStockCorrectionArgs
  }

  // Custom InputTypes
  /**
   * TransferCountOutputType without action
   */
  export type TransferCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferCountOutputType
     */
    select?: TransferCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransferCountOutputType without action
   */
  export type TransferCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferItemWhereInput
  }

  /**
   * TransferCountOutputType without action
   */
  export type TransferCountOutputTypeCountStockCorrectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockCorrectionWhereInput
  }


  /**
   * Count Type StockCorrectionCountOutputType
   */

  export type StockCorrectionCountOutputType = {
    items: number
  }

  export type StockCorrectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | StockCorrectionCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * StockCorrectionCountOutputType without action
   */
  export type StockCorrectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrectionCountOutputType
     */
    select?: StockCorrectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StockCorrectionCountOutputType without action
   */
  export type StockCorrectionCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockCorrectionItemWhereInput
  }


  /**
   * Count Type SellCountOutputType
   */

  export type SellCountOutputType = {
    items: number
    SellStockCorrection: number
  }

  export type SellCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | SellCountOutputTypeCountItemsArgs
    SellStockCorrection?: boolean | SellCountOutputTypeCountSellStockCorrectionArgs
  }

  // Custom InputTypes
  /**
   * SellCountOutputType without action
   */
  export type SellCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellCountOutputType
     */
    select?: SellCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SellCountOutputType without action
   */
  export type SellCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellItemWhereInput
  }

  /**
   * SellCountOutputType without action
   */
  export type SellCountOutputTypeCountSellStockCorrectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellStockCorrectionWhereInput
  }


  /**
   * Count Type SellItemCountOutputType
   */

  export type SellItemCountOutputType = {
    batches: number
  }

  export type SellItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batches?: boolean | SellItemCountOutputTypeCountBatchesArgs
  }

  // Custom InputTypes
  /**
   * SellItemCountOutputType without action
   */
  export type SellItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItemCountOutputType
     */
    select?: SellItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SellItemCountOutputType without action
   */
  export type SellItemCountOutputTypeCountBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellItemBatchWhereInput
  }


  /**
   * Count Type AddToCartCountOutputType
   */

  export type AddToCartCountOutputType = {
    items: number
    waitlists: number
  }

  export type AddToCartCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | AddToCartCountOutputTypeCountItemsArgs
    waitlists?: boolean | AddToCartCountOutputTypeCountWaitlistsArgs
  }

  // Custom InputTypes
  /**
   * AddToCartCountOutputType without action
   */
  export type AddToCartCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToCartCountOutputType
     */
    select?: AddToCartCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AddToCartCountOutputType without action
   */
  export type AddToCartCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }

  /**
   * AddToCartCountOutputType without action
   */
  export type AddToCartCountOutputTypeCountWaitlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WaitlistWhereInput
  }


  /**
   * Count Type CartItemCountOutputType
   */

  export type CartItemCountOutputType = {
    waitlists: number
  }

  export type CartItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    waitlists?: boolean | CartItemCountOutputTypeCountWaitlistsArgs
  }

  // Custom InputTypes
  /**
   * CartItemCountOutputType without action
   */
  export type CartItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemCountOutputType
     */
    select?: CartItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CartItemCountOutputType without action
   */
  export type CartItemCountOutputTypeCountWaitlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WaitlistWhereInput
  }


  /**
   * Count Type SellStockCorrectionCountOutputType
   */

  export type SellStockCorrectionCountOutputType = {
    items: number
  }

  export type SellStockCorrectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | SellStockCorrectionCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * SellStockCorrectionCountOutputType without action
   */
  export type SellStockCorrectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionCountOutputType
     */
    select?: SellStockCorrectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SellStockCorrectionCountOutputType without action
   */
  export type SellStockCorrectionCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellStockCorrectionItemWhereInput
  }


  /**
   * Count Type SellStockCorrectionItemCountOutputType
   */

  export type SellStockCorrectionItemCountOutputType = {
    batches: number
  }

  export type SellStockCorrectionItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batches?: boolean | SellStockCorrectionItemCountOutputTypeCountBatchesArgs
  }

  // Custom InputTypes
  /**
   * SellStockCorrectionItemCountOutputType without action
   */
  export type SellStockCorrectionItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionItemCountOutputType
     */
    select?: SellStockCorrectionItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SellStockCorrectionItemCountOutputType without action
   */
  export type SellStockCorrectionItemCountOutputTypeCountBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellStockCorrectionBatchWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    userCode: string | null
    email: string | null
    admin: boolean | null
    password: string | null
    branchId: string | null
    roleId: string | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    userCode: string | null
    email: string | null
    admin: boolean | null
    password: string | null
    branchId: string | null
    roleId: string | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    userCode: number
    email: number
    admin: number
    password: number
    branchId: number
    roleId: number
    status: number
    createdAt: number
    updatedAt: number
    lastLoginAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    userCode?: true
    email?: true
    admin?: true
    password?: true
    branchId?: true
    roleId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    userCode?: true
    email?: true
    admin?: true
    password?: true
    branchId?: true
    roleId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    userCode?: true
    email?: true
    admin?: true
    password?: true
    branchId?: true
    roleId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    phone: string | null
    userCode: string | null
    email: string
    admin: boolean
    password: string
    branchId: string | null
    roleId: string
    status: $Enums.Status
    createdAt: Date
    updatedAt: Date
    lastLoginAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    userCode?: boolean
    email?: boolean
    admin?: boolean
    password?: boolean
    branchId?: boolean
    roleId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    branch?: boolean | User$branchArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    shops?: boolean | User$shopsArgs<ExtArgs>
    stores?: boolean | User$storesArgs<ExtArgs>
    Log?: boolean | User$LogArgs<ExtArgs>
    StockLedger?: boolean | User$StockLedgerArgs<ExtArgs>
    CreatorPurchase?: boolean | User$CreatorPurchaseArgs<ExtArgs>
    UpdatedPurchase?: boolean | User$UpdatedPurchaseArgs<ExtArgs>
    CreatedTransfer?: boolean | User$CreatedTransferArgs<ExtArgs>
    UpdatedTransfer?: boolean | User$UpdatedTransferArgs<ExtArgs>
    StockCorrection?: boolean | User$StockCorrectionArgs<ExtArgs>
    UpdateStockCorrection?: boolean | User$UpdateStockCorrectionArgs<ExtArgs>
    Sell?: boolean | User$SellArgs<ExtArgs>
    UpdateSell?: boolean | User$UpdateSellArgs<ExtArgs>
    SellStockCorrection?: boolean | User$SellStockCorrectionArgs<ExtArgs>
    UpdateSellStockCorrection?: boolean | User$UpdateSellStockCorrectionArgs<ExtArgs>
    AllAddToCart?: boolean | User$AllAddToCartArgs<ExtArgs>
    CreatedAddToCart?: boolean | User$CreatedAddToCartArgs<ExtArgs>
    AddToCart?: boolean | User$AddToCartArgs<ExtArgs>
    waitlists?: boolean | User$waitlistsArgs<ExtArgs>
    waitlistsCreated?: boolean | User$waitlistsCreatedArgs<ExtArgs>
    waitlistsUpdated?: boolean | User$waitlistsUpdatedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    userCode?: boolean
    email?: boolean
    admin?: boolean
    password?: boolean
    branchId?: boolean
    roleId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "userCode" | "email" | "admin" | "password" | "branchId" | "roleId" | "status" | "createdAt" | "updatedAt" | "lastLoginAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | User$branchArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    shops?: boolean | User$shopsArgs<ExtArgs>
    stores?: boolean | User$storesArgs<ExtArgs>
    Log?: boolean | User$LogArgs<ExtArgs>
    StockLedger?: boolean | User$StockLedgerArgs<ExtArgs>
    CreatorPurchase?: boolean | User$CreatorPurchaseArgs<ExtArgs>
    UpdatedPurchase?: boolean | User$UpdatedPurchaseArgs<ExtArgs>
    CreatedTransfer?: boolean | User$CreatedTransferArgs<ExtArgs>
    UpdatedTransfer?: boolean | User$UpdatedTransferArgs<ExtArgs>
    StockCorrection?: boolean | User$StockCorrectionArgs<ExtArgs>
    UpdateStockCorrection?: boolean | User$UpdateStockCorrectionArgs<ExtArgs>
    Sell?: boolean | User$SellArgs<ExtArgs>
    UpdateSell?: boolean | User$UpdateSellArgs<ExtArgs>
    SellStockCorrection?: boolean | User$SellStockCorrectionArgs<ExtArgs>
    UpdateSellStockCorrection?: boolean | User$UpdateSellStockCorrectionArgs<ExtArgs>
    AllAddToCart?: boolean | User$AllAddToCartArgs<ExtArgs>
    CreatedAddToCart?: boolean | User$CreatedAddToCartArgs<ExtArgs>
    AddToCart?: boolean | User$AddToCartArgs<ExtArgs>
    waitlists?: boolean | User$waitlistsArgs<ExtArgs>
    waitlistsCreated?: boolean | User$waitlistsCreatedArgs<ExtArgs>
    waitlistsUpdated?: boolean | User$waitlistsUpdatedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      role: Prisma.$RolePayload<ExtArgs>
      shops: Prisma.$ShopPayload<ExtArgs>[]
      stores: Prisma.$StorePayload<ExtArgs>[]
      Log: Prisma.$LogPayload<ExtArgs>[]
      StockLedger: Prisma.$StockLedgerPayload<ExtArgs>[]
      CreatorPurchase: Prisma.$PurchasePayload<ExtArgs>[]
      UpdatedPurchase: Prisma.$PurchasePayload<ExtArgs>[]
      CreatedTransfer: Prisma.$TransferPayload<ExtArgs>[]
      UpdatedTransfer: Prisma.$TransferPayload<ExtArgs>[]
      StockCorrection: Prisma.$StockCorrectionPayload<ExtArgs>[]
      UpdateStockCorrection: Prisma.$StockCorrectionPayload<ExtArgs>[]
      Sell: Prisma.$SellPayload<ExtArgs>[]
      UpdateSell: Prisma.$SellPayload<ExtArgs>[]
      SellStockCorrection: Prisma.$SellStockCorrectionPayload<ExtArgs>[]
      UpdateSellStockCorrection: Prisma.$SellStockCorrectionPayload<ExtArgs>[]
      AllAddToCart: Prisma.$AddToCartPayload<ExtArgs>[]
      CreatedAddToCart: Prisma.$AddToCartPayload<ExtArgs>[]
      AddToCart: Prisma.$AddToCartPayload<ExtArgs>[]
      waitlists: Prisma.$WaitlistPayload<ExtArgs>[]
      waitlistsCreated: Prisma.$WaitlistPayload<ExtArgs>[]
      waitlistsUpdated: Prisma.$WaitlistPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      phone: string | null
      userCode: string | null
      email: string
      admin: boolean
      password: string
      branchId: string | null
      roleId: string
      status: $Enums.Status
      createdAt: Date
      updatedAt: Date
      lastLoginAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends User$branchArgs<ExtArgs> = {}>(args?: Subset<T, User$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shops<T extends User$shopsArgs<ExtArgs> = {}>(args?: Subset<T, User$shopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stores<T extends User$storesArgs<ExtArgs> = {}>(args?: Subset<T, User$storesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Log<T extends User$LogArgs<ExtArgs> = {}>(args?: Subset<T, User$LogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StockLedger<T extends User$StockLedgerArgs<ExtArgs> = {}>(args?: Subset<T, User$StockLedgerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CreatorPurchase<T extends User$CreatorPurchaseArgs<ExtArgs> = {}>(args?: Subset<T, User$CreatorPurchaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UpdatedPurchase<T extends User$UpdatedPurchaseArgs<ExtArgs> = {}>(args?: Subset<T, User$UpdatedPurchaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CreatedTransfer<T extends User$CreatedTransferArgs<ExtArgs> = {}>(args?: Subset<T, User$CreatedTransferArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UpdatedTransfer<T extends User$UpdatedTransferArgs<ExtArgs> = {}>(args?: Subset<T, User$UpdatedTransferArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StockCorrection<T extends User$StockCorrectionArgs<ExtArgs> = {}>(args?: Subset<T, User$StockCorrectionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockCorrectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UpdateStockCorrection<T extends User$UpdateStockCorrectionArgs<ExtArgs> = {}>(args?: Subset<T, User$UpdateStockCorrectionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockCorrectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Sell<T extends User$SellArgs<ExtArgs> = {}>(args?: Subset<T, User$SellArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UpdateSell<T extends User$UpdateSellArgs<ExtArgs> = {}>(args?: Subset<T, User$UpdateSellArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SellStockCorrection<T extends User$SellStockCorrectionArgs<ExtArgs> = {}>(args?: Subset<T, User$SellStockCorrectionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellStockCorrectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UpdateSellStockCorrection<T extends User$UpdateSellStockCorrectionArgs<ExtArgs> = {}>(args?: Subset<T, User$UpdateSellStockCorrectionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellStockCorrectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AllAddToCart<T extends User$AllAddToCartArgs<ExtArgs> = {}>(args?: Subset<T, User$AllAddToCartArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddToCartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CreatedAddToCart<T extends User$CreatedAddToCartArgs<ExtArgs> = {}>(args?: Subset<T, User$CreatedAddToCartArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddToCartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AddToCart<T extends User$AddToCartArgs<ExtArgs> = {}>(args?: Subset<T, User$AddToCartArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddToCartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    waitlists<T extends User$waitlistsArgs<ExtArgs> = {}>(args?: Subset<T, User$waitlistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    waitlistsCreated<T extends User$waitlistsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$waitlistsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    waitlistsUpdated<T extends User$waitlistsUpdatedArgs<ExtArgs> = {}>(args?: Subset<T, User$waitlistsUpdatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly userCode: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly admin: FieldRef<"User", 'Boolean'>
    readonly password: FieldRef<"User", 'String'>
    readonly branchId: FieldRef<"User", 'String'>
    readonly roleId: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'Status'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.branch
   */
  export type User$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * User.shops
   */
  export type User$shopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    where?: ShopWhereInput
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    cursor?: ShopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * User.stores
   */
  export type User$storesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    where?: StoreWhereInput
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    cursor?: StoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * User.Log
   */
  export type User$LogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    where?: LogWhereInput
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    cursor?: LogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * User.StockLedger
   */
  export type User$StockLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
    where?: StockLedgerWhereInput
    orderBy?: StockLedgerOrderByWithRelationInput | StockLedgerOrderByWithRelationInput[]
    cursor?: StockLedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockLedgerScalarFieldEnum | StockLedgerScalarFieldEnum[]
  }

  /**
   * User.CreatorPurchase
   */
  export type User$CreatorPurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * User.UpdatedPurchase
   */
  export type User$UpdatedPurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * User.CreatedTransfer
   */
  export type User$CreatedTransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * User.UpdatedTransfer
   */
  export type User$UpdatedTransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * User.StockCorrection
   */
  export type User$StockCorrectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrection
     */
    select?: StockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrection
     */
    omit?: StockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionInclude<ExtArgs> | null
    where?: StockCorrectionWhereInput
    orderBy?: StockCorrectionOrderByWithRelationInput | StockCorrectionOrderByWithRelationInput[]
    cursor?: StockCorrectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockCorrectionScalarFieldEnum | StockCorrectionScalarFieldEnum[]
  }

  /**
   * User.UpdateStockCorrection
   */
  export type User$UpdateStockCorrectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrection
     */
    select?: StockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrection
     */
    omit?: StockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionInclude<ExtArgs> | null
    where?: StockCorrectionWhereInput
    orderBy?: StockCorrectionOrderByWithRelationInput | StockCorrectionOrderByWithRelationInput[]
    cursor?: StockCorrectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockCorrectionScalarFieldEnum | StockCorrectionScalarFieldEnum[]
  }

  /**
   * User.Sell
   */
  export type User$SellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sell
     */
    select?: SellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sell
     */
    omit?: SellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellInclude<ExtArgs> | null
    where?: SellWhereInput
    orderBy?: SellOrderByWithRelationInput | SellOrderByWithRelationInput[]
    cursor?: SellWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellScalarFieldEnum | SellScalarFieldEnum[]
  }

  /**
   * User.UpdateSell
   */
  export type User$UpdateSellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sell
     */
    select?: SellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sell
     */
    omit?: SellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellInclude<ExtArgs> | null
    where?: SellWhereInput
    orderBy?: SellOrderByWithRelationInput | SellOrderByWithRelationInput[]
    cursor?: SellWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellScalarFieldEnum | SellScalarFieldEnum[]
  }

  /**
   * User.SellStockCorrection
   */
  export type User$SellStockCorrectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrection
     */
    select?: SellStockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrection
     */
    omit?: SellStockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionInclude<ExtArgs> | null
    where?: SellStockCorrectionWhereInput
    orderBy?: SellStockCorrectionOrderByWithRelationInput | SellStockCorrectionOrderByWithRelationInput[]
    cursor?: SellStockCorrectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellStockCorrectionScalarFieldEnum | SellStockCorrectionScalarFieldEnum[]
  }

  /**
   * User.UpdateSellStockCorrection
   */
  export type User$UpdateSellStockCorrectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrection
     */
    select?: SellStockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrection
     */
    omit?: SellStockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionInclude<ExtArgs> | null
    where?: SellStockCorrectionWhereInput
    orderBy?: SellStockCorrectionOrderByWithRelationInput | SellStockCorrectionOrderByWithRelationInput[]
    cursor?: SellStockCorrectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellStockCorrectionScalarFieldEnum | SellStockCorrectionScalarFieldEnum[]
  }

  /**
   * User.AllAddToCart
   */
  export type User$AllAddToCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToCart
     */
    select?: AddToCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddToCart
     */
    omit?: AddToCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddToCartInclude<ExtArgs> | null
    where?: AddToCartWhereInput
    orderBy?: AddToCartOrderByWithRelationInput | AddToCartOrderByWithRelationInput[]
    cursor?: AddToCartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddToCartScalarFieldEnum | AddToCartScalarFieldEnum[]
  }

  /**
   * User.CreatedAddToCart
   */
  export type User$CreatedAddToCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToCart
     */
    select?: AddToCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddToCart
     */
    omit?: AddToCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddToCartInclude<ExtArgs> | null
    where?: AddToCartWhereInput
    orderBy?: AddToCartOrderByWithRelationInput | AddToCartOrderByWithRelationInput[]
    cursor?: AddToCartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddToCartScalarFieldEnum | AddToCartScalarFieldEnum[]
  }

  /**
   * User.AddToCart
   */
  export type User$AddToCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToCart
     */
    select?: AddToCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddToCart
     */
    omit?: AddToCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddToCartInclude<ExtArgs> | null
    where?: AddToCartWhereInput
    orderBy?: AddToCartOrderByWithRelationInput | AddToCartOrderByWithRelationInput[]
    cursor?: AddToCartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddToCartScalarFieldEnum | AddToCartScalarFieldEnum[]
  }

  /**
   * User.waitlists
   */
  export type User$waitlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaitlistInclude<ExtArgs> | null
    where?: WaitlistWhereInput
    orderBy?: WaitlistOrderByWithRelationInput | WaitlistOrderByWithRelationInput[]
    cursor?: WaitlistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WaitlistScalarFieldEnum | WaitlistScalarFieldEnum[]
  }

  /**
   * User.waitlistsCreated
   */
  export type User$waitlistsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaitlistInclude<ExtArgs> | null
    where?: WaitlistWhereInput
    orderBy?: WaitlistOrderByWithRelationInput | WaitlistOrderByWithRelationInput[]
    cursor?: WaitlistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WaitlistScalarFieldEnum | WaitlistScalarFieldEnum[]
  }

  /**
   * User.waitlistsUpdated
   */
  export type User$waitlistsUpdatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaitlistInclude<ExtArgs> | null
    where?: WaitlistWhereInput
    orderBy?: WaitlistOrderByWithRelationInput | WaitlistOrderByWithRelationInput[]
    cursor?: WaitlistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WaitlistScalarFieldEnum | WaitlistScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>



  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      permissions: Prisma.$RolePermissionPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permissions<T extends Role$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Role$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.permissions
   */
  export type Role$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>



  export type PermissionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      roles: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends Permission$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Permission$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
    readonly updatedAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission.roles
   */
  export type Permission$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionMinAggregateOutputType = {
    id: string | null
    roleId: string | null
    permissionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    id: string | null
    roleId: string | null
    permissionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RolePermissionCountAggregateOutputType = {
    id: number
    roleId: number
    permissionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RolePermissionMinAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RolePermissionCountAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    id: string
    roleId: string
    permissionId: string
    createdAt: Date
    updatedAt: Date
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>



  export type RolePermissionSelectScalar = {
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RolePermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roleId" | "permissionId" | "createdAt" | "updatedAt", ExtArgs["result"]["rolePermission"]>
  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      permission: Prisma.$PermissionPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roleId: string
      permissionId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */
  interface RolePermissionFieldRefs {
    readonly id: FieldRef<"RolePermission", 'String'>
    readonly roleId: FieldRef<"RolePermission", 'String'>
    readonly permissionId: FieldRef<"RolePermission", 'String'>
    readonly createdAt: FieldRef<"RolePermission", 'DateTime'>
    readonly updatedAt: FieldRef<"RolePermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to delete.
     */
    limit?: number
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    description: string | null
    tinAddress: string | null
    TIN: string | null
    From: string | null
    logo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    description: string | null
    tinAddress: string | null
    TIN: string | null
    From: string | null
    logo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    address: number
    description: number
    tinAddress: number
    TIN: number
    From: number
    logo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    description?: true
    tinAddress?: true
    TIN?: true
    From?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    description?: true
    tinAddress?: true
    TIN?: true
    From?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    description?: true
    tinAddress?: true
    TIN?: true
    From?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    email: string | null
    phone: string | null
    address: string | null
    description: string | null
    tinAddress: string | null
    TIN: string | null
    From: string | null
    logo: string | null
    createdAt: Date
    updatedAt: Date
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    description?: boolean
    tinAddress?: boolean
    TIN?: boolean
    From?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>



  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    description?: boolean
    tinAddress?: boolean
    TIN?: boolean
    From?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "address" | "description" | "tinAddress" | "TIN" | "From" | "logo" | "createdAt" | "updatedAt", ExtArgs["result"]["company"]>

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string | null
      phone: string | null
      address: string | null
      description: string | null
      tinAddress: string | null
      TIN: string | null
      From: string | null
      logo: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly email: FieldRef<"Company", 'String'>
    readonly phone: FieldRef<"Company", 'String'>
    readonly address: FieldRef<"Company", 'String'>
    readonly description: FieldRef<"Company", 'String'>
    readonly tinAddress: FieldRef<"Company", 'String'>
    readonly TIN: FieldRef<"Company", 'String'>
    readonly From: FieldRef<"Company", 'String'>
    readonly logo: FieldRef<"Company", 'String'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
  }


  /**
   * Model Branch
   */

  export type AggregateBranch = {
    _count: BranchCountAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  export type BranchMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchCountAggregateOutputType = {
    id: number
    name: number
    address: number
    phone: number
    email: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BranchMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branch to aggregate.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Branches
    **/
    _count?: true | BranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchMaxAggregateInputType
  }

  export type GetBranchAggregateType<T extends BranchAggregateArgs> = {
        [P in keyof T & keyof AggregateBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranch[P]>
      : GetScalarType<T[P], AggregateBranch[P]>
  }




  export type BranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithAggregationInput | BranchOrderByWithAggregationInput[]
    by: BranchScalarFieldEnum[] | BranchScalarFieldEnum
    having?: BranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchCountAggregateInputType | true
    _min?: BranchMinAggregateInputType
    _max?: BranchMaxAggregateInputType
  }

  export type BranchGroupByOutputType = {
    id: string
    name: string
    address: string | null
    phone: string | null
    email: string | null
    createdAt: Date
    updatedAt: Date
    _count: BranchCountAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  type GetBranchGroupByPayload<T extends BranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchGroupByOutputType[P]>
            : GetScalarType<T[P], BranchGroupByOutputType[P]>
        }
      >
    >


  export type BranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Shop?: boolean | Branch$ShopArgs<ExtArgs>
    Store?: boolean | Branch$StoreArgs<ExtArgs>
    User?: boolean | Branch$UserArgs<ExtArgs>
    Sell?: boolean | Branch$SellArgs<ExtArgs>
    AddToCart?: boolean | Branch$AddToCartArgs<ExtArgs>
    waitlists?: boolean | Branch$waitlistsArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>



  export type BranchSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BranchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "phone" | "email" | "createdAt" | "updatedAt", ExtArgs["result"]["branch"]>
  export type BranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Shop?: boolean | Branch$ShopArgs<ExtArgs>
    Store?: boolean | Branch$StoreArgs<ExtArgs>
    User?: boolean | Branch$UserArgs<ExtArgs>
    Sell?: boolean | Branch$SellArgs<ExtArgs>
    AddToCart?: boolean | Branch$AddToCartArgs<ExtArgs>
    waitlists?: boolean | Branch$waitlistsArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Branch"
    objects: {
      Shop: Prisma.$ShopPayload<ExtArgs>[]
      Store: Prisma.$StorePayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs>[]
      Sell: Prisma.$SellPayload<ExtArgs>[]
      AddToCart: Prisma.$AddToCartPayload<ExtArgs>[]
      waitlists: Prisma.$WaitlistPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string | null
      phone: string | null
      email: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["branch"]>
    composites: {}
  }

  type BranchGetPayload<S extends boolean | null | undefined | BranchDefaultArgs> = $Result.GetResult<Prisma.$BranchPayload, S>

  type BranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BranchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BranchCountAggregateInputType | true
    }

  export interface BranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Branch'], meta: { name: 'Branch' } }
    /**
     * Find zero or one Branch that matches the filter.
     * @param {BranchFindUniqueArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BranchFindUniqueArgs>(args: SelectSubset<T, BranchFindUniqueArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Branch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BranchFindUniqueOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BranchFindUniqueOrThrowArgs>(args: SelectSubset<T, BranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BranchFindFirstArgs>(args?: SelectSubset<T, BranchFindFirstArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BranchFindFirstOrThrowArgs>(args?: SelectSubset<T, BranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branch.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchWithIdOnly = await prisma.branch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BranchFindManyArgs>(args?: SelectSubset<T, BranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Branch.
     * @param {BranchCreateArgs} args - Arguments to create a Branch.
     * @example
     * // Create one Branch
     * const Branch = await prisma.branch.create({
     *   data: {
     *     // ... data to create a Branch
     *   }
     * })
     * 
     */
    create<T extends BranchCreateArgs>(args: SelectSubset<T, BranchCreateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Branches.
     * @param {BranchCreateManyArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BranchCreateManyArgs>(args?: SelectSubset<T, BranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Branch.
     * @param {BranchDeleteArgs} args - Arguments to delete one Branch.
     * @example
     * // Delete one Branch
     * const Branch = await prisma.branch.delete({
     *   where: {
     *     // ... filter to delete one Branch
     *   }
     * })
     * 
     */
    delete<T extends BranchDeleteArgs>(args: SelectSubset<T, BranchDeleteArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Branch.
     * @param {BranchUpdateArgs} args - Arguments to update one Branch.
     * @example
     * // Update one Branch
     * const branch = await prisma.branch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BranchUpdateArgs>(args: SelectSubset<T, BranchUpdateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Branches.
     * @param {BranchDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BranchDeleteManyArgs>(args?: SelectSubset<T, BranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BranchUpdateManyArgs>(args: SelectSubset<T, BranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Branch.
     * @param {BranchUpsertArgs} args - Arguments to update or create a Branch.
     * @example
     * // Update or create a Branch
     * const branch = await prisma.branch.upsert({
     *   create: {
     *     // ... data to create a Branch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branch we want to update
     *   }
     * })
     */
    upsert<T extends BranchUpsertArgs>(args: SelectSubset<T, BranchUpsertArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branch.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends BranchCountArgs>(
      args?: Subset<T, BranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchAggregateArgs>(args: Subset<T, BranchAggregateArgs>): Prisma.PrismaPromise<GetBranchAggregateType<T>>

    /**
     * Group by Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchGroupByArgs['orderBy'] }
        : { orderBy?: BranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Branch model
   */
  readonly fields: BranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Branch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Shop<T extends Branch$ShopArgs<ExtArgs> = {}>(args?: Subset<T, Branch$ShopArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Store<T extends Branch$StoreArgs<ExtArgs> = {}>(args?: Subset<T, Branch$StoreArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends Branch$UserArgs<ExtArgs> = {}>(args?: Subset<T, Branch$UserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Sell<T extends Branch$SellArgs<ExtArgs> = {}>(args?: Subset<T, Branch$SellArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AddToCart<T extends Branch$AddToCartArgs<ExtArgs> = {}>(args?: Subset<T, Branch$AddToCartArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddToCartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    waitlists<T extends Branch$waitlistsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$waitlistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Branch model
   */
  interface BranchFieldRefs {
    readonly id: FieldRef<"Branch", 'String'>
    readonly name: FieldRef<"Branch", 'String'>
    readonly address: FieldRef<"Branch", 'String'>
    readonly phone: FieldRef<"Branch", 'String'>
    readonly email: FieldRef<"Branch", 'String'>
    readonly createdAt: FieldRef<"Branch", 'DateTime'>
    readonly updatedAt: FieldRef<"Branch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Branch findUnique
   */
  export type BranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findUniqueOrThrow
   */
  export type BranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findFirst
   */
  export type BranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findFirstOrThrow
   */
  export type BranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findMany
   */
  export type BranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branches to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch create
   */
  export type BranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to create a Branch.
     */
    data: XOR<BranchCreateInput, BranchUncheckedCreateInput>
  }

  /**
   * Branch createMany
   */
  export type BranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch update
   */
  export type BranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to update a Branch.
     */
    data: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
    /**
     * Choose, which Branch to update.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch updateMany
   */
  export type BranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to update.
     */
    limit?: number
  }

  /**
   * Branch upsert
   */
  export type BranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The filter to search for the Branch to update in case it exists.
     */
    where: BranchWhereUniqueInput
    /**
     * In case the Branch found by the `where` argument doesn't exist, create a new Branch with this data.
     */
    create: XOR<BranchCreateInput, BranchUncheckedCreateInput>
    /**
     * In case the Branch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
  }

  /**
   * Branch delete
   */
  export type BranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter which Branch to delete.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch deleteMany
   */
  export type BranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branches to delete
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to delete.
     */
    limit?: number
  }

  /**
   * Branch.Shop
   */
  export type Branch$ShopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    where?: ShopWhereInput
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    cursor?: ShopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * Branch.Store
   */
  export type Branch$StoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    where?: StoreWhereInput
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    cursor?: StoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Branch.User
   */
  export type Branch$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Branch.Sell
   */
  export type Branch$SellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sell
     */
    select?: SellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sell
     */
    omit?: SellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellInclude<ExtArgs> | null
    where?: SellWhereInput
    orderBy?: SellOrderByWithRelationInput | SellOrderByWithRelationInput[]
    cursor?: SellWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellScalarFieldEnum | SellScalarFieldEnum[]
  }

  /**
   * Branch.AddToCart
   */
  export type Branch$AddToCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToCart
     */
    select?: AddToCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddToCart
     */
    omit?: AddToCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddToCartInclude<ExtArgs> | null
    where?: AddToCartWhereInput
    orderBy?: AddToCartOrderByWithRelationInput | AddToCartOrderByWithRelationInput[]
    cursor?: AddToCartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddToCartScalarFieldEnum | AddToCartScalarFieldEnum[]
  }

  /**
   * Branch.waitlists
   */
  export type Branch$waitlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaitlistInclude<ExtArgs> | null
    where?: WaitlistWhereInput
    orderBy?: WaitlistOrderByWithRelationInput | WaitlistOrderByWithRelationInput[]
    cursor?: WaitlistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WaitlistScalarFieldEnum | WaitlistScalarFieldEnum[]
  }

  /**
   * Branch without action
   */
  export type BranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
  }


  /**
   * Model Shop
   */

  export type AggregateShop = {
    _count: ShopCountAggregateOutputType | null
    _min: ShopMinAggregateOutputType | null
    _max: ShopMaxAggregateOutputType | null
  }

  export type ShopMinAggregateOutputType = {
    id: string | null
    name: string | null
    branchId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopMaxAggregateOutputType = {
    id: string | null
    name: string | null
    branchId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopCountAggregateOutputType = {
    id: number
    name: number
    branchId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShopMinAggregateInputType = {
    id?: true
    name?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopMaxAggregateInputType = {
    id?: true
    name?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopCountAggregateInputType = {
    id?: true
    name?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShopAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shop to aggregate.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shops
    **/
    _count?: true | ShopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopMaxAggregateInputType
  }

  export type GetShopAggregateType<T extends ShopAggregateArgs> = {
        [P in keyof T & keyof AggregateShop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShop[P]>
      : GetScalarType<T[P], AggregateShop[P]>
  }




  export type ShopGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopWhereInput
    orderBy?: ShopOrderByWithAggregationInput | ShopOrderByWithAggregationInput[]
    by: ShopScalarFieldEnum[] | ShopScalarFieldEnum
    having?: ShopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopCountAggregateInputType | true
    _min?: ShopMinAggregateInputType
    _max?: ShopMaxAggregateInputType
  }

  export type ShopGroupByOutputType = {
    id: string
    name: string
    branchId: string
    createdAt: Date
    updatedAt: Date
    _count: ShopCountAggregateOutputType | null
    _min: ShopMinAggregateOutputType | null
    _max: ShopMaxAggregateOutputType | null
  }

  type GetShopGroupByPayload<T extends ShopGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopGroupByOutputType[P]>
            : GetScalarType<T[P], ShopGroupByOutputType[P]>
        }
      >
    >


  export type ShopSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    ShopStock?: boolean | Shop$ShopStockArgs<ExtArgs>
    StockLedger?: boolean | Shop$StockLedgerArgs<ExtArgs>
    SourceTransfer?: boolean | Shop$SourceTransferArgs<ExtArgs>
    DestinatTransfer?: boolean | Shop$DestinatTransferArgs<ExtArgs>
    StockCorrection?: boolean | Shop$StockCorrectionArgs<ExtArgs>
    AdditionalPrice?: boolean | Shop$AdditionalPriceArgs<ExtArgs>
    SellItem?: boolean | Shop$SellItemArgs<ExtArgs>
    SellStockCorrectionItem?: boolean | Shop$SellStockCorrectionItemArgs<ExtArgs>
    User?: boolean | Shop$UserArgs<ExtArgs>
    CartItem?: boolean | Shop$CartItemArgs<ExtArgs>
    waitlists?: boolean | Shop$waitlistsArgs<ExtArgs>
    notifications?: boolean | Shop$notificationsArgs<ExtArgs>
    _count?: boolean | ShopCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shop"]>



  export type ShopSelectScalar = {
    id?: boolean
    name?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShopOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "branchId" | "createdAt" | "updatedAt", ExtArgs["result"]["shop"]>
  export type ShopInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    ShopStock?: boolean | Shop$ShopStockArgs<ExtArgs>
    StockLedger?: boolean | Shop$StockLedgerArgs<ExtArgs>
    SourceTransfer?: boolean | Shop$SourceTransferArgs<ExtArgs>
    DestinatTransfer?: boolean | Shop$DestinatTransferArgs<ExtArgs>
    StockCorrection?: boolean | Shop$StockCorrectionArgs<ExtArgs>
    AdditionalPrice?: boolean | Shop$AdditionalPriceArgs<ExtArgs>
    SellItem?: boolean | Shop$SellItemArgs<ExtArgs>
    SellStockCorrectionItem?: boolean | Shop$SellStockCorrectionItemArgs<ExtArgs>
    User?: boolean | Shop$UserArgs<ExtArgs>
    CartItem?: boolean | Shop$CartItemArgs<ExtArgs>
    waitlists?: boolean | Shop$waitlistsArgs<ExtArgs>
    notifications?: boolean | Shop$notificationsArgs<ExtArgs>
    _count?: boolean | ShopCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ShopPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shop"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      ShopStock: Prisma.$ShopStockPayload<ExtArgs>[]
      StockLedger: Prisma.$StockLedgerPayload<ExtArgs>[]
      SourceTransfer: Prisma.$TransferPayload<ExtArgs>[]
      DestinatTransfer: Prisma.$TransferPayload<ExtArgs>[]
      StockCorrection: Prisma.$StockCorrectionPayload<ExtArgs>[]
      AdditionalPrice: Prisma.$AdditionalPricePayload<ExtArgs>[]
      SellItem: Prisma.$SellItemPayload<ExtArgs>[]
      SellStockCorrectionItem: Prisma.$SellStockCorrectionItemPayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs>[]
      CartItem: Prisma.$CartItemPayload<ExtArgs>[]
      waitlists: Prisma.$WaitlistPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      branchId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shop"]>
    composites: {}
  }

  type ShopGetPayload<S extends boolean | null | undefined | ShopDefaultArgs> = $Result.GetResult<Prisma.$ShopPayload, S>

  type ShopCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShopFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShopCountAggregateInputType | true
    }

  export interface ShopDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shop'], meta: { name: 'Shop' } }
    /**
     * Find zero or one Shop that matches the filter.
     * @param {ShopFindUniqueArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShopFindUniqueArgs>(args: SelectSubset<T, ShopFindUniqueArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shop that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShopFindUniqueOrThrowArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShopFindUniqueOrThrowArgs>(args: SelectSubset<T, ShopFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopFindFirstArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShopFindFirstArgs>(args?: SelectSubset<T, ShopFindFirstArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopFindFirstOrThrowArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShopFindFirstOrThrowArgs>(args?: SelectSubset<T, ShopFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shops
     * const shops = await prisma.shop.findMany()
     * 
     * // Get first 10 Shops
     * const shops = await prisma.shop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopWithIdOnly = await prisma.shop.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShopFindManyArgs>(args?: SelectSubset<T, ShopFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shop.
     * @param {ShopCreateArgs} args - Arguments to create a Shop.
     * @example
     * // Create one Shop
     * const Shop = await prisma.shop.create({
     *   data: {
     *     // ... data to create a Shop
     *   }
     * })
     * 
     */
    create<T extends ShopCreateArgs>(args: SelectSubset<T, ShopCreateArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shops.
     * @param {ShopCreateManyArgs} args - Arguments to create many Shops.
     * @example
     * // Create many Shops
     * const shop = await prisma.shop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShopCreateManyArgs>(args?: SelectSubset<T, ShopCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Shop.
     * @param {ShopDeleteArgs} args - Arguments to delete one Shop.
     * @example
     * // Delete one Shop
     * const Shop = await prisma.shop.delete({
     *   where: {
     *     // ... filter to delete one Shop
     *   }
     * })
     * 
     */
    delete<T extends ShopDeleteArgs>(args: SelectSubset<T, ShopDeleteArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shop.
     * @param {ShopUpdateArgs} args - Arguments to update one Shop.
     * @example
     * // Update one Shop
     * const shop = await prisma.shop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShopUpdateArgs>(args: SelectSubset<T, ShopUpdateArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shops.
     * @param {ShopDeleteManyArgs} args - Arguments to filter Shops to delete.
     * @example
     * // Delete a few Shops
     * const { count } = await prisma.shop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShopDeleteManyArgs>(args?: SelectSubset<T, ShopDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shops
     * const shop = await prisma.shop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShopUpdateManyArgs>(args: SelectSubset<T, ShopUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shop.
     * @param {ShopUpsertArgs} args - Arguments to update or create a Shop.
     * @example
     * // Update or create a Shop
     * const shop = await prisma.shop.upsert({
     *   create: {
     *     // ... data to create a Shop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shop we want to update
     *   }
     * })
     */
    upsert<T extends ShopUpsertArgs>(args: SelectSubset<T, ShopUpsertArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopCountArgs} args - Arguments to filter Shops to count.
     * @example
     * // Count the number of Shops
     * const count = await prisma.shop.count({
     *   where: {
     *     // ... the filter for the Shops we want to count
     *   }
     * })
    **/
    count<T extends ShopCountArgs>(
      args?: Subset<T, ShopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopAggregateArgs>(args: Subset<T, ShopAggregateArgs>): Prisma.PrismaPromise<GetShopAggregateType<T>>

    /**
     * Group by Shop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopGroupByArgs['orderBy'] }
        : { orderBy?: ShopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shop model
   */
  readonly fields: ShopFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ShopStock<T extends Shop$ShopStockArgs<ExtArgs> = {}>(args?: Subset<T, Shop$ShopStockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StockLedger<T extends Shop$StockLedgerArgs<ExtArgs> = {}>(args?: Subset<T, Shop$StockLedgerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SourceTransfer<T extends Shop$SourceTransferArgs<ExtArgs> = {}>(args?: Subset<T, Shop$SourceTransferArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DestinatTransfer<T extends Shop$DestinatTransferArgs<ExtArgs> = {}>(args?: Subset<T, Shop$DestinatTransferArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StockCorrection<T extends Shop$StockCorrectionArgs<ExtArgs> = {}>(args?: Subset<T, Shop$StockCorrectionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockCorrectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AdditionalPrice<T extends Shop$AdditionalPriceArgs<ExtArgs> = {}>(args?: Subset<T, Shop$AdditionalPriceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdditionalPricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SellItem<T extends Shop$SellItemArgs<ExtArgs> = {}>(args?: Subset<T, Shop$SellItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SellStockCorrectionItem<T extends Shop$SellStockCorrectionItemArgs<ExtArgs> = {}>(args?: Subset<T, Shop$SellStockCorrectionItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellStockCorrectionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends Shop$UserArgs<ExtArgs> = {}>(args?: Subset<T, Shop$UserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CartItem<T extends Shop$CartItemArgs<ExtArgs> = {}>(args?: Subset<T, Shop$CartItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    waitlists<T extends Shop$waitlistsArgs<ExtArgs> = {}>(args?: Subset<T, Shop$waitlistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Shop$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Shop$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shop model
   */
  interface ShopFieldRefs {
    readonly id: FieldRef<"Shop", 'String'>
    readonly name: FieldRef<"Shop", 'String'>
    readonly branchId: FieldRef<"Shop", 'String'>
    readonly createdAt: FieldRef<"Shop", 'DateTime'>
    readonly updatedAt: FieldRef<"Shop", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Shop findUnique
   */
  export type ShopFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop findUniqueOrThrow
   */
  export type ShopFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop findFirst
   */
  export type ShopFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shops.
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shops.
     */
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * Shop findFirstOrThrow
   */
  export type ShopFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shops.
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shops.
     */
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * Shop findMany
   */
  export type ShopFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shops to fetch.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shops.
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * Shop create
   */
  export type ShopCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * The data needed to create a Shop.
     */
    data: XOR<ShopCreateInput, ShopUncheckedCreateInput>
  }

  /**
   * Shop createMany
   */
  export type ShopCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shops.
     */
    data: ShopCreateManyInput | ShopCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shop update
   */
  export type ShopUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * The data needed to update a Shop.
     */
    data: XOR<ShopUpdateInput, ShopUncheckedUpdateInput>
    /**
     * Choose, which Shop to update.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop updateMany
   */
  export type ShopUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shops.
     */
    data: XOR<ShopUpdateManyMutationInput, ShopUncheckedUpdateManyInput>
    /**
     * Filter which Shops to update
     */
    where?: ShopWhereInput
    /**
     * Limit how many Shops to update.
     */
    limit?: number
  }

  /**
   * Shop upsert
   */
  export type ShopUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * The filter to search for the Shop to update in case it exists.
     */
    where: ShopWhereUniqueInput
    /**
     * In case the Shop found by the `where` argument doesn't exist, create a new Shop with this data.
     */
    create: XOR<ShopCreateInput, ShopUncheckedCreateInput>
    /**
     * In case the Shop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopUpdateInput, ShopUncheckedUpdateInput>
  }

  /**
   * Shop delete
   */
  export type ShopDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter which Shop to delete.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop deleteMany
   */
  export type ShopDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shops to delete
     */
    where?: ShopWhereInput
    /**
     * Limit how many Shops to delete.
     */
    limit?: number
  }

  /**
   * Shop.ShopStock
   */
  export type Shop$ShopStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopStock
     */
    select?: ShopStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopStock
     */
    omit?: ShopStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopStockInclude<ExtArgs> | null
    where?: ShopStockWhereInput
    orderBy?: ShopStockOrderByWithRelationInput | ShopStockOrderByWithRelationInput[]
    cursor?: ShopStockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopStockScalarFieldEnum | ShopStockScalarFieldEnum[]
  }

  /**
   * Shop.StockLedger
   */
  export type Shop$StockLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
    where?: StockLedgerWhereInput
    orderBy?: StockLedgerOrderByWithRelationInput | StockLedgerOrderByWithRelationInput[]
    cursor?: StockLedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockLedgerScalarFieldEnum | StockLedgerScalarFieldEnum[]
  }

  /**
   * Shop.SourceTransfer
   */
  export type Shop$SourceTransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Shop.DestinatTransfer
   */
  export type Shop$DestinatTransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Shop.StockCorrection
   */
  export type Shop$StockCorrectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrection
     */
    select?: StockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrection
     */
    omit?: StockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionInclude<ExtArgs> | null
    where?: StockCorrectionWhereInput
    orderBy?: StockCorrectionOrderByWithRelationInput | StockCorrectionOrderByWithRelationInput[]
    cursor?: StockCorrectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockCorrectionScalarFieldEnum | StockCorrectionScalarFieldEnum[]
  }

  /**
   * Shop.AdditionalPrice
   */
  export type Shop$AdditionalPriceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalPrice
     */
    select?: AdditionalPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdditionalPrice
     */
    omit?: AdditionalPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalPriceInclude<ExtArgs> | null
    where?: AdditionalPriceWhereInput
    orderBy?: AdditionalPriceOrderByWithRelationInput | AdditionalPriceOrderByWithRelationInput[]
    cursor?: AdditionalPriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdditionalPriceScalarFieldEnum | AdditionalPriceScalarFieldEnum[]
  }

  /**
   * Shop.SellItem
   */
  export type Shop$SellItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItem
     */
    select?: SellItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellItem
     */
    omit?: SellItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellItemInclude<ExtArgs> | null
    where?: SellItemWhereInput
    orderBy?: SellItemOrderByWithRelationInput | SellItemOrderByWithRelationInput[]
    cursor?: SellItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellItemScalarFieldEnum | SellItemScalarFieldEnum[]
  }

  /**
   * Shop.SellStockCorrectionItem
   */
  export type Shop$SellStockCorrectionItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionItem
     */
    select?: SellStockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrectionItem
     */
    omit?: SellStockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionItemInclude<ExtArgs> | null
    where?: SellStockCorrectionItemWhereInput
    orderBy?: SellStockCorrectionItemOrderByWithRelationInput | SellStockCorrectionItemOrderByWithRelationInput[]
    cursor?: SellStockCorrectionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellStockCorrectionItemScalarFieldEnum | SellStockCorrectionItemScalarFieldEnum[]
  }

  /**
   * Shop.User
   */
  export type Shop$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Shop.CartItem
   */
  export type Shop$CartItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * Shop.waitlists
   */
  export type Shop$waitlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaitlistInclude<ExtArgs> | null
    where?: WaitlistWhereInput
    orderBy?: WaitlistOrderByWithRelationInput | WaitlistOrderByWithRelationInput[]
    cursor?: WaitlistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WaitlistScalarFieldEnum | WaitlistScalarFieldEnum[]
  }

  /**
   * Shop.notifications
   */
  export type Shop$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Shop without action
   */
  export type ShopDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
  }


  /**
   * Model Store
   */

  export type AggregateStore = {
    _count: StoreCountAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  export type StoreMinAggregateOutputType = {
    id: string | null
    name: string | null
    branchId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreMaxAggregateOutputType = {
    id: string | null
    name: string | null
    branchId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreCountAggregateOutputType = {
    id: number
    name: number
    branchId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StoreMinAggregateInputType = {
    id?: true
    name?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreMaxAggregateInputType = {
    id?: true
    name?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreCountAggregateInputType = {
    id?: true
    name?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Store to aggregate.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stores
    **/
    _count?: true | StoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreMaxAggregateInputType
  }

  export type GetStoreAggregateType<T extends StoreAggregateArgs> = {
        [P in keyof T & keyof AggregateStore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStore[P]>
      : GetScalarType<T[P], AggregateStore[P]>
  }




  export type StoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreWhereInput
    orderBy?: StoreOrderByWithAggregationInput | StoreOrderByWithAggregationInput[]
    by: StoreScalarFieldEnum[] | StoreScalarFieldEnum
    having?: StoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreCountAggregateInputType | true
    _min?: StoreMinAggregateInputType
    _max?: StoreMaxAggregateInputType
  }

  export type StoreGroupByOutputType = {
    id: string
    name: string
    branchId: string
    createdAt: Date
    updatedAt: Date
    _count: StoreCountAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  type GetStoreGroupByPayload<T extends StoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreGroupByOutputType[P]>
            : GetScalarType<T[P], StoreGroupByOutputType[P]>
        }
      >
    >


  export type StoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    ProductBatch?: boolean | Store$ProductBatchArgs<ExtArgs>
    StoreStock?: boolean | Store$StoreStockArgs<ExtArgs>
    StockLedger?: boolean | Store$StockLedgerArgs<ExtArgs>
    Purchase?: boolean | Store$PurchaseArgs<ExtArgs>
    SourceTransfer?: boolean | Store$SourceTransferArgs<ExtArgs>
    DestinatTransfer?: boolean | Store$DestinatTransferArgs<ExtArgs>
    StockCorrection?: boolean | Store$StockCorrectionArgs<ExtArgs>
    User?: boolean | Store$UserArgs<ExtArgs>
    notifications?: boolean | Store$notificationsArgs<ExtArgs>
    _count?: boolean | StoreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["store"]>



  export type StoreSelectScalar = {
    id?: boolean
    name?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "branchId" | "createdAt" | "updatedAt", ExtArgs["result"]["store"]>
  export type StoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    ProductBatch?: boolean | Store$ProductBatchArgs<ExtArgs>
    StoreStock?: boolean | Store$StoreStockArgs<ExtArgs>
    StockLedger?: boolean | Store$StockLedgerArgs<ExtArgs>
    Purchase?: boolean | Store$PurchaseArgs<ExtArgs>
    SourceTransfer?: boolean | Store$SourceTransferArgs<ExtArgs>
    DestinatTransfer?: boolean | Store$DestinatTransferArgs<ExtArgs>
    StockCorrection?: boolean | Store$StockCorrectionArgs<ExtArgs>
    User?: boolean | Store$UserArgs<ExtArgs>
    notifications?: boolean | Store$notificationsArgs<ExtArgs>
    _count?: boolean | StoreCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $StorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Store"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      ProductBatch: Prisma.$ProductBatchPayload<ExtArgs>[]
      StoreStock: Prisma.$StoreStockPayload<ExtArgs>[]
      StockLedger: Prisma.$StockLedgerPayload<ExtArgs>[]
      Purchase: Prisma.$PurchasePayload<ExtArgs>[]
      SourceTransfer: Prisma.$TransferPayload<ExtArgs>[]
      DestinatTransfer: Prisma.$TransferPayload<ExtArgs>[]
      StockCorrection: Prisma.$StockCorrectionPayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      branchId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["store"]>
    composites: {}
  }

  type StoreGetPayload<S extends boolean | null | undefined | StoreDefaultArgs> = $Result.GetResult<Prisma.$StorePayload, S>

  type StoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoreCountAggregateInputType | true
    }

  export interface StoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Store'], meta: { name: 'Store' } }
    /**
     * Find zero or one Store that matches the filter.
     * @param {StoreFindUniqueArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreFindUniqueArgs>(args: SelectSubset<T, StoreFindUniqueArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Store that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoreFindUniqueOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Store that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreFindFirstArgs>(args?: SelectSubset<T, StoreFindFirstArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Store that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stores
     * const stores = await prisma.store.findMany()
     * 
     * // Get first 10 Stores
     * const stores = await prisma.store.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeWithIdOnly = await prisma.store.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreFindManyArgs>(args?: SelectSubset<T, StoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Store.
     * @param {StoreCreateArgs} args - Arguments to create a Store.
     * @example
     * // Create one Store
     * const Store = await prisma.store.create({
     *   data: {
     *     // ... data to create a Store
     *   }
     * })
     * 
     */
    create<T extends StoreCreateArgs>(args: SelectSubset<T, StoreCreateArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stores.
     * @param {StoreCreateManyArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreCreateManyArgs>(args?: SelectSubset<T, StoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Store.
     * @param {StoreDeleteArgs} args - Arguments to delete one Store.
     * @example
     * // Delete one Store
     * const Store = await prisma.store.delete({
     *   where: {
     *     // ... filter to delete one Store
     *   }
     * })
     * 
     */
    delete<T extends StoreDeleteArgs>(args: SelectSubset<T, StoreDeleteArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Store.
     * @param {StoreUpdateArgs} args - Arguments to update one Store.
     * @example
     * // Update one Store
     * const store = await prisma.store.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreUpdateArgs>(args: SelectSubset<T, StoreUpdateArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stores.
     * @param {StoreDeleteManyArgs} args - Arguments to filter Stores to delete.
     * @example
     * // Delete a few Stores
     * const { count } = await prisma.store.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreDeleteManyArgs>(args?: SelectSubset<T, StoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stores
     * const store = await prisma.store.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreUpdateManyArgs>(args: SelectSubset<T, StoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Store.
     * @param {StoreUpsertArgs} args - Arguments to update or create a Store.
     * @example
     * // Update or create a Store
     * const store = await prisma.store.upsert({
     *   create: {
     *     // ... data to create a Store
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Store we want to update
     *   }
     * })
     */
    upsert<T extends StoreUpsertArgs>(args: SelectSubset<T, StoreUpsertArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreCountArgs} args - Arguments to filter Stores to count.
     * @example
     * // Count the number of Stores
     * const count = await prisma.store.count({
     *   where: {
     *     // ... the filter for the Stores we want to count
     *   }
     * })
    **/
    count<T extends StoreCountArgs>(
      args?: Subset<T, StoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreAggregateArgs>(args: Subset<T, StoreAggregateArgs>): Prisma.PrismaPromise<GetStoreAggregateType<T>>

    /**
     * Group by Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreGroupByArgs['orderBy'] }
        : { orderBy?: StoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Store model
   */
  readonly fields: StoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Store.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ProductBatch<T extends Store$ProductBatchArgs<ExtArgs> = {}>(args?: Subset<T, Store$ProductBatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StoreStock<T extends Store$StoreStockArgs<ExtArgs> = {}>(args?: Subset<T, Store$StoreStockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StockLedger<T extends Store$StockLedgerArgs<ExtArgs> = {}>(args?: Subset<T, Store$StockLedgerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Purchase<T extends Store$PurchaseArgs<ExtArgs> = {}>(args?: Subset<T, Store$PurchaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SourceTransfer<T extends Store$SourceTransferArgs<ExtArgs> = {}>(args?: Subset<T, Store$SourceTransferArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DestinatTransfer<T extends Store$DestinatTransferArgs<ExtArgs> = {}>(args?: Subset<T, Store$DestinatTransferArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StockCorrection<T extends Store$StockCorrectionArgs<ExtArgs> = {}>(args?: Subset<T, Store$StockCorrectionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockCorrectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends Store$UserArgs<ExtArgs> = {}>(args?: Subset<T, Store$UserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Store$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Store$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Store model
   */
  interface StoreFieldRefs {
    readonly id: FieldRef<"Store", 'String'>
    readonly name: FieldRef<"Store", 'String'>
    readonly branchId: FieldRef<"Store", 'String'>
    readonly createdAt: FieldRef<"Store", 'DateTime'>
    readonly updatedAt: FieldRef<"Store", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Store findUnique
   */
  export type StoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store findUniqueOrThrow
   */
  export type StoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store findFirst
   */
  export type StoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store findFirstOrThrow
   */
  export type StoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store findMany
   */
  export type StoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store create
   */
  export type StoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The data needed to create a Store.
     */
    data: XOR<StoreCreateInput, StoreUncheckedCreateInput>
  }

  /**
   * Store createMany
   */
  export type StoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stores.
     */
    data: StoreCreateManyInput | StoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Store update
   */
  export type StoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The data needed to update a Store.
     */
    data: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
    /**
     * Choose, which Store to update.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store updateMany
   */
  export type StoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stores.
     */
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoreWhereInput
    /**
     * Limit how many Stores to update.
     */
    limit?: number
  }

  /**
   * Store upsert
   */
  export type StoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The filter to search for the Store to update in case it exists.
     */
    where: StoreWhereUniqueInput
    /**
     * In case the Store found by the `where` argument doesn't exist, create a new Store with this data.
     */
    create: XOR<StoreCreateInput, StoreUncheckedCreateInput>
    /**
     * In case the Store was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
  }

  /**
   * Store delete
   */
  export type StoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter which Store to delete.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store deleteMany
   */
  export type StoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stores to delete
     */
    where?: StoreWhereInput
    /**
     * Limit how many Stores to delete.
     */
    limit?: number
  }

  /**
   * Store.ProductBatch
   */
  export type Store$ProductBatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatch
     */
    select?: ProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBatch
     */
    omit?: ProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBatchInclude<ExtArgs> | null
    where?: ProductBatchWhereInput
    orderBy?: ProductBatchOrderByWithRelationInput | ProductBatchOrderByWithRelationInput[]
    cursor?: ProductBatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductBatchScalarFieldEnum | ProductBatchScalarFieldEnum[]
  }

  /**
   * Store.StoreStock
   */
  export type Store$StoreStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStock
     */
    select?: StoreStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStock
     */
    omit?: StoreStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStockInclude<ExtArgs> | null
    where?: StoreStockWhereInput
    orderBy?: StoreStockOrderByWithRelationInput | StoreStockOrderByWithRelationInput[]
    cursor?: StoreStockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreStockScalarFieldEnum | StoreStockScalarFieldEnum[]
  }

  /**
   * Store.StockLedger
   */
  export type Store$StockLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
    where?: StockLedgerWhereInput
    orderBy?: StockLedgerOrderByWithRelationInput | StockLedgerOrderByWithRelationInput[]
    cursor?: StockLedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockLedgerScalarFieldEnum | StockLedgerScalarFieldEnum[]
  }

  /**
   * Store.Purchase
   */
  export type Store$PurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Store.SourceTransfer
   */
  export type Store$SourceTransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Store.DestinatTransfer
   */
  export type Store$DestinatTransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Store.StockCorrection
   */
  export type Store$StockCorrectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrection
     */
    select?: StockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrection
     */
    omit?: StockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionInclude<ExtArgs> | null
    where?: StockCorrectionWhereInput
    orderBy?: StockCorrectionOrderByWithRelationInput | StockCorrectionOrderByWithRelationInput[]
    cursor?: StockCorrectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockCorrectionScalarFieldEnum | StockCorrectionScalarFieldEnum[]
  }

  /**
   * Store.User
   */
  export type Store$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Store.notifications
   */
  export type Store$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Store without action
   */
  export type StoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
  }


  /**
   * Model StoreStock
   */

  export type AggregateStoreStock = {
    _count: StoreStockCountAggregateOutputType | null
    _avg: StoreStockAvgAggregateOutputType | null
    _sum: StoreStockSumAggregateOutputType | null
    _min: StoreStockMinAggregateOutputType | null
    _max: StoreStockMaxAggregateOutputType | null
  }

  export type StoreStockAvgAggregateOutputType = {
    quantity: number | null
  }

  export type StoreStockSumAggregateOutputType = {
    quantity: number | null
  }

  export type StoreStockMinAggregateOutputType = {
    id: string | null
    storeId: string | null
    batchId: string | null
    quantity: number | null
    status: $Enums.StockStatus | null
    unitOfMeasureId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreStockMaxAggregateOutputType = {
    id: string | null
    storeId: string | null
    batchId: string | null
    quantity: number | null
    status: $Enums.StockStatus | null
    unitOfMeasureId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreStockCountAggregateOutputType = {
    id: number
    storeId: number
    batchId: number
    quantity: number
    status: number
    unitOfMeasureId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StoreStockAvgAggregateInputType = {
    quantity?: true
  }

  export type StoreStockSumAggregateInputType = {
    quantity?: true
  }

  export type StoreStockMinAggregateInputType = {
    id?: true
    storeId?: true
    batchId?: true
    quantity?: true
    status?: true
    unitOfMeasureId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreStockMaxAggregateInputType = {
    id?: true
    storeId?: true
    batchId?: true
    quantity?: true
    status?: true
    unitOfMeasureId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreStockCountAggregateInputType = {
    id?: true
    storeId?: true
    batchId?: true
    quantity?: true
    status?: true
    unitOfMeasureId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StoreStockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreStock to aggregate.
     */
    where?: StoreStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreStocks to fetch.
     */
    orderBy?: StoreStockOrderByWithRelationInput | StoreStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoreStocks
    **/
    _count?: true | StoreStockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoreStockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoreStockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreStockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreStockMaxAggregateInputType
  }

  export type GetStoreStockAggregateType<T extends StoreStockAggregateArgs> = {
        [P in keyof T & keyof AggregateStoreStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoreStock[P]>
      : GetScalarType<T[P], AggregateStoreStock[P]>
  }




  export type StoreStockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreStockWhereInput
    orderBy?: StoreStockOrderByWithAggregationInput | StoreStockOrderByWithAggregationInput[]
    by: StoreStockScalarFieldEnum[] | StoreStockScalarFieldEnum
    having?: StoreStockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreStockCountAggregateInputType | true
    _avg?: StoreStockAvgAggregateInputType
    _sum?: StoreStockSumAggregateInputType
    _min?: StoreStockMinAggregateInputType
    _max?: StoreStockMaxAggregateInputType
  }

  export type StoreStockGroupByOutputType = {
    id: string
    storeId: string
    batchId: string
    quantity: number
    status: $Enums.StockStatus
    unitOfMeasureId: string
    createdAt: Date
    updatedAt: Date
    _count: StoreStockCountAggregateOutputType | null
    _avg: StoreStockAvgAggregateOutputType | null
    _sum: StoreStockSumAggregateOutputType | null
    _min: StoreStockMinAggregateOutputType | null
    _max: StoreStockMaxAggregateOutputType | null
  }

  type GetStoreStockGroupByPayload<T extends StoreStockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreStockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreStockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreStockGroupByOutputType[P]>
            : GetScalarType<T[P], StoreStockGroupByOutputType[P]>
        }
      >
    >


  export type StoreStockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    batchId?: boolean
    quantity?: boolean
    status?: boolean
    unitOfMeasureId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    batch?: boolean | ProductBatchDefaultArgs<ExtArgs>
    unitOfMeasure?: boolean | UnitOfMeasureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeStock"]>



  export type StoreStockSelectScalar = {
    id?: boolean
    storeId?: boolean
    batchId?: boolean
    quantity?: boolean
    status?: boolean
    unitOfMeasureId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StoreStockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "storeId" | "batchId" | "quantity" | "status" | "unitOfMeasureId" | "createdAt" | "updatedAt", ExtArgs["result"]["storeStock"]>
  export type StoreStockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    batch?: boolean | ProductBatchDefaultArgs<ExtArgs>
    unitOfMeasure?: boolean | UnitOfMeasureDefaultArgs<ExtArgs>
  }

  export type $StoreStockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoreStock"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
      batch: Prisma.$ProductBatchPayload<ExtArgs>
      unitOfMeasure: Prisma.$UnitOfMeasurePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storeId: string
      batchId: string
      quantity: number
      status: $Enums.StockStatus
      unitOfMeasureId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["storeStock"]>
    composites: {}
  }

  type StoreStockGetPayload<S extends boolean | null | undefined | StoreStockDefaultArgs> = $Result.GetResult<Prisma.$StoreStockPayload, S>

  type StoreStockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoreStockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoreStockCountAggregateInputType | true
    }

  export interface StoreStockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoreStock'], meta: { name: 'StoreStock' } }
    /**
     * Find zero or one StoreStock that matches the filter.
     * @param {StoreStockFindUniqueArgs} args - Arguments to find a StoreStock
     * @example
     * // Get one StoreStock
     * const storeStock = await prisma.storeStock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreStockFindUniqueArgs>(args: SelectSubset<T, StoreStockFindUniqueArgs<ExtArgs>>): Prisma__StoreStockClient<$Result.GetResult<Prisma.$StoreStockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StoreStock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoreStockFindUniqueOrThrowArgs} args - Arguments to find a StoreStock
     * @example
     * // Get one StoreStock
     * const storeStock = await prisma.storeStock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreStockFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreStockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreStockClient<$Result.GetResult<Prisma.$StoreStockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoreStock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreStockFindFirstArgs} args - Arguments to find a StoreStock
     * @example
     * // Get one StoreStock
     * const storeStock = await prisma.storeStock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreStockFindFirstArgs>(args?: SelectSubset<T, StoreStockFindFirstArgs<ExtArgs>>): Prisma__StoreStockClient<$Result.GetResult<Prisma.$StoreStockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoreStock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreStockFindFirstOrThrowArgs} args - Arguments to find a StoreStock
     * @example
     * // Get one StoreStock
     * const storeStock = await prisma.storeStock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreStockFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreStockFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreStockClient<$Result.GetResult<Prisma.$StoreStockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StoreStocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreStockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoreStocks
     * const storeStocks = await prisma.storeStock.findMany()
     * 
     * // Get first 10 StoreStocks
     * const storeStocks = await prisma.storeStock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeStockWithIdOnly = await prisma.storeStock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreStockFindManyArgs>(args?: SelectSubset<T, StoreStockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StoreStock.
     * @param {StoreStockCreateArgs} args - Arguments to create a StoreStock.
     * @example
     * // Create one StoreStock
     * const StoreStock = await prisma.storeStock.create({
     *   data: {
     *     // ... data to create a StoreStock
     *   }
     * })
     * 
     */
    create<T extends StoreStockCreateArgs>(args: SelectSubset<T, StoreStockCreateArgs<ExtArgs>>): Prisma__StoreStockClient<$Result.GetResult<Prisma.$StoreStockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StoreStocks.
     * @param {StoreStockCreateManyArgs} args - Arguments to create many StoreStocks.
     * @example
     * // Create many StoreStocks
     * const storeStock = await prisma.storeStock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreStockCreateManyArgs>(args?: SelectSubset<T, StoreStockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StoreStock.
     * @param {StoreStockDeleteArgs} args - Arguments to delete one StoreStock.
     * @example
     * // Delete one StoreStock
     * const StoreStock = await prisma.storeStock.delete({
     *   where: {
     *     // ... filter to delete one StoreStock
     *   }
     * })
     * 
     */
    delete<T extends StoreStockDeleteArgs>(args: SelectSubset<T, StoreStockDeleteArgs<ExtArgs>>): Prisma__StoreStockClient<$Result.GetResult<Prisma.$StoreStockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StoreStock.
     * @param {StoreStockUpdateArgs} args - Arguments to update one StoreStock.
     * @example
     * // Update one StoreStock
     * const storeStock = await prisma.storeStock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreStockUpdateArgs>(args: SelectSubset<T, StoreStockUpdateArgs<ExtArgs>>): Prisma__StoreStockClient<$Result.GetResult<Prisma.$StoreStockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StoreStocks.
     * @param {StoreStockDeleteManyArgs} args - Arguments to filter StoreStocks to delete.
     * @example
     * // Delete a few StoreStocks
     * const { count } = await prisma.storeStock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreStockDeleteManyArgs>(args?: SelectSubset<T, StoreStockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoreStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreStockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoreStocks
     * const storeStock = await prisma.storeStock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreStockUpdateManyArgs>(args: SelectSubset<T, StoreStockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StoreStock.
     * @param {StoreStockUpsertArgs} args - Arguments to update or create a StoreStock.
     * @example
     * // Update or create a StoreStock
     * const storeStock = await prisma.storeStock.upsert({
     *   create: {
     *     // ... data to create a StoreStock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoreStock we want to update
     *   }
     * })
     */
    upsert<T extends StoreStockUpsertArgs>(args: SelectSubset<T, StoreStockUpsertArgs<ExtArgs>>): Prisma__StoreStockClient<$Result.GetResult<Prisma.$StoreStockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StoreStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreStockCountArgs} args - Arguments to filter StoreStocks to count.
     * @example
     * // Count the number of StoreStocks
     * const count = await prisma.storeStock.count({
     *   where: {
     *     // ... the filter for the StoreStocks we want to count
     *   }
     * })
    **/
    count<T extends StoreStockCountArgs>(
      args?: Subset<T, StoreStockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreStockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoreStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreStockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreStockAggregateArgs>(args: Subset<T, StoreStockAggregateArgs>): Prisma.PrismaPromise<GetStoreStockAggregateType<T>>

    /**
     * Group by StoreStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreStockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreStockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreStockGroupByArgs['orderBy'] }
        : { orderBy?: StoreStockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreStockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoreStock model
   */
  readonly fields: StoreStockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoreStock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreStockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    batch<T extends ProductBatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductBatchDefaultArgs<ExtArgs>>): Prisma__ProductBatchClient<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unitOfMeasure<T extends UnitOfMeasureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasureDefaultArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoreStock model
   */
  interface StoreStockFieldRefs {
    readonly id: FieldRef<"StoreStock", 'String'>
    readonly storeId: FieldRef<"StoreStock", 'String'>
    readonly batchId: FieldRef<"StoreStock", 'String'>
    readonly quantity: FieldRef<"StoreStock", 'Int'>
    readonly status: FieldRef<"StoreStock", 'StockStatus'>
    readonly unitOfMeasureId: FieldRef<"StoreStock", 'String'>
    readonly createdAt: FieldRef<"StoreStock", 'DateTime'>
    readonly updatedAt: FieldRef<"StoreStock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StoreStock findUnique
   */
  export type StoreStockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStock
     */
    select?: StoreStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStock
     */
    omit?: StoreStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStockInclude<ExtArgs> | null
    /**
     * Filter, which StoreStock to fetch.
     */
    where: StoreStockWhereUniqueInput
  }

  /**
   * StoreStock findUniqueOrThrow
   */
  export type StoreStockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStock
     */
    select?: StoreStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStock
     */
    omit?: StoreStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStockInclude<ExtArgs> | null
    /**
     * Filter, which StoreStock to fetch.
     */
    where: StoreStockWhereUniqueInput
  }

  /**
   * StoreStock findFirst
   */
  export type StoreStockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStock
     */
    select?: StoreStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStock
     */
    omit?: StoreStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStockInclude<ExtArgs> | null
    /**
     * Filter, which StoreStock to fetch.
     */
    where?: StoreStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreStocks to fetch.
     */
    orderBy?: StoreStockOrderByWithRelationInput | StoreStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreStocks.
     */
    cursor?: StoreStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreStocks.
     */
    distinct?: StoreStockScalarFieldEnum | StoreStockScalarFieldEnum[]
  }

  /**
   * StoreStock findFirstOrThrow
   */
  export type StoreStockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStock
     */
    select?: StoreStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStock
     */
    omit?: StoreStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStockInclude<ExtArgs> | null
    /**
     * Filter, which StoreStock to fetch.
     */
    where?: StoreStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreStocks to fetch.
     */
    orderBy?: StoreStockOrderByWithRelationInput | StoreStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreStocks.
     */
    cursor?: StoreStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreStocks.
     */
    distinct?: StoreStockScalarFieldEnum | StoreStockScalarFieldEnum[]
  }

  /**
   * StoreStock findMany
   */
  export type StoreStockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStock
     */
    select?: StoreStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStock
     */
    omit?: StoreStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStockInclude<ExtArgs> | null
    /**
     * Filter, which StoreStocks to fetch.
     */
    where?: StoreStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreStocks to fetch.
     */
    orderBy?: StoreStockOrderByWithRelationInput | StoreStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoreStocks.
     */
    cursor?: StoreStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreStocks.
     */
    skip?: number
    distinct?: StoreStockScalarFieldEnum | StoreStockScalarFieldEnum[]
  }

  /**
   * StoreStock create
   */
  export type StoreStockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStock
     */
    select?: StoreStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStock
     */
    omit?: StoreStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStockInclude<ExtArgs> | null
    /**
     * The data needed to create a StoreStock.
     */
    data: XOR<StoreStockCreateInput, StoreStockUncheckedCreateInput>
  }

  /**
   * StoreStock createMany
   */
  export type StoreStockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoreStocks.
     */
    data: StoreStockCreateManyInput | StoreStockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoreStock update
   */
  export type StoreStockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStock
     */
    select?: StoreStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStock
     */
    omit?: StoreStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStockInclude<ExtArgs> | null
    /**
     * The data needed to update a StoreStock.
     */
    data: XOR<StoreStockUpdateInput, StoreStockUncheckedUpdateInput>
    /**
     * Choose, which StoreStock to update.
     */
    where: StoreStockWhereUniqueInput
  }

  /**
   * StoreStock updateMany
   */
  export type StoreStockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoreStocks.
     */
    data: XOR<StoreStockUpdateManyMutationInput, StoreStockUncheckedUpdateManyInput>
    /**
     * Filter which StoreStocks to update
     */
    where?: StoreStockWhereInput
    /**
     * Limit how many StoreStocks to update.
     */
    limit?: number
  }

  /**
   * StoreStock upsert
   */
  export type StoreStockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStock
     */
    select?: StoreStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStock
     */
    omit?: StoreStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStockInclude<ExtArgs> | null
    /**
     * The filter to search for the StoreStock to update in case it exists.
     */
    where: StoreStockWhereUniqueInput
    /**
     * In case the StoreStock found by the `where` argument doesn't exist, create a new StoreStock with this data.
     */
    create: XOR<StoreStockCreateInput, StoreStockUncheckedCreateInput>
    /**
     * In case the StoreStock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreStockUpdateInput, StoreStockUncheckedUpdateInput>
  }

  /**
   * StoreStock delete
   */
  export type StoreStockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStock
     */
    select?: StoreStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStock
     */
    omit?: StoreStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStockInclude<ExtArgs> | null
    /**
     * Filter which StoreStock to delete.
     */
    where: StoreStockWhereUniqueInput
  }

  /**
   * StoreStock deleteMany
   */
  export type StoreStockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreStocks to delete
     */
    where?: StoreStockWhereInput
    /**
     * Limit how many StoreStocks to delete.
     */
    limit?: number
  }

  /**
   * StoreStock without action
   */
  export type StoreStockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStock
     */
    select?: StoreStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStock
     */
    omit?: StoreStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStockInclude<ExtArgs> | null
  }


  /**
   * Model ShopStock
   */

  export type AggregateShopStock = {
    _count: ShopStockCountAggregateOutputType | null
    _avg: ShopStockAvgAggregateOutputType | null
    _sum: ShopStockSumAggregateOutputType | null
    _min: ShopStockMinAggregateOutputType | null
    _max: ShopStockMaxAggregateOutputType | null
  }

  export type ShopStockAvgAggregateOutputType = {
    quantity: number | null
  }

  export type ShopStockSumAggregateOutputType = {
    quantity: number | null
  }

  export type ShopStockMinAggregateOutputType = {
    id: string | null
    shopId: string | null
    batchId: string | null
    unitOfMeasureId: string | null
    quantity: number | null
    status: $Enums.StockStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopStockMaxAggregateOutputType = {
    id: string | null
    shopId: string | null
    batchId: string | null
    unitOfMeasureId: string | null
    quantity: number | null
    status: $Enums.StockStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopStockCountAggregateOutputType = {
    id: number
    shopId: number
    batchId: number
    unitOfMeasureId: number
    quantity: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShopStockAvgAggregateInputType = {
    quantity?: true
  }

  export type ShopStockSumAggregateInputType = {
    quantity?: true
  }

  export type ShopStockMinAggregateInputType = {
    id?: true
    shopId?: true
    batchId?: true
    unitOfMeasureId?: true
    quantity?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopStockMaxAggregateInputType = {
    id?: true
    shopId?: true
    batchId?: true
    unitOfMeasureId?: true
    quantity?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopStockCountAggregateInputType = {
    id?: true
    shopId?: true
    batchId?: true
    unitOfMeasureId?: true
    quantity?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShopStockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopStock to aggregate.
     */
    where?: ShopStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopStocks to fetch.
     */
    orderBy?: ShopStockOrderByWithRelationInput | ShopStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShopStocks
    **/
    _count?: true | ShopStockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShopStockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShopStockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopStockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopStockMaxAggregateInputType
  }

  export type GetShopStockAggregateType<T extends ShopStockAggregateArgs> = {
        [P in keyof T & keyof AggregateShopStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopStock[P]>
      : GetScalarType<T[P], AggregateShopStock[P]>
  }




  export type ShopStockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopStockWhereInput
    orderBy?: ShopStockOrderByWithAggregationInput | ShopStockOrderByWithAggregationInput[]
    by: ShopStockScalarFieldEnum[] | ShopStockScalarFieldEnum
    having?: ShopStockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopStockCountAggregateInputType | true
    _avg?: ShopStockAvgAggregateInputType
    _sum?: ShopStockSumAggregateInputType
    _min?: ShopStockMinAggregateInputType
    _max?: ShopStockMaxAggregateInputType
  }

  export type ShopStockGroupByOutputType = {
    id: string
    shopId: string
    batchId: string
    unitOfMeasureId: string
    quantity: number
    status: $Enums.StockStatus
    createdAt: Date
    updatedAt: Date
    _count: ShopStockCountAggregateOutputType | null
    _avg: ShopStockAvgAggregateOutputType | null
    _sum: ShopStockSumAggregateOutputType | null
    _min: ShopStockMinAggregateOutputType | null
    _max: ShopStockMaxAggregateOutputType | null
  }

  type GetShopStockGroupByPayload<T extends ShopStockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopStockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopStockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopStockGroupByOutputType[P]>
            : GetScalarType<T[P], ShopStockGroupByOutputType[P]>
        }
      >
    >


  export type ShopStockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopId?: boolean
    batchId?: boolean
    unitOfMeasureId?: boolean
    quantity?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    batch?: boolean | ProductBatchDefaultArgs<ExtArgs>
    unitOfMeasure?: boolean | UnitOfMeasureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopStock"]>



  export type ShopStockSelectScalar = {
    id?: boolean
    shopId?: boolean
    batchId?: boolean
    unitOfMeasureId?: boolean
    quantity?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShopStockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shopId" | "batchId" | "unitOfMeasureId" | "quantity" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["shopStock"]>
  export type ShopStockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    batch?: boolean | ProductBatchDefaultArgs<ExtArgs>
    unitOfMeasure?: boolean | UnitOfMeasureDefaultArgs<ExtArgs>
  }

  export type $ShopStockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShopStock"
    objects: {
      shop: Prisma.$ShopPayload<ExtArgs>
      batch: Prisma.$ProductBatchPayload<ExtArgs>
      unitOfMeasure: Prisma.$UnitOfMeasurePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shopId: string
      batchId: string
      unitOfMeasureId: string
      quantity: number
      status: $Enums.StockStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shopStock"]>
    composites: {}
  }

  type ShopStockGetPayload<S extends boolean | null | undefined | ShopStockDefaultArgs> = $Result.GetResult<Prisma.$ShopStockPayload, S>

  type ShopStockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShopStockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShopStockCountAggregateInputType | true
    }

  export interface ShopStockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShopStock'], meta: { name: 'ShopStock' } }
    /**
     * Find zero or one ShopStock that matches the filter.
     * @param {ShopStockFindUniqueArgs} args - Arguments to find a ShopStock
     * @example
     * // Get one ShopStock
     * const shopStock = await prisma.shopStock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShopStockFindUniqueArgs>(args: SelectSubset<T, ShopStockFindUniqueArgs<ExtArgs>>): Prisma__ShopStockClient<$Result.GetResult<Prisma.$ShopStockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShopStock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShopStockFindUniqueOrThrowArgs} args - Arguments to find a ShopStock
     * @example
     * // Get one ShopStock
     * const shopStock = await prisma.shopStock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShopStockFindUniqueOrThrowArgs>(args: SelectSubset<T, ShopStockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShopStockClient<$Result.GetResult<Prisma.$ShopStockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShopStock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopStockFindFirstArgs} args - Arguments to find a ShopStock
     * @example
     * // Get one ShopStock
     * const shopStock = await prisma.shopStock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShopStockFindFirstArgs>(args?: SelectSubset<T, ShopStockFindFirstArgs<ExtArgs>>): Prisma__ShopStockClient<$Result.GetResult<Prisma.$ShopStockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShopStock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopStockFindFirstOrThrowArgs} args - Arguments to find a ShopStock
     * @example
     * // Get one ShopStock
     * const shopStock = await prisma.shopStock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShopStockFindFirstOrThrowArgs>(args?: SelectSubset<T, ShopStockFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShopStockClient<$Result.GetResult<Prisma.$ShopStockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShopStocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopStockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShopStocks
     * const shopStocks = await prisma.shopStock.findMany()
     * 
     * // Get first 10 ShopStocks
     * const shopStocks = await prisma.shopStock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopStockWithIdOnly = await prisma.shopStock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShopStockFindManyArgs>(args?: SelectSubset<T, ShopStockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShopStock.
     * @param {ShopStockCreateArgs} args - Arguments to create a ShopStock.
     * @example
     * // Create one ShopStock
     * const ShopStock = await prisma.shopStock.create({
     *   data: {
     *     // ... data to create a ShopStock
     *   }
     * })
     * 
     */
    create<T extends ShopStockCreateArgs>(args: SelectSubset<T, ShopStockCreateArgs<ExtArgs>>): Prisma__ShopStockClient<$Result.GetResult<Prisma.$ShopStockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShopStocks.
     * @param {ShopStockCreateManyArgs} args - Arguments to create many ShopStocks.
     * @example
     * // Create many ShopStocks
     * const shopStock = await prisma.shopStock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShopStockCreateManyArgs>(args?: SelectSubset<T, ShopStockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ShopStock.
     * @param {ShopStockDeleteArgs} args - Arguments to delete one ShopStock.
     * @example
     * // Delete one ShopStock
     * const ShopStock = await prisma.shopStock.delete({
     *   where: {
     *     // ... filter to delete one ShopStock
     *   }
     * })
     * 
     */
    delete<T extends ShopStockDeleteArgs>(args: SelectSubset<T, ShopStockDeleteArgs<ExtArgs>>): Prisma__ShopStockClient<$Result.GetResult<Prisma.$ShopStockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShopStock.
     * @param {ShopStockUpdateArgs} args - Arguments to update one ShopStock.
     * @example
     * // Update one ShopStock
     * const shopStock = await prisma.shopStock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShopStockUpdateArgs>(args: SelectSubset<T, ShopStockUpdateArgs<ExtArgs>>): Prisma__ShopStockClient<$Result.GetResult<Prisma.$ShopStockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShopStocks.
     * @param {ShopStockDeleteManyArgs} args - Arguments to filter ShopStocks to delete.
     * @example
     * // Delete a few ShopStocks
     * const { count } = await prisma.shopStock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShopStockDeleteManyArgs>(args?: SelectSubset<T, ShopStockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopStockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShopStocks
     * const shopStock = await prisma.shopStock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShopStockUpdateManyArgs>(args: SelectSubset<T, ShopStockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShopStock.
     * @param {ShopStockUpsertArgs} args - Arguments to update or create a ShopStock.
     * @example
     * // Update or create a ShopStock
     * const shopStock = await prisma.shopStock.upsert({
     *   create: {
     *     // ... data to create a ShopStock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShopStock we want to update
     *   }
     * })
     */
    upsert<T extends ShopStockUpsertArgs>(args: SelectSubset<T, ShopStockUpsertArgs<ExtArgs>>): Prisma__ShopStockClient<$Result.GetResult<Prisma.$ShopStockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShopStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopStockCountArgs} args - Arguments to filter ShopStocks to count.
     * @example
     * // Count the number of ShopStocks
     * const count = await prisma.shopStock.count({
     *   where: {
     *     // ... the filter for the ShopStocks we want to count
     *   }
     * })
    **/
    count<T extends ShopStockCountArgs>(
      args?: Subset<T, ShopStockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopStockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShopStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopStockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopStockAggregateArgs>(args: Subset<T, ShopStockAggregateArgs>): Prisma.PrismaPromise<GetShopStockAggregateType<T>>

    /**
     * Group by ShopStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopStockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopStockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopStockGroupByArgs['orderBy'] }
        : { orderBy?: ShopStockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopStockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShopStock model
   */
  readonly fields: ShopStockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShopStock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopStockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    batch<T extends ProductBatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductBatchDefaultArgs<ExtArgs>>): Prisma__ProductBatchClient<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unitOfMeasure<T extends UnitOfMeasureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasureDefaultArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShopStock model
   */
  interface ShopStockFieldRefs {
    readonly id: FieldRef<"ShopStock", 'String'>
    readonly shopId: FieldRef<"ShopStock", 'String'>
    readonly batchId: FieldRef<"ShopStock", 'String'>
    readonly unitOfMeasureId: FieldRef<"ShopStock", 'String'>
    readonly quantity: FieldRef<"ShopStock", 'Int'>
    readonly status: FieldRef<"ShopStock", 'StockStatus'>
    readonly createdAt: FieldRef<"ShopStock", 'DateTime'>
    readonly updatedAt: FieldRef<"ShopStock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShopStock findUnique
   */
  export type ShopStockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopStock
     */
    select?: ShopStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopStock
     */
    omit?: ShopStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopStockInclude<ExtArgs> | null
    /**
     * Filter, which ShopStock to fetch.
     */
    where: ShopStockWhereUniqueInput
  }

  /**
   * ShopStock findUniqueOrThrow
   */
  export type ShopStockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopStock
     */
    select?: ShopStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopStock
     */
    omit?: ShopStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopStockInclude<ExtArgs> | null
    /**
     * Filter, which ShopStock to fetch.
     */
    where: ShopStockWhereUniqueInput
  }

  /**
   * ShopStock findFirst
   */
  export type ShopStockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopStock
     */
    select?: ShopStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopStock
     */
    omit?: ShopStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopStockInclude<ExtArgs> | null
    /**
     * Filter, which ShopStock to fetch.
     */
    where?: ShopStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopStocks to fetch.
     */
    orderBy?: ShopStockOrderByWithRelationInput | ShopStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopStocks.
     */
    cursor?: ShopStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopStocks.
     */
    distinct?: ShopStockScalarFieldEnum | ShopStockScalarFieldEnum[]
  }

  /**
   * ShopStock findFirstOrThrow
   */
  export type ShopStockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopStock
     */
    select?: ShopStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopStock
     */
    omit?: ShopStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopStockInclude<ExtArgs> | null
    /**
     * Filter, which ShopStock to fetch.
     */
    where?: ShopStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopStocks to fetch.
     */
    orderBy?: ShopStockOrderByWithRelationInput | ShopStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopStocks.
     */
    cursor?: ShopStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopStocks.
     */
    distinct?: ShopStockScalarFieldEnum | ShopStockScalarFieldEnum[]
  }

  /**
   * ShopStock findMany
   */
  export type ShopStockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopStock
     */
    select?: ShopStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopStock
     */
    omit?: ShopStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopStockInclude<ExtArgs> | null
    /**
     * Filter, which ShopStocks to fetch.
     */
    where?: ShopStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopStocks to fetch.
     */
    orderBy?: ShopStockOrderByWithRelationInput | ShopStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShopStocks.
     */
    cursor?: ShopStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopStocks.
     */
    skip?: number
    distinct?: ShopStockScalarFieldEnum | ShopStockScalarFieldEnum[]
  }

  /**
   * ShopStock create
   */
  export type ShopStockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopStock
     */
    select?: ShopStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopStock
     */
    omit?: ShopStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopStockInclude<ExtArgs> | null
    /**
     * The data needed to create a ShopStock.
     */
    data: XOR<ShopStockCreateInput, ShopStockUncheckedCreateInput>
  }

  /**
   * ShopStock createMany
   */
  export type ShopStockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShopStocks.
     */
    data: ShopStockCreateManyInput | ShopStockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShopStock update
   */
  export type ShopStockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopStock
     */
    select?: ShopStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopStock
     */
    omit?: ShopStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopStockInclude<ExtArgs> | null
    /**
     * The data needed to update a ShopStock.
     */
    data: XOR<ShopStockUpdateInput, ShopStockUncheckedUpdateInput>
    /**
     * Choose, which ShopStock to update.
     */
    where: ShopStockWhereUniqueInput
  }

  /**
   * ShopStock updateMany
   */
  export type ShopStockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShopStocks.
     */
    data: XOR<ShopStockUpdateManyMutationInput, ShopStockUncheckedUpdateManyInput>
    /**
     * Filter which ShopStocks to update
     */
    where?: ShopStockWhereInput
    /**
     * Limit how many ShopStocks to update.
     */
    limit?: number
  }

  /**
   * ShopStock upsert
   */
  export type ShopStockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopStock
     */
    select?: ShopStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopStock
     */
    omit?: ShopStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopStockInclude<ExtArgs> | null
    /**
     * The filter to search for the ShopStock to update in case it exists.
     */
    where: ShopStockWhereUniqueInput
    /**
     * In case the ShopStock found by the `where` argument doesn't exist, create a new ShopStock with this data.
     */
    create: XOR<ShopStockCreateInput, ShopStockUncheckedCreateInput>
    /**
     * In case the ShopStock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopStockUpdateInput, ShopStockUncheckedUpdateInput>
  }

  /**
   * ShopStock delete
   */
  export type ShopStockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopStock
     */
    select?: ShopStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopStock
     */
    omit?: ShopStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopStockInclude<ExtArgs> | null
    /**
     * Filter which ShopStock to delete.
     */
    where: ShopStockWhereUniqueInput
  }

  /**
   * ShopStock deleteMany
   */
  export type ShopStockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopStocks to delete
     */
    where?: ShopStockWhereInput
    /**
     * Limit how many ShopStocks to delete.
     */
    limit?: number
  }

  /**
   * ShopStock without action
   */
  export type ShopStockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopStock
     */
    select?: ShopStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopStock
     */
    omit?: ShopStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopStockInclude<ExtArgs> | null
  }


  /**
   * Model StockLedger
   */

  export type AggregateStockLedger = {
    _count: StockLedgerCountAggregateOutputType | null
    _avg: StockLedgerAvgAggregateOutputType | null
    _sum: StockLedgerSumAggregateOutputType | null
    _min: StockLedgerMinAggregateOutputType | null
    _max: StockLedgerMaxAggregateOutputType | null
  }

  export type StockLedgerAvgAggregateOutputType = {
    quantity: number | null
  }

  export type StockLedgerSumAggregateOutputType = {
    quantity: number | null
  }

  export type StockLedgerMinAggregateOutputType = {
    id: string | null
    invoiceNo: string | null
    batchId: string | null
    storeId: string | null
    shopId: string | null
    movementType: $Enums.StockMovementType | null
    quantity: number | null
    unitOfMeasureId: string | null
    reference: string | null
    userId: string | null
    notes: string | null
    movementDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockLedgerMaxAggregateOutputType = {
    id: string | null
    invoiceNo: string | null
    batchId: string | null
    storeId: string | null
    shopId: string | null
    movementType: $Enums.StockMovementType | null
    quantity: number | null
    unitOfMeasureId: string | null
    reference: string | null
    userId: string | null
    notes: string | null
    movementDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockLedgerCountAggregateOutputType = {
    id: number
    invoiceNo: number
    batchId: number
    storeId: number
    shopId: number
    movementType: number
    quantity: number
    unitOfMeasureId: number
    reference: number
    userId: number
    notes: number
    movementDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StockLedgerAvgAggregateInputType = {
    quantity?: true
  }

  export type StockLedgerSumAggregateInputType = {
    quantity?: true
  }

  export type StockLedgerMinAggregateInputType = {
    id?: true
    invoiceNo?: true
    batchId?: true
    storeId?: true
    shopId?: true
    movementType?: true
    quantity?: true
    unitOfMeasureId?: true
    reference?: true
    userId?: true
    notes?: true
    movementDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockLedgerMaxAggregateInputType = {
    id?: true
    invoiceNo?: true
    batchId?: true
    storeId?: true
    shopId?: true
    movementType?: true
    quantity?: true
    unitOfMeasureId?: true
    reference?: true
    userId?: true
    notes?: true
    movementDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockLedgerCountAggregateInputType = {
    id?: true
    invoiceNo?: true
    batchId?: true
    storeId?: true
    shopId?: true
    movementType?: true
    quantity?: true
    unitOfMeasureId?: true
    reference?: true
    userId?: true
    notes?: true
    movementDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StockLedgerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockLedger to aggregate.
     */
    where?: StockLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockLedgers to fetch.
     */
    orderBy?: StockLedgerOrderByWithRelationInput | StockLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockLedgers
    **/
    _count?: true | StockLedgerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockLedgerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockLedgerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockLedgerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockLedgerMaxAggregateInputType
  }

  export type GetStockLedgerAggregateType<T extends StockLedgerAggregateArgs> = {
        [P in keyof T & keyof AggregateStockLedger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockLedger[P]>
      : GetScalarType<T[P], AggregateStockLedger[P]>
  }




  export type StockLedgerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockLedgerWhereInput
    orderBy?: StockLedgerOrderByWithAggregationInput | StockLedgerOrderByWithAggregationInput[]
    by: StockLedgerScalarFieldEnum[] | StockLedgerScalarFieldEnum
    having?: StockLedgerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockLedgerCountAggregateInputType | true
    _avg?: StockLedgerAvgAggregateInputType
    _sum?: StockLedgerSumAggregateInputType
    _min?: StockLedgerMinAggregateInputType
    _max?: StockLedgerMaxAggregateInputType
  }

  export type StockLedgerGroupByOutputType = {
    id: string
    invoiceNo: string | null
    batchId: string
    storeId: string | null
    shopId: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    unitOfMeasureId: string
    reference: string | null
    userId: string | null
    notes: string | null
    movementDate: Date
    createdAt: Date
    updatedAt: Date
    _count: StockLedgerCountAggregateOutputType | null
    _avg: StockLedgerAvgAggregateOutputType | null
    _sum: StockLedgerSumAggregateOutputType | null
    _min: StockLedgerMinAggregateOutputType | null
    _max: StockLedgerMaxAggregateOutputType | null
  }

  type GetStockLedgerGroupByPayload<T extends StockLedgerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockLedgerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockLedgerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockLedgerGroupByOutputType[P]>
            : GetScalarType<T[P], StockLedgerGroupByOutputType[P]>
        }
      >
    >


  export type StockLedgerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNo?: boolean
    batchId?: boolean
    storeId?: boolean
    shopId?: boolean
    movementType?: boolean
    quantity?: boolean
    unitOfMeasureId?: boolean
    reference?: boolean
    userId?: boolean
    notes?: boolean
    movementDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    batch?: boolean | ProductBatchDefaultArgs<ExtArgs>
    store?: boolean | StockLedger$storeArgs<ExtArgs>
    shop?: boolean | StockLedger$shopArgs<ExtArgs>
    unitOfMeasure?: boolean | UnitOfMeasureDefaultArgs<ExtArgs>
    user?: boolean | StockLedger$userArgs<ExtArgs>
  }, ExtArgs["result"]["stockLedger"]>



  export type StockLedgerSelectScalar = {
    id?: boolean
    invoiceNo?: boolean
    batchId?: boolean
    storeId?: boolean
    shopId?: boolean
    movementType?: boolean
    quantity?: boolean
    unitOfMeasureId?: boolean
    reference?: boolean
    userId?: boolean
    notes?: boolean
    movementDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StockLedgerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceNo" | "batchId" | "storeId" | "shopId" | "movementType" | "quantity" | "unitOfMeasureId" | "reference" | "userId" | "notes" | "movementDate" | "createdAt" | "updatedAt", ExtArgs["result"]["stockLedger"]>
  export type StockLedgerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | ProductBatchDefaultArgs<ExtArgs>
    store?: boolean | StockLedger$storeArgs<ExtArgs>
    shop?: boolean | StockLedger$shopArgs<ExtArgs>
    unitOfMeasure?: boolean | UnitOfMeasureDefaultArgs<ExtArgs>
    user?: boolean | StockLedger$userArgs<ExtArgs>
  }

  export type $StockLedgerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockLedger"
    objects: {
      batch: Prisma.$ProductBatchPayload<ExtArgs>
      store: Prisma.$StorePayload<ExtArgs> | null
      shop: Prisma.$ShopPayload<ExtArgs> | null
      unitOfMeasure: Prisma.$UnitOfMeasurePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceNo: string | null
      batchId: string
      storeId: string | null
      shopId: string | null
      movementType: $Enums.StockMovementType
      quantity: number
      unitOfMeasureId: string
      reference: string | null
      userId: string | null
      notes: string | null
      movementDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stockLedger"]>
    composites: {}
  }

  type StockLedgerGetPayload<S extends boolean | null | undefined | StockLedgerDefaultArgs> = $Result.GetResult<Prisma.$StockLedgerPayload, S>

  type StockLedgerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockLedgerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockLedgerCountAggregateInputType | true
    }

  export interface StockLedgerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockLedger'], meta: { name: 'StockLedger' } }
    /**
     * Find zero or one StockLedger that matches the filter.
     * @param {StockLedgerFindUniqueArgs} args - Arguments to find a StockLedger
     * @example
     * // Get one StockLedger
     * const stockLedger = await prisma.stockLedger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockLedgerFindUniqueArgs>(args: SelectSubset<T, StockLedgerFindUniqueArgs<ExtArgs>>): Prisma__StockLedgerClient<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockLedger that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockLedgerFindUniqueOrThrowArgs} args - Arguments to find a StockLedger
     * @example
     * // Get one StockLedger
     * const stockLedger = await prisma.stockLedger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockLedgerFindUniqueOrThrowArgs>(args: SelectSubset<T, StockLedgerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockLedgerClient<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockLedger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLedgerFindFirstArgs} args - Arguments to find a StockLedger
     * @example
     * // Get one StockLedger
     * const stockLedger = await prisma.stockLedger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockLedgerFindFirstArgs>(args?: SelectSubset<T, StockLedgerFindFirstArgs<ExtArgs>>): Prisma__StockLedgerClient<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockLedger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLedgerFindFirstOrThrowArgs} args - Arguments to find a StockLedger
     * @example
     * // Get one StockLedger
     * const stockLedger = await prisma.stockLedger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockLedgerFindFirstOrThrowArgs>(args?: SelectSubset<T, StockLedgerFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockLedgerClient<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockLedgers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLedgerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockLedgers
     * const stockLedgers = await prisma.stockLedger.findMany()
     * 
     * // Get first 10 StockLedgers
     * const stockLedgers = await prisma.stockLedger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockLedgerWithIdOnly = await prisma.stockLedger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockLedgerFindManyArgs>(args?: SelectSubset<T, StockLedgerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockLedger.
     * @param {StockLedgerCreateArgs} args - Arguments to create a StockLedger.
     * @example
     * // Create one StockLedger
     * const StockLedger = await prisma.stockLedger.create({
     *   data: {
     *     // ... data to create a StockLedger
     *   }
     * })
     * 
     */
    create<T extends StockLedgerCreateArgs>(args: SelectSubset<T, StockLedgerCreateArgs<ExtArgs>>): Prisma__StockLedgerClient<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockLedgers.
     * @param {StockLedgerCreateManyArgs} args - Arguments to create many StockLedgers.
     * @example
     * // Create many StockLedgers
     * const stockLedger = await prisma.stockLedger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockLedgerCreateManyArgs>(args?: SelectSubset<T, StockLedgerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StockLedger.
     * @param {StockLedgerDeleteArgs} args - Arguments to delete one StockLedger.
     * @example
     * // Delete one StockLedger
     * const StockLedger = await prisma.stockLedger.delete({
     *   where: {
     *     // ... filter to delete one StockLedger
     *   }
     * })
     * 
     */
    delete<T extends StockLedgerDeleteArgs>(args: SelectSubset<T, StockLedgerDeleteArgs<ExtArgs>>): Prisma__StockLedgerClient<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockLedger.
     * @param {StockLedgerUpdateArgs} args - Arguments to update one StockLedger.
     * @example
     * // Update one StockLedger
     * const stockLedger = await prisma.stockLedger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockLedgerUpdateArgs>(args: SelectSubset<T, StockLedgerUpdateArgs<ExtArgs>>): Prisma__StockLedgerClient<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockLedgers.
     * @param {StockLedgerDeleteManyArgs} args - Arguments to filter StockLedgers to delete.
     * @example
     * // Delete a few StockLedgers
     * const { count } = await prisma.stockLedger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockLedgerDeleteManyArgs>(args?: SelectSubset<T, StockLedgerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLedgerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockLedgers
     * const stockLedger = await prisma.stockLedger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockLedgerUpdateManyArgs>(args: SelectSubset<T, StockLedgerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockLedger.
     * @param {StockLedgerUpsertArgs} args - Arguments to update or create a StockLedger.
     * @example
     * // Update or create a StockLedger
     * const stockLedger = await prisma.stockLedger.upsert({
     *   create: {
     *     // ... data to create a StockLedger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockLedger we want to update
     *   }
     * })
     */
    upsert<T extends StockLedgerUpsertArgs>(args: SelectSubset<T, StockLedgerUpsertArgs<ExtArgs>>): Prisma__StockLedgerClient<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLedgerCountArgs} args - Arguments to filter StockLedgers to count.
     * @example
     * // Count the number of StockLedgers
     * const count = await prisma.stockLedger.count({
     *   where: {
     *     // ... the filter for the StockLedgers we want to count
     *   }
     * })
    **/
    count<T extends StockLedgerCountArgs>(
      args?: Subset<T, StockLedgerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockLedgerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLedgerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockLedgerAggregateArgs>(args: Subset<T, StockLedgerAggregateArgs>): Prisma.PrismaPromise<GetStockLedgerAggregateType<T>>

    /**
     * Group by StockLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLedgerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockLedgerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockLedgerGroupByArgs['orderBy'] }
        : { orderBy?: StockLedgerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockLedgerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockLedgerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockLedger model
   */
  readonly fields: StockLedgerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockLedger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockLedgerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batch<T extends ProductBatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductBatchDefaultArgs<ExtArgs>>): Prisma__ProductBatchClient<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    store<T extends StockLedger$storeArgs<ExtArgs> = {}>(args?: Subset<T, StockLedger$storeArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    shop<T extends StockLedger$shopArgs<ExtArgs> = {}>(args?: Subset<T, StockLedger$shopArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    unitOfMeasure<T extends UnitOfMeasureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasureDefaultArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends StockLedger$userArgs<ExtArgs> = {}>(args?: Subset<T, StockLedger$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockLedger model
   */
  interface StockLedgerFieldRefs {
    readonly id: FieldRef<"StockLedger", 'String'>
    readonly invoiceNo: FieldRef<"StockLedger", 'String'>
    readonly batchId: FieldRef<"StockLedger", 'String'>
    readonly storeId: FieldRef<"StockLedger", 'String'>
    readonly shopId: FieldRef<"StockLedger", 'String'>
    readonly movementType: FieldRef<"StockLedger", 'StockMovementType'>
    readonly quantity: FieldRef<"StockLedger", 'Int'>
    readonly unitOfMeasureId: FieldRef<"StockLedger", 'String'>
    readonly reference: FieldRef<"StockLedger", 'String'>
    readonly userId: FieldRef<"StockLedger", 'String'>
    readonly notes: FieldRef<"StockLedger", 'String'>
    readonly movementDate: FieldRef<"StockLedger", 'DateTime'>
    readonly createdAt: FieldRef<"StockLedger", 'DateTime'>
    readonly updatedAt: FieldRef<"StockLedger", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockLedger findUnique
   */
  export type StockLedgerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
    /**
     * Filter, which StockLedger to fetch.
     */
    where: StockLedgerWhereUniqueInput
  }

  /**
   * StockLedger findUniqueOrThrow
   */
  export type StockLedgerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
    /**
     * Filter, which StockLedger to fetch.
     */
    where: StockLedgerWhereUniqueInput
  }

  /**
   * StockLedger findFirst
   */
  export type StockLedgerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
    /**
     * Filter, which StockLedger to fetch.
     */
    where?: StockLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockLedgers to fetch.
     */
    orderBy?: StockLedgerOrderByWithRelationInput | StockLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockLedgers.
     */
    cursor?: StockLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockLedgers.
     */
    distinct?: StockLedgerScalarFieldEnum | StockLedgerScalarFieldEnum[]
  }

  /**
   * StockLedger findFirstOrThrow
   */
  export type StockLedgerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
    /**
     * Filter, which StockLedger to fetch.
     */
    where?: StockLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockLedgers to fetch.
     */
    orderBy?: StockLedgerOrderByWithRelationInput | StockLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockLedgers.
     */
    cursor?: StockLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockLedgers.
     */
    distinct?: StockLedgerScalarFieldEnum | StockLedgerScalarFieldEnum[]
  }

  /**
   * StockLedger findMany
   */
  export type StockLedgerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
    /**
     * Filter, which StockLedgers to fetch.
     */
    where?: StockLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockLedgers to fetch.
     */
    orderBy?: StockLedgerOrderByWithRelationInput | StockLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockLedgers.
     */
    cursor?: StockLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockLedgers.
     */
    skip?: number
    distinct?: StockLedgerScalarFieldEnum | StockLedgerScalarFieldEnum[]
  }

  /**
   * StockLedger create
   */
  export type StockLedgerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
    /**
     * The data needed to create a StockLedger.
     */
    data: XOR<StockLedgerCreateInput, StockLedgerUncheckedCreateInput>
  }

  /**
   * StockLedger createMany
   */
  export type StockLedgerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockLedgers.
     */
    data: StockLedgerCreateManyInput | StockLedgerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockLedger update
   */
  export type StockLedgerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
    /**
     * The data needed to update a StockLedger.
     */
    data: XOR<StockLedgerUpdateInput, StockLedgerUncheckedUpdateInput>
    /**
     * Choose, which StockLedger to update.
     */
    where: StockLedgerWhereUniqueInput
  }

  /**
   * StockLedger updateMany
   */
  export type StockLedgerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockLedgers.
     */
    data: XOR<StockLedgerUpdateManyMutationInput, StockLedgerUncheckedUpdateManyInput>
    /**
     * Filter which StockLedgers to update
     */
    where?: StockLedgerWhereInput
    /**
     * Limit how many StockLedgers to update.
     */
    limit?: number
  }

  /**
   * StockLedger upsert
   */
  export type StockLedgerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
    /**
     * The filter to search for the StockLedger to update in case it exists.
     */
    where: StockLedgerWhereUniqueInput
    /**
     * In case the StockLedger found by the `where` argument doesn't exist, create a new StockLedger with this data.
     */
    create: XOR<StockLedgerCreateInput, StockLedgerUncheckedCreateInput>
    /**
     * In case the StockLedger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockLedgerUpdateInput, StockLedgerUncheckedUpdateInput>
  }

  /**
   * StockLedger delete
   */
  export type StockLedgerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
    /**
     * Filter which StockLedger to delete.
     */
    where: StockLedgerWhereUniqueInput
  }

  /**
   * StockLedger deleteMany
   */
  export type StockLedgerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockLedgers to delete
     */
    where?: StockLedgerWhereInput
    /**
     * Limit how many StockLedgers to delete.
     */
    limit?: number
  }

  /**
   * StockLedger.store
   */
  export type StockLedger$storeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    where?: StoreWhereInput
  }

  /**
   * StockLedger.shop
   */
  export type StockLedger$shopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    where?: ShopWhereInput
  }

  /**
   * StockLedger.user
   */
  export type StockLedger$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * StockLedger without action
   */
  export type StockLedgerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
  }


  /**
   * Model Log
   */

  export type AggregateLog = {
    _count: LogCountAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  export type LogMinAggregateOutputType = {
    id: string | null
    action: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LogMaxAggregateOutputType = {
    id: string | null
    action: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LogCountAggregateOutputType = {
    id: number
    action: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LogMinAggregateInputType = {
    id?: true
    action?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LogMaxAggregateInputType = {
    id?: true
    action?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LogCountAggregateInputType = {
    id?: true
    action?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Log to aggregate.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogMaxAggregateInputType
  }

  export type GetLogAggregateType<T extends LogAggregateArgs> = {
        [P in keyof T & keyof AggregateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLog[P]>
      : GetScalarType<T[P], AggregateLog[P]>
  }




  export type LogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
    orderBy?: LogOrderByWithAggregationInput | LogOrderByWithAggregationInput[]
    by: LogScalarFieldEnum[] | LogScalarFieldEnum
    having?: LogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogCountAggregateInputType | true
    _min?: LogMinAggregateInputType
    _max?: LogMaxAggregateInputType
  }

  export type LogGroupByOutputType = {
    id: string
    action: string
    userId: string | null
    createdAt: Date
    updatedAt: Date
    _count: LogCountAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  type GetLogGroupByPayload<T extends LogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogGroupByOutputType[P]>
            : GetScalarType<T[P], LogGroupByOutputType[P]>
        }
      >
    >


  export type LogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Log$userArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>



  export type LogSelectScalar = {
    id?: boolean
    action?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "action" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["log"]>
  export type LogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Log$userArgs<ExtArgs>
  }

  export type $LogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Log"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string
      userId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["log"]>
    composites: {}
  }

  type LogGetPayload<S extends boolean | null | undefined | LogDefaultArgs> = $Result.GetResult<Prisma.$LogPayload, S>

  type LogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LogCountAggregateInputType | true
    }

  export interface LogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Log'], meta: { name: 'Log' } }
    /**
     * Find zero or one Log that matches the filter.
     * @param {LogFindUniqueArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogFindUniqueArgs>(args: SelectSubset<T, LogFindUniqueArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Log that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LogFindUniqueOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogFindUniqueOrThrowArgs>(args: SelectSubset<T, LogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogFindFirstArgs>(args?: SelectSubset<T, LogFindFirstArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogFindFirstOrThrowArgs>(args?: SelectSubset<T, LogFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.log.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logWithIdOnly = await prisma.log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogFindManyArgs>(args?: SelectSubset<T, LogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Log.
     * @param {LogCreateArgs} args - Arguments to create a Log.
     * @example
     * // Create one Log
     * const Log = await prisma.log.create({
     *   data: {
     *     // ... data to create a Log
     *   }
     * })
     * 
     */
    create<T extends LogCreateArgs>(args: SelectSubset<T, LogCreateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Logs.
     * @param {LogCreateManyArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogCreateManyArgs>(args?: SelectSubset<T, LogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Log.
     * @param {LogDeleteArgs} args - Arguments to delete one Log.
     * @example
     * // Delete one Log
     * const Log = await prisma.log.delete({
     *   where: {
     *     // ... filter to delete one Log
     *   }
     * })
     * 
     */
    delete<T extends LogDeleteArgs>(args: SelectSubset<T, LogDeleteArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Log.
     * @param {LogUpdateArgs} args - Arguments to update one Log.
     * @example
     * // Update one Log
     * const log = await prisma.log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogUpdateArgs>(args: SelectSubset<T, LogUpdateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Logs.
     * @param {LogDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogDeleteManyArgs>(args?: SelectSubset<T, LogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogUpdateManyArgs>(args: SelectSubset<T, LogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Log.
     * @param {LogUpsertArgs} args - Arguments to update or create a Log.
     * @example
     * // Update or create a Log
     * const log = await prisma.log.upsert({
     *   create: {
     *     // ... data to create a Log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Log we want to update
     *   }
     * })
     */
    upsert<T extends LogUpsertArgs>(args: SelectSubset<T, LogUpsertArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.log.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogCountArgs>(
      args?: Subset<T, LogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAggregateArgs>(args: Subset<T, LogAggregateArgs>): Prisma.PrismaPromise<GetLogAggregateType<T>>

    /**
     * Group by Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogGroupByArgs['orderBy'] }
        : { orderBy?: LogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Log model
   */
  readonly fields: LogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Log$userArgs<ExtArgs> = {}>(args?: Subset<T, Log$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Log model
   */
  interface LogFieldRefs {
    readonly id: FieldRef<"Log", 'String'>
    readonly action: FieldRef<"Log", 'String'>
    readonly userId: FieldRef<"Log", 'String'>
    readonly createdAt: FieldRef<"Log", 'DateTime'>
    readonly updatedAt: FieldRef<"Log", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Log findUnique
   */
  export type LogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findUniqueOrThrow
   */
  export type LogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findFirst
   */
  export type LogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findFirstOrThrow
   */
  export type LogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findMany
   */
  export type LogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log create
   */
  export type LogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to create a Log.
     */
    data: XOR<LogCreateInput, LogUncheckedCreateInput>
  }

  /**
   * Log createMany
   */
  export type LogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Log update
   */
  export type LogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to update a Log.
     */
    data: XOR<LogUpdateInput, LogUncheckedUpdateInput>
    /**
     * Choose, which Log to update.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log updateMany
   */
  export type LogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to update.
     */
    limit?: number
  }

  /**
   * Log upsert
   */
  export type LogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The filter to search for the Log to update in case it exists.
     */
    where: LogWhereUniqueInput
    /**
     * In case the Log found by the `where` argument doesn't exist, create a new Log with this data.
     */
    create: XOR<LogCreateInput, LogUncheckedCreateInput>
    /**
     * In case the Log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogUpdateInput, LogUncheckedUpdateInput>
  }

  /**
   * Log delete
   */
  export type LogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter which Log to delete.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log deleteMany
   */
  export type LogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to delete
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to delete.
     */
    limit?: number
  }

  /**
   * Log.user
   */
  export type Log$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Log without action
   */
  export type LogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    name: string | null
    companyName: string | null
    phone1: string | null
    phone2: string | null
    tinNumber: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    companyName: string | null
    phone1: string | null
    phone2: string | null
    tinNumber: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    companyName: number
    phone1: number
    phone2: number
    tinNumber: number
    address: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    companyName?: true
    phone1?: true
    phone2?: true
    tinNumber?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    companyName?: true
    phone1?: true
    phone2?: true
    tinNumber?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    companyName?: true
    phone1?: true
    phone2?: true
    tinNumber?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    name: string
    companyName: string | null
    phone1: string
    phone2: string | null
    tinNumber: string | null
    address: string | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    companyName?: boolean
    phone1?: boolean
    phone2?: boolean
    tinNumber?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Sell?: boolean | Customer$SellArgs<ExtArgs>
    AddToCart?: boolean | Customer$AddToCartArgs<ExtArgs>
    waitlists?: boolean | Customer$waitlistsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>



  export type CustomerSelectScalar = {
    id?: boolean
    name?: boolean
    companyName?: boolean
    phone1?: boolean
    phone2?: boolean
    tinNumber?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "companyName" | "phone1" | "phone2" | "tinNumber" | "address" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sell?: boolean | Customer$SellArgs<ExtArgs>
    AddToCart?: boolean | Customer$AddToCartArgs<ExtArgs>
    waitlists?: boolean | Customer$waitlistsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      Sell: Prisma.$SellPayload<ExtArgs>[]
      AddToCart: Prisma.$AddToCartPayload<ExtArgs>[]
      waitlists: Prisma.$WaitlistPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      companyName: string | null
      phone1: string
      phone2: string | null
      tinNumber: string | null
      address: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Sell<T extends Customer$SellArgs<ExtArgs> = {}>(args?: Subset<T, Customer$SellArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AddToCart<T extends Customer$AddToCartArgs<ExtArgs> = {}>(args?: Subset<T, Customer$AddToCartArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddToCartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    waitlists<T extends Customer$waitlistsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$waitlistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly companyName: FieldRef<"Customer", 'String'>
    readonly phone1: FieldRef<"Customer", 'String'>
    readonly phone2: FieldRef<"Customer", 'String'>
    readonly tinNumber: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.Sell
   */
  export type Customer$SellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sell
     */
    select?: SellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sell
     */
    omit?: SellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellInclude<ExtArgs> | null
    where?: SellWhereInput
    orderBy?: SellOrderByWithRelationInput | SellOrderByWithRelationInput[]
    cursor?: SellWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellScalarFieldEnum | SellScalarFieldEnum[]
  }

  /**
   * Customer.AddToCart
   */
  export type Customer$AddToCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToCart
     */
    select?: AddToCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddToCart
     */
    omit?: AddToCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddToCartInclude<ExtArgs> | null
    where?: AddToCartWhereInput
    orderBy?: AddToCartOrderByWithRelationInput | AddToCartOrderByWithRelationInput[]
    cursor?: AddToCartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddToCartScalarFieldEnum | AddToCartScalarFieldEnum[]
  }

  /**
   * Customer.waitlists
   */
  export type Customer$waitlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaitlistInclude<ExtArgs> | null
    where?: WaitlistWhereInput
    orderBy?: WaitlistOrderByWithRelationInput | WaitlistOrderByWithRelationInput[]
    cursor?: WaitlistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WaitlistScalarFieldEnum | WaitlistScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierMinAggregateOutputType = {
    id: string | null
    name: string | null
    contactName: string | null
    phone: string | null
    email: string | null
    address: string | null
    city: string | null
    country: string | null
    tinNumber: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: string | null
    name: string | null
    contactName: string | null
    phone: string | null
    email: string | null
    address: string | null
    city: string | null
    country: string | null
    tinNumber: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    name: number
    contactName: number
    phone: number
    email: number
    address: number
    city: number
    country: number
    tinNumber: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierMinAggregateInputType = {
    id?: true
    name?: true
    contactName?: true
    phone?: true
    email?: true
    address?: true
    city?: true
    country?: true
    tinNumber?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    name?: true
    contactName?: true
    phone?: true
    email?: true
    address?: true
    city?: true
    country?: true
    tinNumber?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    name?: true
    contactName?: true
    phone?: true
    email?: true
    address?: true
    city?: true
    country?: true
    tinNumber?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: string
    name: string
    contactName: string | null
    phone: string | null
    email: string | null
    address: string | null
    city: string | null
    country: string | null
    tinNumber: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    tinNumber?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Purchase?: boolean | Supplier$PurchaseArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>



  export type SupplierSelectScalar = {
    id?: boolean
    name?: boolean
    contactName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    tinNumber?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "contactName" | "phone" | "email" | "address" | "city" | "country" | "tinNumber" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["supplier"]>
  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Purchase?: boolean | Supplier$PurchaseArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      Purchase: Prisma.$PurchasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      contactName: string | null
      phone: string | null
      email: string | null
      address: string | null
      city: string | null
      country: string | null
      tinNumber: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Purchase<T extends Supplier$PurchaseArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$PurchaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'String'>
    readonly name: FieldRef<"Supplier", 'String'>
    readonly contactName: FieldRef<"Supplier", 'String'>
    readonly phone: FieldRef<"Supplier", 'String'>
    readonly email: FieldRef<"Supplier", 'String'>
    readonly address: FieldRef<"Supplier", 'String'>
    readonly city: FieldRef<"Supplier", 'String'>
    readonly country: FieldRef<"Supplier", 'String'>
    readonly tinNumber: FieldRef<"Supplier", 'String'>
    readonly notes: FieldRef<"Supplier", 'String'>
    readonly createdAt: FieldRef<"Supplier", 'DateTime'>
    readonly updatedAt: FieldRef<"Supplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to delete.
     */
    limit?: number
  }

  /**
   * Supplier.Purchase
   */
  export type Supplier$PurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | Category$productsArgs<ExtArgs>
    subCategories?: boolean | Category$subCategoriesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>



  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Category$productsArgs<ExtArgs>
    subCategories?: boolean | Category$subCategoriesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
      subCategories: Prisma.$SubCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subCategories<T extends Category$subCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Category$subCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Category.subCategories
   */
  export type Category$subCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    where?: SubCategoryWhereInput
    orderBy?: SubCategoryOrderByWithRelationInput | SubCategoryOrderByWithRelationInput[]
    cursor?: SubCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubCategoryScalarFieldEnum | SubCategoryScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model SubCategory
   */

  export type AggregateSubCategory = {
    _count: SubCategoryCountAggregateOutputType | null
    _min: SubCategoryMinAggregateOutputType | null
    _max: SubCategoryMaxAggregateOutputType | null
  }

  export type SubCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubCategoryCountAggregateOutputType = {
    id: number
    name: number
    categoryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubCategoryMinAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubCategoryCountAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubCategory to aggregate.
     */
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     */
    orderBy?: SubCategoryOrderByWithRelationInput | SubCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubCategories
    **/
    _count?: true | SubCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubCategoryMaxAggregateInputType
  }

  export type GetSubCategoryAggregateType<T extends SubCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSubCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubCategory[P]>
      : GetScalarType<T[P], AggregateSubCategory[P]>
  }




  export type SubCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubCategoryWhereInput
    orderBy?: SubCategoryOrderByWithAggregationInput | SubCategoryOrderByWithAggregationInput[]
    by: SubCategoryScalarFieldEnum[] | SubCategoryScalarFieldEnum
    having?: SubCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubCategoryCountAggregateInputType | true
    _min?: SubCategoryMinAggregateInputType
    _max?: SubCategoryMaxAggregateInputType
  }

  export type SubCategoryGroupByOutputType = {
    id: string
    name: string
    categoryId: string
    createdAt: Date
    updatedAt: Date
    _count: SubCategoryCountAggregateOutputType | null
    _min: SubCategoryMinAggregateOutputType | null
    _max: SubCategoryMaxAggregateOutputType | null
  }

  type GetSubCategoryGroupByPayload<T extends SubCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], SubCategoryGroupByOutputType[P]>
        }
      >
    >


  export type SubCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    products?: boolean | SubCategory$productsArgs<ExtArgs>
    _count?: boolean | SubCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subCategory"]>



  export type SubCategorySelectScalar = {
    id?: boolean
    name?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "categoryId" | "createdAt" | "updatedAt", ExtArgs["result"]["subCategory"]>
  export type SubCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    products?: boolean | SubCategory$productsArgs<ExtArgs>
    _count?: boolean | SubCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SubCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubCategory"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      categoryId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subCategory"]>
    composites: {}
  }

  type SubCategoryGetPayload<S extends boolean | null | undefined | SubCategoryDefaultArgs> = $Result.GetResult<Prisma.$SubCategoryPayload, S>

  type SubCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubCategoryCountAggregateInputType | true
    }

  export interface SubCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubCategory'], meta: { name: 'SubCategory' } }
    /**
     * Find zero or one SubCategory that matches the filter.
     * @param {SubCategoryFindUniqueArgs} args - Arguments to find a SubCategory
     * @example
     * // Get one SubCategory
     * const subCategory = await prisma.subCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubCategoryFindUniqueArgs>(args: SelectSubset<T, SubCategoryFindUniqueArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubCategoryFindUniqueOrThrowArgs} args - Arguments to find a SubCategory
     * @example
     * // Get one SubCategory
     * const subCategory = await prisma.subCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SubCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryFindFirstArgs} args - Arguments to find a SubCategory
     * @example
     * // Get one SubCategory
     * const subCategory = await prisma.subCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubCategoryFindFirstArgs>(args?: SelectSubset<T, SubCategoryFindFirstArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryFindFirstOrThrowArgs} args - Arguments to find a SubCategory
     * @example
     * // Get one SubCategory
     * const subCategory = await prisma.subCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SubCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubCategories
     * const subCategories = await prisma.subCategory.findMany()
     * 
     * // Get first 10 SubCategories
     * const subCategories = await prisma.subCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subCategoryWithIdOnly = await prisma.subCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubCategoryFindManyArgs>(args?: SelectSubset<T, SubCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubCategory.
     * @param {SubCategoryCreateArgs} args - Arguments to create a SubCategory.
     * @example
     * // Create one SubCategory
     * const SubCategory = await prisma.subCategory.create({
     *   data: {
     *     // ... data to create a SubCategory
     *   }
     * })
     * 
     */
    create<T extends SubCategoryCreateArgs>(args: SelectSubset<T, SubCategoryCreateArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubCategories.
     * @param {SubCategoryCreateManyArgs} args - Arguments to create many SubCategories.
     * @example
     * // Create many SubCategories
     * const subCategory = await prisma.subCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubCategoryCreateManyArgs>(args?: SelectSubset<T, SubCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SubCategory.
     * @param {SubCategoryDeleteArgs} args - Arguments to delete one SubCategory.
     * @example
     * // Delete one SubCategory
     * const SubCategory = await prisma.subCategory.delete({
     *   where: {
     *     // ... filter to delete one SubCategory
     *   }
     * })
     * 
     */
    delete<T extends SubCategoryDeleteArgs>(args: SelectSubset<T, SubCategoryDeleteArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubCategory.
     * @param {SubCategoryUpdateArgs} args - Arguments to update one SubCategory.
     * @example
     * // Update one SubCategory
     * const subCategory = await prisma.subCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubCategoryUpdateArgs>(args: SelectSubset<T, SubCategoryUpdateArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubCategories.
     * @param {SubCategoryDeleteManyArgs} args - Arguments to filter SubCategories to delete.
     * @example
     * // Delete a few SubCategories
     * const { count } = await prisma.subCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubCategoryDeleteManyArgs>(args?: SelectSubset<T, SubCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubCategories
     * const subCategory = await prisma.subCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubCategoryUpdateManyArgs>(args: SelectSubset<T, SubCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubCategory.
     * @param {SubCategoryUpsertArgs} args - Arguments to update or create a SubCategory.
     * @example
     * // Update or create a SubCategory
     * const subCategory = await prisma.subCategory.upsert({
     *   create: {
     *     // ... data to create a SubCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubCategory we want to update
     *   }
     * })
     */
    upsert<T extends SubCategoryUpsertArgs>(args: SelectSubset<T, SubCategoryUpsertArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryCountArgs} args - Arguments to filter SubCategories to count.
     * @example
     * // Count the number of SubCategories
     * const count = await prisma.subCategory.count({
     *   where: {
     *     // ... the filter for the SubCategories we want to count
     *   }
     * })
    **/
    count<T extends SubCategoryCountArgs>(
      args?: Subset<T, SubCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubCategoryAggregateArgs>(args: Subset<T, SubCategoryAggregateArgs>): Prisma.PrismaPromise<GetSubCategoryAggregateType<T>>

    /**
     * Group by SubCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubCategoryGroupByArgs['orderBy'] }
        : { orderBy?: SubCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubCategory model
   */
  readonly fields: SubCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    products<T extends SubCategory$productsArgs<ExtArgs> = {}>(args?: Subset<T, SubCategory$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubCategory model
   */
  interface SubCategoryFieldRefs {
    readonly id: FieldRef<"SubCategory", 'String'>
    readonly name: FieldRef<"SubCategory", 'String'>
    readonly categoryId: FieldRef<"SubCategory", 'String'>
    readonly createdAt: FieldRef<"SubCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"SubCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubCategory findUnique
   */
  export type SubCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubCategory to fetch.
     */
    where: SubCategoryWhereUniqueInput
  }

  /**
   * SubCategory findUniqueOrThrow
   */
  export type SubCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubCategory to fetch.
     */
    where: SubCategoryWhereUniqueInput
  }

  /**
   * SubCategory findFirst
   */
  export type SubCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubCategory to fetch.
     */
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     */
    orderBy?: SubCategoryOrderByWithRelationInput | SubCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubCategories.
     */
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubCategories.
     */
    distinct?: SubCategoryScalarFieldEnum | SubCategoryScalarFieldEnum[]
  }

  /**
   * SubCategory findFirstOrThrow
   */
  export type SubCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubCategory to fetch.
     */
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     */
    orderBy?: SubCategoryOrderByWithRelationInput | SubCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubCategories.
     */
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubCategories.
     */
    distinct?: SubCategoryScalarFieldEnum | SubCategoryScalarFieldEnum[]
  }

  /**
   * SubCategory findMany
   */
  export type SubCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubCategories to fetch.
     */
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     */
    orderBy?: SubCategoryOrderByWithRelationInput | SubCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubCategories.
     */
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     */
    skip?: number
    distinct?: SubCategoryScalarFieldEnum | SubCategoryScalarFieldEnum[]
  }

  /**
   * SubCategory create
   */
  export type SubCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a SubCategory.
     */
    data: XOR<SubCategoryCreateInput, SubCategoryUncheckedCreateInput>
  }

  /**
   * SubCategory createMany
   */
  export type SubCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubCategories.
     */
    data: SubCategoryCreateManyInput | SubCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubCategory update
   */
  export type SubCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a SubCategory.
     */
    data: XOR<SubCategoryUpdateInput, SubCategoryUncheckedUpdateInput>
    /**
     * Choose, which SubCategory to update.
     */
    where: SubCategoryWhereUniqueInput
  }

  /**
   * SubCategory updateMany
   */
  export type SubCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubCategories.
     */
    data: XOR<SubCategoryUpdateManyMutationInput, SubCategoryUncheckedUpdateManyInput>
    /**
     * Filter which SubCategories to update
     */
    where?: SubCategoryWhereInput
    /**
     * Limit how many SubCategories to update.
     */
    limit?: number
  }

  /**
   * SubCategory upsert
   */
  export type SubCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the SubCategory to update in case it exists.
     */
    where: SubCategoryWhereUniqueInput
    /**
     * In case the SubCategory found by the `where` argument doesn't exist, create a new SubCategory with this data.
     */
    create: XOR<SubCategoryCreateInput, SubCategoryUncheckedCreateInput>
    /**
     * In case the SubCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubCategoryUpdateInput, SubCategoryUncheckedUpdateInput>
  }

  /**
   * SubCategory delete
   */
  export type SubCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter which SubCategory to delete.
     */
    where: SubCategoryWhereUniqueInput
  }

  /**
   * SubCategory deleteMany
   */
  export type SubCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubCategories to delete
     */
    where?: SubCategoryWhereInput
    /**
     * Limit how many SubCategories to delete.
     */
    limit?: number
  }

  /**
   * SubCategory.products
   */
  export type SubCategory$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * SubCategory without action
   */
  export type SubCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    sellPrice: Decimal | null
  }

  export type ProductSumAggregateOutputType = {
    sellPrice: Decimal | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    productCode: string | null
    name: string | null
    generic: string | null
    description: string | null
    categoryId: string | null
    subCategoryId: string | null
    sellPrice: Decimal | null
    imageUrl: string | null
    unitOfMeasureId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    productCode: string | null
    name: string | null
    generic: string | null
    description: string | null
    categoryId: string | null
    subCategoryId: string | null
    sellPrice: Decimal | null
    imageUrl: string | null
    unitOfMeasureId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    productCode: number
    name: number
    generic: number
    description: number
    categoryId: number
    subCategoryId: number
    sellPrice: number
    imageUrl: number
    unitOfMeasureId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    sellPrice?: true
  }

  export type ProductSumAggregateInputType = {
    sellPrice?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    productCode?: true
    name?: true
    generic?: true
    description?: true
    categoryId?: true
    subCategoryId?: true
    sellPrice?: true
    imageUrl?: true
    unitOfMeasureId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    productCode?: true
    name?: true
    generic?: true
    description?: true
    categoryId?: true
    subCategoryId?: true
    sellPrice?: true
    imageUrl?: true
    unitOfMeasureId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    productCode?: true
    name?: true
    generic?: true
    description?: true
    categoryId?: true
    subCategoryId?: true
    sellPrice?: true
    imageUrl?: true
    unitOfMeasureId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    productCode: string
    name: string
    generic: string | null
    description: string | null
    categoryId: string
    subCategoryId: string | null
    sellPrice: Decimal | null
    imageUrl: string
    unitOfMeasureId: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productCode?: boolean
    name?: boolean
    generic?: boolean
    description?: boolean
    categoryId?: boolean
    subCategoryId?: boolean
    sellPrice?: boolean
    imageUrl?: boolean
    unitOfMeasureId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    subCategory?: boolean | Product$subCategoryArgs<ExtArgs>
    unitOfMeasure?: boolean | UnitOfMeasureDefaultArgs<ExtArgs>
    batches?: boolean | Product$batchesArgs<ExtArgs>
    PurchaseItem?: boolean | Product$PurchaseItemArgs<ExtArgs>
    TransferItem?: boolean | Product$TransferItemArgs<ExtArgs>
    StockCorrectionItem?: boolean | Product$StockCorrectionItemArgs<ExtArgs>
    CartItem?: boolean | Product$CartItemArgs<ExtArgs>
    AdditionalPrice?: boolean | Product$AdditionalPriceArgs<ExtArgs>
    SellItem?: boolean | Product$SellItemArgs<ExtArgs>
    SellStockCorrectionItem?: boolean | Product$SellStockCorrectionItemArgs<ExtArgs>
    waitlists?: boolean | Product$waitlistsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>



  export type ProductSelectScalar = {
    id?: boolean
    productCode?: boolean
    name?: boolean
    generic?: boolean
    description?: boolean
    categoryId?: boolean
    subCategoryId?: boolean
    sellPrice?: boolean
    imageUrl?: boolean
    unitOfMeasureId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productCode" | "name" | "generic" | "description" | "categoryId" | "subCategoryId" | "sellPrice" | "imageUrl" | "unitOfMeasureId" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    subCategory?: boolean | Product$subCategoryArgs<ExtArgs>
    unitOfMeasure?: boolean | UnitOfMeasureDefaultArgs<ExtArgs>
    batches?: boolean | Product$batchesArgs<ExtArgs>
    PurchaseItem?: boolean | Product$PurchaseItemArgs<ExtArgs>
    TransferItem?: boolean | Product$TransferItemArgs<ExtArgs>
    StockCorrectionItem?: boolean | Product$StockCorrectionItemArgs<ExtArgs>
    CartItem?: boolean | Product$CartItemArgs<ExtArgs>
    AdditionalPrice?: boolean | Product$AdditionalPriceArgs<ExtArgs>
    SellItem?: boolean | Product$SellItemArgs<ExtArgs>
    SellStockCorrectionItem?: boolean | Product$SellStockCorrectionItemArgs<ExtArgs>
    waitlists?: boolean | Product$waitlistsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      subCategory: Prisma.$SubCategoryPayload<ExtArgs> | null
      unitOfMeasure: Prisma.$UnitOfMeasurePayload<ExtArgs>
      batches: Prisma.$ProductBatchPayload<ExtArgs>[]
      PurchaseItem: Prisma.$PurchaseItemPayload<ExtArgs>[]
      TransferItem: Prisma.$TransferItemPayload<ExtArgs>[]
      StockCorrectionItem: Prisma.$StockCorrectionItemPayload<ExtArgs>[]
      CartItem: Prisma.$CartItemPayload<ExtArgs>[]
      AdditionalPrice: Prisma.$AdditionalPricePayload<ExtArgs>[]
      SellItem: Prisma.$SellItemPayload<ExtArgs>[]
      SellStockCorrectionItem: Prisma.$SellStockCorrectionItemPayload<ExtArgs>[]
      waitlists: Prisma.$WaitlistPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productCode: string
      name: string
      generic: string | null
      description: string | null
      categoryId: string
      subCategoryId: string | null
      sellPrice: Prisma.Decimal | null
      imageUrl: string
      unitOfMeasureId: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subCategory<T extends Product$subCategoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$subCategoryArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    unitOfMeasure<T extends UnitOfMeasureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasureDefaultArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    batches<T extends Product$batchesArgs<ExtArgs> = {}>(args?: Subset<T, Product$batchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PurchaseItem<T extends Product$PurchaseItemArgs<ExtArgs> = {}>(args?: Subset<T, Product$PurchaseItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TransferItem<T extends Product$TransferItemArgs<ExtArgs> = {}>(args?: Subset<T, Product$TransferItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StockCorrectionItem<T extends Product$StockCorrectionItemArgs<ExtArgs> = {}>(args?: Subset<T, Product$StockCorrectionItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockCorrectionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CartItem<T extends Product$CartItemArgs<ExtArgs> = {}>(args?: Subset<T, Product$CartItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AdditionalPrice<T extends Product$AdditionalPriceArgs<ExtArgs> = {}>(args?: Subset<T, Product$AdditionalPriceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdditionalPricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SellItem<T extends Product$SellItemArgs<ExtArgs> = {}>(args?: Subset<T, Product$SellItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SellStockCorrectionItem<T extends Product$SellStockCorrectionItemArgs<ExtArgs> = {}>(args?: Subset<T, Product$SellStockCorrectionItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellStockCorrectionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    waitlists<T extends Product$waitlistsArgs<ExtArgs> = {}>(args?: Subset<T, Product$waitlistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly productCode: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly generic: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly categoryId: FieldRef<"Product", 'String'>
    readonly subCategoryId: FieldRef<"Product", 'String'>
    readonly sellPrice: FieldRef<"Product", 'Decimal'>
    readonly imageUrl: FieldRef<"Product", 'String'>
    readonly unitOfMeasureId: FieldRef<"Product", 'String'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.subCategory
   */
  export type Product$subCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    where?: SubCategoryWhereInput
  }

  /**
   * Product.batches
   */
  export type Product$batchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatch
     */
    select?: ProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBatch
     */
    omit?: ProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBatchInclude<ExtArgs> | null
    where?: ProductBatchWhereInput
    orderBy?: ProductBatchOrderByWithRelationInput | ProductBatchOrderByWithRelationInput[]
    cursor?: ProductBatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductBatchScalarFieldEnum | ProductBatchScalarFieldEnum[]
  }

  /**
   * Product.PurchaseItem
   */
  export type Product$PurchaseItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    where?: PurchaseItemWhereInput
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    cursor?: PurchaseItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * Product.TransferItem
   */
  export type Product$TransferItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    where?: TransferItemWhereInput
    orderBy?: TransferItemOrderByWithRelationInput | TransferItemOrderByWithRelationInput[]
    cursor?: TransferItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferItemScalarFieldEnum | TransferItemScalarFieldEnum[]
  }

  /**
   * Product.StockCorrectionItem
   */
  export type Product$StockCorrectionItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrectionItem
     */
    select?: StockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrectionItem
     */
    omit?: StockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionItemInclude<ExtArgs> | null
    where?: StockCorrectionItemWhereInput
    orderBy?: StockCorrectionItemOrderByWithRelationInput | StockCorrectionItemOrderByWithRelationInput[]
    cursor?: StockCorrectionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockCorrectionItemScalarFieldEnum | StockCorrectionItemScalarFieldEnum[]
  }

  /**
   * Product.CartItem
   */
  export type Product$CartItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * Product.AdditionalPrice
   */
  export type Product$AdditionalPriceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalPrice
     */
    select?: AdditionalPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdditionalPrice
     */
    omit?: AdditionalPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalPriceInclude<ExtArgs> | null
    where?: AdditionalPriceWhereInput
    orderBy?: AdditionalPriceOrderByWithRelationInput | AdditionalPriceOrderByWithRelationInput[]
    cursor?: AdditionalPriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdditionalPriceScalarFieldEnum | AdditionalPriceScalarFieldEnum[]
  }

  /**
   * Product.SellItem
   */
  export type Product$SellItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItem
     */
    select?: SellItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellItem
     */
    omit?: SellItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellItemInclude<ExtArgs> | null
    where?: SellItemWhereInput
    orderBy?: SellItemOrderByWithRelationInput | SellItemOrderByWithRelationInput[]
    cursor?: SellItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellItemScalarFieldEnum | SellItemScalarFieldEnum[]
  }

  /**
   * Product.SellStockCorrectionItem
   */
  export type Product$SellStockCorrectionItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionItem
     */
    select?: SellStockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrectionItem
     */
    omit?: SellStockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionItemInclude<ExtArgs> | null
    where?: SellStockCorrectionItemWhereInput
    orderBy?: SellStockCorrectionItemOrderByWithRelationInput | SellStockCorrectionItemOrderByWithRelationInput[]
    cursor?: SellStockCorrectionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellStockCorrectionItemScalarFieldEnum | SellStockCorrectionItemScalarFieldEnum[]
  }

  /**
   * Product.waitlists
   */
  export type Product$waitlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaitlistInclude<ExtArgs> | null
    where?: WaitlistWhereInput
    orderBy?: WaitlistOrderByWithRelationInput | WaitlistOrderByWithRelationInput[]
    cursor?: WaitlistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WaitlistScalarFieldEnum | WaitlistScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model AdditionalPrice
   */

  export type AggregateAdditionalPrice = {
    _count: AdditionalPriceCountAggregateOutputType | null
    _avg: AdditionalPriceAvgAggregateOutputType | null
    _sum: AdditionalPriceSumAggregateOutputType | null
    _min: AdditionalPriceMinAggregateOutputType | null
    _max: AdditionalPriceMaxAggregateOutputType | null
  }

  export type AdditionalPriceAvgAggregateOutputType = {
    price: number | null
  }

  export type AdditionalPriceSumAggregateOutputType = {
    price: number | null
  }

  export type AdditionalPriceMinAggregateOutputType = {
    id: string | null
    label: string | null
    price: number | null
    productId: string | null
    shopId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdditionalPriceMaxAggregateOutputType = {
    id: string | null
    label: string | null
    price: number | null
    productId: string | null
    shopId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdditionalPriceCountAggregateOutputType = {
    id: number
    label: number
    price: number
    productId: number
    shopId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdditionalPriceAvgAggregateInputType = {
    price?: true
  }

  export type AdditionalPriceSumAggregateInputType = {
    price?: true
  }

  export type AdditionalPriceMinAggregateInputType = {
    id?: true
    label?: true
    price?: true
    productId?: true
    shopId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdditionalPriceMaxAggregateInputType = {
    id?: true
    label?: true
    price?: true
    productId?: true
    shopId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdditionalPriceCountAggregateInputType = {
    id?: true
    label?: true
    price?: true
    productId?: true
    shopId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdditionalPriceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdditionalPrice to aggregate.
     */
    where?: AdditionalPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdditionalPrices to fetch.
     */
    orderBy?: AdditionalPriceOrderByWithRelationInput | AdditionalPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdditionalPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdditionalPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdditionalPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdditionalPrices
    **/
    _count?: true | AdditionalPriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdditionalPriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdditionalPriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdditionalPriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdditionalPriceMaxAggregateInputType
  }

  export type GetAdditionalPriceAggregateType<T extends AdditionalPriceAggregateArgs> = {
        [P in keyof T & keyof AggregateAdditionalPrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdditionalPrice[P]>
      : GetScalarType<T[P], AggregateAdditionalPrice[P]>
  }




  export type AdditionalPriceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdditionalPriceWhereInput
    orderBy?: AdditionalPriceOrderByWithAggregationInput | AdditionalPriceOrderByWithAggregationInput[]
    by: AdditionalPriceScalarFieldEnum[] | AdditionalPriceScalarFieldEnum
    having?: AdditionalPriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdditionalPriceCountAggregateInputType | true
    _avg?: AdditionalPriceAvgAggregateInputType
    _sum?: AdditionalPriceSumAggregateInputType
    _min?: AdditionalPriceMinAggregateInputType
    _max?: AdditionalPriceMaxAggregateInputType
  }

  export type AdditionalPriceGroupByOutputType = {
    id: string
    label: string | null
    price: number
    productId: string
    shopId: string | null
    createdAt: Date
    updatedAt: Date
    _count: AdditionalPriceCountAggregateOutputType | null
    _avg: AdditionalPriceAvgAggregateOutputType | null
    _sum: AdditionalPriceSumAggregateOutputType | null
    _min: AdditionalPriceMinAggregateOutputType | null
    _max: AdditionalPriceMaxAggregateOutputType | null
  }

  type GetAdditionalPriceGroupByPayload<T extends AdditionalPriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdditionalPriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdditionalPriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdditionalPriceGroupByOutputType[P]>
            : GetScalarType<T[P], AdditionalPriceGroupByOutputType[P]>
        }
      >
    >


  export type AdditionalPriceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    price?: boolean
    productId?: boolean
    shopId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    shop?: boolean | AdditionalPrice$shopArgs<ExtArgs>
  }, ExtArgs["result"]["additionalPrice"]>



  export type AdditionalPriceSelectScalar = {
    id?: boolean
    label?: boolean
    price?: boolean
    productId?: boolean
    shopId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdditionalPriceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "price" | "productId" | "shopId" | "createdAt" | "updatedAt", ExtArgs["result"]["additionalPrice"]>
  export type AdditionalPriceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    shop?: boolean | AdditionalPrice$shopArgs<ExtArgs>
  }

  export type $AdditionalPricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdditionalPrice"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      shop: Prisma.$ShopPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      label: string | null
      price: number
      productId: string
      shopId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["additionalPrice"]>
    composites: {}
  }

  type AdditionalPriceGetPayload<S extends boolean | null | undefined | AdditionalPriceDefaultArgs> = $Result.GetResult<Prisma.$AdditionalPricePayload, S>

  type AdditionalPriceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdditionalPriceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdditionalPriceCountAggregateInputType | true
    }

  export interface AdditionalPriceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdditionalPrice'], meta: { name: 'AdditionalPrice' } }
    /**
     * Find zero or one AdditionalPrice that matches the filter.
     * @param {AdditionalPriceFindUniqueArgs} args - Arguments to find a AdditionalPrice
     * @example
     * // Get one AdditionalPrice
     * const additionalPrice = await prisma.additionalPrice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdditionalPriceFindUniqueArgs>(args: SelectSubset<T, AdditionalPriceFindUniqueArgs<ExtArgs>>): Prisma__AdditionalPriceClient<$Result.GetResult<Prisma.$AdditionalPricePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdditionalPrice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdditionalPriceFindUniqueOrThrowArgs} args - Arguments to find a AdditionalPrice
     * @example
     * // Get one AdditionalPrice
     * const additionalPrice = await prisma.additionalPrice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdditionalPriceFindUniqueOrThrowArgs>(args: SelectSubset<T, AdditionalPriceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdditionalPriceClient<$Result.GetResult<Prisma.$AdditionalPricePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdditionalPrice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalPriceFindFirstArgs} args - Arguments to find a AdditionalPrice
     * @example
     * // Get one AdditionalPrice
     * const additionalPrice = await prisma.additionalPrice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdditionalPriceFindFirstArgs>(args?: SelectSubset<T, AdditionalPriceFindFirstArgs<ExtArgs>>): Prisma__AdditionalPriceClient<$Result.GetResult<Prisma.$AdditionalPricePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdditionalPrice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalPriceFindFirstOrThrowArgs} args - Arguments to find a AdditionalPrice
     * @example
     * // Get one AdditionalPrice
     * const additionalPrice = await prisma.additionalPrice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdditionalPriceFindFirstOrThrowArgs>(args?: SelectSubset<T, AdditionalPriceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdditionalPriceClient<$Result.GetResult<Prisma.$AdditionalPricePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdditionalPrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalPriceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdditionalPrices
     * const additionalPrices = await prisma.additionalPrice.findMany()
     * 
     * // Get first 10 AdditionalPrices
     * const additionalPrices = await prisma.additionalPrice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const additionalPriceWithIdOnly = await prisma.additionalPrice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdditionalPriceFindManyArgs>(args?: SelectSubset<T, AdditionalPriceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdditionalPricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdditionalPrice.
     * @param {AdditionalPriceCreateArgs} args - Arguments to create a AdditionalPrice.
     * @example
     * // Create one AdditionalPrice
     * const AdditionalPrice = await prisma.additionalPrice.create({
     *   data: {
     *     // ... data to create a AdditionalPrice
     *   }
     * })
     * 
     */
    create<T extends AdditionalPriceCreateArgs>(args: SelectSubset<T, AdditionalPriceCreateArgs<ExtArgs>>): Prisma__AdditionalPriceClient<$Result.GetResult<Prisma.$AdditionalPricePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdditionalPrices.
     * @param {AdditionalPriceCreateManyArgs} args - Arguments to create many AdditionalPrices.
     * @example
     * // Create many AdditionalPrices
     * const additionalPrice = await prisma.additionalPrice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdditionalPriceCreateManyArgs>(args?: SelectSubset<T, AdditionalPriceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AdditionalPrice.
     * @param {AdditionalPriceDeleteArgs} args - Arguments to delete one AdditionalPrice.
     * @example
     * // Delete one AdditionalPrice
     * const AdditionalPrice = await prisma.additionalPrice.delete({
     *   where: {
     *     // ... filter to delete one AdditionalPrice
     *   }
     * })
     * 
     */
    delete<T extends AdditionalPriceDeleteArgs>(args: SelectSubset<T, AdditionalPriceDeleteArgs<ExtArgs>>): Prisma__AdditionalPriceClient<$Result.GetResult<Prisma.$AdditionalPricePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdditionalPrice.
     * @param {AdditionalPriceUpdateArgs} args - Arguments to update one AdditionalPrice.
     * @example
     * // Update one AdditionalPrice
     * const additionalPrice = await prisma.additionalPrice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdditionalPriceUpdateArgs>(args: SelectSubset<T, AdditionalPriceUpdateArgs<ExtArgs>>): Prisma__AdditionalPriceClient<$Result.GetResult<Prisma.$AdditionalPricePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdditionalPrices.
     * @param {AdditionalPriceDeleteManyArgs} args - Arguments to filter AdditionalPrices to delete.
     * @example
     * // Delete a few AdditionalPrices
     * const { count } = await prisma.additionalPrice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdditionalPriceDeleteManyArgs>(args?: SelectSubset<T, AdditionalPriceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdditionalPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalPriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdditionalPrices
     * const additionalPrice = await prisma.additionalPrice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdditionalPriceUpdateManyArgs>(args: SelectSubset<T, AdditionalPriceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdditionalPrice.
     * @param {AdditionalPriceUpsertArgs} args - Arguments to update or create a AdditionalPrice.
     * @example
     * // Update or create a AdditionalPrice
     * const additionalPrice = await prisma.additionalPrice.upsert({
     *   create: {
     *     // ... data to create a AdditionalPrice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdditionalPrice we want to update
     *   }
     * })
     */
    upsert<T extends AdditionalPriceUpsertArgs>(args: SelectSubset<T, AdditionalPriceUpsertArgs<ExtArgs>>): Prisma__AdditionalPriceClient<$Result.GetResult<Prisma.$AdditionalPricePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdditionalPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalPriceCountArgs} args - Arguments to filter AdditionalPrices to count.
     * @example
     * // Count the number of AdditionalPrices
     * const count = await prisma.additionalPrice.count({
     *   where: {
     *     // ... the filter for the AdditionalPrices we want to count
     *   }
     * })
    **/
    count<T extends AdditionalPriceCountArgs>(
      args?: Subset<T, AdditionalPriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdditionalPriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdditionalPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalPriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdditionalPriceAggregateArgs>(args: Subset<T, AdditionalPriceAggregateArgs>): Prisma.PrismaPromise<GetAdditionalPriceAggregateType<T>>

    /**
     * Group by AdditionalPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalPriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdditionalPriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdditionalPriceGroupByArgs['orderBy'] }
        : { orderBy?: AdditionalPriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdditionalPriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdditionalPriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdditionalPrice model
   */
  readonly fields: AdditionalPriceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdditionalPrice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdditionalPriceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shop<T extends AdditionalPrice$shopArgs<ExtArgs> = {}>(args?: Subset<T, AdditionalPrice$shopArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdditionalPrice model
   */
  interface AdditionalPriceFieldRefs {
    readonly id: FieldRef<"AdditionalPrice", 'String'>
    readonly label: FieldRef<"AdditionalPrice", 'String'>
    readonly price: FieldRef<"AdditionalPrice", 'Float'>
    readonly productId: FieldRef<"AdditionalPrice", 'String'>
    readonly shopId: FieldRef<"AdditionalPrice", 'String'>
    readonly createdAt: FieldRef<"AdditionalPrice", 'DateTime'>
    readonly updatedAt: FieldRef<"AdditionalPrice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdditionalPrice findUnique
   */
  export type AdditionalPriceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalPrice
     */
    select?: AdditionalPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdditionalPrice
     */
    omit?: AdditionalPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalPriceInclude<ExtArgs> | null
    /**
     * Filter, which AdditionalPrice to fetch.
     */
    where: AdditionalPriceWhereUniqueInput
  }

  /**
   * AdditionalPrice findUniqueOrThrow
   */
  export type AdditionalPriceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalPrice
     */
    select?: AdditionalPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdditionalPrice
     */
    omit?: AdditionalPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalPriceInclude<ExtArgs> | null
    /**
     * Filter, which AdditionalPrice to fetch.
     */
    where: AdditionalPriceWhereUniqueInput
  }

  /**
   * AdditionalPrice findFirst
   */
  export type AdditionalPriceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalPrice
     */
    select?: AdditionalPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdditionalPrice
     */
    omit?: AdditionalPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalPriceInclude<ExtArgs> | null
    /**
     * Filter, which AdditionalPrice to fetch.
     */
    where?: AdditionalPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdditionalPrices to fetch.
     */
    orderBy?: AdditionalPriceOrderByWithRelationInput | AdditionalPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdditionalPrices.
     */
    cursor?: AdditionalPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdditionalPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdditionalPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdditionalPrices.
     */
    distinct?: AdditionalPriceScalarFieldEnum | AdditionalPriceScalarFieldEnum[]
  }

  /**
   * AdditionalPrice findFirstOrThrow
   */
  export type AdditionalPriceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalPrice
     */
    select?: AdditionalPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdditionalPrice
     */
    omit?: AdditionalPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalPriceInclude<ExtArgs> | null
    /**
     * Filter, which AdditionalPrice to fetch.
     */
    where?: AdditionalPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdditionalPrices to fetch.
     */
    orderBy?: AdditionalPriceOrderByWithRelationInput | AdditionalPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdditionalPrices.
     */
    cursor?: AdditionalPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdditionalPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdditionalPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdditionalPrices.
     */
    distinct?: AdditionalPriceScalarFieldEnum | AdditionalPriceScalarFieldEnum[]
  }

  /**
   * AdditionalPrice findMany
   */
  export type AdditionalPriceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalPrice
     */
    select?: AdditionalPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdditionalPrice
     */
    omit?: AdditionalPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalPriceInclude<ExtArgs> | null
    /**
     * Filter, which AdditionalPrices to fetch.
     */
    where?: AdditionalPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdditionalPrices to fetch.
     */
    orderBy?: AdditionalPriceOrderByWithRelationInput | AdditionalPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdditionalPrices.
     */
    cursor?: AdditionalPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdditionalPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdditionalPrices.
     */
    skip?: number
    distinct?: AdditionalPriceScalarFieldEnum | AdditionalPriceScalarFieldEnum[]
  }

  /**
   * AdditionalPrice create
   */
  export type AdditionalPriceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalPrice
     */
    select?: AdditionalPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdditionalPrice
     */
    omit?: AdditionalPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalPriceInclude<ExtArgs> | null
    /**
     * The data needed to create a AdditionalPrice.
     */
    data: XOR<AdditionalPriceCreateInput, AdditionalPriceUncheckedCreateInput>
  }

  /**
   * AdditionalPrice createMany
   */
  export type AdditionalPriceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdditionalPrices.
     */
    data: AdditionalPriceCreateManyInput | AdditionalPriceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdditionalPrice update
   */
  export type AdditionalPriceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalPrice
     */
    select?: AdditionalPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdditionalPrice
     */
    omit?: AdditionalPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalPriceInclude<ExtArgs> | null
    /**
     * The data needed to update a AdditionalPrice.
     */
    data: XOR<AdditionalPriceUpdateInput, AdditionalPriceUncheckedUpdateInput>
    /**
     * Choose, which AdditionalPrice to update.
     */
    where: AdditionalPriceWhereUniqueInput
  }

  /**
   * AdditionalPrice updateMany
   */
  export type AdditionalPriceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdditionalPrices.
     */
    data: XOR<AdditionalPriceUpdateManyMutationInput, AdditionalPriceUncheckedUpdateManyInput>
    /**
     * Filter which AdditionalPrices to update
     */
    where?: AdditionalPriceWhereInput
    /**
     * Limit how many AdditionalPrices to update.
     */
    limit?: number
  }

  /**
   * AdditionalPrice upsert
   */
  export type AdditionalPriceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalPrice
     */
    select?: AdditionalPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdditionalPrice
     */
    omit?: AdditionalPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalPriceInclude<ExtArgs> | null
    /**
     * The filter to search for the AdditionalPrice to update in case it exists.
     */
    where: AdditionalPriceWhereUniqueInput
    /**
     * In case the AdditionalPrice found by the `where` argument doesn't exist, create a new AdditionalPrice with this data.
     */
    create: XOR<AdditionalPriceCreateInput, AdditionalPriceUncheckedCreateInput>
    /**
     * In case the AdditionalPrice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdditionalPriceUpdateInput, AdditionalPriceUncheckedUpdateInput>
  }

  /**
   * AdditionalPrice delete
   */
  export type AdditionalPriceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalPrice
     */
    select?: AdditionalPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdditionalPrice
     */
    omit?: AdditionalPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalPriceInclude<ExtArgs> | null
    /**
     * Filter which AdditionalPrice to delete.
     */
    where: AdditionalPriceWhereUniqueInput
  }

  /**
   * AdditionalPrice deleteMany
   */
  export type AdditionalPriceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdditionalPrices to delete
     */
    where?: AdditionalPriceWhereInput
    /**
     * Limit how many AdditionalPrices to delete.
     */
    limit?: number
  }

  /**
   * AdditionalPrice.shop
   */
  export type AdditionalPrice$shopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    where?: ShopWhereInput
  }

  /**
   * AdditionalPrice without action
   */
  export type AdditionalPriceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalPrice
     */
    select?: AdditionalPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdditionalPrice
     */
    omit?: AdditionalPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalPriceInclude<ExtArgs> | null
  }


  /**
   * Model ProductBatch
   */

  export type AggregateProductBatch = {
    _count: ProductBatchCountAggregateOutputType | null
    _avg: ProductBatchAvgAggregateOutputType | null
    _sum: ProductBatchSumAggregateOutputType | null
    _min: ProductBatchMinAggregateOutputType | null
    _max: ProductBatchMaxAggregateOutputType | null
  }

  export type ProductBatchAvgAggregateOutputType = {
    price: number | null
    stock: number | null
    warningQuantity: number | null
  }

  export type ProductBatchSumAggregateOutputType = {
    price: number | null
    stock: number | null
    warningQuantity: number | null
  }

  export type ProductBatchMinAggregateOutputType = {
    id: string | null
    batchNumber: string | null
    expiryDate: Date | null
    productId: string | null
    price: number | null
    stock: number | null
    warningQuantity: number | null
    storeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductBatchMaxAggregateOutputType = {
    id: string | null
    batchNumber: string | null
    expiryDate: Date | null
    productId: string | null
    price: number | null
    stock: number | null
    warningQuantity: number | null
    storeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductBatchCountAggregateOutputType = {
    id: number
    batchNumber: number
    expiryDate: number
    productId: number
    price: number
    stock: number
    warningQuantity: number
    storeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductBatchAvgAggregateInputType = {
    price?: true
    stock?: true
    warningQuantity?: true
  }

  export type ProductBatchSumAggregateInputType = {
    price?: true
    stock?: true
    warningQuantity?: true
  }

  export type ProductBatchMinAggregateInputType = {
    id?: true
    batchNumber?: true
    expiryDate?: true
    productId?: true
    price?: true
    stock?: true
    warningQuantity?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductBatchMaxAggregateInputType = {
    id?: true
    batchNumber?: true
    expiryDate?: true
    productId?: true
    price?: true
    stock?: true
    warningQuantity?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductBatchCountAggregateInputType = {
    id?: true
    batchNumber?: true
    expiryDate?: true
    productId?: true
    price?: true
    stock?: true
    warningQuantity?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductBatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductBatch to aggregate.
     */
    where?: ProductBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductBatches to fetch.
     */
    orderBy?: ProductBatchOrderByWithRelationInput | ProductBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductBatches
    **/
    _count?: true | ProductBatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductBatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductBatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductBatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductBatchMaxAggregateInputType
  }

  export type GetProductBatchAggregateType<T extends ProductBatchAggregateArgs> = {
        [P in keyof T & keyof AggregateProductBatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductBatch[P]>
      : GetScalarType<T[P], AggregateProductBatch[P]>
  }




  export type ProductBatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductBatchWhereInput
    orderBy?: ProductBatchOrderByWithAggregationInput | ProductBatchOrderByWithAggregationInput[]
    by: ProductBatchScalarFieldEnum[] | ProductBatchScalarFieldEnum
    having?: ProductBatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductBatchCountAggregateInputType | true
    _avg?: ProductBatchAvgAggregateInputType
    _sum?: ProductBatchSumAggregateInputType
    _min?: ProductBatchMinAggregateInputType
    _max?: ProductBatchMaxAggregateInputType
  }

  export type ProductBatchGroupByOutputType = {
    id: string
    batchNumber: string
    expiryDate: Date | null
    productId: string
    price: number | null
    stock: number | null
    warningQuantity: number | null
    storeId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProductBatchCountAggregateOutputType | null
    _avg: ProductBatchAvgAggregateOutputType | null
    _sum: ProductBatchSumAggregateOutputType | null
    _min: ProductBatchMinAggregateOutputType | null
    _max: ProductBatchMaxAggregateOutputType | null
  }

  type GetProductBatchGroupByPayload<T extends ProductBatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductBatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductBatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductBatchGroupByOutputType[P]>
            : GetScalarType<T[P], ProductBatchGroupByOutputType[P]>
        }
      >
    >


  export type ProductBatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchNumber?: boolean
    expiryDate?: boolean
    productId?: boolean
    price?: boolean
    stock?: boolean
    warningQuantity?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | ProductBatch$storeArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    ShopStock?: boolean | ProductBatch$ShopStockArgs<ExtArgs>
    StoreStock?: boolean | ProductBatch$StoreStockArgs<ExtArgs>
    StockLedger?: boolean | ProductBatch$StockLedgerArgs<ExtArgs>
    PurchaseItem?: boolean | ProductBatch$PurchaseItemArgs<ExtArgs>
    TransferItem?: boolean | ProductBatch$TransferItemArgs<ExtArgs>
    StockCorrectionItem?: boolean | ProductBatch$StockCorrectionItemArgs<ExtArgs>
    SellItemBatch?: boolean | ProductBatch$SellItemBatchArgs<ExtArgs>
    SellStockCorrectionBatch?: boolean | ProductBatch$SellStockCorrectionBatchArgs<ExtArgs>
    _count?: boolean | ProductBatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productBatch"]>



  export type ProductBatchSelectScalar = {
    id?: boolean
    batchNumber?: boolean
    expiryDate?: boolean
    productId?: boolean
    price?: boolean
    stock?: boolean
    warningQuantity?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductBatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "batchNumber" | "expiryDate" | "productId" | "price" | "stock" | "warningQuantity" | "storeId" | "createdAt" | "updatedAt", ExtArgs["result"]["productBatch"]>
  export type ProductBatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | ProductBatch$storeArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    ShopStock?: boolean | ProductBatch$ShopStockArgs<ExtArgs>
    StoreStock?: boolean | ProductBatch$StoreStockArgs<ExtArgs>
    StockLedger?: boolean | ProductBatch$StockLedgerArgs<ExtArgs>
    PurchaseItem?: boolean | ProductBatch$PurchaseItemArgs<ExtArgs>
    TransferItem?: boolean | ProductBatch$TransferItemArgs<ExtArgs>
    StockCorrectionItem?: boolean | ProductBatch$StockCorrectionItemArgs<ExtArgs>
    SellItemBatch?: boolean | ProductBatch$SellItemBatchArgs<ExtArgs>
    SellStockCorrectionBatch?: boolean | ProductBatch$SellStockCorrectionBatchArgs<ExtArgs>
    _count?: boolean | ProductBatchCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductBatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductBatch"
    objects: {
      store: Prisma.$StorePayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs>
      ShopStock: Prisma.$ShopStockPayload<ExtArgs>[]
      StoreStock: Prisma.$StoreStockPayload<ExtArgs>[]
      StockLedger: Prisma.$StockLedgerPayload<ExtArgs>[]
      PurchaseItem: Prisma.$PurchaseItemPayload<ExtArgs>[]
      TransferItem: Prisma.$TransferItemPayload<ExtArgs>[]
      StockCorrectionItem: Prisma.$StockCorrectionItemPayload<ExtArgs>[]
      SellItemBatch: Prisma.$SellItemBatchPayload<ExtArgs>[]
      SellStockCorrectionBatch: Prisma.$SellStockCorrectionBatchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      batchNumber: string
      expiryDate: Date | null
      productId: string
      price: number | null
      stock: number | null
      warningQuantity: number | null
      storeId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productBatch"]>
    composites: {}
  }

  type ProductBatchGetPayload<S extends boolean | null | undefined | ProductBatchDefaultArgs> = $Result.GetResult<Prisma.$ProductBatchPayload, S>

  type ProductBatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductBatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductBatchCountAggregateInputType | true
    }

  export interface ProductBatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductBatch'], meta: { name: 'ProductBatch' } }
    /**
     * Find zero or one ProductBatch that matches the filter.
     * @param {ProductBatchFindUniqueArgs} args - Arguments to find a ProductBatch
     * @example
     * // Get one ProductBatch
     * const productBatch = await prisma.productBatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductBatchFindUniqueArgs>(args: SelectSubset<T, ProductBatchFindUniqueArgs<ExtArgs>>): Prisma__ProductBatchClient<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductBatch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductBatchFindUniqueOrThrowArgs} args - Arguments to find a ProductBatch
     * @example
     * // Get one ProductBatch
     * const productBatch = await prisma.productBatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductBatchFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductBatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductBatchClient<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductBatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBatchFindFirstArgs} args - Arguments to find a ProductBatch
     * @example
     * // Get one ProductBatch
     * const productBatch = await prisma.productBatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductBatchFindFirstArgs>(args?: SelectSubset<T, ProductBatchFindFirstArgs<ExtArgs>>): Prisma__ProductBatchClient<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductBatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBatchFindFirstOrThrowArgs} args - Arguments to find a ProductBatch
     * @example
     * // Get one ProductBatch
     * const productBatch = await prisma.productBatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductBatchFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductBatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductBatchClient<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductBatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductBatches
     * const productBatches = await prisma.productBatch.findMany()
     * 
     * // Get first 10 ProductBatches
     * const productBatches = await prisma.productBatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productBatchWithIdOnly = await prisma.productBatch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductBatchFindManyArgs>(args?: SelectSubset<T, ProductBatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductBatch.
     * @param {ProductBatchCreateArgs} args - Arguments to create a ProductBatch.
     * @example
     * // Create one ProductBatch
     * const ProductBatch = await prisma.productBatch.create({
     *   data: {
     *     // ... data to create a ProductBatch
     *   }
     * })
     * 
     */
    create<T extends ProductBatchCreateArgs>(args: SelectSubset<T, ProductBatchCreateArgs<ExtArgs>>): Prisma__ProductBatchClient<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductBatches.
     * @param {ProductBatchCreateManyArgs} args - Arguments to create many ProductBatches.
     * @example
     * // Create many ProductBatches
     * const productBatch = await prisma.productBatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductBatchCreateManyArgs>(args?: SelectSubset<T, ProductBatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductBatch.
     * @param {ProductBatchDeleteArgs} args - Arguments to delete one ProductBatch.
     * @example
     * // Delete one ProductBatch
     * const ProductBatch = await prisma.productBatch.delete({
     *   where: {
     *     // ... filter to delete one ProductBatch
     *   }
     * })
     * 
     */
    delete<T extends ProductBatchDeleteArgs>(args: SelectSubset<T, ProductBatchDeleteArgs<ExtArgs>>): Prisma__ProductBatchClient<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductBatch.
     * @param {ProductBatchUpdateArgs} args - Arguments to update one ProductBatch.
     * @example
     * // Update one ProductBatch
     * const productBatch = await prisma.productBatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductBatchUpdateArgs>(args: SelectSubset<T, ProductBatchUpdateArgs<ExtArgs>>): Prisma__ProductBatchClient<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductBatches.
     * @param {ProductBatchDeleteManyArgs} args - Arguments to filter ProductBatches to delete.
     * @example
     * // Delete a few ProductBatches
     * const { count } = await prisma.productBatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductBatchDeleteManyArgs>(args?: SelectSubset<T, ProductBatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductBatches
     * const productBatch = await prisma.productBatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductBatchUpdateManyArgs>(args: SelectSubset<T, ProductBatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductBatch.
     * @param {ProductBatchUpsertArgs} args - Arguments to update or create a ProductBatch.
     * @example
     * // Update or create a ProductBatch
     * const productBatch = await prisma.productBatch.upsert({
     *   create: {
     *     // ... data to create a ProductBatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductBatch we want to update
     *   }
     * })
     */
    upsert<T extends ProductBatchUpsertArgs>(args: SelectSubset<T, ProductBatchUpsertArgs<ExtArgs>>): Prisma__ProductBatchClient<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBatchCountArgs} args - Arguments to filter ProductBatches to count.
     * @example
     * // Count the number of ProductBatches
     * const count = await prisma.productBatch.count({
     *   where: {
     *     // ... the filter for the ProductBatches we want to count
     *   }
     * })
    **/
    count<T extends ProductBatchCountArgs>(
      args?: Subset<T, ProductBatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductBatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductBatchAggregateArgs>(args: Subset<T, ProductBatchAggregateArgs>): Prisma.PrismaPromise<GetProductBatchAggregateType<T>>

    /**
     * Group by ProductBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductBatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductBatchGroupByArgs['orderBy'] }
        : { orderBy?: ProductBatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductBatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductBatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductBatch model
   */
  readonly fields: ProductBatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductBatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductBatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends ProductBatch$storeArgs<ExtArgs> = {}>(args?: Subset<T, ProductBatch$storeArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ShopStock<T extends ProductBatch$ShopStockArgs<ExtArgs> = {}>(args?: Subset<T, ProductBatch$ShopStockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StoreStock<T extends ProductBatch$StoreStockArgs<ExtArgs> = {}>(args?: Subset<T, ProductBatch$StoreStockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StockLedger<T extends ProductBatch$StockLedgerArgs<ExtArgs> = {}>(args?: Subset<T, ProductBatch$StockLedgerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PurchaseItem<T extends ProductBatch$PurchaseItemArgs<ExtArgs> = {}>(args?: Subset<T, ProductBatch$PurchaseItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TransferItem<T extends ProductBatch$TransferItemArgs<ExtArgs> = {}>(args?: Subset<T, ProductBatch$TransferItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StockCorrectionItem<T extends ProductBatch$StockCorrectionItemArgs<ExtArgs> = {}>(args?: Subset<T, ProductBatch$StockCorrectionItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockCorrectionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SellItemBatch<T extends ProductBatch$SellItemBatchArgs<ExtArgs> = {}>(args?: Subset<T, ProductBatch$SellItemBatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellItemBatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SellStockCorrectionBatch<T extends ProductBatch$SellStockCorrectionBatchArgs<ExtArgs> = {}>(args?: Subset<T, ProductBatch$SellStockCorrectionBatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellStockCorrectionBatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductBatch model
   */
  interface ProductBatchFieldRefs {
    readonly id: FieldRef<"ProductBatch", 'String'>
    readonly batchNumber: FieldRef<"ProductBatch", 'String'>
    readonly expiryDate: FieldRef<"ProductBatch", 'DateTime'>
    readonly productId: FieldRef<"ProductBatch", 'String'>
    readonly price: FieldRef<"ProductBatch", 'Float'>
    readonly stock: FieldRef<"ProductBatch", 'Int'>
    readonly warningQuantity: FieldRef<"ProductBatch", 'Int'>
    readonly storeId: FieldRef<"ProductBatch", 'String'>
    readonly createdAt: FieldRef<"ProductBatch", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductBatch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductBatch findUnique
   */
  export type ProductBatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatch
     */
    select?: ProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBatch
     */
    omit?: ProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBatchInclude<ExtArgs> | null
    /**
     * Filter, which ProductBatch to fetch.
     */
    where: ProductBatchWhereUniqueInput
  }

  /**
   * ProductBatch findUniqueOrThrow
   */
  export type ProductBatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatch
     */
    select?: ProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBatch
     */
    omit?: ProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBatchInclude<ExtArgs> | null
    /**
     * Filter, which ProductBatch to fetch.
     */
    where: ProductBatchWhereUniqueInput
  }

  /**
   * ProductBatch findFirst
   */
  export type ProductBatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatch
     */
    select?: ProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBatch
     */
    omit?: ProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBatchInclude<ExtArgs> | null
    /**
     * Filter, which ProductBatch to fetch.
     */
    where?: ProductBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductBatches to fetch.
     */
    orderBy?: ProductBatchOrderByWithRelationInput | ProductBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductBatches.
     */
    cursor?: ProductBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductBatches.
     */
    distinct?: ProductBatchScalarFieldEnum | ProductBatchScalarFieldEnum[]
  }

  /**
   * ProductBatch findFirstOrThrow
   */
  export type ProductBatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatch
     */
    select?: ProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBatch
     */
    omit?: ProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBatchInclude<ExtArgs> | null
    /**
     * Filter, which ProductBatch to fetch.
     */
    where?: ProductBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductBatches to fetch.
     */
    orderBy?: ProductBatchOrderByWithRelationInput | ProductBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductBatches.
     */
    cursor?: ProductBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductBatches.
     */
    distinct?: ProductBatchScalarFieldEnum | ProductBatchScalarFieldEnum[]
  }

  /**
   * ProductBatch findMany
   */
  export type ProductBatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatch
     */
    select?: ProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBatch
     */
    omit?: ProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBatchInclude<ExtArgs> | null
    /**
     * Filter, which ProductBatches to fetch.
     */
    where?: ProductBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductBatches to fetch.
     */
    orderBy?: ProductBatchOrderByWithRelationInput | ProductBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductBatches.
     */
    cursor?: ProductBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductBatches.
     */
    skip?: number
    distinct?: ProductBatchScalarFieldEnum | ProductBatchScalarFieldEnum[]
  }

  /**
   * ProductBatch create
   */
  export type ProductBatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatch
     */
    select?: ProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBatch
     */
    omit?: ProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBatchInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductBatch.
     */
    data: XOR<ProductBatchCreateInput, ProductBatchUncheckedCreateInput>
  }

  /**
   * ProductBatch createMany
   */
  export type ProductBatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductBatches.
     */
    data: ProductBatchCreateManyInput | ProductBatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductBatch update
   */
  export type ProductBatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatch
     */
    select?: ProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBatch
     */
    omit?: ProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBatchInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductBatch.
     */
    data: XOR<ProductBatchUpdateInput, ProductBatchUncheckedUpdateInput>
    /**
     * Choose, which ProductBatch to update.
     */
    where: ProductBatchWhereUniqueInput
  }

  /**
   * ProductBatch updateMany
   */
  export type ProductBatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductBatches.
     */
    data: XOR<ProductBatchUpdateManyMutationInput, ProductBatchUncheckedUpdateManyInput>
    /**
     * Filter which ProductBatches to update
     */
    where?: ProductBatchWhereInput
    /**
     * Limit how many ProductBatches to update.
     */
    limit?: number
  }

  /**
   * ProductBatch upsert
   */
  export type ProductBatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatch
     */
    select?: ProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBatch
     */
    omit?: ProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBatchInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductBatch to update in case it exists.
     */
    where: ProductBatchWhereUniqueInput
    /**
     * In case the ProductBatch found by the `where` argument doesn't exist, create a new ProductBatch with this data.
     */
    create: XOR<ProductBatchCreateInput, ProductBatchUncheckedCreateInput>
    /**
     * In case the ProductBatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductBatchUpdateInput, ProductBatchUncheckedUpdateInput>
  }

  /**
   * ProductBatch delete
   */
  export type ProductBatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatch
     */
    select?: ProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBatch
     */
    omit?: ProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBatchInclude<ExtArgs> | null
    /**
     * Filter which ProductBatch to delete.
     */
    where: ProductBatchWhereUniqueInput
  }

  /**
   * ProductBatch deleteMany
   */
  export type ProductBatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductBatches to delete
     */
    where?: ProductBatchWhereInput
    /**
     * Limit how many ProductBatches to delete.
     */
    limit?: number
  }

  /**
   * ProductBatch.store
   */
  export type ProductBatch$storeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    where?: StoreWhereInput
  }

  /**
   * ProductBatch.ShopStock
   */
  export type ProductBatch$ShopStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopStock
     */
    select?: ShopStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopStock
     */
    omit?: ShopStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopStockInclude<ExtArgs> | null
    where?: ShopStockWhereInput
    orderBy?: ShopStockOrderByWithRelationInput | ShopStockOrderByWithRelationInput[]
    cursor?: ShopStockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopStockScalarFieldEnum | ShopStockScalarFieldEnum[]
  }

  /**
   * ProductBatch.StoreStock
   */
  export type ProductBatch$StoreStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStock
     */
    select?: StoreStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStock
     */
    omit?: StoreStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStockInclude<ExtArgs> | null
    where?: StoreStockWhereInput
    orderBy?: StoreStockOrderByWithRelationInput | StoreStockOrderByWithRelationInput[]
    cursor?: StoreStockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreStockScalarFieldEnum | StoreStockScalarFieldEnum[]
  }

  /**
   * ProductBatch.StockLedger
   */
  export type ProductBatch$StockLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
    where?: StockLedgerWhereInput
    orderBy?: StockLedgerOrderByWithRelationInput | StockLedgerOrderByWithRelationInput[]
    cursor?: StockLedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockLedgerScalarFieldEnum | StockLedgerScalarFieldEnum[]
  }

  /**
   * ProductBatch.PurchaseItem
   */
  export type ProductBatch$PurchaseItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    where?: PurchaseItemWhereInput
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    cursor?: PurchaseItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * ProductBatch.TransferItem
   */
  export type ProductBatch$TransferItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    where?: TransferItemWhereInput
    orderBy?: TransferItemOrderByWithRelationInput | TransferItemOrderByWithRelationInput[]
    cursor?: TransferItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferItemScalarFieldEnum | TransferItemScalarFieldEnum[]
  }

  /**
   * ProductBatch.StockCorrectionItem
   */
  export type ProductBatch$StockCorrectionItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrectionItem
     */
    select?: StockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrectionItem
     */
    omit?: StockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionItemInclude<ExtArgs> | null
    where?: StockCorrectionItemWhereInput
    orderBy?: StockCorrectionItemOrderByWithRelationInput | StockCorrectionItemOrderByWithRelationInput[]
    cursor?: StockCorrectionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockCorrectionItemScalarFieldEnum | StockCorrectionItemScalarFieldEnum[]
  }

  /**
   * ProductBatch.SellItemBatch
   */
  export type ProductBatch$SellItemBatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItemBatch
     */
    select?: SellItemBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellItemBatch
     */
    omit?: SellItemBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellItemBatchInclude<ExtArgs> | null
    where?: SellItemBatchWhereInput
    orderBy?: SellItemBatchOrderByWithRelationInput | SellItemBatchOrderByWithRelationInput[]
    cursor?: SellItemBatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellItemBatchScalarFieldEnum | SellItemBatchScalarFieldEnum[]
  }

  /**
   * ProductBatch.SellStockCorrectionBatch
   */
  export type ProductBatch$SellStockCorrectionBatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionBatch
     */
    select?: SellStockCorrectionBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrectionBatch
     */
    omit?: SellStockCorrectionBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionBatchInclude<ExtArgs> | null
    where?: SellStockCorrectionBatchWhereInput
    orderBy?: SellStockCorrectionBatchOrderByWithRelationInput | SellStockCorrectionBatchOrderByWithRelationInput[]
    cursor?: SellStockCorrectionBatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellStockCorrectionBatchScalarFieldEnum | SellStockCorrectionBatchScalarFieldEnum[]
  }

  /**
   * ProductBatch without action
   */
  export type ProductBatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatch
     */
    select?: ProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBatch
     */
    omit?: ProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBatchInclude<ExtArgs> | null
  }


  /**
   * Model UnitOfMeasure
   */

  export type AggregateUnitOfMeasure = {
    _count: UnitOfMeasureCountAggregateOutputType | null
    _min: UnitOfMeasureMinAggregateOutputType | null
    _max: UnitOfMeasureMaxAggregateOutputType | null
  }

  export type UnitOfMeasureMinAggregateOutputType = {
    id: string | null
    name: string | null
    symbol: string | null
    base: boolean | null
  }

  export type UnitOfMeasureMaxAggregateOutputType = {
    id: string | null
    name: string | null
    symbol: string | null
    base: boolean | null
  }

  export type UnitOfMeasureCountAggregateOutputType = {
    id: number
    name: number
    symbol: number
    base: number
    _all: number
  }


  export type UnitOfMeasureMinAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    base?: true
  }

  export type UnitOfMeasureMaxAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    base?: true
  }

  export type UnitOfMeasureCountAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    base?: true
    _all?: true
  }

  export type UnitOfMeasureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitOfMeasure to aggregate.
     */
    where?: UnitOfMeasureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitOfMeasures to fetch.
     */
    orderBy?: UnitOfMeasureOrderByWithRelationInput | UnitOfMeasureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitOfMeasureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitOfMeasures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitOfMeasures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitOfMeasures
    **/
    _count?: true | UnitOfMeasureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitOfMeasureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitOfMeasureMaxAggregateInputType
  }

  export type GetUnitOfMeasureAggregateType<T extends UnitOfMeasureAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitOfMeasure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitOfMeasure[P]>
      : GetScalarType<T[P], AggregateUnitOfMeasure[P]>
  }




  export type UnitOfMeasureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitOfMeasureWhereInput
    orderBy?: UnitOfMeasureOrderByWithAggregationInput | UnitOfMeasureOrderByWithAggregationInput[]
    by: UnitOfMeasureScalarFieldEnum[] | UnitOfMeasureScalarFieldEnum
    having?: UnitOfMeasureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitOfMeasureCountAggregateInputType | true
    _min?: UnitOfMeasureMinAggregateInputType
    _max?: UnitOfMeasureMaxAggregateInputType
  }

  export type UnitOfMeasureGroupByOutputType = {
    id: string
    name: string
    symbol: string | null
    base: boolean
    _count: UnitOfMeasureCountAggregateOutputType | null
    _min: UnitOfMeasureMinAggregateOutputType | null
    _max: UnitOfMeasureMaxAggregateOutputType | null
  }

  type GetUnitOfMeasureGroupByPayload<T extends UnitOfMeasureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitOfMeasureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitOfMeasureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitOfMeasureGroupByOutputType[P]>
            : GetScalarType<T[P], UnitOfMeasureGroupByOutputType[P]>
        }
      >
    >


  export type UnitOfMeasureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    symbol?: boolean
    base?: boolean
    products?: boolean | UnitOfMeasure$productsArgs<ExtArgs>
    PurchaseItem?: boolean | UnitOfMeasure$PurchaseItemArgs<ExtArgs>
    TransferItem?: boolean | UnitOfMeasure$TransferItemArgs<ExtArgs>
    StockLedger?: boolean | UnitOfMeasure$StockLedgerArgs<ExtArgs>
    ShopStock?: boolean | UnitOfMeasure$ShopStockArgs<ExtArgs>
    StoreStock?: boolean | UnitOfMeasure$StoreStockArgs<ExtArgs>
    StockCorrectionItem?: boolean | UnitOfMeasure$StockCorrectionItemArgs<ExtArgs>
    SellItem?: boolean | UnitOfMeasure$SellItemArgs<ExtArgs>
    SellStockCorrectionItem?: boolean | UnitOfMeasure$SellStockCorrectionItemArgs<ExtArgs>
    CartItem?: boolean | UnitOfMeasure$CartItemArgs<ExtArgs>
    _count?: boolean | UnitOfMeasureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitOfMeasure"]>



  export type UnitOfMeasureSelectScalar = {
    id?: boolean
    name?: boolean
    symbol?: boolean
    base?: boolean
  }

  export type UnitOfMeasureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "symbol" | "base", ExtArgs["result"]["unitOfMeasure"]>
  export type UnitOfMeasureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | UnitOfMeasure$productsArgs<ExtArgs>
    PurchaseItem?: boolean | UnitOfMeasure$PurchaseItemArgs<ExtArgs>
    TransferItem?: boolean | UnitOfMeasure$TransferItemArgs<ExtArgs>
    StockLedger?: boolean | UnitOfMeasure$StockLedgerArgs<ExtArgs>
    ShopStock?: boolean | UnitOfMeasure$ShopStockArgs<ExtArgs>
    StoreStock?: boolean | UnitOfMeasure$StoreStockArgs<ExtArgs>
    StockCorrectionItem?: boolean | UnitOfMeasure$StockCorrectionItemArgs<ExtArgs>
    SellItem?: boolean | UnitOfMeasure$SellItemArgs<ExtArgs>
    SellStockCorrectionItem?: boolean | UnitOfMeasure$SellStockCorrectionItemArgs<ExtArgs>
    CartItem?: boolean | UnitOfMeasure$CartItemArgs<ExtArgs>
    _count?: boolean | UnitOfMeasureCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UnitOfMeasurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitOfMeasure"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
      PurchaseItem: Prisma.$PurchaseItemPayload<ExtArgs>[]
      TransferItem: Prisma.$TransferItemPayload<ExtArgs>[]
      StockLedger: Prisma.$StockLedgerPayload<ExtArgs>[]
      ShopStock: Prisma.$ShopStockPayload<ExtArgs>[]
      StoreStock: Prisma.$StoreStockPayload<ExtArgs>[]
      StockCorrectionItem: Prisma.$StockCorrectionItemPayload<ExtArgs>[]
      SellItem: Prisma.$SellItemPayload<ExtArgs>[]
      SellStockCorrectionItem: Prisma.$SellStockCorrectionItemPayload<ExtArgs>[]
      CartItem: Prisma.$CartItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      symbol: string | null
      base: boolean
    }, ExtArgs["result"]["unitOfMeasure"]>
    composites: {}
  }

  type UnitOfMeasureGetPayload<S extends boolean | null | undefined | UnitOfMeasureDefaultArgs> = $Result.GetResult<Prisma.$UnitOfMeasurePayload, S>

  type UnitOfMeasureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitOfMeasureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitOfMeasureCountAggregateInputType | true
    }

  export interface UnitOfMeasureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitOfMeasure'], meta: { name: 'UnitOfMeasure' } }
    /**
     * Find zero or one UnitOfMeasure that matches the filter.
     * @param {UnitOfMeasureFindUniqueArgs} args - Arguments to find a UnitOfMeasure
     * @example
     * // Get one UnitOfMeasure
     * const unitOfMeasure = await prisma.unitOfMeasure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitOfMeasureFindUniqueArgs>(args: SelectSubset<T, UnitOfMeasureFindUniqueArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitOfMeasure that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitOfMeasureFindUniqueOrThrowArgs} args - Arguments to find a UnitOfMeasure
     * @example
     * // Get one UnitOfMeasure
     * const unitOfMeasure = await prisma.unitOfMeasure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitOfMeasureFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitOfMeasureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitOfMeasure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasureFindFirstArgs} args - Arguments to find a UnitOfMeasure
     * @example
     * // Get one UnitOfMeasure
     * const unitOfMeasure = await prisma.unitOfMeasure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitOfMeasureFindFirstArgs>(args?: SelectSubset<T, UnitOfMeasureFindFirstArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitOfMeasure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasureFindFirstOrThrowArgs} args - Arguments to find a UnitOfMeasure
     * @example
     * // Get one UnitOfMeasure
     * const unitOfMeasure = await prisma.unitOfMeasure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitOfMeasureFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitOfMeasureFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitOfMeasures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitOfMeasures
     * const unitOfMeasures = await prisma.unitOfMeasure.findMany()
     * 
     * // Get first 10 UnitOfMeasures
     * const unitOfMeasures = await prisma.unitOfMeasure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitOfMeasureWithIdOnly = await prisma.unitOfMeasure.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitOfMeasureFindManyArgs>(args?: SelectSubset<T, UnitOfMeasureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitOfMeasure.
     * @param {UnitOfMeasureCreateArgs} args - Arguments to create a UnitOfMeasure.
     * @example
     * // Create one UnitOfMeasure
     * const UnitOfMeasure = await prisma.unitOfMeasure.create({
     *   data: {
     *     // ... data to create a UnitOfMeasure
     *   }
     * })
     * 
     */
    create<T extends UnitOfMeasureCreateArgs>(args: SelectSubset<T, UnitOfMeasureCreateArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitOfMeasures.
     * @param {UnitOfMeasureCreateManyArgs} args - Arguments to create many UnitOfMeasures.
     * @example
     * // Create many UnitOfMeasures
     * const unitOfMeasure = await prisma.unitOfMeasure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitOfMeasureCreateManyArgs>(args?: SelectSubset<T, UnitOfMeasureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UnitOfMeasure.
     * @param {UnitOfMeasureDeleteArgs} args - Arguments to delete one UnitOfMeasure.
     * @example
     * // Delete one UnitOfMeasure
     * const UnitOfMeasure = await prisma.unitOfMeasure.delete({
     *   where: {
     *     // ... filter to delete one UnitOfMeasure
     *   }
     * })
     * 
     */
    delete<T extends UnitOfMeasureDeleteArgs>(args: SelectSubset<T, UnitOfMeasureDeleteArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitOfMeasure.
     * @param {UnitOfMeasureUpdateArgs} args - Arguments to update one UnitOfMeasure.
     * @example
     * // Update one UnitOfMeasure
     * const unitOfMeasure = await prisma.unitOfMeasure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitOfMeasureUpdateArgs>(args: SelectSubset<T, UnitOfMeasureUpdateArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitOfMeasures.
     * @param {UnitOfMeasureDeleteManyArgs} args - Arguments to filter UnitOfMeasures to delete.
     * @example
     * // Delete a few UnitOfMeasures
     * const { count } = await prisma.unitOfMeasure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitOfMeasureDeleteManyArgs>(args?: SelectSubset<T, UnitOfMeasureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitOfMeasures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitOfMeasures
     * const unitOfMeasure = await prisma.unitOfMeasure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitOfMeasureUpdateManyArgs>(args: SelectSubset<T, UnitOfMeasureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UnitOfMeasure.
     * @param {UnitOfMeasureUpsertArgs} args - Arguments to update or create a UnitOfMeasure.
     * @example
     * // Update or create a UnitOfMeasure
     * const unitOfMeasure = await prisma.unitOfMeasure.upsert({
     *   create: {
     *     // ... data to create a UnitOfMeasure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitOfMeasure we want to update
     *   }
     * })
     */
    upsert<T extends UnitOfMeasureUpsertArgs>(args: SelectSubset<T, UnitOfMeasureUpsertArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitOfMeasures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasureCountArgs} args - Arguments to filter UnitOfMeasures to count.
     * @example
     * // Count the number of UnitOfMeasures
     * const count = await prisma.unitOfMeasure.count({
     *   where: {
     *     // ... the filter for the UnitOfMeasures we want to count
     *   }
     * })
    **/
    count<T extends UnitOfMeasureCountArgs>(
      args?: Subset<T, UnitOfMeasureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitOfMeasureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitOfMeasure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitOfMeasureAggregateArgs>(args: Subset<T, UnitOfMeasureAggregateArgs>): Prisma.PrismaPromise<GetUnitOfMeasureAggregateType<T>>

    /**
     * Group by UnitOfMeasure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitOfMeasureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitOfMeasureGroupByArgs['orderBy'] }
        : { orderBy?: UnitOfMeasureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitOfMeasureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitOfMeasureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitOfMeasure model
   */
  readonly fields: UnitOfMeasureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitOfMeasure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitOfMeasureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends UnitOfMeasure$productsArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasure$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PurchaseItem<T extends UnitOfMeasure$PurchaseItemArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasure$PurchaseItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TransferItem<T extends UnitOfMeasure$TransferItemArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasure$TransferItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StockLedger<T extends UnitOfMeasure$StockLedgerArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasure$StockLedgerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ShopStock<T extends UnitOfMeasure$ShopStockArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasure$ShopStockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StoreStock<T extends UnitOfMeasure$StoreStockArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasure$StoreStockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StockCorrectionItem<T extends UnitOfMeasure$StockCorrectionItemArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasure$StockCorrectionItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockCorrectionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SellItem<T extends UnitOfMeasure$SellItemArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasure$SellItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SellStockCorrectionItem<T extends UnitOfMeasure$SellStockCorrectionItemArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasure$SellStockCorrectionItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellStockCorrectionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CartItem<T extends UnitOfMeasure$CartItemArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasure$CartItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitOfMeasure model
   */
  interface UnitOfMeasureFieldRefs {
    readonly id: FieldRef<"UnitOfMeasure", 'String'>
    readonly name: FieldRef<"UnitOfMeasure", 'String'>
    readonly symbol: FieldRef<"UnitOfMeasure", 'String'>
    readonly base: FieldRef<"UnitOfMeasure", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * UnitOfMeasure findUnique
   */
  export type UnitOfMeasureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasure
     */
    select?: UnitOfMeasureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasure
     */
    omit?: UnitOfMeasureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasureInclude<ExtArgs> | null
    /**
     * Filter, which UnitOfMeasure to fetch.
     */
    where: UnitOfMeasureWhereUniqueInput
  }

  /**
   * UnitOfMeasure findUniqueOrThrow
   */
  export type UnitOfMeasureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasure
     */
    select?: UnitOfMeasureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasure
     */
    omit?: UnitOfMeasureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasureInclude<ExtArgs> | null
    /**
     * Filter, which UnitOfMeasure to fetch.
     */
    where: UnitOfMeasureWhereUniqueInput
  }

  /**
   * UnitOfMeasure findFirst
   */
  export type UnitOfMeasureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasure
     */
    select?: UnitOfMeasureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasure
     */
    omit?: UnitOfMeasureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasureInclude<ExtArgs> | null
    /**
     * Filter, which UnitOfMeasure to fetch.
     */
    where?: UnitOfMeasureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitOfMeasures to fetch.
     */
    orderBy?: UnitOfMeasureOrderByWithRelationInput | UnitOfMeasureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitOfMeasures.
     */
    cursor?: UnitOfMeasureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitOfMeasures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitOfMeasures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitOfMeasures.
     */
    distinct?: UnitOfMeasureScalarFieldEnum | UnitOfMeasureScalarFieldEnum[]
  }

  /**
   * UnitOfMeasure findFirstOrThrow
   */
  export type UnitOfMeasureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasure
     */
    select?: UnitOfMeasureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasure
     */
    omit?: UnitOfMeasureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasureInclude<ExtArgs> | null
    /**
     * Filter, which UnitOfMeasure to fetch.
     */
    where?: UnitOfMeasureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitOfMeasures to fetch.
     */
    orderBy?: UnitOfMeasureOrderByWithRelationInput | UnitOfMeasureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitOfMeasures.
     */
    cursor?: UnitOfMeasureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitOfMeasures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitOfMeasures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitOfMeasures.
     */
    distinct?: UnitOfMeasureScalarFieldEnum | UnitOfMeasureScalarFieldEnum[]
  }

  /**
   * UnitOfMeasure findMany
   */
  export type UnitOfMeasureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasure
     */
    select?: UnitOfMeasureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasure
     */
    omit?: UnitOfMeasureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasureInclude<ExtArgs> | null
    /**
     * Filter, which UnitOfMeasures to fetch.
     */
    where?: UnitOfMeasureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitOfMeasures to fetch.
     */
    orderBy?: UnitOfMeasureOrderByWithRelationInput | UnitOfMeasureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitOfMeasures.
     */
    cursor?: UnitOfMeasureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitOfMeasures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitOfMeasures.
     */
    skip?: number
    distinct?: UnitOfMeasureScalarFieldEnum | UnitOfMeasureScalarFieldEnum[]
  }

  /**
   * UnitOfMeasure create
   */
  export type UnitOfMeasureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasure
     */
    select?: UnitOfMeasureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasure
     */
    omit?: UnitOfMeasureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasureInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitOfMeasure.
     */
    data: XOR<UnitOfMeasureCreateInput, UnitOfMeasureUncheckedCreateInput>
  }

  /**
   * UnitOfMeasure createMany
   */
  export type UnitOfMeasureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitOfMeasures.
     */
    data: UnitOfMeasureCreateManyInput | UnitOfMeasureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitOfMeasure update
   */
  export type UnitOfMeasureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasure
     */
    select?: UnitOfMeasureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasure
     */
    omit?: UnitOfMeasureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasureInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitOfMeasure.
     */
    data: XOR<UnitOfMeasureUpdateInput, UnitOfMeasureUncheckedUpdateInput>
    /**
     * Choose, which UnitOfMeasure to update.
     */
    where: UnitOfMeasureWhereUniqueInput
  }

  /**
   * UnitOfMeasure updateMany
   */
  export type UnitOfMeasureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitOfMeasures.
     */
    data: XOR<UnitOfMeasureUpdateManyMutationInput, UnitOfMeasureUncheckedUpdateManyInput>
    /**
     * Filter which UnitOfMeasures to update
     */
    where?: UnitOfMeasureWhereInput
    /**
     * Limit how many UnitOfMeasures to update.
     */
    limit?: number
  }

  /**
   * UnitOfMeasure upsert
   */
  export type UnitOfMeasureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasure
     */
    select?: UnitOfMeasureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasure
     */
    omit?: UnitOfMeasureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasureInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitOfMeasure to update in case it exists.
     */
    where: UnitOfMeasureWhereUniqueInput
    /**
     * In case the UnitOfMeasure found by the `where` argument doesn't exist, create a new UnitOfMeasure with this data.
     */
    create: XOR<UnitOfMeasureCreateInput, UnitOfMeasureUncheckedCreateInput>
    /**
     * In case the UnitOfMeasure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitOfMeasureUpdateInput, UnitOfMeasureUncheckedUpdateInput>
  }

  /**
   * UnitOfMeasure delete
   */
  export type UnitOfMeasureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasure
     */
    select?: UnitOfMeasureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasure
     */
    omit?: UnitOfMeasureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasureInclude<ExtArgs> | null
    /**
     * Filter which UnitOfMeasure to delete.
     */
    where: UnitOfMeasureWhereUniqueInput
  }

  /**
   * UnitOfMeasure deleteMany
   */
  export type UnitOfMeasureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitOfMeasures to delete
     */
    where?: UnitOfMeasureWhereInput
    /**
     * Limit how many UnitOfMeasures to delete.
     */
    limit?: number
  }

  /**
   * UnitOfMeasure.products
   */
  export type UnitOfMeasure$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * UnitOfMeasure.PurchaseItem
   */
  export type UnitOfMeasure$PurchaseItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    where?: PurchaseItemWhereInput
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    cursor?: PurchaseItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * UnitOfMeasure.TransferItem
   */
  export type UnitOfMeasure$TransferItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    where?: TransferItemWhereInput
    orderBy?: TransferItemOrderByWithRelationInput | TransferItemOrderByWithRelationInput[]
    cursor?: TransferItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferItemScalarFieldEnum | TransferItemScalarFieldEnum[]
  }

  /**
   * UnitOfMeasure.StockLedger
   */
  export type UnitOfMeasure$StockLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
    where?: StockLedgerWhereInput
    orderBy?: StockLedgerOrderByWithRelationInput | StockLedgerOrderByWithRelationInput[]
    cursor?: StockLedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockLedgerScalarFieldEnum | StockLedgerScalarFieldEnum[]
  }

  /**
   * UnitOfMeasure.ShopStock
   */
  export type UnitOfMeasure$ShopStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopStock
     */
    select?: ShopStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopStock
     */
    omit?: ShopStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopStockInclude<ExtArgs> | null
    where?: ShopStockWhereInput
    orderBy?: ShopStockOrderByWithRelationInput | ShopStockOrderByWithRelationInput[]
    cursor?: ShopStockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopStockScalarFieldEnum | ShopStockScalarFieldEnum[]
  }

  /**
   * UnitOfMeasure.StoreStock
   */
  export type UnitOfMeasure$StoreStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStock
     */
    select?: StoreStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStock
     */
    omit?: StoreStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStockInclude<ExtArgs> | null
    where?: StoreStockWhereInput
    orderBy?: StoreStockOrderByWithRelationInput | StoreStockOrderByWithRelationInput[]
    cursor?: StoreStockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreStockScalarFieldEnum | StoreStockScalarFieldEnum[]
  }

  /**
   * UnitOfMeasure.StockCorrectionItem
   */
  export type UnitOfMeasure$StockCorrectionItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrectionItem
     */
    select?: StockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrectionItem
     */
    omit?: StockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionItemInclude<ExtArgs> | null
    where?: StockCorrectionItemWhereInput
    orderBy?: StockCorrectionItemOrderByWithRelationInput | StockCorrectionItemOrderByWithRelationInput[]
    cursor?: StockCorrectionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockCorrectionItemScalarFieldEnum | StockCorrectionItemScalarFieldEnum[]
  }

  /**
   * UnitOfMeasure.SellItem
   */
  export type UnitOfMeasure$SellItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItem
     */
    select?: SellItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellItem
     */
    omit?: SellItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellItemInclude<ExtArgs> | null
    where?: SellItemWhereInput
    orderBy?: SellItemOrderByWithRelationInput | SellItemOrderByWithRelationInput[]
    cursor?: SellItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellItemScalarFieldEnum | SellItemScalarFieldEnum[]
  }

  /**
   * UnitOfMeasure.SellStockCorrectionItem
   */
  export type UnitOfMeasure$SellStockCorrectionItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionItem
     */
    select?: SellStockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrectionItem
     */
    omit?: SellStockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionItemInclude<ExtArgs> | null
    where?: SellStockCorrectionItemWhereInput
    orderBy?: SellStockCorrectionItemOrderByWithRelationInput | SellStockCorrectionItemOrderByWithRelationInput[]
    cursor?: SellStockCorrectionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellStockCorrectionItemScalarFieldEnum | SellStockCorrectionItemScalarFieldEnum[]
  }

  /**
   * UnitOfMeasure.CartItem
   */
  export type UnitOfMeasure$CartItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * UnitOfMeasure without action
   */
  export type UnitOfMeasureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasure
     */
    select?: UnitOfMeasureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasure
     */
    omit?: UnitOfMeasureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasureInclude<ExtArgs> | null
  }


  /**
   * Model Purchase
   */

  export type AggregatePurchase = {
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  export type PurchaseAvgAggregateOutputType = {
    totalProducts: number | null
    subTotal: number | null
    grandTotal: number | null
  }

  export type PurchaseSumAggregateOutputType = {
    totalProducts: number | null
    subTotal: number | null
    grandTotal: number | null
  }

  export type PurchaseMinAggregateOutputType = {
    id: string | null
    invoiceNo: string | null
    supplierId: string | null
    storeId: string | null
    paymentStatus: $Enums.PaymentStatus | null
    totalProducts: number | null
    subTotal: number | null
    grandTotal: number | null
    notes: string | null
    purchaseDate: Date | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseMaxAggregateOutputType = {
    id: string | null
    invoiceNo: string | null
    supplierId: string | null
    storeId: string | null
    paymentStatus: $Enums.PaymentStatus | null
    totalProducts: number | null
    subTotal: number | null
    grandTotal: number | null
    notes: string | null
    purchaseDate: Date | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseCountAggregateOutputType = {
    id: number
    invoiceNo: number
    supplierId: number
    storeId: number
    paymentStatus: number
    totalProducts: number
    subTotal: number
    grandTotal: number
    notes: number
    purchaseDate: number
    createdById: number
    updatedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseAvgAggregateInputType = {
    totalProducts?: true
    subTotal?: true
    grandTotal?: true
  }

  export type PurchaseSumAggregateInputType = {
    totalProducts?: true
    subTotal?: true
    grandTotal?: true
  }

  export type PurchaseMinAggregateInputType = {
    id?: true
    invoiceNo?: true
    supplierId?: true
    storeId?: true
    paymentStatus?: true
    totalProducts?: true
    subTotal?: true
    grandTotal?: true
    notes?: true
    purchaseDate?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseMaxAggregateInputType = {
    id?: true
    invoiceNo?: true
    supplierId?: true
    storeId?: true
    paymentStatus?: true
    totalProducts?: true
    subTotal?: true
    grandTotal?: true
    notes?: true
    purchaseDate?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseCountAggregateInputType = {
    id?: true
    invoiceNo?: true
    supplierId?: true
    storeId?: true
    paymentStatus?: true
    totalProducts?: true
    subTotal?: true
    grandTotal?: true
    notes?: true
    purchaseDate?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchase to aggregate.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Purchases
    **/
    _count?: true | PurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseMaxAggregateInputType
  }

  export type GetPurchaseAggregateType<T extends PurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchase[P]>
      : GetScalarType<T[P], AggregatePurchase[P]>
  }




  export type PurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithAggregationInput | PurchaseOrderByWithAggregationInput[]
    by: PurchaseScalarFieldEnum[] | PurchaseScalarFieldEnum
    having?: PurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseCountAggregateInputType | true
    _avg?: PurchaseAvgAggregateInputType
    _sum?: PurchaseSumAggregateInputType
    _min?: PurchaseMinAggregateInputType
    _max?: PurchaseMaxAggregateInputType
  }

  export type PurchaseGroupByOutputType = {
    id: string
    invoiceNo: string
    supplierId: string
    storeId: string
    paymentStatus: $Enums.PaymentStatus
    totalProducts: number
    subTotal: number
    grandTotal: number
    notes: string | null
    purchaseDate: Date
    createdById: string | null
    updatedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  type GetPurchaseGroupByPayload<T extends PurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNo?: boolean
    supplierId?: boolean
    storeId?: boolean
    paymentStatus?: boolean
    totalProducts?: boolean
    subTotal?: boolean
    grandTotal?: boolean
    notes?: boolean
    purchaseDate?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
    createdBy?: boolean | Purchase$createdByArgs<ExtArgs>
    updatedBy?: boolean | Purchase$updatedByArgs<ExtArgs>
    items?: boolean | Purchase$itemsArgs<ExtArgs>
    StockCorrection?: boolean | Purchase$StockCorrectionArgs<ExtArgs>
    _count?: boolean | PurchaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>



  export type PurchaseSelectScalar = {
    id?: boolean
    invoiceNo?: boolean
    supplierId?: boolean
    storeId?: boolean
    paymentStatus?: boolean
    totalProducts?: boolean
    subTotal?: boolean
    grandTotal?: boolean
    notes?: boolean
    purchaseDate?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceNo" | "supplierId" | "storeId" | "paymentStatus" | "totalProducts" | "subTotal" | "grandTotal" | "notes" | "purchaseDate" | "createdById" | "updatedById" | "createdAt" | "updatedAt", ExtArgs["result"]["purchase"]>
  export type PurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
    createdBy?: boolean | Purchase$createdByArgs<ExtArgs>
    updatedBy?: boolean | Purchase$updatedByArgs<ExtArgs>
    items?: boolean | Purchase$itemsArgs<ExtArgs>
    StockCorrection?: boolean | Purchase$StockCorrectionArgs<ExtArgs>
    _count?: boolean | PurchaseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Purchase"
    objects: {
      supplier: Prisma.$SupplierPayload<ExtArgs>
      store: Prisma.$StorePayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
      items: Prisma.$PurchaseItemPayload<ExtArgs>[]
      StockCorrection: Prisma.$StockCorrectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceNo: string
      supplierId: string
      storeId: string
      paymentStatus: $Enums.PaymentStatus
      totalProducts: number
      subTotal: number
      grandTotal: number
      notes: string | null
      purchaseDate: Date
      createdById: string | null
      updatedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchase"]>
    composites: {}
  }

  type PurchaseGetPayload<S extends boolean | null | undefined | PurchaseDefaultArgs> = $Result.GetResult<Prisma.$PurchasePayload, S>

  type PurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseCountAggregateInputType | true
    }

  export interface PurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Purchase'], meta: { name: 'Purchase' } }
    /**
     * Find zero or one Purchase that matches the filter.
     * @param {PurchaseFindUniqueArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseFindUniqueArgs>(args: SelectSubset<T, PurchaseFindUniqueArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Purchase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseFindUniqueOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Purchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseFindFirstArgs>(args?: SelectSubset<T, PurchaseFindFirstArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Purchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Purchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Purchases
     * const purchases = await prisma.purchase.findMany()
     * 
     * // Get first 10 Purchases
     * const purchases = await prisma.purchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseWithIdOnly = await prisma.purchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseFindManyArgs>(args?: SelectSubset<T, PurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Purchase.
     * @param {PurchaseCreateArgs} args - Arguments to create a Purchase.
     * @example
     * // Create one Purchase
     * const Purchase = await prisma.purchase.create({
     *   data: {
     *     // ... data to create a Purchase
     *   }
     * })
     * 
     */
    create<T extends PurchaseCreateArgs>(args: SelectSubset<T, PurchaseCreateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Purchases.
     * @param {PurchaseCreateManyArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseCreateManyArgs>(args?: SelectSubset<T, PurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Purchase.
     * @param {PurchaseDeleteArgs} args - Arguments to delete one Purchase.
     * @example
     * // Delete one Purchase
     * const Purchase = await prisma.purchase.delete({
     *   where: {
     *     // ... filter to delete one Purchase
     *   }
     * })
     * 
     */
    delete<T extends PurchaseDeleteArgs>(args: SelectSubset<T, PurchaseDeleteArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Purchase.
     * @param {PurchaseUpdateArgs} args - Arguments to update one Purchase.
     * @example
     * // Update one Purchase
     * const purchase = await prisma.purchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseUpdateArgs>(args: SelectSubset<T, PurchaseUpdateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Purchases.
     * @param {PurchaseDeleteManyArgs} args - Arguments to filter Purchases to delete.
     * @example
     * // Delete a few Purchases
     * const { count } = await prisma.purchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseDeleteManyArgs>(args?: SelectSubset<T, PurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseUpdateManyArgs>(args: SelectSubset<T, PurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Purchase.
     * @param {PurchaseUpsertArgs} args - Arguments to update or create a Purchase.
     * @example
     * // Update or create a Purchase
     * const purchase = await prisma.purchase.upsert({
     *   create: {
     *     // ... data to create a Purchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Purchase we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseUpsertArgs>(args: SelectSubset<T, PurchaseUpsertArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseCountArgs} args - Arguments to filter Purchases to count.
     * @example
     * // Count the number of Purchases
     * const count = await prisma.purchase.count({
     *   where: {
     *     // ... the filter for the Purchases we want to count
     *   }
     * })
    **/
    count<T extends PurchaseCountArgs>(
      args?: Subset<T, PurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseAggregateArgs>(args: Subset<T, PurchaseAggregateArgs>): Prisma.PrismaPromise<GetPurchaseAggregateType<T>>

    /**
     * Group by Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Purchase model
   */
  readonly fields: PurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Purchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends Purchase$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Purchase$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends Purchase$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, Purchase$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Purchase$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Purchase$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StockCorrection<T extends Purchase$StockCorrectionArgs<ExtArgs> = {}>(args?: Subset<T, Purchase$StockCorrectionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockCorrectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Purchase model
   */
  interface PurchaseFieldRefs {
    readonly id: FieldRef<"Purchase", 'String'>
    readonly invoiceNo: FieldRef<"Purchase", 'String'>
    readonly supplierId: FieldRef<"Purchase", 'String'>
    readonly storeId: FieldRef<"Purchase", 'String'>
    readonly paymentStatus: FieldRef<"Purchase", 'PaymentStatus'>
    readonly totalProducts: FieldRef<"Purchase", 'Int'>
    readonly subTotal: FieldRef<"Purchase", 'Float'>
    readonly grandTotal: FieldRef<"Purchase", 'Float'>
    readonly notes: FieldRef<"Purchase", 'String'>
    readonly purchaseDate: FieldRef<"Purchase", 'DateTime'>
    readonly createdById: FieldRef<"Purchase", 'String'>
    readonly updatedById: FieldRef<"Purchase", 'String'>
    readonly createdAt: FieldRef<"Purchase", 'DateTime'>
    readonly updatedAt: FieldRef<"Purchase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Purchase findUnique
   */
  export type PurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findUniqueOrThrow
   */
  export type PurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findFirst
   */
  export type PurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findFirstOrThrow
   */
  export type PurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findMany
   */
  export type PurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchases to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase create
   */
  export type PurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Purchase.
     */
    data: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
  }

  /**
   * Purchase createMany
   */
  export type PurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Purchase update
   */
  export type PurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Purchase.
     */
    data: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
    /**
     * Choose, which Purchase to update.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase updateMany
   */
  export type PurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to update.
     */
    limit?: number
  }

  /**
   * Purchase upsert
   */
  export type PurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Purchase to update in case it exists.
     */
    where: PurchaseWhereUniqueInput
    /**
     * In case the Purchase found by the `where` argument doesn't exist, create a new Purchase with this data.
     */
    create: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
    /**
     * In case the Purchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
  }

  /**
   * Purchase delete
   */
  export type PurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter which Purchase to delete.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase deleteMany
   */
  export type PurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchases to delete
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to delete.
     */
    limit?: number
  }

  /**
   * Purchase.createdBy
   */
  export type Purchase$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Purchase.updatedBy
   */
  export type Purchase$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Purchase.items
   */
  export type Purchase$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    where?: PurchaseItemWhereInput
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    cursor?: PurchaseItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * Purchase.StockCorrection
   */
  export type Purchase$StockCorrectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrection
     */
    select?: StockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrection
     */
    omit?: StockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionInclude<ExtArgs> | null
    where?: StockCorrectionWhereInput
    orderBy?: StockCorrectionOrderByWithRelationInput | StockCorrectionOrderByWithRelationInput[]
    cursor?: StockCorrectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockCorrectionScalarFieldEnum | StockCorrectionScalarFieldEnum[]
  }

  /**
   * Purchase without action
   */
  export type PurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseItem
   */

  export type AggregatePurchaseItem = {
    _count: PurchaseItemCountAggregateOutputType | null
    _avg: PurchaseItemAvgAggregateOutputType | null
    _sum: PurchaseItemSumAggregateOutputType | null
    _min: PurchaseItemMinAggregateOutputType | null
    _max: PurchaseItemMaxAggregateOutputType | null
  }

  export type PurchaseItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
  }

  export type PurchaseItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
  }

  export type PurchaseItemMinAggregateOutputType = {
    id: string | null
    purchaseId: string | null
    productId: string | null
    batchId: string | null
    unitOfMeasureId: string | null
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseItemMaxAggregateOutputType = {
    id: string | null
    purchaseId: string | null
    productId: string | null
    batchId: string | null
    unitOfMeasureId: string | null
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseItemCountAggregateOutputType = {
    id: number
    purchaseId: number
    productId: number
    batchId: number
    unitOfMeasureId: number
    quantity: number
    unitPrice: number
    totalPrice: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type PurchaseItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type PurchaseItemMinAggregateInputType = {
    id?: true
    purchaseId?: true
    productId?: true
    batchId?: true
    unitOfMeasureId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseItemMaxAggregateInputType = {
    id?: true
    purchaseId?: true
    productId?: true
    batchId?: true
    unitOfMeasureId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseItemCountAggregateInputType = {
    id?: true
    purchaseId?: true
    productId?: true
    batchId?: true
    unitOfMeasureId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseItem to aggregate.
     */
    where?: PurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseItems
    **/
    _count?: true | PurchaseItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseItemMaxAggregateInputType
  }

  export type GetPurchaseItemAggregateType<T extends PurchaseItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseItem[P]>
      : GetScalarType<T[P], AggregatePurchaseItem[P]>
  }




  export type PurchaseItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemWhereInput
    orderBy?: PurchaseItemOrderByWithAggregationInput | PurchaseItemOrderByWithAggregationInput[]
    by: PurchaseItemScalarFieldEnum[] | PurchaseItemScalarFieldEnum
    having?: PurchaseItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseItemCountAggregateInputType | true
    _avg?: PurchaseItemAvgAggregateInputType
    _sum?: PurchaseItemSumAggregateInputType
    _min?: PurchaseItemMinAggregateInputType
    _max?: PurchaseItemMaxAggregateInputType
  }

  export type PurchaseItemGroupByOutputType = {
    id: string
    purchaseId: string
    productId: string
    batchId: string
    unitOfMeasureId: string
    quantity: number
    unitPrice: number
    totalPrice: number
    createdAt: Date
    updatedAt: Date
    _count: PurchaseItemCountAggregateOutputType | null
    _avg: PurchaseItemAvgAggregateOutputType | null
    _sum: PurchaseItemSumAggregateOutputType | null
    _min: PurchaseItemMinAggregateOutputType | null
    _max: PurchaseItemMaxAggregateOutputType | null
  }

  type GetPurchaseItemGroupByPayload<T extends PurchaseItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseItemGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseItemGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseId?: boolean
    productId?: boolean
    batchId?: boolean
    unitOfMeasureId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    batch?: boolean | ProductBatchDefaultArgs<ExtArgs>
    unitOfMeasure?: boolean | UnitOfMeasureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseItem"]>



  export type PurchaseItemSelectScalar = {
    id?: boolean
    purchaseId?: boolean
    productId?: boolean
    batchId?: boolean
    unitOfMeasureId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "purchaseId" | "productId" | "batchId" | "unitOfMeasureId" | "quantity" | "unitPrice" | "totalPrice" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseItem"]>
  export type PurchaseItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    batch?: boolean | ProductBatchDefaultArgs<ExtArgs>
    unitOfMeasure?: boolean | UnitOfMeasureDefaultArgs<ExtArgs>
  }

  export type $PurchaseItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseItem"
    objects: {
      purchase: Prisma.$PurchasePayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      batch: Prisma.$ProductBatchPayload<ExtArgs>
      unitOfMeasure: Prisma.$UnitOfMeasurePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      purchaseId: string
      productId: string
      batchId: string
      unitOfMeasureId: string
      quantity: number
      unitPrice: number
      totalPrice: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseItem"]>
    composites: {}
  }

  type PurchaseItemGetPayload<S extends boolean | null | undefined | PurchaseItemDefaultArgs> = $Result.GetResult<Prisma.$PurchaseItemPayload, S>

  type PurchaseItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseItemCountAggregateInputType | true
    }

  export interface PurchaseItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseItem'], meta: { name: 'PurchaseItem' } }
    /**
     * Find zero or one PurchaseItem that matches the filter.
     * @param {PurchaseItemFindUniqueArgs} args - Arguments to find a PurchaseItem
     * @example
     * // Get one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseItemFindUniqueArgs>(args: SelectSubset<T, PurchaseItemFindUniqueArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseItemFindUniqueOrThrowArgs} args - Arguments to find a PurchaseItem
     * @example
     * // Get one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemFindFirstArgs} args - Arguments to find a PurchaseItem
     * @example
     * // Get one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseItemFindFirstArgs>(args?: SelectSubset<T, PurchaseItemFindFirstArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemFindFirstOrThrowArgs} args - Arguments to find a PurchaseItem
     * @example
     * // Get one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseItems
     * const purchaseItems = await prisma.purchaseItem.findMany()
     * 
     * // Get first 10 PurchaseItems
     * const purchaseItems = await prisma.purchaseItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseItemWithIdOnly = await prisma.purchaseItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseItemFindManyArgs>(args?: SelectSubset<T, PurchaseItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseItem.
     * @param {PurchaseItemCreateArgs} args - Arguments to create a PurchaseItem.
     * @example
     * // Create one PurchaseItem
     * const PurchaseItem = await prisma.purchaseItem.create({
     *   data: {
     *     // ... data to create a PurchaseItem
     *   }
     * })
     * 
     */
    create<T extends PurchaseItemCreateArgs>(args: SelectSubset<T, PurchaseItemCreateArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseItems.
     * @param {PurchaseItemCreateManyArgs} args - Arguments to create many PurchaseItems.
     * @example
     * // Create many PurchaseItems
     * const purchaseItem = await prisma.purchaseItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseItemCreateManyArgs>(args?: SelectSubset<T, PurchaseItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PurchaseItem.
     * @param {PurchaseItemDeleteArgs} args - Arguments to delete one PurchaseItem.
     * @example
     * // Delete one PurchaseItem
     * const PurchaseItem = await prisma.purchaseItem.delete({
     *   where: {
     *     // ... filter to delete one PurchaseItem
     *   }
     * })
     * 
     */
    delete<T extends PurchaseItemDeleteArgs>(args: SelectSubset<T, PurchaseItemDeleteArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseItem.
     * @param {PurchaseItemUpdateArgs} args - Arguments to update one PurchaseItem.
     * @example
     * // Update one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseItemUpdateArgs>(args: SelectSubset<T, PurchaseItemUpdateArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseItems.
     * @param {PurchaseItemDeleteManyArgs} args - Arguments to filter PurchaseItems to delete.
     * @example
     * // Delete a few PurchaseItems
     * const { count } = await prisma.purchaseItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseItemDeleteManyArgs>(args?: SelectSubset<T, PurchaseItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseItems
     * const purchaseItem = await prisma.purchaseItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseItemUpdateManyArgs>(args: SelectSubset<T, PurchaseItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseItem.
     * @param {PurchaseItemUpsertArgs} args - Arguments to update or create a PurchaseItem.
     * @example
     * // Update or create a PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.upsert({
     *   create: {
     *     // ... data to create a PurchaseItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseItem we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseItemUpsertArgs>(args: SelectSubset<T, PurchaseItemUpsertArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemCountArgs} args - Arguments to filter PurchaseItems to count.
     * @example
     * // Count the number of PurchaseItems
     * const count = await prisma.purchaseItem.count({
     *   where: {
     *     // ... the filter for the PurchaseItems we want to count
     *   }
     * })
    **/
    count<T extends PurchaseItemCountArgs>(
      args?: Subset<T, PurchaseItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseItemAggregateArgs>(args: Subset<T, PurchaseItemAggregateArgs>): Prisma.PrismaPromise<GetPurchaseItemAggregateType<T>>

    /**
     * Group by PurchaseItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseItemGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseItem model
   */
  readonly fields: PurchaseItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchase<T extends PurchaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseDefaultArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    batch<T extends ProductBatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductBatchDefaultArgs<ExtArgs>>): Prisma__ProductBatchClient<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unitOfMeasure<T extends UnitOfMeasureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasureDefaultArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseItem model
   */
  interface PurchaseItemFieldRefs {
    readonly id: FieldRef<"PurchaseItem", 'String'>
    readonly purchaseId: FieldRef<"PurchaseItem", 'String'>
    readonly productId: FieldRef<"PurchaseItem", 'String'>
    readonly batchId: FieldRef<"PurchaseItem", 'String'>
    readonly unitOfMeasureId: FieldRef<"PurchaseItem", 'String'>
    readonly quantity: FieldRef<"PurchaseItem", 'Int'>
    readonly unitPrice: FieldRef<"PurchaseItem", 'Float'>
    readonly totalPrice: FieldRef<"PurchaseItem", 'Float'>
    readonly createdAt: FieldRef<"PurchaseItem", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseItem findUnique
   */
  export type PurchaseItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItem to fetch.
     */
    where: PurchaseItemWhereUniqueInput
  }

  /**
   * PurchaseItem findUniqueOrThrow
   */
  export type PurchaseItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItem to fetch.
     */
    where: PurchaseItemWhereUniqueInput
  }

  /**
   * PurchaseItem findFirst
   */
  export type PurchaseItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItem to fetch.
     */
    where?: PurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseItems.
     */
    cursor?: PurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseItems.
     */
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * PurchaseItem findFirstOrThrow
   */
  export type PurchaseItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItem to fetch.
     */
    where?: PurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseItems.
     */
    cursor?: PurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseItems.
     */
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * PurchaseItem findMany
   */
  export type PurchaseItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItems to fetch.
     */
    where?: PurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseItems.
     */
    cursor?: PurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * PurchaseItem create
   */
  export type PurchaseItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseItem.
     */
    data: XOR<PurchaseItemCreateInput, PurchaseItemUncheckedCreateInput>
  }

  /**
   * PurchaseItem createMany
   */
  export type PurchaseItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseItems.
     */
    data: PurchaseItemCreateManyInput | PurchaseItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseItem update
   */
  export type PurchaseItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseItem.
     */
    data: XOR<PurchaseItemUpdateInput, PurchaseItemUncheckedUpdateInput>
    /**
     * Choose, which PurchaseItem to update.
     */
    where: PurchaseItemWhereUniqueInput
  }

  /**
   * PurchaseItem updateMany
   */
  export type PurchaseItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseItems.
     */
    data: XOR<PurchaseItemUpdateManyMutationInput, PurchaseItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseItems to update
     */
    where?: PurchaseItemWhereInput
    /**
     * Limit how many PurchaseItems to update.
     */
    limit?: number
  }

  /**
   * PurchaseItem upsert
   */
  export type PurchaseItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseItem to update in case it exists.
     */
    where: PurchaseItemWhereUniqueInput
    /**
     * In case the PurchaseItem found by the `where` argument doesn't exist, create a new PurchaseItem with this data.
     */
    create: XOR<PurchaseItemCreateInput, PurchaseItemUncheckedCreateInput>
    /**
     * In case the PurchaseItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseItemUpdateInput, PurchaseItemUncheckedUpdateInput>
  }

  /**
   * PurchaseItem delete
   */
  export type PurchaseItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter which PurchaseItem to delete.
     */
    where: PurchaseItemWhereUniqueInput
  }

  /**
   * PurchaseItem deleteMany
   */
  export type PurchaseItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseItems to delete
     */
    where?: PurchaseItemWhereInput
    /**
     * Limit how many PurchaseItems to delete.
     */
    limit?: number
  }

  /**
   * PurchaseItem without action
   */
  export type PurchaseItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
  }


  /**
   * Model Transfer
   */

  export type AggregateTransfer = {
    _count: TransferCountAggregateOutputType | null
    _min: TransferMinAggregateOutputType | null
    _max: TransferMaxAggregateOutputType | null
  }

  export type TransferMinAggregateOutputType = {
    id: string | null
    shortCode: string | null
    sourceType: $Enums.TransferEntityType | null
    sourceStoreId: string | null
    sourceShopId: string | null
    destinationType: $Enums.TransferEntityType | null
    destStoreId: string | null
    destShopId: string | null
    reference: string | null
    notes: string | null
    status: $Enums.TransferStatus | null
    movementDate: Date | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferMaxAggregateOutputType = {
    id: string | null
    shortCode: string | null
    sourceType: $Enums.TransferEntityType | null
    sourceStoreId: string | null
    sourceShopId: string | null
    destinationType: $Enums.TransferEntityType | null
    destStoreId: string | null
    destShopId: string | null
    reference: string | null
    notes: string | null
    status: $Enums.TransferStatus | null
    movementDate: Date | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferCountAggregateOutputType = {
    id: number
    shortCode: number
    sourceType: number
    sourceStoreId: number
    sourceShopId: number
    destinationType: number
    destStoreId: number
    destShopId: number
    reference: number
    notes: number
    status: number
    movementDate: number
    createdById: number
    updatedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransferMinAggregateInputType = {
    id?: true
    shortCode?: true
    sourceType?: true
    sourceStoreId?: true
    sourceShopId?: true
    destinationType?: true
    destStoreId?: true
    destShopId?: true
    reference?: true
    notes?: true
    status?: true
    movementDate?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferMaxAggregateInputType = {
    id?: true
    shortCode?: true
    sourceType?: true
    sourceStoreId?: true
    sourceShopId?: true
    destinationType?: true
    destStoreId?: true
    destShopId?: true
    reference?: true
    notes?: true
    status?: true
    movementDate?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferCountAggregateInputType = {
    id?: true
    shortCode?: true
    sourceType?: true
    sourceStoreId?: true
    sourceShopId?: true
    destinationType?: true
    destStoreId?: true
    destShopId?: true
    reference?: true
    notes?: true
    status?: true
    movementDate?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transfer to aggregate.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transfers
    **/
    _count?: true | TransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransferMaxAggregateInputType
  }

  export type GetTransferAggregateType<T extends TransferAggregateArgs> = {
        [P in keyof T & keyof AggregateTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransfer[P]>
      : GetScalarType<T[P], AggregateTransfer[P]>
  }




  export type TransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithAggregationInput | TransferOrderByWithAggregationInput[]
    by: TransferScalarFieldEnum[] | TransferScalarFieldEnum
    having?: TransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferCountAggregateInputType | true
    _min?: TransferMinAggregateInputType
    _max?: TransferMaxAggregateInputType
  }

  export type TransferGroupByOutputType = {
    id: string
    shortCode: string
    sourceType: $Enums.TransferEntityType
    sourceStoreId: string | null
    sourceShopId: string | null
    destinationType: $Enums.TransferEntityType
    destStoreId: string | null
    destShopId: string | null
    reference: string | null
    notes: string | null
    status: $Enums.TransferStatus
    movementDate: Date
    createdById: string | null
    updatedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: TransferCountAggregateOutputType | null
    _min: TransferMinAggregateOutputType | null
    _max: TransferMaxAggregateOutputType | null
  }

  type GetTransferGroupByPayload<T extends TransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferGroupByOutputType[P]>
            : GetScalarType<T[P], TransferGroupByOutputType[P]>
        }
      >
    >


  export type TransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shortCode?: boolean
    sourceType?: boolean
    sourceStoreId?: boolean
    sourceShopId?: boolean
    destinationType?: boolean
    destStoreId?: boolean
    destShopId?: boolean
    reference?: boolean
    notes?: boolean
    status?: boolean
    movementDate?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sourceStore?: boolean | Transfer$sourceStoreArgs<ExtArgs>
    sourceShop?: boolean | Transfer$sourceShopArgs<ExtArgs>
    destStore?: boolean | Transfer$destStoreArgs<ExtArgs>
    destShop?: boolean | Transfer$destShopArgs<ExtArgs>
    createdBy?: boolean | Transfer$createdByArgs<ExtArgs>
    updatedBy?: boolean | Transfer$updatedByArgs<ExtArgs>
    items?: boolean | Transfer$itemsArgs<ExtArgs>
    StockCorrection?: boolean | Transfer$StockCorrectionArgs<ExtArgs>
    _count?: boolean | TransferCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>



  export type TransferSelectScalar = {
    id?: boolean
    shortCode?: boolean
    sourceType?: boolean
    sourceStoreId?: boolean
    sourceShopId?: boolean
    destinationType?: boolean
    destStoreId?: boolean
    destShopId?: boolean
    reference?: boolean
    notes?: boolean
    status?: boolean
    movementDate?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shortCode" | "sourceType" | "sourceStoreId" | "sourceShopId" | "destinationType" | "destStoreId" | "destShopId" | "reference" | "notes" | "status" | "movementDate" | "createdById" | "updatedById" | "createdAt" | "updatedAt", ExtArgs["result"]["transfer"]>
  export type TransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceStore?: boolean | Transfer$sourceStoreArgs<ExtArgs>
    sourceShop?: boolean | Transfer$sourceShopArgs<ExtArgs>
    destStore?: boolean | Transfer$destStoreArgs<ExtArgs>
    destShop?: boolean | Transfer$destShopArgs<ExtArgs>
    createdBy?: boolean | Transfer$createdByArgs<ExtArgs>
    updatedBy?: boolean | Transfer$updatedByArgs<ExtArgs>
    items?: boolean | Transfer$itemsArgs<ExtArgs>
    StockCorrection?: boolean | Transfer$StockCorrectionArgs<ExtArgs>
    _count?: boolean | TransferCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transfer"
    objects: {
      sourceStore: Prisma.$StorePayload<ExtArgs> | null
      sourceShop: Prisma.$ShopPayload<ExtArgs> | null
      destStore: Prisma.$StorePayload<ExtArgs> | null
      destShop: Prisma.$ShopPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
      items: Prisma.$TransferItemPayload<ExtArgs>[]
      StockCorrection: Prisma.$StockCorrectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shortCode: string
      sourceType: $Enums.TransferEntityType
      sourceStoreId: string | null
      sourceShopId: string | null
      destinationType: $Enums.TransferEntityType
      destStoreId: string | null
      destShopId: string | null
      reference: string | null
      notes: string | null
      status: $Enums.TransferStatus
      movementDate: Date
      createdById: string | null
      updatedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transfer"]>
    composites: {}
  }

  type TransferGetPayload<S extends boolean | null | undefined | TransferDefaultArgs> = $Result.GetResult<Prisma.$TransferPayload, S>

  type TransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransferCountAggregateInputType | true
    }

  export interface TransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transfer'], meta: { name: 'Transfer' } }
    /**
     * Find zero or one Transfer that matches the filter.
     * @param {TransferFindUniqueArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransferFindUniqueArgs>(args: SelectSubset<T, TransferFindUniqueArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transfer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransferFindUniqueOrThrowArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransferFindUniqueOrThrowArgs>(args: SelectSubset<T, TransferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindFirstArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransferFindFirstArgs>(args?: SelectSubset<T, TransferFindFirstArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindFirstOrThrowArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransferFindFirstOrThrowArgs>(args?: SelectSubset<T, TransferFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transfers
     * const transfers = await prisma.transfer.findMany()
     * 
     * // Get first 10 Transfers
     * const transfers = await prisma.transfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transferWithIdOnly = await prisma.transfer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransferFindManyArgs>(args?: SelectSubset<T, TransferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transfer.
     * @param {TransferCreateArgs} args - Arguments to create a Transfer.
     * @example
     * // Create one Transfer
     * const Transfer = await prisma.transfer.create({
     *   data: {
     *     // ... data to create a Transfer
     *   }
     * })
     * 
     */
    create<T extends TransferCreateArgs>(args: SelectSubset<T, TransferCreateArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transfers.
     * @param {TransferCreateManyArgs} args - Arguments to create many Transfers.
     * @example
     * // Create many Transfers
     * const transfer = await prisma.transfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransferCreateManyArgs>(args?: SelectSubset<T, TransferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transfer.
     * @param {TransferDeleteArgs} args - Arguments to delete one Transfer.
     * @example
     * // Delete one Transfer
     * const Transfer = await prisma.transfer.delete({
     *   where: {
     *     // ... filter to delete one Transfer
     *   }
     * })
     * 
     */
    delete<T extends TransferDeleteArgs>(args: SelectSubset<T, TransferDeleteArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transfer.
     * @param {TransferUpdateArgs} args - Arguments to update one Transfer.
     * @example
     * // Update one Transfer
     * const transfer = await prisma.transfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransferUpdateArgs>(args: SelectSubset<T, TransferUpdateArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transfers.
     * @param {TransferDeleteManyArgs} args - Arguments to filter Transfers to delete.
     * @example
     * // Delete a few Transfers
     * const { count } = await prisma.transfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransferDeleteManyArgs>(args?: SelectSubset<T, TransferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transfers
     * const transfer = await prisma.transfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransferUpdateManyArgs>(args: SelectSubset<T, TransferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transfer.
     * @param {TransferUpsertArgs} args - Arguments to update or create a Transfer.
     * @example
     * // Update or create a Transfer
     * const transfer = await prisma.transfer.upsert({
     *   create: {
     *     // ... data to create a Transfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transfer we want to update
     *   }
     * })
     */
    upsert<T extends TransferUpsertArgs>(args: SelectSubset<T, TransferUpsertArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferCountArgs} args - Arguments to filter Transfers to count.
     * @example
     * // Count the number of Transfers
     * const count = await prisma.transfer.count({
     *   where: {
     *     // ... the filter for the Transfers we want to count
     *   }
     * })
    **/
    count<T extends TransferCountArgs>(
      args?: Subset<T, TransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferAggregateArgs>(args: Subset<T, TransferAggregateArgs>): Prisma.PrismaPromise<GetTransferAggregateType<T>>

    /**
     * Group by Transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransferGroupByArgs['orderBy'] }
        : { orderBy?: TransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transfer model
   */
  readonly fields: TransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sourceStore<T extends Transfer$sourceStoreArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$sourceStoreArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sourceShop<T extends Transfer$sourceShopArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$sourceShopArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    destStore<T extends Transfer$destStoreArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$destStoreArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    destShop<T extends Transfer$destShopArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$destShopArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends Transfer$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends Transfer$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Transfer$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StockCorrection<T extends Transfer$StockCorrectionArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$StockCorrectionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockCorrectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transfer model
   */
  interface TransferFieldRefs {
    readonly id: FieldRef<"Transfer", 'String'>
    readonly shortCode: FieldRef<"Transfer", 'String'>
    readonly sourceType: FieldRef<"Transfer", 'TransferEntityType'>
    readonly sourceStoreId: FieldRef<"Transfer", 'String'>
    readonly sourceShopId: FieldRef<"Transfer", 'String'>
    readonly destinationType: FieldRef<"Transfer", 'TransferEntityType'>
    readonly destStoreId: FieldRef<"Transfer", 'String'>
    readonly destShopId: FieldRef<"Transfer", 'String'>
    readonly reference: FieldRef<"Transfer", 'String'>
    readonly notes: FieldRef<"Transfer", 'String'>
    readonly status: FieldRef<"Transfer", 'TransferStatus'>
    readonly movementDate: FieldRef<"Transfer", 'DateTime'>
    readonly createdById: FieldRef<"Transfer", 'String'>
    readonly updatedById: FieldRef<"Transfer", 'String'>
    readonly createdAt: FieldRef<"Transfer", 'DateTime'>
    readonly updatedAt: FieldRef<"Transfer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transfer findUnique
   */
  export type TransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer findUniqueOrThrow
   */
  export type TransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer findFirst
   */
  export type TransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transfers.
     */
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer findFirstOrThrow
   */
  export type TransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transfers.
     */
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer findMany
   */
  export type TransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfers to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer create
   */
  export type TransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The data needed to create a Transfer.
     */
    data: XOR<TransferCreateInput, TransferUncheckedCreateInput>
  }

  /**
   * Transfer createMany
   */
  export type TransferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transfers.
     */
    data: TransferCreateManyInput | TransferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transfer update
   */
  export type TransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The data needed to update a Transfer.
     */
    data: XOR<TransferUpdateInput, TransferUncheckedUpdateInput>
    /**
     * Choose, which Transfer to update.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer updateMany
   */
  export type TransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transfers.
     */
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyInput>
    /**
     * Filter which Transfers to update
     */
    where?: TransferWhereInput
    /**
     * Limit how many Transfers to update.
     */
    limit?: number
  }

  /**
   * Transfer upsert
   */
  export type TransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The filter to search for the Transfer to update in case it exists.
     */
    where: TransferWhereUniqueInput
    /**
     * In case the Transfer found by the `where` argument doesn't exist, create a new Transfer with this data.
     */
    create: XOR<TransferCreateInput, TransferUncheckedCreateInput>
    /**
     * In case the Transfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransferUpdateInput, TransferUncheckedUpdateInput>
  }

  /**
   * Transfer delete
   */
  export type TransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter which Transfer to delete.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer deleteMany
   */
  export type TransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transfers to delete
     */
    where?: TransferWhereInput
    /**
     * Limit how many Transfers to delete.
     */
    limit?: number
  }

  /**
   * Transfer.sourceStore
   */
  export type Transfer$sourceStoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    where?: StoreWhereInput
  }

  /**
   * Transfer.sourceShop
   */
  export type Transfer$sourceShopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    where?: ShopWhereInput
  }

  /**
   * Transfer.destStore
   */
  export type Transfer$destStoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    where?: StoreWhereInput
  }

  /**
   * Transfer.destShop
   */
  export type Transfer$destShopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    where?: ShopWhereInput
  }

  /**
   * Transfer.createdBy
   */
  export type Transfer$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Transfer.updatedBy
   */
  export type Transfer$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Transfer.items
   */
  export type Transfer$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    where?: TransferItemWhereInput
    orderBy?: TransferItemOrderByWithRelationInput | TransferItemOrderByWithRelationInput[]
    cursor?: TransferItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferItemScalarFieldEnum | TransferItemScalarFieldEnum[]
  }

  /**
   * Transfer.StockCorrection
   */
  export type Transfer$StockCorrectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrection
     */
    select?: StockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrection
     */
    omit?: StockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionInclude<ExtArgs> | null
    where?: StockCorrectionWhereInput
    orderBy?: StockCorrectionOrderByWithRelationInput | StockCorrectionOrderByWithRelationInput[]
    cursor?: StockCorrectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockCorrectionScalarFieldEnum | StockCorrectionScalarFieldEnum[]
  }

  /**
   * Transfer without action
   */
  export type TransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
  }


  /**
   * Model TransferItem
   */

  export type AggregateTransferItem = {
    _count: TransferItemCountAggregateOutputType | null
    _avg: TransferItemAvgAggregateOutputType | null
    _sum: TransferItemSumAggregateOutputType | null
    _min: TransferItemMinAggregateOutputType | null
    _max: TransferItemMaxAggregateOutputType | null
  }

  export type TransferItemAvgAggregateOutputType = {
    quantity: number | null
  }

  export type TransferItemSumAggregateOutputType = {
    quantity: number | null
  }

  export type TransferItemMinAggregateOutputType = {
    id: string | null
    transferId: string | null
    productId: string | null
    batchId: string | null
    unitOfMeasureId: string | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferItemMaxAggregateOutputType = {
    id: string | null
    transferId: string | null
    productId: string | null
    batchId: string | null
    unitOfMeasureId: string | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferItemCountAggregateOutputType = {
    id: number
    transferId: number
    productId: number
    batchId: number
    unitOfMeasureId: number
    quantity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransferItemAvgAggregateInputType = {
    quantity?: true
  }

  export type TransferItemSumAggregateInputType = {
    quantity?: true
  }

  export type TransferItemMinAggregateInputType = {
    id?: true
    transferId?: true
    productId?: true
    batchId?: true
    unitOfMeasureId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferItemMaxAggregateInputType = {
    id?: true
    transferId?: true
    productId?: true
    batchId?: true
    unitOfMeasureId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferItemCountAggregateInputType = {
    id?: true
    transferId?: true
    productId?: true
    batchId?: true
    unitOfMeasureId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransferItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransferItem to aggregate.
     */
    where?: TransferItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferItems to fetch.
     */
    orderBy?: TransferItemOrderByWithRelationInput | TransferItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransferItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransferItems
    **/
    _count?: true | TransferItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransferItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransferItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransferItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransferItemMaxAggregateInputType
  }

  export type GetTransferItemAggregateType<T extends TransferItemAggregateArgs> = {
        [P in keyof T & keyof AggregateTransferItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransferItem[P]>
      : GetScalarType<T[P], AggregateTransferItem[P]>
  }




  export type TransferItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferItemWhereInput
    orderBy?: TransferItemOrderByWithAggregationInput | TransferItemOrderByWithAggregationInput[]
    by: TransferItemScalarFieldEnum[] | TransferItemScalarFieldEnum
    having?: TransferItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferItemCountAggregateInputType | true
    _avg?: TransferItemAvgAggregateInputType
    _sum?: TransferItemSumAggregateInputType
    _min?: TransferItemMinAggregateInputType
    _max?: TransferItemMaxAggregateInputType
  }

  export type TransferItemGroupByOutputType = {
    id: string
    transferId: string
    productId: string
    batchId: string
    unitOfMeasureId: string
    quantity: number
    createdAt: Date
    updatedAt: Date
    _count: TransferItemCountAggregateOutputType | null
    _avg: TransferItemAvgAggregateOutputType | null
    _sum: TransferItemSumAggregateOutputType | null
    _min: TransferItemMinAggregateOutputType | null
    _max: TransferItemMaxAggregateOutputType | null
  }

  type GetTransferItemGroupByPayload<T extends TransferItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransferItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferItemGroupByOutputType[P]>
            : GetScalarType<T[P], TransferItemGroupByOutputType[P]>
        }
      >
    >


  export type TransferItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferId?: boolean
    productId?: boolean
    batchId?: boolean
    unitOfMeasureId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    batch?: boolean | ProductBatchDefaultArgs<ExtArgs>
    unitOfMeasure?: boolean | UnitOfMeasureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferItem"]>



  export type TransferItemSelectScalar = {
    id?: boolean
    transferId?: boolean
    productId?: boolean
    batchId?: boolean
    unitOfMeasureId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransferItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transferId" | "productId" | "batchId" | "unitOfMeasureId" | "quantity" | "createdAt" | "updatedAt", ExtArgs["result"]["transferItem"]>
  export type TransferItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    batch?: boolean | ProductBatchDefaultArgs<ExtArgs>
    unitOfMeasure?: boolean | UnitOfMeasureDefaultArgs<ExtArgs>
  }

  export type $TransferItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransferItem"
    objects: {
      transfer: Prisma.$TransferPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      batch: Prisma.$ProductBatchPayload<ExtArgs>
      unitOfMeasure: Prisma.$UnitOfMeasurePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transferId: string
      productId: string
      batchId: string
      unitOfMeasureId: string
      quantity: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transferItem"]>
    composites: {}
  }

  type TransferItemGetPayload<S extends boolean | null | undefined | TransferItemDefaultArgs> = $Result.GetResult<Prisma.$TransferItemPayload, S>

  type TransferItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransferItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransferItemCountAggregateInputType | true
    }

  export interface TransferItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransferItem'], meta: { name: 'TransferItem' } }
    /**
     * Find zero or one TransferItem that matches the filter.
     * @param {TransferItemFindUniqueArgs} args - Arguments to find a TransferItem
     * @example
     * // Get one TransferItem
     * const transferItem = await prisma.transferItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransferItemFindUniqueArgs>(args: SelectSubset<T, TransferItemFindUniqueArgs<ExtArgs>>): Prisma__TransferItemClient<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransferItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransferItemFindUniqueOrThrowArgs} args - Arguments to find a TransferItem
     * @example
     * // Get one TransferItem
     * const transferItem = await prisma.transferItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransferItemFindUniqueOrThrowArgs>(args: SelectSubset<T, TransferItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransferItemClient<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransferItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferItemFindFirstArgs} args - Arguments to find a TransferItem
     * @example
     * // Get one TransferItem
     * const transferItem = await prisma.transferItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransferItemFindFirstArgs>(args?: SelectSubset<T, TransferItemFindFirstArgs<ExtArgs>>): Prisma__TransferItemClient<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransferItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferItemFindFirstOrThrowArgs} args - Arguments to find a TransferItem
     * @example
     * // Get one TransferItem
     * const transferItem = await prisma.transferItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransferItemFindFirstOrThrowArgs>(args?: SelectSubset<T, TransferItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransferItemClient<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransferItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransferItems
     * const transferItems = await prisma.transferItem.findMany()
     * 
     * // Get first 10 TransferItems
     * const transferItems = await prisma.transferItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transferItemWithIdOnly = await prisma.transferItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransferItemFindManyArgs>(args?: SelectSubset<T, TransferItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransferItem.
     * @param {TransferItemCreateArgs} args - Arguments to create a TransferItem.
     * @example
     * // Create one TransferItem
     * const TransferItem = await prisma.transferItem.create({
     *   data: {
     *     // ... data to create a TransferItem
     *   }
     * })
     * 
     */
    create<T extends TransferItemCreateArgs>(args: SelectSubset<T, TransferItemCreateArgs<ExtArgs>>): Prisma__TransferItemClient<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransferItems.
     * @param {TransferItemCreateManyArgs} args - Arguments to create many TransferItems.
     * @example
     * // Create many TransferItems
     * const transferItem = await prisma.transferItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransferItemCreateManyArgs>(args?: SelectSubset<T, TransferItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TransferItem.
     * @param {TransferItemDeleteArgs} args - Arguments to delete one TransferItem.
     * @example
     * // Delete one TransferItem
     * const TransferItem = await prisma.transferItem.delete({
     *   where: {
     *     // ... filter to delete one TransferItem
     *   }
     * })
     * 
     */
    delete<T extends TransferItemDeleteArgs>(args: SelectSubset<T, TransferItemDeleteArgs<ExtArgs>>): Prisma__TransferItemClient<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransferItem.
     * @param {TransferItemUpdateArgs} args - Arguments to update one TransferItem.
     * @example
     * // Update one TransferItem
     * const transferItem = await prisma.transferItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransferItemUpdateArgs>(args: SelectSubset<T, TransferItemUpdateArgs<ExtArgs>>): Prisma__TransferItemClient<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransferItems.
     * @param {TransferItemDeleteManyArgs} args - Arguments to filter TransferItems to delete.
     * @example
     * // Delete a few TransferItems
     * const { count } = await prisma.transferItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransferItemDeleteManyArgs>(args?: SelectSubset<T, TransferItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransferItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransferItems
     * const transferItem = await prisma.transferItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransferItemUpdateManyArgs>(args: SelectSubset<T, TransferItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TransferItem.
     * @param {TransferItemUpsertArgs} args - Arguments to update or create a TransferItem.
     * @example
     * // Update or create a TransferItem
     * const transferItem = await prisma.transferItem.upsert({
     *   create: {
     *     // ... data to create a TransferItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransferItem we want to update
     *   }
     * })
     */
    upsert<T extends TransferItemUpsertArgs>(args: SelectSubset<T, TransferItemUpsertArgs<ExtArgs>>): Prisma__TransferItemClient<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransferItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferItemCountArgs} args - Arguments to filter TransferItems to count.
     * @example
     * // Count the number of TransferItems
     * const count = await prisma.transferItem.count({
     *   where: {
     *     // ... the filter for the TransferItems we want to count
     *   }
     * })
    **/
    count<T extends TransferItemCountArgs>(
      args?: Subset<T, TransferItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransferItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferItemAggregateArgs>(args: Subset<T, TransferItemAggregateArgs>): Prisma.PrismaPromise<GetTransferItemAggregateType<T>>

    /**
     * Group by TransferItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransferItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransferItemGroupByArgs['orderBy'] }
        : { orderBy?: TransferItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransferItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransferItem model
   */
  readonly fields: TransferItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransferItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransferItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transfer<T extends TransferDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransferDefaultArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    batch<T extends ProductBatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductBatchDefaultArgs<ExtArgs>>): Prisma__ProductBatchClient<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unitOfMeasure<T extends UnitOfMeasureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasureDefaultArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransferItem model
   */
  interface TransferItemFieldRefs {
    readonly id: FieldRef<"TransferItem", 'String'>
    readonly transferId: FieldRef<"TransferItem", 'String'>
    readonly productId: FieldRef<"TransferItem", 'String'>
    readonly batchId: FieldRef<"TransferItem", 'String'>
    readonly unitOfMeasureId: FieldRef<"TransferItem", 'String'>
    readonly quantity: FieldRef<"TransferItem", 'Int'>
    readonly createdAt: FieldRef<"TransferItem", 'DateTime'>
    readonly updatedAt: FieldRef<"TransferItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransferItem findUnique
   */
  export type TransferItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * Filter, which TransferItem to fetch.
     */
    where: TransferItemWhereUniqueInput
  }

  /**
   * TransferItem findUniqueOrThrow
   */
  export type TransferItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * Filter, which TransferItem to fetch.
     */
    where: TransferItemWhereUniqueInput
  }

  /**
   * TransferItem findFirst
   */
  export type TransferItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * Filter, which TransferItem to fetch.
     */
    where?: TransferItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferItems to fetch.
     */
    orderBy?: TransferItemOrderByWithRelationInput | TransferItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransferItems.
     */
    cursor?: TransferItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransferItems.
     */
    distinct?: TransferItemScalarFieldEnum | TransferItemScalarFieldEnum[]
  }

  /**
   * TransferItem findFirstOrThrow
   */
  export type TransferItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * Filter, which TransferItem to fetch.
     */
    where?: TransferItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferItems to fetch.
     */
    orderBy?: TransferItemOrderByWithRelationInput | TransferItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransferItems.
     */
    cursor?: TransferItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransferItems.
     */
    distinct?: TransferItemScalarFieldEnum | TransferItemScalarFieldEnum[]
  }

  /**
   * TransferItem findMany
   */
  export type TransferItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * Filter, which TransferItems to fetch.
     */
    where?: TransferItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferItems to fetch.
     */
    orderBy?: TransferItemOrderByWithRelationInput | TransferItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransferItems.
     */
    cursor?: TransferItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferItems.
     */
    skip?: number
    distinct?: TransferItemScalarFieldEnum | TransferItemScalarFieldEnum[]
  }

  /**
   * TransferItem create
   */
  export type TransferItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * The data needed to create a TransferItem.
     */
    data: XOR<TransferItemCreateInput, TransferItemUncheckedCreateInput>
  }

  /**
   * TransferItem createMany
   */
  export type TransferItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransferItems.
     */
    data: TransferItemCreateManyInput | TransferItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransferItem update
   */
  export type TransferItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * The data needed to update a TransferItem.
     */
    data: XOR<TransferItemUpdateInput, TransferItemUncheckedUpdateInput>
    /**
     * Choose, which TransferItem to update.
     */
    where: TransferItemWhereUniqueInput
  }

  /**
   * TransferItem updateMany
   */
  export type TransferItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransferItems.
     */
    data: XOR<TransferItemUpdateManyMutationInput, TransferItemUncheckedUpdateManyInput>
    /**
     * Filter which TransferItems to update
     */
    where?: TransferItemWhereInput
    /**
     * Limit how many TransferItems to update.
     */
    limit?: number
  }

  /**
   * TransferItem upsert
   */
  export type TransferItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * The filter to search for the TransferItem to update in case it exists.
     */
    where: TransferItemWhereUniqueInput
    /**
     * In case the TransferItem found by the `where` argument doesn't exist, create a new TransferItem with this data.
     */
    create: XOR<TransferItemCreateInput, TransferItemUncheckedCreateInput>
    /**
     * In case the TransferItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransferItemUpdateInput, TransferItemUncheckedUpdateInput>
  }

  /**
   * TransferItem delete
   */
  export type TransferItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * Filter which TransferItem to delete.
     */
    where: TransferItemWhereUniqueInput
  }

  /**
   * TransferItem deleteMany
   */
  export type TransferItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransferItems to delete
     */
    where?: TransferItemWhereInput
    /**
     * Limit how many TransferItems to delete.
     */
    limit?: number
  }

  /**
   * TransferItem without action
   */
  export type TransferItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
  }


  /**
   * Model StockCorrection
   */

  export type AggregateStockCorrection = {
    _count: StockCorrectionCountAggregateOutputType | null
    _min: StockCorrectionMinAggregateOutputType | null
    _max: StockCorrectionMaxAggregateOutputType | null
  }

  export type StockCorrectionMinAggregateOutputType = {
    id: string | null
    shortCode: string | null
    storeId: string | null
    shopId: string | null
    reason: $Enums.StockCorrectionReason | null
    status: $Enums.StockCorrectionStatus | null
    purchaseId: string | null
    transferId: string | null
    reference: string | null
    notes: string | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockCorrectionMaxAggregateOutputType = {
    id: string | null
    shortCode: string | null
    storeId: string | null
    shopId: string | null
    reason: $Enums.StockCorrectionReason | null
    status: $Enums.StockCorrectionStatus | null
    purchaseId: string | null
    transferId: string | null
    reference: string | null
    notes: string | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockCorrectionCountAggregateOutputType = {
    id: number
    shortCode: number
    storeId: number
    shopId: number
    reason: number
    status: number
    purchaseId: number
    transferId: number
    reference: number
    notes: number
    createdById: number
    updatedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StockCorrectionMinAggregateInputType = {
    id?: true
    shortCode?: true
    storeId?: true
    shopId?: true
    reason?: true
    status?: true
    purchaseId?: true
    transferId?: true
    reference?: true
    notes?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockCorrectionMaxAggregateInputType = {
    id?: true
    shortCode?: true
    storeId?: true
    shopId?: true
    reason?: true
    status?: true
    purchaseId?: true
    transferId?: true
    reference?: true
    notes?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockCorrectionCountAggregateInputType = {
    id?: true
    shortCode?: true
    storeId?: true
    shopId?: true
    reason?: true
    status?: true
    purchaseId?: true
    transferId?: true
    reference?: true
    notes?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StockCorrectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockCorrection to aggregate.
     */
    where?: StockCorrectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockCorrections to fetch.
     */
    orderBy?: StockCorrectionOrderByWithRelationInput | StockCorrectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockCorrectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockCorrections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockCorrections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockCorrections
    **/
    _count?: true | StockCorrectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockCorrectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockCorrectionMaxAggregateInputType
  }

  export type GetStockCorrectionAggregateType<T extends StockCorrectionAggregateArgs> = {
        [P in keyof T & keyof AggregateStockCorrection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockCorrection[P]>
      : GetScalarType<T[P], AggregateStockCorrection[P]>
  }




  export type StockCorrectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockCorrectionWhereInput
    orderBy?: StockCorrectionOrderByWithAggregationInput | StockCorrectionOrderByWithAggregationInput[]
    by: StockCorrectionScalarFieldEnum[] | StockCorrectionScalarFieldEnum
    having?: StockCorrectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockCorrectionCountAggregateInputType | true
    _min?: StockCorrectionMinAggregateInputType
    _max?: StockCorrectionMaxAggregateInputType
  }

  export type StockCorrectionGroupByOutputType = {
    id: string
    shortCode: string
    storeId: string | null
    shopId: string | null
    reason: $Enums.StockCorrectionReason
    status: $Enums.StockCorrectionStatus
    purchaseId: string | null
    transferId: string | null
    reference: string | null
    notes: string | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: StockCorrectionCountAggregateOutputType | null
    _min: StockCorrectionMinAggregateOutputType | null
    _max: StockCorrectionMaxAggregateOutputType | null
  }

  type GetStockCorrectionGroupByPayload<T extends StockCorrectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockCorrectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockCorrectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockCorrectionGroupByOutputType[P]>
            : GetScalarType<T[P], StockCorrectionGroupByOutputType[P]>
        }
      >
    >


  export type StockCorrectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shortCode?: boolean
    storeId?: boolean
    shopId?: boolean
    reason?: boolean
    status?: boolean
    purchaseId?: boolean
    transferId?: boolean
    reference?: boolean
    notes?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StockCorrection$storeArgs<ExtArgs>
    shop?: boolean | StockCorrection$shopArgs<ExtArgs>
    purchase?: boolean | StockCorrection$purchaseArgs<ExtArgs>
    transfer?: boolean | StockCorrection$transferArgs<ExtArgs>
    createdBy?: boolean | StockCorrection$createdByArgs<ExtArgs>
    updatedBy?: boolean | StockCorrection$updatedByArgs<ExtArgs>
    items?: boolean | StockCorrection$itemsArgs<ExtArgs>
    _count?: boolean | StockCorrectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockCorrection"]>



  export type StockCorrectionSelectScalar = {
    id?: boolean
    shortCode?: boolean
    storeId?: boolean
    shopId?: boolean
    reason?: boolean
    status?: boolean
    purchaseId?: boolean
    transferId?: boolean
    reference?: boolean
    notes?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StockCorrectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shortCode" | "storeId" | "shopId" | "reason" | "status" | "purchaseId" | "transferId" | "reference" | "notes" | "createdById" | "updatedById" | "createdAt" | "updatedAt", ExtArgs["result"]["stockCorrection"]>
  export type StockCorrectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StockCorrection$storeArgs<ExtArgs>
    shop?: boolean | StockCorrection$shopArgs<ExtArgs>
    purchase?: boolean | StockCorrection$purchaseArgs<ExtArgs>
    transfer?: boolean | StockCorrection$transferArgs<ExtArgs>
    createdBy?: boolean | StockCorrection$createdByArgs<ExtArgs>
    updatedBy?: boolean | StockCorrection$updatedByArgs<ExtArgs>
    items?: boolean | StockCorrection$itemsArgs<ExtArgs>
    _count?: boolean | StockCorrectionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $StockCorrectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockCorrection"
    objects: {
      store: Prisma.$StorePayload<ExtArgs> | null
      shop: Prisma.$ShopPayload<ExtArgs> | null
      purchase: Prisma.$PurchasePayload<ExtArgs> | null
      transfer: Prisma.$TransferPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
      items: Prisma.$StockCorrectionItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shortCode: string
      storeId: string | null
      shopId: string | null
      reason: $Enums.StockCorrectionReason
      status: $Enums.StockCorrectionStatus
      purchaseId: string | null
      transferId: string | null
      reference: string | null
      notes: string | null
      createdById: string | null
      updatedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stockCorrection"]>
    composites: {}
  }

  type StockCorrectionGetPayload<S extends boolean | null | undefined | StockCorrectionDefaultArgs> = $Result.GetResult<Prisma.$StockCorrectionPayload, S>

  type StockCorrectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockCorrectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockCorrectionCountAggregateInputType | true
    }

  export interface StockCorrectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockCorrection'], meta: { name: 'StockCorrection' } }
    /**
     * Find zero or one StockCorrection that matches the filter.
     * @param {StockCorrectionFindUniqueArgs} args - Arguments to find a StockCorrection
     * @example
     * // Get one StockCorrection
     * const stockCorrection = await prisma.stockCorrection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockCorrectionFindUniqueArgs>(args: SelectSubset<T, StockCorrectionFindUniqueArgs<ExtArgs>>): Prisma__StockCorrectionClient<$Result.GetResult<Prisma.$StockCorrectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockCorrection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockCorrectionFindUniqueOrThrowArgs} args - Arguments to find a StockCorrection
     * @example
     * // Get one StockCorrection
     * const stockCorrection = await prisma.stockCorrection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockCorrectionFindUniqueOrThrowArgs>(args: SelectSubset<T, StockCorrectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockCorrectionClient<$Result.GetResult<Prisma.$StockCorrectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockCorrection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockCorrectionFindFirstArgs} args - Arguments to find a StockCorrection
     * @example
     * // Get one StockCorrection
     * const stockCorrection = await prisma.stockCorrection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockCorrectionFindFirstArgs>(args?: SelectSubset<T, StockCorrectionFindFirstArgs<ExtArgs>>): Prisma__StockCorrectionClient<$Result.GetResult<Prisma.$StockCorrectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockCorrection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockCorrectionFindFirstOrThrowArgs} args - Arguments to find a StockCorrection
     * @example
     * // Get one StockCorrection
     * const stockCorrection = await prisma.stockCorrection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockCorrectionFindFirstOrThrowArgs>(args?: SelectSubset<T, StockCorrectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockCorrectionClient<$Result.GetResult<Prisma.$StockCorrectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockCorrections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockCorrectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockCorrections
     * const stockCorrections = await prisma.stockCorrection.findMany()
     * 
     * // Get first 10 StockCorrections
     * const stockCorrections = await prisma.stockCorrection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockCorrectionWithIdOnly = await prisma.stockCorrection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockCorrectionFindManyArgs>(args?: SelectSubset<T, StockCorrectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockCorrectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockCorrection.
     * @param {StockCorrectionCreateArgs} args - Arguments to create a StockCorrection.
     * @example
     * // Create one StockCorrection
     * const StockCorrection = await prisma.stockCorrection.create({
     *   data: {
     *     // ... data to create a StockCorrection
     *   }
     * })
     * 
     */
    create<T extends StockCorrectionCreateArgs>(args: SelectSubset<T, StockCorrectionCreateArgs<ExtArgs>>): Prisma__StockCorrectionClient<$Result.GetResult<Prisma.$StockCorrectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockCorrections.
     * @param {StockCorrectionCreateManyArgs} args - Arguments to create many StockCorrections.
     * @example
     * // Create many StockCorrections
     * const stockCorrection = await prisma.stockCorrection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockCorrectionCreateManyArgs>(args?: SelectSubset<T, StockCorrectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StockCorrection.
     * @param {StockCorrectionDeleteArgs} args - Arguments to delete one StockCorrection.
     * @example
     * // Delete one StockCorrection
     * const StockCorrection = await prisma.stockCorrection.delete({
     *   where: {
     *     // ... filter to delete one StockCorrection
     *   }
     * })
     * 
     */
    delete<T extends StockCorrectionDeleteArgs>(args: SelectSubset<T, StockCorrectionDeleteArgs<ExtArgs>>): Prisma__StockCorrectionClient<$Result.GetResult<Prisma.$StockCorrectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockCorrection.
     * @param {StockCorrectionUpdateArgs} args - Arguments to update one StockCorrection.
     * @example
     * // Update one StockCorrection
     * const stockCorrection = await prisma.stockCorrection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockCorrectionUpdateArgs>(args: SelectSubset<T, StockCorrectionUpdateArgs<ExtArgs>>): Prisma__StockCorrectionClient<$Result.GetResult<Prisma.$StockCorrectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockCorrections.
     * @param {StockCorrectionDeleteManyArgs} args - Arguments to filter StockCorrections to delete.
     * @example
     * // Delete a few StockCorrections
     * const { count } = await prisma.stockCorrection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockCorrectionDeleteManyArgs>(args?: SelectSubset<T, StockCorrectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockCorrections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockCorrectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockCorrections
     * const stockCorrection = await prisma.stockCorrection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockCorrectionUpdateManyArgs>(args: SelectSubset<T, StockCorrectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockCorrection.
     * @param {StockCorrectionUpsertArgs} args - Arguments to update or create a StockCorrection.
     * @example
     * // Update or create a StockCorrection
     * const stockCorrection = await prisma.stockCorrection.upsert({
     *   create: {
     *     // ... data to create a StockCorrection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockCorrection we want to update
     *   }
     * })
     */
    upsert<T extends StockCorrectionUpsertArgs>(args: SelectSubset<T, StockCorrectionUpsertArgs<ExtArgs>>): Prisma__StockCorrectionClient<$Result.GetResult<Prisma.$StockCorrectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockCorrections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockCorrectionCountArgs} args - Arguments to filter StockCorrections to count.
     * @example
     * // Count the number of StockCorrections
     * const count = await prisma.stockCorrection.count({
     *   where: {
     *     // ... the filter for the StockCorrections we want to count
     *   }
     * })
    **/
    count<T extends StockCorrectionCountArgs>(
      args?: Subset<T, StockCorrectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockCorrectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockCorrection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockCorrectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockCorrectionAggregateArgs>(args: Subset<T, StockCorrectionAggregateArgs>): Prisma.PrismaPromise<GetStockCorrectionAggregateType<T>>

    /**
     * Group by StockCorrection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockCorrectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockCorrectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockCorrectionGroupByArgs['orderBy'] }
        : { orderBy?: StockCorrectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockCorrectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockCorrectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockCorrection model
   */
  readonly fields: StockCorrectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockCorrection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockCorrectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StockCorrection$storeArgs<ExtArgs> = {}>(args?: Subset<T, StockCorrection$storeArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    shop<T extends StockCorrection$shopArgs<ExtArgs> = {}>(args?: Subset<T, StockCorrection$shopArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    purchase<T extends StockCorrection$purchaseArgs<ExtArgs> = {}>(args?: Subset<T, StockCorrection$purchaseArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transfer<T extends StockCorrection$transferArgs<ExtArgs> = {}>(args?: Subset<T, StockCorrection$transferArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends StockCorrection$createdByArgs<ExtArgs> = {}>(args?: Subset<T, StockCorrection$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends StockCorrection$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, StockCorrection$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends StockCorrection$itemsArgs<ExtArgs> = {}>(args?: Subset<T, StockCorrection$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockCorrectionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockCorrection model
   */
  interface StockCorrectionFieldRefs {
    readonly id: FieldRef<"StockCorrection", 'String'>
    readonly shortCode: FieldRef<"StockCorrection", 'String'>
    readonly storeId: FieldRef<"StockCorrection", 'String'>
    readonly shopId: FieldRef<"StockCorrection", 'String'>
    readonly reason: FieldRef<"StockCorrection", 'StockCorrectionReason'>
    readonly status: FieldRef<"StockCorrection", 'StockCorrectionStatus'>
    readonly purchaseId: FieldRef<"StockCorrection", 'String'>
    readonly transferId: FieldRef<"StockCorrection", 'String'>
    readonly reference: FieldRef<"StockCorrection", 'String'>
    readonly notes: FieldRef<"StockCorrection", 'String'>
    readonly createdById: FieldRef<"StockCorrection", 'String'>
    readonly updatedById: FieldRef<"StockCorrection", 'String'>
    readonly createdAt: FieldRef<"StockCorrection", 'DateTime'>
    readonly updatedAt: FieldRef<"StockCorrection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockCorrection findUnique
   */
  export type StockCorrectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrection
     */
    select?: StockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrection
     */
    omit?: StockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionInclude<ExtArgs> | null
    /**
     * Filter, which StockCorrection to fetch.
     */
    where: StockCorrectionWhereUniqueInput
  }

  /**
   * StockCorrection findUniqueOrThrow
   */
  export type StockCorrectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrection
     */
    select?: StockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrection
     */
    omit?: StockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionInclude<ExtArgs> | null
    /**
     * Filter, which StockCorrection to fetch.
     */
    where: StockCorrectionWhereUniqueInput
  }

  /**
   * StockCorrection findFirst
   */
  export type StockCorrectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrection
     */
    select?: StockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrection
     */
    omit?: StockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionInclude<ExtArgs> | null
    /**
     * Filter, which StockCorrection to fetch.
     */
    where?: StockCorrectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockCorrections to fetch.
     */
    orderBy?: StockCorrectionOrderByWithRelationInput | StockCorrectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockCorrections.
     */
    cursor?: StockCorrectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockCorrections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockCorrections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockCorrections.
     */
    distinct?: StockCorrectionScalarFieldEnum | StockCorrectionScalarFieldEnum[]
  }

  /**
   * StockCorrection findFirstOrThrow
   */
  export type StockCorrectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrection
     */
    select?: StockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrection
     */
    omit?: StockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionInclude<ExtArgs> | null
    /**
     * Filter, which StockCorrection to fetch.
     */
    where?: StockCorrectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockCorrections to fetch.
     */
    orderBy?: StockCorrectionOrderByWithRelationInput | StockCorrectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockCorrections.
     */
    cursor?: StockCorrectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockCorrections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockCorrections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockCorrections.
     */
    distinct?: StockCorrectionScalarFieldEnum | StockCorrectionScalarFieldEnum[]
  }

  /**
   * StockCorrection findMany
   */
  export type StockCorrectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrection
     */
    select?: StockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrection
     */
    omit?: StockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionInclude<ExtArgs> | null
    /**
     * Filter, which StockCorrections to fetch.
     */
    where?: StockCorrectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockCorrections to fetch.
     */
    orderBy?: StockCorrectionOrderByWithRelationInput | StockCorrectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockCorrections.
     */
    cursor?: StockCorrectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockCorrections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockCorrections.
     */
    skip?: number
    distinct?: StockCorrectionScalarFieldEnum | StockCorrectionScalarFieldEnum[]
  }

  /**
   * StockCorrection create
   */
  export type StockCorrectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrection
     */
    select?: StockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrection
     */
    omit?: StockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionInclude<ExtArgs> | null
    /**
     * The data needed to create a StockCorrection.
     */
    data: XOR<StockCorrectionCreateInput, StockCorrectionUncheckedCreateInput>
  }

  /**
   * StockCorrection createMany
   */
  export type StockCorrectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockCorrections.
     */
    data: StockCorrectionCreateManyInput | StockCorrectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockCorrection update
   */
  export type StockCorrectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrection
     */
    select?: StockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrection
     */
    omit?: StockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionInclude<ExtArgs> | null
    /**
     * The data needed to update a StockCorrection.
     */
    data: XOR<StockCorrectionUpdateInput, StockCorrectionUncheckedUpdateInput>
    /**
     * Choose, which StockCorrection to update.
     */
    where: StockCorrectionWhereUniqueInput
  }

  /**
   * StockCorrection updateMany
   */
  export type StockCorrectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockCorrections.
     */
    data: XOR<StockCorrectionUpdateManyMutationInput, StockCorrectionUncheckedUpdateManyInput>
    /**
     * Filter which StockCorrections to update
     */
    where?: StockCorrectionWhereInput
    /**
     * Limit how many StockCorrections to update.
     */
    limit?: number
  }

  /**
   * StockCorrection upsert
   */
  export type StockCorrectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrection
     */
    select?: StockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrection
     */
    omit?: StockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionInclude<ExtArgs> | null
    /**
     * The filter to search for the StockCorrection to update in case it exists.
     */
    where: StockCorrectionWhereUniqueInput
    /**
     * In case the StockCorrection found by the `where` argument doesn't exist, create a new StockCorrection with this data.
     */
    create: XOR<StockCorrectionCreateInput, StockCorrectionUncheckedCreateInput>
    /**
     * In case the StockCorrection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockCorrectionUpdateInput, StockCorrectionUncheckedUpdateInput>
  }

  /**
   * StockCorrection delete
   */
  export type StockCorrectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrection
     */
    select?: StockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrection
     */
    omit?: StockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionInclude<ExtArgs> | null
    /**
     * Filter which StockCorrection to delete.
     */
    where: StockCorrectionWhereUniqueInput
  }

  /**
   * StockCorrection deleteMany
   */
  export type StockCorrectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockCorrections to delete
     */
    where?: StockCorrectionWhereInput
    /**
     * Limit how many StockCorrections to delete.
     */
    limit?: number
  }

  /**
   * StockCorrection.store
   */
  export type StockCorrection$storeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    where?: StoreWhereInput
  }

  /**
   * StockCorrection.shop
   */
  export type StockCorrection$shopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    where?: ShopWhereInput
  }

  /**
   * StockCorrection.purchase
   */
  export type StockCorrection$purchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
  }

  /**
   * StockCorrection.transfer
   */
  export type StockCorrection$transferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
  }

  /**
   * StockCorrection.createdBy
   */
  export type StockCorrection$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * StockCorrection.updatedBy
   */
  export type StockCorrection$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * StockCorrection.items
   */
  export type StockCorrection$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrectionItem
     */
    select?: StockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrectionItem
     */
    omit?: StockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionItemInclude<ExtArgs> | null
    where?: StockCorrectionItemWhereInput
    orderBy?: StockCorrectionItemOrderByWithRelationInput | StockCorrectionItemOrderByWithRelationInput[]
    cursor?: StockCorrectionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockCorrectionItemScalarFieldEnum | StockCorrectionItemScalarFieldEnum[]
  }

  /**
   * StockCorrection without action
   */
  export type StockCorrectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrection
     */
    select?: StockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrection
     */
    omit?: StockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionInclude<ExtArgs> | null
  }


  /**
   * Model StockCorrectionItem
   */

  export type AggregateStockCorrectionItem = {
    _count: StockCorrectionItemCountAggregateOutputType | null
    _avg: StockCorrectionItemAvgAggregateOutputType | null
    _sum: StockCorrectionItemSumAggregateOutputType | null
    _min: StockCorrectionItemMinAggregateOutputType | null
    _max: StockCorrectionItemMaxAggregateOutputType | null
  }

  export type StockCorrectionItemAvgAggregateOutputType = {
    quantity: number | null
  }

  export type StockCorrectionItemSumAggregateOutputType = {
    quantity: number | null
  }

  export type StockCorrectionItemMinAggregateOutputType = {
    id: string | null
    correctionId: string | null
    productId: string | null
    batchId: string | null
    unitOfMeasureId: string | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockCorrectionItemMaxAggregateOutputType = {
    id: string | null
    correctionId: string | null
    productId: string | null
    batchId: string | null
    unitOfMeasureId: string | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockCorrectionItemCountAggregateOutputType = {
    id: number
    correctionId: number
    productId: number
    batchId: number
    unitOfMeasureId: number
    quantity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StockCorrectionItemAvgAggregateInputType = {
    quantity?: true
  }

  export type StockCorrectionItemSumAggregateInputType = {
    quantity?: true
  }

  export type StockCorrectionItemMinAggregateInputType = {
    id?: true
    correctionId?: true
    productId?: true
    batchId?: true
    unitOfMeasureId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockCorrectionItemMaxAggregateInputType = {
    id?: true
    correctionId?: true
    productId?: true
    batchId?: true
    unitOfMeasureId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockCorrectionItemCountAggregateInputType = {
    id?: true
    correctionId?: true
    productId?: true
    batchId?: true
    unitOfMeasureId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StockCorrectionItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockCorrectionItem to aggregate.
     */
    where?: StockCorrectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockCorrectionItems to fetch.
     */
    orderBy?: StockCorrectionItemOrderByWithRelationInput | StockCorrectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockCorrectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockCorrectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockCorrectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockCorrectionItems
    **/
    _count?: true | StockCorrectionItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockCorrectionItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockCorrectionItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockCorrectionItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockCorrectionItemMaxAggregateInputType
  }

  export type GetStockCorrectionItemAggregateType<T extends StockCorrectionItemAggregateArgs> = {
        [P in keyof T & keyof AggregateStockCorrectionItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockCorrectionItem[P]>
      : GetScalarType<T[P], AggregateStockCorrectionItem[P]>
  }




  export type StockCorrectionItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockCorrectionItemWhereInput
    orderBy?: StockCorrectionItemOrderByWithAggregationInput | StockCorrectionItemOrderByWithAggregationInput[]
    by: StockCorrectionItemScalarFieldEnum[] | StockCorrectionItemScalarFieldEnum
    having?: StockCorrectionItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockCorrectionItemCountAggregateInputType | true
    _avg?: StockCorrectionItemAvgAggregateInputType
    _sum?: StockCorrectionItemSumAggregateInputType
    _min?: StockCorrectionItemMinAggregateInputType
    _max?: StockCorrectionItemMaxAggregateInputType
  }

  export type StockCorrectionItemGroupByOutputType = {
    id: string
    correctionId: string
    productId: string
    batchId: string | null
    unitOfMeasureId: string
    quantity: number
    createdAt: Date
    updatedAt: Date
    _count: StockCorrectionItemCountAggregateOutputType | null
    _avg: StockCorrectionItemAvgAggregateOutputType | null
    _sum: StockCorrectionItemSumAggregateOutputType | null
    _min: StockCorrectionItemMinAggregateOutputType | null
    _max: StockCorrectionItemMaxAggregateOutputType | null
  }

  type GetStockCorrectionItemGroupByPayload<T extends StockCorrectionItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockCorrectionItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockCorrectionItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockCorrectionItemGroupByOutputType[P]>
            : GetScalarType<T[P], StockCorrectionItemGroupByOutputType[P]>
        }
      >
    >


  export type StockCorrectionItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    correctionId?: boolean
    productId?: boolean
    batchId?: boolean
    unitOfMeasureId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    correction?: boolean | StockCorrectionDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    batch?: boolean | StockCorrectionItem$batchArgs<ExtArgs>
    unitOfMeasure?: boolean | UnitOfMeasureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockCorrectionItem"]>



  export type StockCorrectionItemSelectScalar = {
    id?: boolean
    correctionId?: boolean
    productId?: boolean
    batchId?: boolean
    unitOfMeasureId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StockCorrectionItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "correctionId" | "productId" | "batchId" | "unitOfMeasureId" | "quantity" | "createdAt" | "updatedAt", ExtArgs["result"]["stockCorrectionItem"]>
  export type StockCorrectionItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    correction?: boolean | StockCorrectionDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    batch?: boolean | StockCorrectionItem$batchArgs<ExtArgs>
    unitOfMeasure?: boolean | UnitOfMeasureDefaultArgs<ExtArgs>
  }

  export type $StockCorrectionItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockCorrectionItem"
    objects: {
      correction: Prisma.$StockCorrectionPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      batch: Prisma.$ProductBatchPayload<ExtArgs> | null
      unitOfMeasure: Prisma.$UnitOfMeasurePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      correctionId: string
      productId: string
      batchId: string | null
      unitOfMeasureId: string
      quantity: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stockCorrectionItem"]>
    composites: {}
  }

  type StockCorrectionItemGetPayload<S extends boolean | null | undefined | StockCorrectionItemDefaultArgs> = $Result.GetResult<Prisma.$StockCorrectionItemPayload, S>

  type StockCorrectionItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockCorrectionItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockCorrectionItemCountAggregateInputType | true
    }

  export interface StockCorrectionItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockCorrectionItem'], meta: { name: 'StockCorrectionItem' } }
    /**
     * Find zero or one StockCorrectionItem that matches the filter.
     * @param {StockCorrectionItemFindUniqueArgs} args - Arguments to find a StockCorrectionItem
     * @example
     * // Get one StockCorrectionItem
     * const stockCorrectionItem = await prisma.stockCorrectionItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockCorrectionItemFindUniqueArgs>(args: SelectSubset<T, StockCorrectionItemFindUniqueArgs<ExtArgs>>): Prisma__StockCorrectionItemClient<$Result.GetResult<Prisma.$StockCorrectionItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockCorrectionItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockCorrectionItemFindUniqueOrThrowArgs} args - Arguments to find a StockCorrectionItem
     * @example
     * // Get one StockCorrectionItem
     * const stockCorrectionItem = await prisma.stockCorrectionItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockCorrectionItemFindUniqueOrThrowArgs>(args: SelectSubset<T, StockCorrectionItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockCorrectionItemClient<$Result.GetResult<Prisma.$StockCorrectionItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockCorrectionItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockCorrectionItemFindFirstArgs} args - Arguments to find a StockCorrectionItem
     * @example
     * // Get one StockCorrectionItem
     * const stockCorrectionItem = await prisma.stockCorrectionItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockCorrectionItemFindFirstArgs>(args?: SelectSubset<T, StockCorrectionItemFindFirstArgs<ExtArgs>>): Prisma__StockCorrectionItemClient<$Result.GetResult<Prisma.$StockCorrectionItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockCorrectionItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockCorrectionItemFindFirstOrThrowArgs} args - Arguments to find a StockCorrectionItem
     * @example
     * // Get one StockCorrectionItem
     * const stockCorrectionItem = await prisma.stockCorrectionItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockCorrectionItemFindFirstOrThrowArgs>(args?: SelectSubset<T, StockCorrectionItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockCorrectionItemClient<$Result.GetResult<Prisma.$StockCorrectionItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockCorrectionItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockCorrectionItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockCorrectionItems
     * const stockCorrectionItems = await prisma.stockCorrectionItem.findMany()
     * 
     * // Get first 10 StockCorrectionItems
     * const stockCorrectionItems = await prisma.stockCorrectionItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockCorrectionItemWithIdOnly = await prisma.stockCorrectionItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockCorrectionItemFindManyArgs>(args?: SelectSubset<T, StockCorrectionItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockCorrectionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockCorrectionItem.
     * @param {StockCorrectionItemCreateArgs} args - Arguments to create a StockCorrectionItem.
     * @example
     * // Create one StockCorrectionItem
     * const StockCorrectionItem = await prisma.stockCorrectionItem.create({
     *   data: {
     *     // ... data to create a StockCorrectionItem
     *   }
     * })
     * 
     */
    create<T extends StockCorrectionItemCreateArgs>(args: SelectSubset<T, StockCorrectionItemCreateArgs<ExtArgs>>): Prisma__StockCorrectionItemClient<$Result.GetResult<Prisma.$StockCorrectionItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockCorrectionItems.
     * @param {StockCorrectionItemCreateManyArgs} args - Arguments to create many StockCorrectionItems.
     * @example
     * // Create many StockCorrectionItems
     * const stockCorrectionItem = await prisma.stockCorrectionItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockCorrectionItemCreateManyArgs>(args?: SelectSubset<T, StockCorrectionItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StockCorrectionItem.
     * @param {StockCorrectionItemDeleteArgs} args - Arguments to delete one StockCorrectionItem.
     * @example
     * // Delete one StockCorrectionItem
     * const StockCorrectionItem = await prisma.stockCorrectionItem.delete({
     *   where: {
     *     // ... filter to delete one StockCorrectionItem
     *   }
     * })
     * 
     */
    delete<T extends StockCorrectionItemDeleteArgs>(args: SelectSubset<T, StockCorrectionItemDeleteArgs<ExtArgs>>): Prisma__StockCorrectionItemClient<$Result.GetResult<Prisma.$StockCorrectionItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockCorrectionItem.
     * @param {StockCorrectionItemUpdateArgs} args - Arguments to update one StockCorrectionItem.
     * @example
     * // Update one StockCorrectionItem
     * const stockCorrectionItem = await prisma.stockCorrectionItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockCorrectionItemUpdateArgs>(args: SelectSubset<T, StockCorrectionItemUpdateArgs<ExtArgs>>): Prisma__StockCorrectionItemClient<$Result.GetResult<Prisma.$StockCorrectionItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockCorrectionItems.
     * @param {StockCorrectionItemDeleteManyArgs} args - Arguments to filter StockCorrectionItems to delete.
     * @example
     * // Delete a few StockCorrectionItems
     * const { count } = await prisma.stockCorrectionItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockCorrectionItemDeleteManyArgs>(args?: SelectSubset<T, StockCorrectionItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockCorrectionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockCorrectionItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockCorrectionItems
     * const stockCorrectionItem = await prisma.stockCorrectionItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockCorrectionItemUpdateManyArgs>(args: SelectSubset<T, StockCorrectionItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockCorrectionItem.
     * @param {StockCorrectionItemUpsertArgs} args - Arguments to update or create a StockCorrectionItem.
     * @example
     * // Update or create a StockCorrectionItem
     * const stockCorrectionItem = await prisma.stockCorrectionItem.upsert({
     *   create: {
     *     // ... data to create a StockCorrectionItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockCorrectionItem we want to update
     *   }
     * })
     */
    upsert<T extends StockCorrectionItemUpsertArgs>(args: SelectSubset<T, StockCorrectionItemUpsertArgs<ExtArgs>>): Prisma__StockCorrectionItemClient<$Result.GetResult<Prisma.$StockCorrectionItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockCorrectionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockCorrectionItemCountArgs} args - Arguments to filter StockCorrectionItems to count.
     * @example
     * // Count the number of StockCorrectionItems
     * const count = await prisma.stockCorrectionItem.count({
     *   where: {
     *     // ... the filter for the StockCorrectionItems we want to count
     *   }
     * })
    **/
    count<T extends StockCorrectionItemCountArgs>(
      args?: Subset<T, StockCorrectionItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockCorrectionItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockCorrectionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockCorrectionItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockCorrectionItemAggregateArgs>(args: Subset<T, StockCorrectionItemAggregateArgs>): Prisma.PrismaPromise<GetStockCorrectionItemAggregateType<T>>

    /**
     * Group by StockCorrectionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockCorrectionItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockCorrectionItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockCorrectionItemGroupByArgs['orderBy'] }
        : { orderBy?: StockCorrectionItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockCorrectionItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockCorrectionItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockCorrectionItem model
   */
  readonly fields: StockCorrectionItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockCorrectionItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockCorrectionItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    correction<T extends StockCorrectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockCorrectionDefaultArgs<ExtArgs>>): Prisma__StockCorrectionClient<$Result.GetResult<Prisma.$StockCorrectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    batch<T extends StockCorrectionItem$batchArgs<ExtArgs> = {}>(args?: Subset<T, StockCorrectionItem$batchArgs<ExtArgs>>): Prisma__ProductBatchClient<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    unitOfMeasure<T extends UnitOfMeasureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasureDefaultArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockCorrectionItem model
   */
  interface StockCorrectionItemFieldRefs {
    readonly id: FieldRef<"StockCorrectionItem", 'String'>
    readonly correctionId: FieldRef<"StockCorrectionItem", 'String'>
    readonly productId: FieldRef<"StockCorrectionItem", 'String'>
    readonly batchId: FieldRef<"StockCorrectionItem", 'String'>
    readonly unitOfMeasureId: FieldRef<"StockCorrectionItem", 'String'>
    readonly quantity: FieldRef<"StockCorrectionItem", 'Int'>
    readonly createdAt: FieldRef<"StockCorrectionItem", 'DateTime'>
    readonly updatedAt: FieldRef<"StockCorrectionItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockCorrectionItem findUnique
   */
  export type StockCorrectionItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrectionItem
     */
    select?: StockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrectionItem
     */
    omit?: StockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionItemInclude<ExtArgs> | null
    /**
     * Filter, which StockCorrectionItem to fetch.
     */
    where: StockCorrectionItemWhereUniqueInput
  }

  /**
   * StockCorrectionItem findUniqueOrThrow
   */
  export type StockCorrectionItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrectionItem
     */
    select?: StockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrectionItem
     */
    omit?: StockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionItemInclude<ExtArgs> | null
    /**
     * Filter, which StockCorrectionItem to fetch.
     */
    where: StockCorrectionItemWhereUniqueInput
  }

  /**
   * StockCorrectionItem findFirst
   */
  export type StockCorrectionItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrectionItem
     */
    select?: StockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrectionItem
     */
    omit?: StockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionItemInclude<ExtArgs> | null
    /**
     * Filter, which StockCorrectionItem to fetch.
     */
    where?: StockCorrectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockCorrectionItems to fetch.
     */
    orderBy?: StockCorrectionItemOrderByWithRelationInput | StockCorrectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockCorrectionItems.
     */
    cursor?: StockCorrectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockCorrectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockCorrectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockCorrectionItems.
     */
    distinct?: StockCorrectionItemScalarFieldEnum | StockCorrectionItemScalarFieldEnum[]
  }

  /**
   * StockCorrectionItem findFirstOrThrow
   */
  export type StockCorrectionItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrectionItem
     */
    select?: StockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrectionItem
     */
    omit?: StockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionItemInclude<ExtArgs> | null
    /**
     * Filter, which StockCorrectionItem to fetch.
     */
    where?: StockCorrectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockCorrectionItems to fetch.
     */
    orderBy?: StockCorrectionItemOrderByWithRelationInput | StockCorrectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockCorrectionItems.
     */
    cursor?: StockCorrectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockCorrectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockCorrectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockCorrectionItems.
     */
    distinct?: StockCorrectionItemScalarFieldEnum | StockCorrectionItemScalarFieldEnum[]
  }

  /**
   * StockCorrectionItem findMany
   */
  export type StockCorrectionItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrectionItem
     */
    select?: StockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrectionItem
     */
    omit?: StockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionItemInclude<ExtArgs> | null
    /**
     * Filter, which StockCorrectionItems to fetch.
     */
    where?: StockCorrectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockCorrectionItems to fetch.
     */
    orderBy?: StockCorrectionItemOrderByWithRelationInput | StockCorrectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockCorrectionItems.
     */
    cursor?: StockCorrectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockCorrectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockCorrectionItems.
     */
    skip?: number
    distinct?: StockCorrectionItemScalarFieldEnum | StockCorrectionItemScalarFieldEnum[]
  }

  /**
   * StockCorrectionItem create
   */
  export type StockCorrectionItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrectionItem
     */
    select?: StockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrectionItem
     */
    omit?: StockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionItemInclude<ExtArgs> | null
    /**
     * The data needed to create a StockCorrectionItem.
     */
    data: XOR<StockCorrectionItemCreateInput, StockCorrectionItemUncheckedCreateInput>
  }

  /**
   * StockCorrectionItem createMany
   */
  export type StockCorrectionItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockCorrectionItems.
     */
    data: StockCorrectionItemCreateManyInput | StockCorrectionItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockCorrectionItem update
   */
  export type StockCorrectionItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrectionItem
     */
    select?: StockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrectionItem
     */
    omit?: StockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionItemInclude<ExtArgs> | null
    /**
     * The data needed to update a StockCorrectionItem.
     */
    data: XOR<StockCorrectionItemUpdateInput, StockCorrectionItemUncheckedUpdateInput>
    /**
     * Choose, which StockCorrectionItem to update.
     */
    where: StockCorrectionItemWhereUniqueInput
  }

  /**
   * StockCorrectionItem updateMany
   */
  export type StockCorrectionItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockCorrectionItems.
     */
    data: XOR<StockCorrectionItemUpdateManyMutationInput, StockCorrectionItemUncheckedUpdateManyInput>
    /**
     * Filter which StockCorrectionItems to update
     */
    where?: StockCorrectionItemWhereInput
    /**
     * Limit how many StockCorrectionItems to update.
     */
    limit?: number
  }

  /**
   * StockCorrectionItem upsert
   */
  export type StockCorrectionItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrectionItem
     */
    select?: StockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrectionItem
     */
    omit?: StockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionItemInclude<ExtArgs> | null
    /**
     * The filter to search for the StockCorrectionItem to update in case it exists.
     */
    where: StockCorrectionItemWhereUniqueInput
    /**
     * In case the StockCorrectionItem found by the `where` argument doesn't exist, create a new StockCorrectionItem with this data.
     */
    create: XOR<StockCorrectionItemCreateInput, StockCorrectionItemUncheckedCreateInput>
    /**
     * In case the StockCorrectionItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockCorrectionItemUpdateInput, StockCorrectionItemUncheckedUpdateInput>
  }

  /**
   * StockCorrectionItem delete
   */
  export type StockCorrectionItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrectionItem
     */
    select?: StockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrectionItem
     */
    omit?: StockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionItemInclude<ExtArgs> | null
    /**
     * Filter which StockCorrectionItem to delete.
     */
    where: StockCorrectionItemWhereUniqueInput
  }

  /**
   * StockCorrectionItem deleteMany
   */
  export type StockCorrectionItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockCorrectionItems to delete
     */
    where?: StockCorrectionItemWhereInput
    /**
     * Limit how many StockCorrectionItems to delete.
     */
    limit?: number
  }

  /**
   * StockCorrectionItem.batch
   */
  export type StockCorrectionItem$batchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatch
     */
    select?: ProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBatch
     */
    omit?: ProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBatchInclude<ExtArgs> | null
    where?: ProductBatchWhereInput
  }

  /**
   * StockCorrectionItem without action
   */
  export type StockCorrectionItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCorrectionItem
     */
    select?: StockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockCorrectionItem
     */
    omit?: StockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockCorrectionItemInclude<ExtArgs> | null
  }


  /**
   * Model Sell
   */

  export type AggregateSell = {
    _count: SellCountAggregateOutputType | null
    _avg: SellAvgAggregateOutputType | null
    _sum: SellSumAggregateOutputType | null
    _min: SellMinAggregateOutputType | null
    _max: SellMaxAggregateOutputType | null
  }

  export type SellAvgAggregateOutputType = {
    totalProducts: number | null
    subTotal: number | null
    discount: number | null
    vat: number | null
    grandTotal: number | null
    NetTotal: number | null
  }

  export type SellSumAggregateOutputType = {
    totalProducts: number | null
    subTotal: number | null
    discount: number | null
    vat: number | null
    grandTotal: number | null
    NetTotal: number | null
  }

  export type SellMinAggregateOutputType = {
    id: string | null
    invoiceNo: string | null
    saleStatus: $Enums.SaleStatus | null
    locked: boolean | null
    lockedAt: Date | null
    branchId: string | null
    customerId: string | null
    totalProducts: number | null
    subTotal: number | null
    discount: number | null
    vat: number | null
    grandTotal: number | null
    NetTotal: number | null
    notes: string | null
    saleDate: Date | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SellMaxAggregateOutputType = {
    id: string | null
    invoiceNo: string | null
    saleStatus: $Enums.SaleStatus | null
    locked: boolean | null
    lockedAt: Date | null
    branchId: string | null
    customerId: string | null
    totalProducts: number | null
    subTotal: number | null
    discount: number | null
    vat: number | null
    grandTotal: number | null
    NetTotal: number | null
    notes: string | null
    saleDate: Date | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SellCountAggregateOutputType = {
    id: number
    invoiceNo: number
    saleStatus: number
    locked: number
    lockedAt: number
    branchId: number
    customerId: number
    totalProducts: number
    subTotal: number
    discount: number
    vat: number
    grandTotal: number
    NetTotal: number
    notes: number
    saleDate: number
    createdById: number
    updatedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SellAvgAggregateInputType = {
    totalProducts?: true
    subTotal?: true
    discount?: true
    vat?: true
    grandTotal?: true
    NetTotal?: true
  }

  export type SellSumAggregateInputType = {
    totalProducts?: true
    subTotal?: true
    discount?: true
    vat?: true
    grandTotal?: true
    NetTotal?: true
  }

  export type SellMinAggregateInputType = {
    id?: true
    invoiceNo?: true
    saleStatus?: true
    locked?: true
    lockedAt?: true
    branchId?: true
    customerId?: true
    totalProducts?: true
    subTotal?: true
    discount?: true
    vat?: true
    grandTotal?: true
    NetTotal?: true
    notes?: true
    saleDate?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SellMaxAggregateInputType = {
    id?: true
    invoiceNo?: true
    saleStatus?: true
    locked?: true
    lockedAt?: true
    branchId?: true
    customerId?: true
    totalProducts?: true
    subTotal?: true
    discount?: true
    vat?: true
    grandTotal?: true
    NetTotal?: true
    notes?: true
    saleDate?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SellCountAggregateInputType = {
    id?: true
    invoiceNo?: true
    saleStatus?: true
    locked?: true
    lockedAt?: true
    branchId?: true
    customerId?: true
    totalProducts?: true
    subTotal?: true
    discount?: true
    vat?: true
    grandTotal?: true
    NetTotal?: true
    notes?: true
    saleDate?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SellAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sell to aggregate.
     */
    where?: SellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sells to fetch.
     */
    orderBy?: SellOrderByWithRelationInput | SellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sells
    **/
    _count?: true | SellCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SellAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SellSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellMaxAggregateInputType
  }

  export type GetSellAggregateType<T extends SellAggregateArgs> = {
        [P in keyof T & keyof AggregateSell]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSell[P]>
      : GetScalarType<T[P], AggregateSell[P]>
  }




  export type SellGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellWhereInput
    orderBy?: SellOrderByWithAggregationInput | SellOrderByWithAggregationInput[]
    by: SellScalarFieldEnum[] | SellScalarFieldEnum
    having?: SellScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellCountAggregateInputType | true
    _avg?: SellAvgAggregateInputType
    _sum?: SellSumAggregateInputType
    _min?: SellMinAggregateInputType
    _max?: SellMaxAggregateInputType
  }

  export type SellGroupByOutputType = {
    id: string
    invoiceNo: string
    saleStatus: $Enums.SaleStatus
    locked: boolean
    lockedAt: Date | null
    branchId: string | null
    customerId: string | null
    totalProducts: number
    subTotal: number
    discount: number
    vat: number
    grandTotal: number
    NetTotal: number
    notes: string | null
    saleDate: Date
    createdById: string | null
    updatedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: SellCountAggregateOutputType | null
    _avg: SellAvgAggregateOutputType | null
    _sum: SellSumAggregateOutputType | null
    _min: SellMinAggregateOutputType | null
    _max: SellMaxAggregateOutputType | null
  }

  type GetSellGroupByPayload<T extends SellGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellGroupByOutputType[P]>
            : GetScalarType<T[P], SellGroupByOutputType[P]>
        }
      >
    >


  export type SellSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNo?: boolean
    saleStatus?: boolean
    locked?: boolean
    lockedAt?: boolean
    branchId?: boolean
    customerId?: boolean
    totalProducts?: boolean
    subTotal?: boolean
    discount?: boolean
    vat?: boolean
    grandTotal?: boolean
    NetTotal?: boolean
    notes?: boolean
    saleDate?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | Sell$branchArgs<ExtArgs>
    customer?: boolean | Sell$customerArgs<ExtArgs>
    createdBy?: boolean | Sell$createdByArgs<ExtArgs>
    updatedBy?: boolean | Sell$updatedByArgs<ExtArgs>
    items?: boolean | Sell$itemsArgs<ExtArgs>
    SellStockCorrection?: boolean | Sell$SellStockCorrectionArgs<ExtArgs>
    _count?: boolean | SellCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sell"]>



  export type SellSelectScalar = {
    id?: boolean
    invoiceNo?: boolean
    saleStatus?: boolean
    locked?: boolean
    lockedAt?: boolean
    branchId?: boolean
    customerId?: boolean
    totalProducts?: boolean
    subTotal?: boolean
    discount?: boolean
    vat?: boolean
    grandTotal?: boolean
    NetTotal?: boolean
    notes?: boolean
    saleDate?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SellOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceNo" | "saleStatus" | "locked" | "lockedAt" | "branchId" | "customerId" | "totalProducts" | "subTotal" | "discount" | "vat" | "grandTotal" | "NetTotal" | "notes" | "saleDate" | "createdById" | "updatedById" | "createdAt" | "updatedAt", ExtArgs["result"]["sell"]>
  export type SellInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Sell$branchArgs<ExtArgs>
    customer?: boolean | Sell$customerArgs<ExtArgs>
    createdBy?: boolean | Sell$createdByArgs<ExtArgs>
    updatedBy?: boolean | Sell$updatedByArgs<ExtArgs>
    items?: boolean | Sell$itemsArgs<ExtArgs>
    SellStockCorrection?: boolean | Sell$SellStockCorrectionArgs<ExtArgs>
    _count?: boolean | SellCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SellPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sell"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
      items: Prisma.$SellItemPayload<ExtArgs>[]
      SellStockCorrection: Prisma.$SellStockCorrectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceNo: string
      saleStatus: $Enums.SaleStatus
      locked: boolean
      lockedAt: Date | null
      branchId: string | null
      customerId: string | null
      totalProducts: number
      subTotal: number
      discount: number
      vat: number
      grandTotal: number
      NetTotal: number
      notes: string | null
      saleDate: Date
      createdById: string | null
      updatedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sell"]>
    composites: {}
  }

  type SellGetPayload<S extends boolean | null | undefined | SellDefaultArgs> = $Result.GetResult<Prisma.$SellPayload, S>

  type SellCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SellFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SellCountAggregateInputType | true
    }

  export interface SellDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sell'], meta: { name: 'Sell' } }
    /**
     * Find zero or one Sell that matches the filter.
     * @param {SellFindUniqueArgs} args - Arguments to find a Sell
     * @example
     * // Get one Sell
     * const sell = await prisma.sell.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellFindUniqueArgs>(args: SelectSubset<T, SellFindUniqueArgs<ExtArgs>>): Prisma__SellClient<$Result.GetResult<Prisma.$SellPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sell that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SellFindUniqueOrThrowArgs} args - Arguments to find a Sell
     * @example
     * // Get one Sell
     * const sell = await prisma.sell.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellFindUniqueOrThrowArgs>(args: SelectSubset<T, SellFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellClient<$Result.GetResult<Prisma.$SellPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sell that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellFindFirstArgs} args - Arguments to find a Sell
     * @example
     * // Get one Sell
     * const sell = await prisma.sell.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellFindFirstArgs>(args?: SelectSubset<T, SellFindFirstArgs<ExtArgs>>): Prisma__SellClient<$Result.GetResult<Prisma.$SellPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sell that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellFindFirstOrThrowArgs} args - Arguments to find a Sell
     * @example
     * // Get one Sell
     * const sell = await prisma.sell.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellFindFirstOrThrowArgs>(args?: SelectSubset<T, SellFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellClient<$Result.GetResult<Prisma.$SellPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sells that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sells
     * const sells = await prisma.sell.findMany()
     * 
     * // Get first 10 Sells
     * const sells = await prisma.sell.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellWithIdOnly = await prisma.sell.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellFindManyArgs>(args?: SelectSubset<T, SellFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sell.
     * @param {SellCreateArgs} args - Arguments to create a Sell.
     * @example
     * // Create one Sell
     * const Sell = await prisma.sell.create({
     *   data: {
     *     // ... data to create a Sell
     *   }
     * })
     * 
     */
    create<T extends SellCreateArgs>(args: SelectSubset<T, SellCreateArgs<ExtArgs>>): Prisma__SellClient<$Result.GetResult<Prisma.$SellPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sells.
     * @param {SellCreateManyArgs} args - Arguments to create many Sells.
     * @example
     * // Create many Sells
     * const sell = await prisma.sell.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellCreateManyArgs>(args?: SelectSubset<T, SellCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sell.
     * @param {SellDeleteArgs} args - Arguments to delete one Sell.
     * @example
     * // Delete one Sell
     * const Sell = await prisma.sell.delete({
     *   where: {
     *     // ... filter to delete one Sell
     *   }
     * })
     * 
     */
    delete<T extends SellDeleteArgs>(args: SelectSubset<T, SellDeleteArgs<ExtArgs>>): Prisma__SellClient<$Result.GetResult<Prisma.$SellPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sell.
     * @param {SellUpdateArgs} args - Arguments to update one Sell.
     * @example
     * // Update one Sell
     * const sell = await prisma.sell.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellUpdateArgs>(args: SelectSubset<T, SellUpdateArgs<ExtArgs>>): Prisma__SellClient<$Result.GetResult<Prisma.$SellPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sells.
     * @param {SellDeleteManyArgs} args - Arguments to filter Sells to delete.
     * @example
     * // Delete a few Sells
     * const { count } = await prisma.sell.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellDeleteManyArgs>(args?: SelectSubset<T, SellDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sells
     * const sell = await prisma.sell.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellUpdateManyArgs>(args: SelectSubset<T, SellUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sell.
     * @param {SellUpsertArgs} args - Arguments to update or create a Sell.
     * @example
     * // Update or create a Sell
     * const sell = await prisma.sell.upsert({
     *   create: {
     *     // ... data to create a Sell
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sell we want to update
     *   }
     * })
     */
    upsert<T extends SellUpsertArgs>(args: SelectSubset<T, SellUpsertArgs<ExtArgs>>): Prisma__SellClient<$Result.GetResult<Prisma.$SellPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellCountArgs} args - Arguments to filter Sells to count.
     * @example
     * // Count the number of Sells
     * const count = await prisma.sell.count({
     *   where: {
     *     // ... the filter for the Sells we want to count
     *   }
     * })
    **/
    count<T extends SellCountArgs>(
      args?: Subset<T, SellCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellAggregateArgs>(args: Subset<T, SellAggregateArgs>): Prisma.PrismaPromise<GetSellAggregateType<T>>

    /**
     * Group by Sell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellGroupByArgs['orderBy'] }
        : { orderBy?: SellGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sell model
   */
  readonly fields: SellFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sell.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends Sell$branchArgs<ExtArgs> = {}>(args?: Subset<T, Sell$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customer<T extends Sell$customerArgs<ExtArgs> = {}>(args?: Subset<T, Sell$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends Sell$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Sell$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends Sell$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, Sell$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Sell$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Sell$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SellStockCorrection<T extends Sell$SellStockCorrectionArgs<ExtArgs> = {}>(args?: Subset<T, Sell$SellStockCorrectionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellStockCorrectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sell model
   */
  interface SellFieldRefs {
    readonly id: FieldRef<"Sell", 'String'>
    readonly invoiceNo: FieldRef<"Sell", 'String'>
    readonly saleStatus: FieldRef<"Sell", 'SaleStatus'>
    readonly locked: FieldRef<"Sell", 'Boolean'>
    readonly lockedAt: FieldRef<"Sell", 'DateTime'>
    readonly branchId: FieldRef<"Sell", 'String'>
    readonly customerId: FieldRef<"Sell", 'String'>
    readonly totalProducts: FieldRef<"Sell", 'Int'>
    readonly subTotal: FieldRef<"Sell", 'Float'>
    readonly discount: FieldRef<"Sell", 'Float'>
    readonly vat: FieldRef<"Sell", 'Float'>
    readonly grandTotal: FieldRef<"Sell", 'Float'>
    readonly NetTotal: FieldRef<"Sell", 'Float'>
    readonly notes: FieldRef<"Sell", 'String'>
    readonly saleDate: FieldRef<"Sell", 'DateTime'>
    readonly createdById: FieldRef<"Sell", 'String'>
    readonly updatedById: FieldRef<"Sell", 'String'>
    readonly createdAt: FieldRef<"Sell", 'DateTime'>
    readonly updatedAt: FieldRef<"Sell", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sell findUnique
   */
  export type SellFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sell
     */
    select?: SellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sell
     */
    omit?: SellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellInclude<ExtArgs> | null
    /**
     * Filter, which Sell to fetch.
     */
    where: SellWhereUniqueInput
  }

  /**
   * Sell findUniqueOrThrow
   */
  export type SellFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sell
     */
    select?: SellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sell
     */
    omit?: SellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellInclude<ExtArgs> | null
    /**
     * Filter, which Sell to fetch.
     */
    where: SellWhereUniqueInput
  }

  /**
   * Sell findFirst
   */
  export type SellFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sell
     */
    select?: SellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sell
     */
    omit?: SellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellInclude<ExtArgs> | null
    /**
     * Filter, which Sell to fetch.
     */
    where?: SellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sells to fetch.
     */
    orderBy?: SellOrderByWithRelationInput | SellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sells.
     */
    cursor?: SellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sells.
     */
    distinct?: SellScalarFieldEnum | SellScalarFieldEnum[]
  }

  /**
   * Sell findFirstOrThrow
   */
  export type SellFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sell
     */
    select?: SellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sell
     */
    omit?: SellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellInclude<ExtArgs> | null
    /**
     * Filter, which Sell to fetch.
     */
    where?: SellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sells to fetch.
     */
    orderBy?: SellOrderByWithRelationInput | SellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sells.
     */
    cursor?: SellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sells.
     */
    distinct?: SellScalarFieldEnum | SellScalarFieldEnum[]
  }

  /**
   * Sell findMany
   */
  export type SellFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sell
     */
    select?: SellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sell
     */
    omit?: SellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellInclude<ExtArgs> | null
    /**
     * Filter, which Sells to fetch.
     */
    where?: SellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sells to fetch.
     */
    orderBy?: SellOrderByWithRelationInput | SellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sells.
     */
    cursor?: SellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sells.
     */
    skip?: number
    distinct?: SellScalarFieldEnum | SellScalarFieldEnum[]
  }

  /**
   * Sell create
   */
  export type SellCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sell
     */
    select?: SellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sell
     */
    omit?: SellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellInclude<ExtArgs> | null
    /**
     * The data needed to create a Sell.
     */
    data: XOR<SellCreateInput, SellUncheckedCreateInput>
  }

  /**
   * Sell createMany
   */
  export type SellCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sells.
     */
    data: SellCreateManyInput | SellCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sell update
   */
  export type SellUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sell
     */
    select?: SellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sell
     */
    omit?: SellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellInclude<ExtArgs> | null
    /**
     * The data needed to update a Sell.
     */
    data: XOR<SellUpdateInput, SellUncheckedUpdateInput>
    /**
     * Choose, which Sell to update.
     */
    where: SellWhereUniqueInput
  }

  /**
   * Sell updateMany
   */
  export type SellUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sells.
     */
    data: XOR<SellUpdateManyMutationInput, SellUncheckedUpdateManyInput>
    /**
     * Filter which Sells to update
     */
    where?: SellWhereInput
    /**
     * Limit how many Sells to update.
     */
    limit?: number
  }

  /**
   * Sell upsert
   */
  export type SellUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sell
     */
    select?: SellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sell
     */
    omit?: SellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellInclude<ExtArgs> | null
    /**
     * The filter to search for the Sell to update in case it exists.
     */
    where: SellWhereUniqueInput
    /**
     * In case the Sell found by the `where` argument doesn't exist, create a new Sell with this data.
     */
    create: XOR<SellCreateInput, SellUncheckedCreateInput>
    /**
     * In case the Sell was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellUpdateInput, SellUncheckedUpdateInput>
  }

  /**
   * Sell delete
   */
  export type SellDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sell
     */
    select?: SellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sell
     */
    omit?: SellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellInclude<ExtArgs> | null
    /**
     * Filter which Sell to delete.
     */
    where: SellWhereUniqueInput
  }

  /**
   * Sell deleteMany
   */
  export type SellDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sells to delete
     */
    where?: SellWhereInput
    /**
     * Limit how many Sells to delete.
     */
    limit?: number
  }

  /**
   * Sell.branch
   */
  export type Sell$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Sell.customer
   */
  export type Sell$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Sell.createdBy
   */
  export type Sell$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Sell.updatedBy
   */
  export type Sell$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Sell.items
   */
  export type Sell$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItem
     */
    select?: SellItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellItem
     */
    omit?: SellItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellItemInclude<ExtArgs> | null
    where?: SellItemWhereInput
    orderBy?: SellItemOrderByWithRelationInput | SellItemOrderByWithRelationInput[]
    cursor?: SellItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellItemScalarFieldEnum | SellItemScalarFieldEnum[]
  }

  /**
   * Sell.SellStockCorrection
   */
  export type Sell$SellStockCorrectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrection
     */
    select?: SellStockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrection
     */
    omit?: SellStockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionInclude<ExtArgs> | null
    where?: SellStockCorrectionWhereInput
    orderBy?: SellStockCorrectionOrderByWithRelationInput | SellStockCorrectionOrderByWithRelationInput[]
    cursor?: SellStockCorrectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellStockCorrectionScalarFieldEnum | SellStockCorrectionScalarFieldEnum[]
  }

  /**
   * Sell without action
   */
  export type SellDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sell
     */
    select?: SellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sell
     */
    omit?: SellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellInclude<ExtArgs> | null
  }


  /**
   * Model SellItem
   */

  export type AggregateSellItem = {
    _count: SellItemCountAggregateOutputType | null
    _avg: SellItemAvgAggregateOutputType | null
    _sum: SellItemSumAggregateOutputType | null
    _min: SellItemMinAggregateOutputType | null
    _max: SellItemMaxAggregateOutputType | null
  }

  export type SellItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
  }

  export type SellItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
  }

  export type SellItemMinAggregateOutputType = {
    id: string | null
    sellId: string | null
    productId: string | null
    shopId: string | null
    unitOfMeasureId: string | null
    itemSaleStatus: $Enums.ItemSaleStatus | null
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SellItemMaxAggregateOutputType = {
    id: string | null
    sellId: string | null
    productId: string | null
    shopId: string | null
    unitOfMeasureId: string | null
    itemSaleStatus: $Enums.ItemSaleStatus | null
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SellItemCountAggregateOutputType = {
    id: number
    sellId: number
    productId: number
    shopId: number
    unitOfMeasureId: number
    itemSaleStatus: number
    quantity: number
    unitPrice: number
    totalPrice: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SellItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type SellItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type SellItemMinAggregateInputType = {
    id?: true
    sellId?: true
    productId?: true
    shopId?: true
    unitOfMeasureId?: true
    itemSaleStatus?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SellItemMaxAggregateInputType = {
    id?: true
    sellId?: true
    productId?: true
    shopId?: true
    unitOfMeasureId?: true
    itemSaleStatus?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SellItemCountAggregateInputType = {
    id?: true
    sellId?: true
    productId?: true
    shopId?: true
    unitOfMeasureId?: true
    itemSaleStatus?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SellItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellItem to aggregate.
     */
    where?: SellItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellItems to fetch.
     */
    orderBy?: SellItemOrderByWithRelationInput | SellItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SellItems
    **/
    _count?: true | SellItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SellItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SellItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellItemMaxAggregateInputType
  }

  export type GetSellItemAggregateType<T extends SellItemAggregateArgs> = {
        [P in keyof T & keyof AggregateSellItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSellItem[P]>
      : GetScalarType<T[P], AggregateSellItem[P]>
  }




  export type SellItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellItemWhereInput
    orderBy?: SellItemOrderByWithAggregationInput | SellItemOrderByWithAggregationInput[]
    by: SellItemScalarFieldEnum[] | SellItemScalarFieldEnum
    having?: SellItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellItemCountAggregateInputType | true
    _avg?: SellItemAvgAggregateInputType
    _sum?: SellItemSumAggregateInputType
    _min?: SellItemMinAggregateInputType
    _max?: SellItemMaxAggregateInputType
  }

  export type SellItemGroupByOutputType = {
    id: string
    sellId: string
    productId: string
    shopId: string
    unitOfMeasureId: string
    itemSaleStatus: $Enums.ItemSaleStatus
    quantity: number
    unitPrice: number
    totalPrice: number
    createdAt: Date
    updatedAt: Date
    _count: SellItemCountAggregateOutputType | null
    _avg: SellItemAvgAggregateOutputType | null
    _sum: SellItemSumAggregateOutputType | null
    _min: SellItemMinAggregateOutputType | null
    _max: SellItemMaxAggregateOutputType | null
  }

  type GetSellItemGroupByPayload<T extends SellItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellItemGroupByOutputType[P]>
            : GetScalarType<T[P], SellItemGroupByOutputType[P]>
        }
      >
    >


  export type SellItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellId?: boolean
    productId?: boolean
    shopId?: boolean
    unitOfMeasureId?: boolean
    itemSaleStatus?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sell?: boolean | SellDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    unitOfMeasure?: boolean | UnitOfMeasureDefaultArgs<ExtArgs>
    batches?: boolean | SellItem$batchesArgs<ExtArgs>
    _count?: boolean | SellItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sellItem"]>



  export type SellItemSelectScalar = {
    id?: boolean
    sellId?: boolean
    productId?: boolean
    shopId?: boolean
    unitOfMeasureId?: boolean
    itemSaleStatus?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SellItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sellId" | "productId" | "shopId" | "unitOfMeasureId" | "itemSaleStatus" | "quantity" | "unitPrice" | "totalPrice" | "createdAt" | "updatedAt", ExtArgs["result"]["sellItem"]>
  export type SellItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sell?: boolean | SellDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    unitOfMeasure?: boolean | UnitOfMeasureDefaultArgs<ExtArgs>
    batches?: boolean | SellItem$batchesArgs<ExtArgs>
    _count?: boolean | SellItemCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SellItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SellItem"
    objects: {
      sell: Prisma.$SellPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      shop: Prisma.$ShopPayload<ExtArgs>
      unitOfMeasure: Prisma.$UnitOfMeasurePayload<ExtArgs>
      batches: Prisma.$SellItemBatchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sellId: string
      productId: string
      shopId: string
      unitOfMeasureId: string
      itemSaleStatus: $Enums.ItemSaleStatus
      quantity: number
      unitPrice: number
      totalPrice: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sellItem"]>
    composites: {}
  }

  type SellItemGetPayload<S extends boolean | null | undefined | SellItemDefaultArgs> = $Result.GetResult<Prisma.$SellItemPayload, S>

  type SellItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SellItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SellItemCountAggregateInputType | true
    }

  export interface SellItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SellItem'], meta: { name: 'SellItem' } }
    /**
     * Find zero or one SellItem that matches the filter.
     * @param {SellItemFindUniqueArgs} args - Arguments to find a SellItem
     * @example
     * // Get one SellItem
     * const sellItem = await prisma.sellItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellItemFindUniqueArgs>(args: SelectSubset<T, SellItemFindUniqueArgs<ExtArgs>>): Prisma__SellItemClient<$Result.GetResult<Prisma.$SellItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SellItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SellItemFindUniqueOrThrowArgs} args - Arguments to find a SellItem
     * @example
     * // Get one SellItem
     * const sellItem = await prisma.sellItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellItemFindUniqueOrThrowArgs>(args: SelectSubset<T, SellItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellItemClient<$Result.GetResult<Prisma.$SellItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellItemFindFirstArgs} args - Arguments to find a SellItem
     * @example
     * // Get one SellItem
     * const sellItem = await prisma.sellItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellItemFindFirstArgs>(args?: SelectSubset<T, SellItemFindFirstArgs<ExtArgs>>): Prisma__SellItemClient<$Result.GetResult<Prisma.$SellItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellItemFindFirstOrThrowArgs} args - Arguments to find a SellItem
     * @example
     * // Get one SellItem
     * const sellItem = await prisma.sellItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellItemFindFirstOrThrowArgs>(args?: SelectSubset<T, SellItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellItemClient<$Result.GetResult<Prisma.$SellItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SellItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SellItems
     * const sellItems = await prisma.sellItem.findMany()
     * 
     * // Get first 10 SellItems
     * const sellItems = await prisma.sellItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellItemWithIdOnly = await prisma.sellItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellItemFindManyArgs>(args?: SelectSubset<T, SellItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SellItem.
     * @param {SellItemCreateArgs} args - Arguments to create a SellItem.
     * @example
     * // Create one SellItem
     * const SellItem = await prisma.sellItem.create({
     *   data: {
     *     // ... data to create a SellItem
     *   }
     * })
     * 
     */
    create<T extends SellItemCreateArgs>(args: SelectSubset<T, SellItemCreateArgs<ExtArgs>>): Prisma__SellItemClient<$Result.GetResult<Prisma.$SellItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SellItems.
     * @param {SellItemCreateManyArgs} args - Arguments to create many SellItems.
     * @example
     * // Create many SellItems
     * const sellItem = await prisma.sellItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellItemCreateManyArgs>(args?: SelectSubset<T, SellItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SellItem.
     * @param {SellItemDeleteArgs} args - Arguments to delete one SellItem.
     * @example
     * // Delete one SellItem
     * const SellItem = await prisma.sellItem.delete({
     *   where: {
     *     // ... filter to delete one SellItem
     *   }
     * })
     * 
     */
    delete<T extends SellItemDeleteArgs>(args: SelectSubset<T, SellItemDeleteArgs<ExtArgs>>): Prisma__SellItemClient<$Result.GetResult<Prisma.$SellItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SellItem.
     * @param {SellItemUpdateArgs} args - Arguments to update one SellItem.
     * @example
     * // Update one SellItem
     * const sellItem = await prisma.sellItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellItemUpdateArgs>(args: SelectSubset<T, SellItemUpdateArgs<ExtArgs>>): Prisma__SellItemClient<$Result.GetResult<Prisma.$SellItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SellItems.
     * @param {SellItemDeleteManyArgs} args - Arguments to filter SellItems to delete.
     * @example
     * // Delete a few SellItems
     * const { count } = await prisma.sellItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellItemDeleteManyArgs>(args?: SelectSubset<T, SellItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SellItems
     * const sellItem = await prisma.sellItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellItemUpdateManyArgs>(args: SelectSubset<T, SellItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SellItem.
     * @param {SellItemUpsertArgs} args - Arguments to update or create a SellItem.
     * @example
     * // Update or create a SellItem
     * const sellItem = await prisma.sellItem.upsert({
     *   create: {
     *     // ... data to create a SellItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SellItem we want to update
     *   }
     * })
     */
    upsert<T extends SellItemUpsertArgs>(args: SelectSubset<T, SellItemUpsertArgs<ExtArgs>>): Prisma__SellItemClient<$Result.GetResult<Prisma.$SellItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SellItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellItemCountArgs} args - Arguments to filter SellItems to count.
     * @example
     * // Count the number of SellItems
     * const count = await prisma.sellItem.count({
     *   where: {
     *     // ... the filter for the SellItems we want to count
     *   }
     * })
    **/
    count<T extends SellItemCountArgs>(
      args?: Subset<T, SellItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SellItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellItemAggregateArgs>(args: Subset<T, SellItemAggregateArgs>): Prisma.PrismaPromise<GetSellItemAggregateType<T>>

    /**
     * Group by SellItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellItemGroupByArgs['orderBy'] }
        : { orderBy?: SellItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SellItem model
   */
  readonly fields: SellItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SellItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sell<T extends SellDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SellDefaultArgs<ExtArgs>>): Prisma__SellClient<$Result.GetResult<Prisma.$SellPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unitOfMeasure<T extends UnitOfMeasureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasureDefaultArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    batches<T extends SellItem$batchesArgs<ExtArgs> = {}>(args?: Subset<T, SellItem$batchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellItemBatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SellItem model
   */
  interface SellItemFieldRefs {
    readonly id: FieldRef<"SellItem", 'String'>
    readonly sellId: FieldRef<"SellItem", 'String'>
    readonly productId: FieldRef<"SellItem", 'String'>
    readonly shopId: FieldRef<"SellItem", 'String'>
    readonly unitOfMeasureId: FieldRef<"SellItem", 'String'>
    readonly itemSaleStatus: FieldRef<"SellItem", 'ItemSaleStatus'>
    readonly quantity: FieldRef<"SellItem", 'Int'>
    readonly unitPrice: FieldRef<"SellItem", 'Float'>
    readonly totalPrice: FieldRef<"SellItem", 'Float'>
    readonly createdAt: FieldRef<"SellItem", 'DateTime'>
    readonly updatedAt: FieldRef<"SellItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SellItem findUnique
   */
  export type SellItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItem
     */
    select?: SellItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellItem
     */
    omit?: SellItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellItemInclude<ExtArgs> | null
    /**
     * Filter, which SellItem to fetch.
     */
    where: SellItemWhereUniqueInput
  }

  /**
   * SellItem findUniqueOrThrow
   */
  export type SellItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItem
     */
    select?: SellItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellItem
     */
    omit?: SellItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellItemInclude<ExtArgs> | null
    /**
     * Filter, which SellItem to fetch.
     */
    where: SellItemWhereUniqueInput
  }

  /**
   * SellItem findFirst
   */
  export type SellItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItem
     */
    select?: SellItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellItem
     */
    omit?: SellItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellItemInclude<ExtArgs> | null
    /**
     * Filter, which SellItem to fetch.
     */
    where?: SellItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellItems to fetch.
     */
    orderBy?: SellItemOrderByWithRelationInput | SellItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellItems.
     */
    cursor?: SellItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellItems.
     */
    distinct?: SellItemScalarFieldEnum | SellItemScalarFieldEnum[]
  }

  /**
   * SellItem findFirstOrThrow
   */
  export type SellItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItem
     */
    select?: SellItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellItem
     */
    omit?: SellItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellItemInclude<ExtArgs> | null
    /**
     * Filter, which SellItem to fetch.
     */
    where?: SellItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellItems to fetch.
     */
    orderBy?: SellItemOrderByWithRelationInput | SellItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellItems.
     */
    cursor?: SellItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellItems.
     */
    distinct?: SellItemScalarFieldEnum | SellItemScalarFieldEnum[]
  }

  /**
   * SellItem findMany
   */
  export type SellItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItem
     */
    select?: SellItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellItem
     */
    omit?: SellItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellItemInclude<ExtArgs> | null
    /**
     * Filter, which SellItems to fetch.
     */
    where?: SellItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellItems to fetch.
     */
    orderBy?: SellItemOrderByWithRelationInput | SellItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SellItems.
     */
    cursor?: SellItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellItems.
     */
    skip?: number
    distinct?: SellItemScalarFieldEnum | SellItemScalarFieldEnum[]
  }

  /**
   * SellItem create
   */
  export type SellItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItem
     */
    select?: SellItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellItem
     */
    omit?: SellItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellItemInclude<ExtArgs> | null
    /**
     * The data needed to create a SellItem.
     */
    data: XOR<SellItemCreateInput, SellItemUncheckedCreateInput>
  }

  /**
   * SellItem createMany
   */
  export type SellItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SellItems.
     */
    data: SellItemCreateManyInput | SellItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SellItem update
   */
  export type SellItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItem
     */
    select?: SellItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellItem
     */
    omit?: SellItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellItemInclude<ExtArgs> | null
    /**
     * The data needed to update a SellItem.
     */
    data: XOR<SellItemUpdateInput, SellItemUncheckedUpdateInput>
    /**
     * Choose, which SellItem to update.
     */
    where: SellItemWhereUniqueInput
  }

  /**
   * SellItem updateMany
   */
  export type SellItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SellItems.
     */
    data: XOR<SellItemUpdateManyMutationInput, SellItemUncheckedUpdateManyInput>
    /**
     * Filter which SellItems to update
     */
    where?: SellItemWhereInput
    /**
     * Limit how many SellItems to update.
     */
    limit?: number
  }

  /**
   * SellItem upsert
   */
  export type SellItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItem
     */
    select?: SellItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellItem
     */
    omit?: SellItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellItemInclude<ExtArgs> | null
    /**
     * The filter to search for the SellItem to update in case it exists.
     */
    where: SellItemWhereUniqueInput
    /**
     * In case the SellItem found by the `where` argument doesn't exist, create a new SellItem with this data.
     */
    create: XOR<SellItemCreateInput, SellItemUncheckedCreateInput>
    /**
     * In case the SellItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellItemUpdateInput, SellItemUncheckedUpdateInput>
  }

  /**
   * SellItem delete
   */
  export type SellItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItem
     */
    select?: SellItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellItem
     */
    omit?: SellItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellItemInclude<ExtArgs> | null
    /**
     * Filter which SellItem to delete.
     */
    where: SellItemWhereUniqueInput
  }

  /**
   * SellItem deleteMany
   */
  export type SellItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellItems to delete
     */
    where?: SellItemWhereInput
    /**
     * Limit how many SellItems to delete.
     */
    limit?: number
  }

  /**
   * SellItem.batches
   */
  export type SellItem$batchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItemBatch
     */
    select?: SellItemBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellItemBatch
     */
    omit?: SellItemBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellItemBatchInclude<ExtArgs> | null
    where?: SellItemBatchWhereInput
    orderBy?: SellItemBatchOrderByWithRelationInput | SellItemBatchOrderByWithRelationInput[]
    cursor?: SellItemBatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellItemBatchScalarFieldEnum | SellItemBatchScalarFieldEnum[]
  }

  /**
   * SellItem without action
   */
  export type SellItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItem
     */
    select?: SellItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellItem
     */
    omit?: SellItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellItemInclude<ExtArgs> | null
  }


  /**
   * Model SellItemBatch
   */

  export type AggregateSellItemBatch = {
    _count: SellItemBatchCountAggregateOutputType | null
    _avg: SellItemBatchAvgAggregateOutputType | null
    _sum: SellItemBatchSumAggregateOutputType | null
    _min: SellItemBatchMinAggregateOutputType | null
    _max: SellItemBatchMaxAggregateOutputType | null
  }

  export type SellItemBatchAvgAggregateOutputType = {
    quantity: number | null
  }

  export type SellItemBatchSumAggregateOutputType = {
    quantity: number | null
  }

  export type SellItemBatchMinAggregateOutputType = {
    id: string | null
    sellItemId: string | null
    batchId: string | null
    quantity: number | null
  }

  export type SellItemBatchMaxAggregateOutputType = {
    id: string | null
    sellItemId: string | null
    batchId: string | null
    quantity: number | null
  }

  export type SellItemBatchCountAggregateOutputType = {
    id: number
    sellItemId: number
    batchId: number
    quantity: number
    _all: number
  }


  export type SellItemBatchAvgAggregateInputType = {
    quantity?: true
  }

  export type SellItemBatchSumAggregateInputType = {
    quantity?: true
  }

  export type SellItemBatchMinAggregateInputType = {
    id?: true
    sellItemId?: true
    batchId?: true
    quantity?: true
  }

  export type SellItemBatchMaxAggregateInputType = {
    id?: true
    sellItemId?: true
    batchId?: true
    quantity?: true
  }

  export type SellItemBatchCountAggregateInputType = {
    id?: true
    sellItemId?: true
    batchId?: true
    quantity?: true
    _all?: true
  }

  export type SellItemBatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellItemBatch to aggregate.
     */
    where?: SellItemBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellItemBatches to fetch.
     */
    orderBy?: SellItemBatchOrderByWithRelationInput | SellItemBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellItemBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellItemBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellItemBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SellItemBatches
    **/
    _count?: true | SellItemBatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SellItemBatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SellItemBatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellItemBatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellItemBatchMaxAggregateInputType
  }

  export type GetSellItemBatchAggregateType<T extends SellItemBatchAggregateArgs> = {
        [P in keyof T & keyof AggregateSellItemBatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSellItemBatch[P]>
      : GetScalarType<T[P], AggregateSellItemBatch[P]>
  }




  export type SellItemBatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellItemBatchWhereInput
    orderBy?: SellItemBatchOrderByWithAggregationInput | SellItemBatchOrderByWithAggregationInput[]
    by: SellItemBatchScalarFieldEnum[] | SellItemBatchScalarFieldEnum
    having?: SellItemBatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellItemBatchCountAggregateInputType | true
    _avg?: SellItemBatchAvgAggregateInputType
    _sum?: SellItemBatchSumAggregateInputType
    _min?: SellItemBatchMinAggregateInputType
    _max?: SellItemBatchMaxAggregateInputType
  }

  export type SellItemBatchGroupByOutputType = {
    id: string
    sellItemId: string
    batchId: string
    quantity: number
    _count: SellItemBatchCountAggregateOutputType | null
    _avg: SellItemBatchAvgAggregateOutputType | null
    _sum: SellItemBatchSumAggregateOutputType | null
    _min: SellItemBatchMinAggregateOutputType | null
    _max: SellItemBatchMaxAggregateOutputType | null
  }

  type GetSellItemBatchGroupByPayload<T extends SellItemBatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellItemBatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellItemBatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellItemBatchGroupByOutputType[P]>
            : GetScalarType<T[P], SellItemBatchGroupByOutputType[P]>
        }
      >
    >


  export type SellItemBatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellItemId?: boolean
    batchId?: boolean
    quantity?: boolean
    sellItem?: boolean | SellItemDefaultArgs<ExtArgs>
    batch?: boolean | ProductBatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sellItemBatch"]>



  export type SellItemBatchSelectScalar = {
    id?: boolean
    sellItemId?: boolean
    batchId?: boolean
    quantity?: boolean
  }

  export type SellItemBatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sellItemId" | "batchId" | "quantity", ExtArgs["result"]["sellItemBatch"]>
  export type SellItemBatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sellItem?: boolean | SellItemDefaultArgs<ExtArgs>
    batch?: boolean | ProductBatchDefaultArgs<ExtArgs>
  }

  export type $SellItemBatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SellItemBatch"
    objects: {
      sellItem: Prisma.$SellItemPayload<ExtArgs>
      batch: Prisma.$ProductBatchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sellItemId: string
      batchId: string
      quantity: number
    }, ExtArgs["result"]["sellItemBatch"]>
    composites: {}
  }

  type SellItemBatchGetPayload<S extends boolean | null | undefined | SellItemBatchDefaultArgs> = $Result.GetResult<Prisma.$SellItemBatchPayload, S>

  type SellItemBatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SellItemBatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SellItemBatchCountAggregateInputType | true
    }

  export interface SellItemBatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SellItemBatch'], meta: { name: 'SellItemBatch' } }
    /**
     * Find zero or one SellItemBatch that matches the filter.
     * @param {SellItemBatchFindUniqueArgs} args - Arguments to find a SellItemBatch
     * @example
     * // Get one SellItemBatch
     * const sellItemBatch = await prisma.sellItemBatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellItemBatchFindUniqueArgs>(args: SelectSubset<T, SellItemBatchFindUniqueArgs<ExtArgs>>): Prisma__SellItemBatchClient<$Result.GetResult<Prisma.$SellItemBatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SellItemBatch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SellItemBatchFindUniqueOrThrowArgs} args - Arguments to find a SellItemBatch
     * @example
     * // Get one SellItemBatch
     * const sellItemBatch = await prisma.sellItemBatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellItemBatchFindUniqueOrThrowArgs>(args: SelectSubset<T, SellItemBatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellItemBatchClient<$Result.GetResult<Prisma.$SellItemBatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellItemBatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellItemBatchFindFirstArgs} args - Arguments to find a SellItemBatch
     * @example
     * // Get one SellItemBatch
     * const sellItemBatch = await prisma.sellItemBatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellItemBatchFindFirstArgs>(args?: SelectSubset<T, SellItemBatchFindFirstArgs<ExtArgs>>): Prisma__SellItemBatchClient<$Result.GetResult<Prisma.$SellItemBatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellItemBatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellItemBatchFindFirstOrThrowArgs} args - Arguments to find a SellItemBatch
     * @example
     * // Get one SellItemBatch
     * const sellItemBatch = await prisma.sellItemBatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellItemBatchFindFirstOrThrowArgs>(args?: SelectSubset<T, SellItemBatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellItemBatchClient<$Result.GetResult<Prisma.$SellItemBatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SellItemBatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellItemBatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SellItemBatches
     * const sellItemBatches = await prisma.sellItemBatch.findMany()
     * 
     * // Get first 10 SellItemBatches
     * const sellItemBatches = await prisma.sellItemBatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellItemBatchWithIdOnly = await prisma.sellItemBatch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellItemBatchFindManyArgs>(args?: SelectSubset<T, SellItemBatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellItemBatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SellItemBatch.
     * @param {SellItemBatchCreateArgs} args - Arguments to create a SellItemBatch.
     * @example
     * // Create one SellItemBatch
     * const SellItemBatch = await prisma.sellItemBatch.create({
     *   data: {
     *     // ... data to create a SellItemBatch
     *   }
     * })
     * 
     */
    create<T extends SellItemBatchCreateArgs>(args: SelectSubset<T, SellItemBatchCreateArgs<ExtArgs>>): Prisma__SellItemBatchClient<$Result.GetResult<Prisma.$SellItemBatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SellItemBatches.
     * @param {SellItemBatchCreateManyArgs} args - Arguments to create many SellItemBatches.
     * @example
     * // Create many SellItemBatches
     * const sellItemBatch = await prisma.sellItemBatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellItemBatchCreateManyArgs>(args?: SelectSubset<T, SellItemBatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SellItemBatch.
     * @param {SellItemBatchDeleteArgs} args - Arguments to delete one SellItemBatch.
     * @example
     * // Delete one SellItemBatch
     * const SellItemBatch = await prisma.sellItemBatch.delete({
     *   where: {
     *     // ... filter to delete one SellItemBatch
     *   }
     * })
     * 
     */
    delete<T extends SellItemBatchDeleteArgs>(args: SelectSubset<T, SellItemBatchDeleteArgs<ExtArgs>>): Prisma__SellItemBatchClient<$Result.GetResult<Prisma.$SellItemBatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SellItemBatch.
     * @param {SellItemBatchUpdateArgs} args - Arguments to update one SellItemBatch.
     * @example
     * // Update one SellItemBatch
     * const sellItemBatch = await prisma.sellItemBatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellItemBatchUpdateArgs>(args: SelectSubset<T, SellItemBatchUpdateArgs<ExtArgs>>): Prisma__SellItemBatchClient<$Result.GetResult<Prisma.$SellItemBatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SellItemBatches.
     * @param {SellItemBatchDeleteManyArgs} args - Arguments to filter SellItemBatches to delete.
     * @example
     * // Delete a few SellItemBatches
     * const { count } = await prisma.sellItemBatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellItemBatchDeleteManyArgs>(args?: SelectSubset<T, SellItemBatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellItemBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellItemBatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SellItemBatches
     * const sellItemBatch = await prisma.sellItemBatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellItemBatchUpdateManyArgs>(args: SelectSubset<T, SellItemBatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SellItemBatch.
     * @param {SellItemBatchUpsertArgs} args - Arguments to update or create a SellItemBatch.
     * @example
     * // Update or create a SellItemBatch
     * const sellItemBatch = await prisma.sellItemBatch.upsert({
     *   create: {
     *     // ... data to create a SellItemBatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SellItemBatch we want to update
     *   }
     * })
     */
    upsert<T extends SellItemBatchUpsertArgs>(args: SelectSubset<T, SellItemBatchUpsertArgs<ExtArgs>>): Prisma__SellItemBatchClient<$Result.GetResult<Prisma.$SellItemBatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SellItemBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellItemBatchCountArgs} args - Arguments to filter SellItemBatches to count.
     * @example
     * // Count the number of SellItemBatches
     * const count = await prisma.sellItemBatch.count({
     *   where: {
     *     // ... the filter for the SellItemBatches we want to count
     *   }
     * })
    **/
    count<T extends SellItemBatchCountArgs>(
      args?: Subset<T, SellItemBatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellItemBatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SellItemBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellItemBatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellItemBatchAggregateArgs>(args: Subset<T, SellItemBatchAggregateArgs>): Prisma.PrismaPromise<GetSellItemBatchAggregateType<T>>

    /**
     * Group by SellItemBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellItemBatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellItemBatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellItemBatchGroupByArgs['orderBy'] }
        : { orderBy?: SellItemBatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellItemBatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellItemBatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SellItemBatch model
   */
  readonly fields: SellItemBatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SellItemBatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellItemBatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sellItem<T extends SellItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SellItemDefaultArgs<ExtArgs>>): Prisma__SellItemClient<$Result.GetResult<Prisma.$SellItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    batch<T extends ProductBatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductBatchDefaultArgs<ExtArgs>>): Prisma__ProductBatchClient<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SellItemBatch model
   */
  interface SellItemBatchFieldRefs {
    readonly id: FieldRef<"SellItemBatch", 'String'>
    readonly sellItemId: FieldRef<"SellItemBatch", 'String'>
    readonly batchId: FieldRef<"SellItemBatch", 'String'>
    readonly quantity: FieldRef<"SellItemBatch", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SellItemBatch findUnique
   */
  export type SellItemBatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItemBatch
     */
    select?: SellItemBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellItemBatch
     */
    omit?: SellItemBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellItemBatchInclude<ExtArgs> | null
    /**
     * Filter, which SellItemBatch to fetch.
     */
    where: SellItemBatchWhereUniqueInput
  }

  /**
   * SellItemBatch findUniqueOrThrow
   */
  export type SellItemBatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItemBatch
     */
    select?: SellItemBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellItemBatch
     */
    omit?: SellItemBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellItemBatchInclude<ExtArgs> | null
    /**
     * Filter, which SellItemBatch to fetch.
     */
    where: SellItemBatchWhereUniqueInput
  }

  /**
   * SellItemBatch findFirst
   */
  export type SellItemBatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItemBatch
     */
    select?: SellItemBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellItemBatch
     */
    omit?: SellItemBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellItemBatchInclude<ExtArgs> | null
    /**
     * Filter, which SellItemBatch to fetch.
     */
    where?: SellItemBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellItemBatches to fetch.
     */
    orderBy?: SellItemBatchOrderByWithRelationInput | SellItemBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellItemBatches.
     */
    cursor?: SellItemBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellItemBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellItemBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellItemBatches.
     */
    distinct?: SellItemBatchScalarFieldEnum | SellItemBatchScalarFieldEnum[]
  }

  /**
   * SellItemBatch findFirstOrThrow
   */
  export type SellItemBatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItemBatch
     */
    select?: SellItemBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellItemBatch
     */
    omit?: SellItemBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellItemBatchInclude<ExtArgs> | null
    /**
     * Filter, which SellItemBatch to fetch.
     */
    where?: SellItemBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellItemBatches to fetch.
     */
    orderBy?: SellItemBatchOrderByWithRelationInput | SellItemBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellItemBatches.
     */
    cursor?: SellItemBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellItemBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellItemBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellItemBatches.
     */
    distinct?: SellItemBatchScalarFieldEnum | SellItemBatchScalarFieldEnum[]
  }

  /**
   * SellItemBatch findMany
   */
  export type SellItemBatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItemBatch
     */
    select?: SellItemBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellItemBatch
     */
    omit?: SellItemBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellItemBatchInclude<ExtArgs> | null
    /**
     * Filter, which SellItemBatches to fetch.
     */
    where?: SellItemBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellItemBatches to fetch.
     */
    orderBy?: SellItemBatchOrderByWithRelationInput | SellItemBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SellItemBatches.
     */
    cursor?: SellItemBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellItemBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellItemBatches.
     */
    skip?: number
    distinct?: SellItemBatchScalarFieldEnum | SellItemBatchScalarFieldEnum[]
  }

  /**
   * SellItemBatch create
   */
  export type SellItemBatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItemBatch
     */
    select?: SellItemBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellItemBatch
     */
    omit?: SellItemBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellItemBatchInclude<ExtArgs> | null
    /**
     * The data needed to create a SellItemBatch.
     */
    data: XOR<SellItemBatchCreateInput, SellItemBatchUncheckedCreateInput>
  }

  /**
   * SellItemBatch createMany
   */
  export type SellItemBatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SellItemBatches.
     */
    data: SellItemBatchCreateManyInput | SellItemBatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SellItemBatch update
   */
  export type SellItemBatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItemBatch
     */
    select?: SellItemBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellItemBatch
     */
    omit?: SellItemBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellItemBatchInclude<ExtArgs> | null
    /**
     * The data needed to update a SellItemBatch.
     */
    data: XOR<SellItemBatchUpdateInput, SellItemBatchUncheckedUpdateInput>
    /**
     * Choose, which SellItemBatch to update.
     */
    where: SellItemBatchWhereUniqueInput
  }

  /**
   * SellItemBatch updateMany
   */
  export type SellItemBatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SellItemBatches.
     */
    data: XOR<SellItemBatchUpdateManyMutationInput, SellItemBatchUncheckedUpdateManyInput>
    /**
     * Filter which SellItemBatches to update
     */
    where?: SellItemBatchWhereInput
    /**
     * Limit how many SellItemBatches to update.
     */
    limit?: number
  }

  /**
   * SellItemBatch upsert
   */
  export type SellItemBatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItemBatch
     */
    select?: SellItemBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellItemBatch
     */
    omit?: SellItemBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellItemBatchInclude<ExtArgs> | null
    /**
     * The filter to search for the SellItemBatch to update in case it exists.
     */
    where: SellItemBatchWhereUniqueInput
    /**
     * In case the SellItemBatch found by the `where` argument doesn't exist, create a new SellItemBatch with this data.
     */
    create: XOR<SellItemBatchCreateInput, SellItemBatchUncheckedCreateInput>
    /**
     * In case the SellItemBatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellItemBatchUpdateInput, SellItemBatchUncheckedUpdateInput>
  }

  /**
   * SellItemBatch delete
   */
  export type SellItemBatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItemBatch
     */
    select?: SellItemBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellItemBatch
     */
    omit?: SellItemBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellItemBatchInclude<ExtArgs> | null
    /**
     * Filter which SellItemBatch to delete.
     */
    where: SellItemBatchWhereUniqueInput
  }

  /**
   * SellItemBatch deleteMany
   */
  export type SellItemBatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellItemBatches to delete
     */
    where?: SellItemBatchWhereInput
    /**
     * Limit how many SellItemBatches to delete.
     */
    limit?: number
  }

  /**
   * SellItemBatch without action
   */
  export type SellItemBatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellItemBatch
     */
    select?: SellItemBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellItemBatch
     */
    omit?: SellItemBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellItemBatchInclude<ExtArgs> | null
  }


  /**
   * Model AddToCart
   */

  export type AggregateAddToCart = {
    _count: AddToCartCountAggregateOutputType | null
    _avg: AddToCartAvgAggregateOutputType | null
    _sum: AddToCartSumAggregateOutputType | null
    _min: AddToCartMinAggregateOutputType | null
    _max: AddToCartMaxAggregateOutputType | null
  }

  export type AddToCartAvgAggregateOutputType = {
    totalItems: number | null
    totalAmount: number | null
  }

  export type AddToCartSumAggregateOutputType = {
    totalItems: number | null
    totalAmount: number | null
  }

  export type AddToCartMinAggregateOutputType = {
    id: string | null
    userId: string | null
    branchId: string | null
    isCheckedOut: boolean | null
    isWaitlist: boolean | null
    customerId: string | null
    totalItems: number | null
    totalAmount: number | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddToCartMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    branchId: string | null
    isCheckedOut: boolean | null
    isWaitlist: boolean | null
    customerId: string | null
    totalItems: number | null
    totalAmount: number | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddToCartCountAggregateOutputType = {
    id: number
    userId: number
    branchId: number
    isCheckedOut: number
    isWaitlist: number
    customerId: number
    totalItems: number
    totalAmount: number
    createdById: number
    updatedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AddToCartAvgAggregateInputType = {
    totalItems?: true
    totalAmount?: true
  }

  export type AddToCartSumAggregateInputType = {
    totalItems?: true
    totalAmount?: true
  }

  export type AddToCartMinAggregateInputType = {
    id?: true
    userId?: true
    branchId?: true
    isCheckedOut?: true
    isWaitlist?: true
    customerId?: true
    totalItems?: true
    totalAmount?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddToCartMaxAggregateInputType = {
    id?: true
    userId?: true
    branchId?: true
    isCheckedOut?: true
    isWaitlist?: true
    customerId?: true
    totalItems?: true
    totalAmount?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddToCartCountAggregateInputType = {
    id?: true
    userId?: true
    branchId?: true
    isCheckedOut?: true
    isWaitlist?: true
    customerId?: true
    totalItems?: true
    totalAmount?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AddToCartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddToCart to aggregate.
     */
    where?: AddToCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddToCarts to fetch.
     */
    orderBy?: AddToCartOrderByWithRelationInput | AddToCartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddToCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddToCarts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddToCarts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AddToCarts
    **/
    _count?: true | AddToCartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddToCartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddToCartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddToCartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddToCartMaxAggregateInputType
  }

  export type GetAddToCartAggregateType<T extends AddToCartAggregateArgs> = {
        [P in keyof T & keyof AggregateAddToCart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddToCart[P]>
      : GetScalarType<T[P], AggregateAddToCart[P]>
  }




  export type AddToCartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddToCartWhereInput
    orderBy?: AddToCartOrderByWithAggregationInput | AddToCartOrderByWithAggregationInput[]
    by: AddToCartScalarFieldEnum[] | AddToCartScalarFieldEnum
    having?: AddToCartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddToCartCountAggregateInputType | true
    _avg?: AddToCartAvgAggregateInputType
    _sum?: AddToCartSumAggregateInputType
    _min?: AddToCartMinAggregateInputType
    _max?: AddToCartMaxAggregateInputType
  }

  export type AddToCartGroupByOutputType = {
    id: string
    userId: string
    branchId: string | null
    isCheckedOut: boolean
    isWaitlist: boolean
    customerId: string | null
    totalItems: number
    totalAmount: number
    createdById: string | null
    updatedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: AddToCartCountAggregateOutputType | null
    _avg: AddToCartAvgAggregateOutputType | null
    _sum: AddToCartSumAggregateOutputType | null
    _min: AddToCartMinAggregateOutputType | null
    _max: AddToCartMaxAggregateOutputType | null
  }

  type GetAddToCartGroupByPayload<T extends AddToCartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddToCartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddToCartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddToCartGroupByOutputType[P]>
            : GetScalarType<T[P], AddToCartGroupByOutputType[P]>
        }
      >
    >


  export type AddToCartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    branchId?: boolean
    isCheckedOut?: boolean
    isWaitlist?: boolean
    customerId?: boolean
    totalItems?: boolean
    totalAmount?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | AddToCart$branchArgs<ExtArgs>
    customer?: boolean | AddToCart$customerArgs<ExtArgs>
    createdBy?: boolean | AddToCart$createdByArgs<ExtArgs>
    updatedBy?: boolean | AddToCart$updatedByArgs<ExtArgs>
    items?: boolean | AddToCart$itemsArgs<ExtArgs>
    waitlists?: boolean | AddToCart$waitlistsArgs<ExtArgs>
    _count?: boolean | AddToCartCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addToCart"]>



  export type AddToCartSelectScalar = {
    id?: boolean
    userId?: boolean
    branchId?: boolean
    isCheckedOut?: boolean
    isWaitlist?: boolean
    customerId?: boolean
    totalItems?: boolean
    totalAmount?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AddToCartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "branchId" | "isCheckedOut" | "isWaitlist" | "customerId" | "totalItems" | "totalAmount" | "createdById" | "updatedById" | "createdAt" | "updatedAt", ExtArgs["result"]["addToCart"]>
  export type AddToCartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | AddToCart$branchArgs<ExtArgs>
    customer?: boolean | AddToCart$customerArgs<ExtArgs>
    createdBy?: boolean | AddToCart$createdByArgs<ExtArgs>
    updatedBy?: boolean | AddToCart$updatedByArgs<ExtArgs>
    items?: boolean | AddToCart$itemsArgs<ExtArgs>
    waitlists?: boolean | AddToCart$waitlistsArgs<ExtArgs>
    _count?: boolean | AddToCartCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AddToCartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AddToCart"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs> | null
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
      items: Prisma.$CartItemPayload<ExtArgs>[]
      waitlists: Prisma.$WaitlistPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      branchId: string | null
      isCheckedOut: boolean
      isWaitlist: boolean
      customerId: string | null
      totalItems: number
      totalAmount: number
      createdById: string | null
      updatedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["addToCart"]>
    composites: {}
  }

  type AddToCartGetPayload<S extends boolean | null | undefined | AddToCartDefaultArgs> = $Result.GetResult<Prisma.$AddToCartPayload, S>

  type AddToCartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddToCartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddToCartCountAggregateInputType | true
    }

  export interface AddToCartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AddToCart'], meta: { name: 'AddToCart' } }
    /**
     * Find zero or one AddToCart that matches the filter.
     * @param {AddToCartFindUniqueArgs} args - Arguments to find a AddToCart
     * @example
     * // Get one AddToCart
     * const addToCart = await prisma.addToCart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddToCartFindUniqueArgs>(args: SelectSubset<T, AddToCartFindUniqueArgs<ExtArgs>>): Prisma__AddToCartClient<$Result.GetResult<Prisma.$AddToCartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AddToCart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddToCartFindUniqueOrThrowArgs} args - Arguments to find a AddToCart
     * @example
     * // Get one AddToCart
     * const addToCart = await prisma.addToCart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddToCartFindUniqueOrThrowArgs>(args: SelectSubset<T, AddToCartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddToCartClient<$Result.GetResult<Prisma.$AddToCartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddToCart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddToCartFindFirstArgs} args - Arguments to find a AddToCart
     * @example
     * // Get one AddToCart
     * const addToCart = await prisma.addToCart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddToCartFindFirstArgs>(args?: SelectSubset<T, AddToCartFindFirstArgs<ExtArgs>>): Prisma__AddToCartClient<$Result.GetResult<Prisma.$AddToCartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddToCart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddToCartFindFirstOrThrowArgs} args - Arguments to find a AddToCart
     * @example
     * // Get one AddToCart
     * const addToCart = await prisma.addToCart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddToCartFindFirstOrThrowArgs>(args?: SelectSubset<T, AddToCartFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddToCartClient<$Result.GetResult<Prisma.$AddToCartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AddToCarts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddToCartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AddToCarts
     * const addToCarts = await prisma.addToCart.findMany()
     * 
     * // Get first 10 AddToCarts
     * const addToCarts = await prisma.addToCart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addToCartWithIdOnly = await prisma.addToCart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddToCartFindManyArgs>(args?: SelectSubset<T, AddToCartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddToCartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AddToCart.
     * @param {AddToCartCreateArgs} args - Arguments to create a AddToCart.
     * @example
     * // Create one AddToCart
     * const AddToCart = await prisma.addToCart.create({
     *   data: {
     *     // ... data to create a AddToCart
     *   }
     * })
     * 
     */
    create<T extends AddToCartCreateArgs>(args: SelectSubset<T, AddToCartCreateArgs<ExtArgs>>): Prisma__AddToCartClient<$Result.GetResult<Prisma.$AddToCartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AddToCarts.
     * @param {AddToCartCreateManyArgs} args - Arguments to create many AddToCarts.
     * @example
     * // Create many AddToCarts
     * const addToCart = await prisma.addToCart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddToCartCreateManyArgs>(args?: SelectSubset<T, AddToCartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AddToCart.
     * @param {AddToCartDeleteArgs} args - Arguments to delete one AddToCart.
     * @example
     * // Delete one AddToCart
     * const AddToCart = await prisma.addToCart.delete({
     *   where: {
     *     // ... filter to delete one AddToCart
     *   }
     * })
     * 
     */
    delete<T extends AddToCartDeleteArgs>(args: SelectSubset<T, AddToCartDeleteArgs<ExtArgs>>): Prisma__AddToCartClient<$Result.GetResult<Prisma.$AddToCartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AddToCart.
     * @param {AddToCartUpdateArgs} args - Arguments to update one AddToCart.
     * @example
     * // Update one AddToCart
     * const addToCart = await prisma.addToCart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddToCartUpdateArgs>(args: SelectSubset<T, AddToCartUpdateArgs<ExtArgs>>): Prisma__AddToCartClient<$Result.GetResult<Prisma.$AddToCartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AddToCarts.
     * @param {AddToCartDeleteManyArgs} args - Arguments to filter AddToCarts to delete.
     * @example
     * // Delete a few AddToCarts
     * const { count } = await prisma.addToCart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddToCartDeleteManyArgs>(args?: SelectSubset<T, AddToCartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddToCarts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddToCartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AddToCarts
     * const addToCart = await prisma.addToCart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddToCartUpdateManyArgs>(args: SelectSubset<T, AddToCartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AddToCart.
     * @param {AddToCartUpsertArgs} args - Arguments to update or create a AddToCart.
     * @example
     * // Update or create a AddToCart
     * const addToCart = await prisma.addToCart.upsert({
     *   create: {
     *     // ... data to create a AddToCart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AddToCart we want to update
     *   }
     * })
     */
    upsert<T extends AddToCartUpsertArgs>(args: SelectSubset<T, AddToCartUpsertArgs<ExtArgs>>): Prisma__AddToCartClient<$Result.GetResult<Prisma.$AddToCartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AddToCarts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddToCartCountArgs} args - Arguments to filter AddToCarts to count.
     * @example
     * // Count the number of AddToCarts
     * const count = await prisma.addToCart.count({
     *   where: {
     *     // ... the filter for the AddToCarts we want to count
     *   }
     * })
    **/
    count<T extends AddToCartCountArgs>(
      args?: Subset<T, AddToCartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddToCartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AddToCart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddToCartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddToCartAggregateArgs>(args: Subset<T, AddToCartAggregateArgs>): Prisma.PrismaPromise<GetAddToCartAggregateType<T>>

    /**
     * Group by AddToCart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddToCartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddToCartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddToCartGroupByArgs['orderBy'] }
        : { orderBy?: AddToCartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddToCartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddToCartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AddToCart model
   */
  readonly fields: AddToCartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AddToCart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddToCartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    branch<T extends AddToCart$branchArgs<ExtArgs> = {}>(args?: Subset<T, AddToCart$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customer<T extends AddToCart$customerArgs<ExtArgs> = {}>(args?: Subset<T, AddToCart$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends AddToCart$createdByArgs<ExtArgs> = {}>(args?: Subset<T, AddToCart$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends AddToCart$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, AddToCart$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends AddToCart$itemsArgs<ExtArgs> = {}>(args?: Subset<T, AddToCart$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    waitlists<T extends AddToCart$waitlistsArgs<ExtArgs> = {}>(args?: Subset<T, AddToCart$waitlistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AddToCart model
   */
  interface AddToCartFieldRefs {
    readonly id: FieldRef<"AddToCart", 'String'>
    readonly userId: FieldRef<"AddToCart", 'String'>
    readonly branchId: FieldRef<"AddToCart", 'String'>
    readonly isCheckedOut: FieldRef<"AddToCart", 'Boolean'>
    readonly isWaitlist: FieldRef<"AddToCart", 'Boolean'>
    readonly customerId: FieldRef<"AddToCart", 'String'>
    readonly totalItems: FieldRef<"AddToCart", 'Int'>
    readonly totalAmount: FieldRef<"AddToCart", 'Float'>
    readonly createdById: FieldRef<"AddToCart", 'String'>
    readonly updatedById: FieldRef<"AddToCart", 'String'>
    readonly createdAt: FieldRef<"AddToCart", 'DateTime'>
    readonly updatedAt: FieldRef<"AddToCart", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AddToCart findUnique
   */
  export type AddToCartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToCart
     */
    select?: AddToCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddToCart
     */
    omit?: AddToCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddToCartInclude<ExtArgs> | null
    /**
     * Filter, which AddToCart to fetch.
     */
    where: AddToCartWhereUniqueInput
  }

  /**
   * AddToCart findUniqueOrThrow
   */
  export type AddToCartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToCart
     */
    select?: AddToCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddToCart
     */
    omit?: AddToCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddToCartInclude<ExtArgs> | null
    /**
     * Filter, which AddToCart to fetch.
     */
    where: AddToCartWhereUniqueInput
  }

  /**
   * AddToCart findFirst
   */
  export type AddToCartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToCart
     */
    select?: AddToCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddToCart
     */
    omit?: AddToCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddToCartInclude<ExtArgs> | null
    /**
     * Filter, which AddToCart to fetch.
     */
    where?: AddToCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddToCarts to fetch.
     */
    orderBy?: AddToCartOrderByWithRelationInput | AddToCartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddToCarts.
     */
    cursor?: AddToCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddToCarts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddToCarts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddToCarts.
     */
    distinct?: AddToCartScalarFieldEnum | AddToCartScalarFieldEnum[]
  }

  /**
   * AddToCart findFirstOrThrow
   */
  export type AddToCartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToCart
     */
    select?: AddToCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddToCart
     */
    omit?: AddToCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddToCartInclude<ExtArgs> | null
    /**
     * Filter, which AddToCart to fetch.
     */
    where?: AddToCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddToCarts to fetch.
     */
    orderBy?: AddToCartOrderByWithRelationInput | AddToCartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddToCarts.
     */
    cursor?: AddToCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddToCarts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddToCarts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddToCarts.
     */
    distinct?: AddToCartScalarFieldEnum | AddToCartScalarFieldEnum[]
  }

  /**
   * AddToCart findMany
   */
  export type AddToCartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToCart
     */
    select?: AddToCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddToCart
     */
    omit?: AddToCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddToCartInclude<ExtArgs> | null
    /**
     * Filter, which AddToCarts to fetch.
     */
    where?: AddToCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddToCarts to fetch.
     */
    orderBy?: AddToCartOrderByWithRelationInput | AddToCartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AddToCarts.
     */
    cursor?: AddToCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddToCarts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddToCarts.
     */
    skip?: number
    distinct?: AddToCartScalarFieldEnum | AddToCartScalarFieldEnum[]
  }

  /**
   * AddToCart create
   */
  export type AddToCartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToCart
     */
    select?: AddToCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddToCart
     */
    omit?: AddToCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddToCartInclude<ExtArgs> | null
    /**
     * The data needed to create a AddToCart.
     */
    data: XOR<AddToCartCreateInput, AddToCartUncheckedCreateInput>
  }

  /**
   * AddToCart createMany
   */
  export type AddToCartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AddToCarts.
     */
    data: AddToCartCreateManyInput | AddToCartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AddToCart update
   */
  export type AddToCartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToCart
     */
    select?: AddToCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddToCart
     */
    omit?: AddToCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddToCartInclude<ExtArgs> | null
    /**
     * The data needed to update a AddToCart.
     */
    data: XOR<AddToCartUpdateInput, AddToCartUncheckedUpdateInput>
    /**
     * Choose, which AddToCart to update.
     */
    where: AddToCartWhereUniqueInput
  }

  /**
   * AddToCart updateMany
   */
  export type AddToCartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AddToCarts.
     */
    data: XOR<AddToCartUpdateManyMutationInput, AddToCartUncheckedUpdateManyInput>
    /**
     * Filter which AddToCarts to update
     */
    where?: AddToCartWhereInput
    /**
     * Limit how many AddToCarts to update.
     */
    limit?: number
  }

  /**
   * AddToCart upsert
   */
  export type AddToCartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToCart
     */
    select?: AddToCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddToCart
     */
    omit?: AddToCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddToCartInclude<ExtArgs> | null
    /**
     * The filter to search for the AddToCart to update in case it exists.
     */
    where: AddToCartWhereUniqueInput
    /**
     * In case the AddToCart found by the `where` argument doesn't exist, create a new AddToCart with this data.
     */
    create: XOR<AddToCartCreateInput, AddToCartUncheckedCreateInput>
    /**
     * In case the AddToCart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddToCartUpdateInput, AddToCartUncheckedUpdateInput>
  }

  /**
   * AddToCart delete
   */
  export type AddToCartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToCart
     */
    select?: AddToCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddToCart
     */
    omit?: AddToCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddToCartInclude<ExtArgs> | null
    /**
     * Filter which AddToCart to delete.
     */
    where: AddToCartWhereUniqueInput
  }

  /**
   * AddToCart deleteMany
   */
  export type AddToCartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddToCarts to delete
     */
    where?: AddToCartWhereInput
    /**
     * Limit how many AddToCarts to delete.
     */
    limit?: number
  }

  /**
   * AddToCart.branch
   */
  export type AddToCart$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * AddToCart.customer
   */
  export type AddToCart$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * AddToCart.createdBy
   */
  export type AddToCart$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AddToCart.updatedBy
   */
  export type AddToCart$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AddToCart.items
   */
  export type AddToCart$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * AddToCart.waitlists
   */
  export type AddToCart$waitlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaitlistInclude<ExtArgs> | null
    where?: WaitlistWhereInput
    orderBy?: WaitlistOrderByWithRelationInput | WaitlistOrderByWithRelationInput[]
    cursor?: WaitlistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WaitlistScalarFieldEnum | WaitlistScalarFieldEnum[]
  }

  /**
   * AddToCart without action
   */
  export type AddToCartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToCart
     */
    select?: AddToCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddToCart
     */
    omit?: AddToCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddToCartInclude<ExtArgs> | null
  }


  /**
   * Model CartItem
   */

  export type AggregateCartItem = {
    _count: CartItemCountAggregateOutputType | null
    _avg: CartItemAvgAggregateOutputType | null
    _sum: CartItemSumAggregateOutputType | null
    _min: CartItemMinAggregateOutputType | null
    _max: CartItemMaxAggregateOutputType | null
  }

  export type CartItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
  }

  export type CartItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
  }

  export type CartItemMinAggregateOutputType = {
    id: string | null
    cartId: string | null
    isWaitlist: boolean | null
    shopId: string | null
    productId: string | null
    unitOfMeasureId: string | null
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartItemMaxAggregateOutputType = {
    id: string | null
    cartId: string | null
    isWaitlist: boolean | null
    shopId: string | null
    productId: string | null
    unitOfMeasureId: string | null
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartItemCountAggregateOutputType = {
    id: number
    cartId: number
    isWaitlist: number
    shopId: number
    productId: number
    unitOfMeasureId: number
    quantity: number
    unitPrice: number
    totalPrice: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CartItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type CartItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type CartItemMinAggregateInputType = {
    id?: true
    cartId?: true
    isWaitlist?: true
    shopId?: true
    productId?: true
    unitOfMeasureId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartItemMaxAggregateInputType = {
    id?: true
    cartId?: true
    isWaitlist?: true
    shopId?: true
    productId?: true
    unitOfMeasureId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartItemCountAggregateInputType = {
    id?: true
    cartId?: true
    isWaitlist?: true
    shopId?: true
    productId?: true
    unitOfMeasureId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CartItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItem to aggregate.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CartItems
    **/
    _count?: true | CartItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartItemMaxAggregateInputType
  }

  export type GetCartItemAggregateType<T extends CartItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCartItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCartItem[P]>
      : GetScalarType<T[P], AggregateCartItem[P]>
  }




  export type CartItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithAggregationInput | CartItemOrderByWithAggregationInput[]
    by: CartItemScalarFieldEnum[] | CartItemScalarFieldEnum
    having?: CartItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartItemCountAggregateInputType | true
    _avg?: CartItemAvgAggregateInputType
    _sum?: CartItemSumAggregateInputType
    _min?: CartItemMinAggregateInputType
    _max?: CartItemMaxAggregateInputType
  }

  export type CartItemGroupByOutputType = {
    id: string
    cartId: string
    isWaitlist: boolean
    shopId: string
    productId: string
    unitOfMeasureId: string | null
    quantity: number
    unitPrice: number
    totalPrice: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: CartItemCountAggregateOutputType | null
    _avg: CartItemAvgAggregateOutputType | null
    _sum: CartItemSumAggregateOutputType | null
    _min: CartItemMinAggregateOutputType | null
    _max: CartItemMaxAggregateOutputType | null
  }

  type GetCartItemGroupByPayload<T extends CartItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartItemGroupByOutputType[P]>
            : GetScalarType<T[P], CartItemGroupByOutputType[P]>
        }
      >
    >


  export type CartItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartId?: boolean
    isWaitlist?: boolean
    shopId?: boolean
    productId?: boolean
    unitOfMeasureId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cart?: boolean | AddToCartDefaultArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    unitOfMeasure?: boolean | CartItem$unitOfMeasureArgs<ExtArgs>
    waitlists?: boolean | CartItem$waitlistsArgs<ExtArgs>
    _count?: boolean | CartItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>



  export type CartItemSelectScalar = {
    id?: boolean
    cartId?: boolean
    isWaitlist?: boolean
    shopId?: boolean
    productId?: boolean
    unitOfMeasureId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CartItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cartId" | "isWaitlist" | "shopId" | "productId" | "unitOfMeasureId" | "quantity" | "unitPrice" | "totalPrice" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["cartItem"]>
  export type CartItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | AddToCartDefaultArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    unitOfMeasure?: boolean | CartItem$unitOfMeasureArgs<ExtArgs>
    waitlists?: boolean | CartItem$waitlistsArgs<ExtArgs>
    _count?: boolean | CartItemCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CartItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CartItem"
    objects: {
      cart: Prisma.$AddToCartPayload<ExtArgs>
      shop: Prisma.$ShopPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      unitOfMeasure: Prisma.$UnitOfMeasurePayload<ExtArgs> | null
      waitlists: Prisma.$WaitlistPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cartId: string
      isWaitlist: boolean
      shopId: string
      productId: string
      unitOfMeasureId: string | null
      quantity: number
      unitPrice: number
      totalPrice: number
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cartItem"]>
    composites: {}
  }

  type CartItemGetPayload<S extends boolean | null | undefined | CartItemDefaultArgs> = $Result.GetResult<Prisma.$CartItemPayload, S>

  type CartItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartItemCountAggregateInputType | true
    }

  export interface CartItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CartItem'], meta: { name: 'CartItem' } }
    /**
     * Find zero or one CartItem that matches the filter.
     * @param {CartItemFindUniqueArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartItemFindUniqueArgs>(args: SelectSubset<T, CartItemFindUniqueArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CartItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartItemFindUniqueOrThrowArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CartItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindFirstArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartItemFindFirstArgs>(args?: SelectSubset<T, CartItemFindFirstArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindFirstOrThrowArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CartItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CartItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CartItems
     * const cartItems = await prisma.cartItem.findMany()
     * 
     * // Get first 10 CartItems
     * const cartItems = await prisma.cartItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartItemFindManyArgs>(args?: SelectSubset<T, CartItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CartItem.
     * @param {CartItemCreateArgs} args - Arguments to create a CartItem.
     * @example
     * // Create one CartItem
     * const CartItem = await prisma.cartItem.create({
     *   data: {
     *     // ... data to create a CartItem
     *   }
     * })
     * 
     */
    create<T extends CartItemCreateArgs>(args: SelectSubset<T, CartItemCreateArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CartItems.
     * @param {CartItemCreateManyArgs} args - Arguments to create many CartItems.
     * @example
     * // Create many CartItems
     * const cartItem = await prisma.cartItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartItemCreateManyArgs>(args?: SelectSubset<T, CartItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CartItem.
     * @param {CartItemDeleteArgs} args - Arguments to delete one CartItem.
     * @example
     * // Delete one CartItem
     * const CartItem = await prisma.cartItem.delete({
     *   where: {
     *     // ... filter to delete one CartItem
     *   }
     * })
     * 
     */
    delete<T extends CartItemDeleteArgs>(args: SelectSubset<T, CartItemDeleteArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CartItem.
     * @param {CartItemUpdateArgs} args - Arguments to update one CartItem.
     * @example
     * // Update one CartItem
     * const cartItem = await prisma.cartItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartItemUpdateArgs>(args: SelectSubset<T, CartItemUpdateArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CartItems.
     * @param {CartItemDeleteManyArgs} args - Arguments to filter CartItems to delete.
     * @example
     * // Delete a few CartItems
     * const { count } = await prisma.cartItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartItemDeleteManyArgs>(args?: SelectSubset<T, CartItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CartItems
     * const cartItem = await prisma.cartItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartItemUpdateManyArgs>(args: SelectSubset<T, CartItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CartItem.
     * @param {CartItemUpsertArgs} args - Arguments to update or create a CartItem.
     * @example
     * // Update or create a CartItem
     * const cartItem = await prisma.cartItem.upsert({
     *   create: {
     *     // ... data to create a CartItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CartItem we want to update
     *   }
     * })
     */
    upsert<T extends CartItemUpsertArgs>(args: SelectSubset<T, CartItemUpsertArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemCountArgs} args - Arguments to filter CartItems to count.
     * @example
     * // Count the number of CartItems
     * const count = await prisma.cartItem.count({
     *   where: {
     *     // ... the filter for the CartItems we want to count
     *   }
     * })
    **/
    count<T extends CartItemCountArgs>(
      args?: Subset<T, CartItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartItemAggregateArgs>(args: Subset<T, CartItemAggregateArgs>): Prisma.PrismaPromise<GetCartItemAggregateType<T>>

    /**
     * Group by CartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartItemGroupByArgs['orderBy'] }
        : { orderBy?: CartItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CartItem model
   */
  readonly fields: CartItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CartItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cart<T extends AddToCartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddToCartDefaultArgs<ExtArgs>>): Prisma__AddToCartClient<$Result.GetResult<Prisma.$AddToCartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unitOfMeasure<T extends CartItem$unitOfMeasureArgs<ExtArgs> = {}>(args?: Subset<T, CartItem$unitOfMeasureArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    waitlists<T extends CartItem$waitlistsArgs<ExtArgs> = {}>(args?: Subset<T, CartItem$waitlistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CartItem model
   */
  interface CartItemFieldRefs {
    readonly id: FieldRef<"CartItem", 'String'>
    readonly cartId: FieldRef<"CartItem", 'String'>
    readonly isWaitlist: FieldRef<"CartItem", 'Boolean'>
    readonly shopId: FieldRef<"CartItem", 'String'>
    readonly productId: FieldRef<"CartItem", 'String'>
    readonly unitOfMeasureId: FieldRef<"CartItem", 'String'>
    readonly quantity: FieldRef<"CartItem", 'Int'>
    readonly unitPrice: FieldRef<"CartItem", 'Float'>
    readonly totalPrice: FieldRef<"CartItem", 'Float'>
    readonly notes: FieldRef<"CartItem", 'String'>
    readonly createdAt: FieldRef<"CartItem", 'DateTime'>
    readonly updatedAt: FieldRef<"CartItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CartItem findUnique
   */
  export type CartItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem findUniqueOrThrow
   */
  export type CartItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem findFirst
   */
  export type CartItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem findFirstOrThrow
   */
  export type CartItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem findMany
   */
  export type CartItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItems to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem create
   */
  export type CartItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CartItem.
     */
    data: XOR<CartItemCreateInput, CartItemUncheckedCreateInput>
  }

  /**
   * CartItem createMany
   */
  export type CartItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CartItems.
     */
    data: CartItemCreateManyInput | CartItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CartItem update
   */
  export type CartItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CartItem.
     */
    data: XOR<CartItemUpdateInput, CartItemUncheckedUpdateInput>
    /**
     * Choose, which CartItem to update.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem updateMany
   */
  export type CartItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CartItems.
     */
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyInput>
    /**
     * Filter which CartItems to update
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to update.
     */
    limit?: number
  }

  /**
   * CartItem upsert
   */
  export type CartItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CartItem to update in case it exists.
     */
    where: CartItemWhereUniqueInput
    /**
     * In case the CartItem found by the `where` argument doesn't exist, create a new CartItem with this data.
     */
    create: XOR<CartItemCreateInput, CartItemUncheckedCreateInput>
    /**
     * In case the CartItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartItemUpdateInput, CartItemUncheckedUpdateInput>
  }

  /**
   * CartItem delete
   */
  export type CartItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter which CartItem to delete.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem deleteMany
   */
  export type CartItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItems to delete
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to delete.
     */
    limit?: number
  }

  /**
   * CartItem.unitOfMeasure
   */
  export type CartItem$unitOfMeasureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasure
     */
    select?: UnitOfMeasureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasure
     */
    omit?: UnitOfMeasureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasureInclude<ExtArgs> | null
    where?: UnitOfMeasureWhereInput
  }

  /**
   * CartItem.waitlists
   */
  export type CartItem$waitlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaitlistInclude<ExtArgs> | null
    where?: WaitlistWhereInput
    orderBy?: WaitlistOrderByWithRelationInput | WaitlistOrderByWithRelationInput[]
    cursor?: WaitlistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WaitlistScalarFieldEnum | WaitlistScalarFieldEnum[]
  }

  /**
   * CartItem without action
   */
  export type CartItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
  }


  /**
   * Model Waitlist
   */

  export type AggregateWaitlist = {
    _count: WaitlistCountAggregateOutputType | null
    _avg: WaitlistAvgAggregateOutputType | null
    _sum: WaitlistSumAggregateOutputType | null
    _min: WaitlistMinAggregateOutputType | null
    _max: WaitlistMaxAggregateOutputType | null
  }

  export type WaitlistAvgAggregateOutputType = {
    quantity: number | null
  }

  export type WaitlistSumAggregateOutputType = {
    quantity: number | null
  }

  export type WaitlistMinAggregateOutputType = {
    id: string | null
    userId: string | null
    customerId: string | null
    branchId: string | null
    cartId: string | null
    cartItemId: string | null
    productId: string | null
    quantity: number | null
    note: string | null
    shopId: string | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WaitlistMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    customerId: string | null
    branchId: string | null
    cartId: string | null
    cartItemId: string | null
    productId: string | null
    quantity: number | null
    note: string | null
    shopId: string | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WaitlistCountAggregateOutputType = {
    id: number
    userId: number
    customerId: number
    branchId: number
    cartId: number
    cartItemId: number
    productId: number
    quantity: number
    note: number
    shopId: number
    createdById: number
    updatedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WaitlistAvgAggregateInputType = {
    quantity?: true
  }

  export type WaitlistSumAggregateInputType = {
    quantity?: true
  }

  export type WaitlistMinAggregateInputType = {
    id?: true
    userId?: true
    customerId?: true
    branchId?: true
    cartId?: true
    cartItemId?: true
    productId?: true
    quantity?: true
    note?: true
    shopId?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WaitlistMaxAggregateInputType = {
    id?: true
    userId?: true
    customerId?: true
    branchId?: true
    cartId?: true
    cartItemId?: true
    productId?: true
    quantity?: true
    note?: true
    shopId?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WaitlistCountAggregateInputType = {
    id?: true
    userId?: true
    customerId?: true
    branchId?: true
    cartId?: true
    cartItemId?: true
    productId?: true
    quantity?: true
    note?: true
    shopId?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WaitlistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Waitlist to aggregate.
     */
    where?: WaitlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Waitlists to fetch.
     */
    orderBy?: WaitlistOrderByWithRelationInput | WaitlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WaitlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Waitlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Waitlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Waitlists
    **/
    _count?: true | WaitlistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WaitlistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WaitlistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WaitlistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WaitlistMaxAggregateInputType
  }

  export type GetWaitlistAggregateType<T extends WaitlistAggregateArgs> = {
        [P in keyof T & keyof AggregateWaitlist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWaitlist[P]>
      : GetScalarType<T[P], AggregateWaitlist[P]>
  }




  export type WaitlistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WaitlistWhereInput
    orderBy?: WaitlistOrderByWithAggregationInput | WaitlistOrderByWithAggregationInput[]
    by: WaitlistScalarFieldEnum[] | WaitlistScalarFieldEnum
    having?: WaitlistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WaitlistCountAggregateInputType | true
    _avg?: WaitlistAvgAggregateInputType
    _sum?: WaitlistSumAggregateInputType
    _min?: WaitlistMinAggregateInputType
    _max?: WaitlistMaxAggregateInputType
  }

  export type WaitlistGroupByOutputType = {
    id: string
    userId: string | null
    customerId: string | null
    branchId: string | null
    cartId: string | null
    cartItemId: string | null
    productId: string | null
    quantity: number
    note: string | null
    shopId: string | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: WaitlistCountAggregateOutputType | null
    _avg: WaitlistAvgAggregateOutputType | null
    _sum: WaitlistSumAggregateOutputType | null
    _min: WaitlistMinAggregateOutputType | null
    _max: WaitlistMaxAggregateOutputType | null
  }

  type GetWaitlistGroupByPayload<T extends WaitlistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WaitlistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WaitlistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WaitlistGroupByOutputType[P]>
            : GetScalarType<T[P], WaitlistGroupByOutputType[P]>
        }
      >
    >


  export type WaitlistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    customerId?: boolean
    branchId?: boolean
    cartId?: boolean
    cartItemId?: boolean
    productId?: boolean
    quantity?: boolean
    note?: boolean
    shopId?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Waitlist$userArgs<ExtArgs>
    customer?: boolean | Waitlist$customerArgs<ExtArgs>
    branch?: boolean | Waitlist$branchArgs<ExtArgs>
    cart?: boolean | Waitlist$cartArgs<ExtArgs>
    cartItem?: boolean | Waitlist$cartItemArgs<ExtArgs>
    product?: boolean | Waitlist$productArgs<ExtArgs>
    shop?: boolean | Waitlist$shopArgs<ExtArgs>
    createdBy?: boolean | Waitlist$createdByArgs<ExtArgs>
    updatedBy?: boolean | Waitlist$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["waitlist"]>



  export type WaitlistSelectScalar = {
    id?: boolean
    userId?: boolean
    customerId?: boolean
    branchId?: boolean
    cartId?: boolean
    cartItemId?: boolean
    productId?: boolean
    quantity?: boolean
    note?: boolean
    shopId?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WaitlistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "customerId" | "branchId" | "cartId" | "cartItemId" | "productId" | "quantity" | "note" | "shopId" | "createdById" | "updatedById" | "createdAt" | "updatedAt", ExtArgs["result"]["waitlist"]>
  export type WaitlistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Waitlist$userArgs<ExtArgs>
    customer?: boolean | Waitlist$customerArgs<ExtArgs>
    branch?: boolean | Waitlist$branchArgs<ExtArgs>
    cart?: boolean | Waitlist$cartArgs<ExtArgs>
    cartItem?: boolean | Waitlist$cartItemArgs<ExtArgs>
    product?: boolean | Waitlist$productArgs<ExtArgs>
    shop?: boolean | Waitlist$shopArgs<ExtArgs>
    createdBy?: boolean | Waitlist$createdByArgs<ExtArgs>
    updatedBy?: boolean | Waitlist$updatedByArgs<ExtArgs>
  }

  export type $WaitlistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Waitlist"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      branch: Prisma.$BranchPayload<ExtArgs> | null
      cart: Prisma.$AddToCartPayload<ExtArgs> | null
      cartItem: Prisma.$CartItemPayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs> | null
      shop: Prisma.$ShopPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      customerId: string | null
      branchId: string | null
      cartId: string | null
      cartItemId: string | null
      productId: string | null
      quantity: number
      note: string | null
      shopId: string | null
      createdById: string | null
      updatedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["waitlist"]>
    composites: {}
  }

  type WaitlistGetPayload<S extends boolean | null | undefined | WaitlistDefaultArgs> = $Result.GetResult<Prisma.$WaitlistPayload, S>

  type WaitlistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WaitlistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WaitlistCountAggregateInputType | true
    }

  export interface WaitlistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Waitlist'], meta: { name: 'Waitlist' } }
    /**
     * Find zero or one Waitlist that matches the filter.
     * @param {WaitlistFindUniqueArgs} args - Arguments to find a Waitlist
     * @example
     * // Get one Waitlist
     * const waitlist = await prisma.waitlist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WaitlistFindUniqueArgs>(args: SelectSubset<T, WaitlistFindUniqueArgs<ExtArgs>>): Prisma__WaitlistClient<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Waitlist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WaitlistFindUniqueOrThrowArgs} args - Arguments to find a Waitlist
     * @example
     * // Get one Waitlist
     * const waitlist = await prisma.waitlist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WaitlistFindUniqueOrThrowArgs>(args: SelectSubset<T, WaitlistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WaitlistClient<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Waitlist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitlistFindFirstArgs} args - Arguments to find a Waitlist
     * @example
     * // Get one Waitlist
     * const waitlist = await prisma.waitlist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WaitlistFindFirstArgs>(args?: SelectSubset<T, WaitlistFindFirstArgs<ExtArgs>>): Prisma__WaitlistClient<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Waitlist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitlistFindFirstOrThrowArgs} args - Arguments to find a Waitlist
     * @example
     * // Get one Waitlist
     * const waitlist = await prisma.waitlist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WaitlistFindFirstOrThrowArgs>(args?: SelectSubset<T, WaitlistFindFirstOrThrowArgs<ExtArgs>>): Prisma__WaitlistClient<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Waitlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitlistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Waitlists
     * const waitlists = await prisma.waitlist.findMany()
     * 
     * // Get first 10 Waitlists
     * const waitlists = await prisma.waitlist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const waitlistWithIdOnly = await prisma.waitlist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WaitlistFindManyArgs>(args?: SelectSubset<T, WaitlistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Waitlist.
     * @param {WaitlistCreateArgs} args - Arguments to create a Waitlist.
     * @example
     * // Create one Waitlist
     * const Waitlist = await prisma.waitlist.create({
     *   data: {
     *     // ... data to create a Waitlist
     *   }
     * })
     * 
     */
    create<T extends WaitlistCreateArgs>(args: SelectSubset<T, WaitlistCreateArgs<ExtArgs>>): Prisma__WaitlistClient<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Waitlists.
     * @param {WaitlistCreateManyArgs} args - Arguments to create many Waitlists.
     * @example
     * // Create many Waitlists
     * const waitlist = await prisma.waitlist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WaitlistCreateManyArgs>(args?: SelectSubset<T, WaitlistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Waitlist.
     * @param {WaitlistDeleteArgs} args - Arguments to delete one Waitlist.
     * @example
     * // Delete one Waitlist
     * const Waitlist = await prisma.waitlist.delete({
     *   where: {
     *     // ... filter to delete one Waitlist
     *   }
     * })
     * 
     */
    delete<T extends WaitlistDeleteArgs>(args: SelectSubset<T, WaitlistDeleteArgs<ExtArgs>>): Prisma__WaitlistClient<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Waitlist.
     * @param {WaitlistUpdateArgs} args - Arguments to update one Waitlist.
     * @example
     * // Update one Waitlist
     * const waitlist = await prisma.waitlist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WaitlistUpdateArgs>(args: SelectSubset<T, WaitlistUpdateArgs<ExtArgs>>): Prisma__WaitlistClient<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Waitlists.
     * @param {WaitlistDeleteManyArgs} args - Arguments to filter Waitlists to delete.
     * @example
     * // Delete a few Waitlists
     * const { count } = await prisma.waitlist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WaitlistDeleteManyArgs>(args?: SelectSubset<T, WaitlistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Waitlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitlistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Waitlists
     * const waitlist = await prisma.waitlist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WaitlistUpdateManyArgs>(args: SelectSubset<T, WaitlistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Waitlist.
     * @param {WaitlistUpsertArgs} args - Arguments to update or create a Waitlist.
     * @example
     * // Update or create a Waitlist
     * const waitlist = await prisma.waitlist.upsert({
     *   create: {
     *     // ... data to create a Waitlist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Waitlist we want to update
     *   }
     * })
     */
    upsert<T extends WaitlistUpsertArgs>(args: SelectSubset<T, WaitlistUpsertArgs<ExtArgs>>): Prisma__WaitlistClient<$Result.GetResult<Prisma.$WaitlistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Waitlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitlistCountArgs} args - Arguments to filter Waitlists to count.
     * @example
     * // Count the number of Waitlists
     * const count = await prisma.waitlist.count({
     *   where: {
     *     // ... the filter for the Waitlists we want to count
     *   }
     * })
    **/
    count<T extends WaitlistCountArgs>(
      args?: Subset<T, WaitlistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WaitlistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Waitlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitlistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WaitlistAggregateArgs>(args: Subset<T, WaitlistAggregateArgs>): Prisma.PrismaPromise<GetWaitlistAggregateType<T>>

    /**
     * Group by Waitlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitlistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WaitlistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WaitlistGroupByArgs['orderBy'] }
        : { orderBy?: WaitlistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WaitlistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWaitlistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Waitlist model
   */
  readonly fields: WaitlistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Waitlist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WaitlistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Waitlist$userArgs<ExtArgs> = {}>(args?: Subset<T, Waitlist$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customer<T extends Waitlist$customerArgs<ExtArgs> = {}>(args?: Subset<T, Waitlist$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    branch<T extends Waitlist$branchArgs<ExtArgs> = {}>(args?: Subset<T, Waitlist$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    cart<T extends Waitlist$cartArgs<ExtArgs> = {}>(args?: Subset<T, Waitlist$cartArgs<ExtArgs>>): Prisma__AddToCartClient<$Result.GetResult<Prisma.$AddToCartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    cartItem<T extends Waitlist$cartItemArgs<ExtArgs> = {}>(args?: Subset<T, Waitlist$cartItemArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends Waitlist$productArgs<ExtArgs> = {}>(args?: Subset<T, Waitlist$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    shop<T extends Waitlist$shopArgs<ExtArgs> = {}>(args?: Subset<T, Waitlist$shopArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends Waitlist$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Waitlist$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends Waitlist$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, Waitlist$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Waitlist model
   */
  interface WaitlistFieldRefs {
    readonly id: FieldRef<"Waitlist", 'String'>
    readonly userId: FieldRef<"Waitlist", 'String'>
    readonly customerId: FieldRef<"Waitlist", 'String'>
    readonly branchId: FieldRef<"Waitlist", 'String'>
    readonly cartId: FieldRef<"Waitlist", 'String'>
    readonly cartItemId: FieldRef<"Waitlist", 'String'>
    readonly productId: FieldRef<"Waitlist", 'String'>
    readonly quantity: FieldRef<"Waitlist", 'Int'>
    readonly note: FieldRef<"Waitlist", 'String'>
    readonly shopId: FieldRef<"Waitlist", 'String'>
    readonly createdById: FieldRef<"Waitlist", 'String'>
    readonly updatedById: FieldRef<"Waitlist", 'String'>
    readonly createdAt: FieldRef<"Waitlist", 'DateTime'>
    readonly updatedAt: FieldRef<"Waitlist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Waitlist findUnique
   */
  export type WaitlistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaitlistInclude<ExtArgs> | null
    /**
     * Filter, which Waitlist to fetch.
     */
    where: WaitlistWhereUniqueInput
  }

  /**
   * Waitlist findUniqueOrThrow
   */
  export type WaitlistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaitlistInclude<ExtArgs> | null
    /**
     * Filter, which Waitlist to fetch.
     */
    where: WaitlistWhereUniqueInput
  }

  /**
   * Waitlist findFirst
   */
  export type WaitlistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaitlistInclude<ExtArgs> | null
    /**
     * Filter, which Waitlist to fetch.
     */
    where?: WaitlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Waitlists to fetch.
     */
    orderBy?: WaitlistOrderByWithRelationInput | WaitlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Waitlists.
     */
    cursor?: WaitlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Waitlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Waitlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Waitlists.
     */
    distinct?: WaitlistScalarFieldEnum | WaitlistScalarFieldEnum[]
  }

  /**
   * Waitlist findFirstOrThrow
   */
  export type WaitlistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaitlistInclude<ExtArgs> | null
    /**
     * Filter, which Waitlist to fetch.
     */
    where?: WaitlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Waitlists to fetch.
     */
    orderBy?: WaitlistOrderByWithRelationInput | WaitlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Waitlists.
     */
    cursor?: WaitlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Waitlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Waitlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Waitlists.
     */
    distinct?: WaitlistScalarFieldEnum | WaitlistScalarFieldEnum[]
  }

  /**
   * Waitlist findMany
   */
  export type WaitlistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaitlistInclude<ExtArgs> | null
    /**
     * Filter, which Waitlists to fetch.
     */
    where?: WaitlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Waitlists to fetch.
     */
    orderBy?: WaitlistOrderByWithRelationInput | WaitlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Waitlists.
     */
    cursor?: WaitlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Waitlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Waitlists.
     */
    skip?: number
    distinct?: WaitlistScalarFieldEnum | WaitlistScalarFieldEnum[]
  }

  /**
   * Waitlist create
   */
  export type WaitlistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaitlistInclude<ExtArgs> | null
    /**
     * The data needed to create a Waitlist.
     */
    data: XOR<WaitlistCreateInput, WaitlistUncheckedCreateInput>
  }

  /**
   * Waitlist createMany
   */
  export type WaitlistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Waitlists.
     */
    data: WaitlistCreateManyInput | WaitlistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Waitlist update
   */
  export type WaitlistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaitlistInclude<ExtArgs> | null
    /**
     * The data needed to update a Waitlist.
     */
    data: XOR<WaitlistUpdateInput, WaitlistUncheckedUpdateInput>
    /**
     * Choose, which Waitlist to update.
     */
    where: WaitlistWhereUniqueInput
  }

  /**
   * Waitlist updateMany
   */
  export type WaitlistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Waitlists.
     */
    data: XOR<WaitlistUpdateManyMutationInput, WaitlistUncheckedUpdateManyInput>
    /**
     * Filter which Waitlists to update
     */
    where?: WaitlistWhereInput
    /**
     * Limit how many Waitlists to update.
     */
    limit?: number
  }

  /**
   * Waitlist upsert
   */
  export type WaitlistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaitlistInclude<ExtArgs> | null
    /**
     * The filter to search for the Waitlist to update in case it exists.
     */
    where: WaitlistWhereUniqueInput
    /**
     * In case the Waitlist found by the `where` argument doesn't exist, create a new Waitlist with this data.
     */
    create: XOR<WaitlistCreateInput, WaitlistUncheckedCreateInput>
    /**
     * In case the Waitlist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WaitlistUpdateInput, WaitlistUncheckedUpdateInput>
  }

  /**
   * Waitlist delete
   */
  export type WaitlistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaitlistInclude<ExtArgs> | null
    /**
     * Filter which Waitlist to delete.
     */
    where: WaitlistWhereUniqueInput
  }

  /**
   * Waitlist deleteMany
   */
  export type WaitlistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Waitlists to delete
     */
    where?: WaitlistWhereInput
    /**
     * Limit how many Waitlists to delete.
     */
    limit?: number
  }

  /**
   * Waitlist.user
   */
  export type Waitlist$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Waitlist.customer
   */
  export type Waitlist$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Waitlist.branch
   */
  export type Waitlist$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Waitlist.cart
   */
  export type Waitlist$cartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToCart
     */
    select?: AddToCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddToCart
     */
    omit?: AddToCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddToCartInclude<ExtArgs> | null
    where?: AddToCartWhereInput
  }

  /**
   * Waitlist.cartItem
   */
  export type Waitlist$cartItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
  }

  /**
   * Waitlist.product
   */
  export type Waitlist$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * Waitlist.shop
   */
  export type Waitlist$shopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    where?: ShopWhereInput
  }

  /**
   * Waitlist.createdBy
   */
  export type Waitlist$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Waitlist.updatedBy
   */
  export type Waitlist$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Waitlist without action
   */
  export type WaitlistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Waitlist
     */
    select?: WaitlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Waitlist
     */
    omit?: WaitlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaitlistInclude<ExtArgs> | null
  }


  /**
   * Model SellStockCorrection
   */

  export type AggregateSellStockCorrection = {
    _count: SellStockCorrectionCountAggregateOutputType | null
    _avg: SellStockCorrectionAvgAggregateOutputType | null
    _sum: SellStockCorrectionSumAggregateOutputType | null
    _min: SellStockCorrectionMinAggregateOutputType | null
    _max: SellStockCorrectionMaxAggregateOutputType | null
  }

  export type SellStockCorrectionAvgAggregateOutputType = {
    total: number | null
  }

  export type SellStockCorrectionSumAggregateOutputType = {
    total: number | null
  }

  export type SellStockCorrectionMinAggregateOutputType = {
    id: string | null
    sellId: string | null
    status: $Enums.SellStockCorrectionStatus | null
    reference: string | null
    notes: string | null
    createdById: string | null
    updatedById: string | null
    total: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SellStockCorrectionMaxAggregateOutputType = {
    id: string | null
    sellId: string | null
    status: $Enums.SellStockCorrectionStatus | null
    reference: string | null
    notes: string | null
    createdById: string | null
    updatedById: string | null
    total: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SellStockCorrectionCountAggregateOutputType = {
    id: number
    sellId: number
    status: number
    reference: number
    notes: number
    createdById: number
    updatedById: number
    total: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SellStockCorrectionAvgAggregateInputType = {
    total?: true
  }

  export type SellStockCorrectionSumAggregateInputType = {
    total?: true
  }

  export type SellStockCorrectionMinAggregateInputType = {
    id?: true
    sellId?: true
    status?: true
    reference?: true
    notes?: true
    createdById?: true
    updatedById?: true
    total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SellStockCorrectionMaxAggregateInputType = {
    id?: true
    sellId?: true
    status?: true
    reference?: true
    notes?: true
    createdById?: true
    updatedById?: true
    total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SellStockCorrectionCountAggregateInputType = {
    id?: true
    sellId?: true
    status?: true
    reference?: true
    notes?: true
    createdById?: true
    updatedById?: true
    total?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SellStockCorrectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellStockCorrection to aggregate.
     */
    where?: SellStockCorrectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellStockCorrections to fetch.
     */
    orderBy?: SellStockCorrectionOrderByWithRelationInput | SellStockCorrectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellStockCorrectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellStockCorrections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellStockCorrections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SellStockCorrections
    **/
    _count?: true | SellStockCorrectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SellStockCorrectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SellStockCorrectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellStockCorrectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellStockCorrectionMaxAggregateInputType
  }

  export type GetSellStockCorrectionAggregateType<T extends SellStockCorrectionAggregateArgs> = {
        [P in keyof T & keyof AggregateSellStockCorrection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSellStockCorrection[P]>
      : GetScalarType<T[P], AggregateSellStockCorrection[P]>
  }




  export type SellStockCorrectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellStockCorrectionWhereInput
    orderBy?: SellStockCorrectionOrderByWithAggregationInput | SellStockCorrectionOrderByWithAggregationInput[]
    by: SellStockCorrectionScalarFieldEnum[] | SellStockCorrectionScalarFieldEnum
    having?: SellStockCorrectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellStockCorrectionCountAggregateInputType | true
    _avg?: SellStockCorrectionAvgAggregateInputType
    _sum?: SellStockCorrectionSumAggregateInputType
    _min?: SellStockCorrectionMinAggregateInputType
    _max?: SellStockCorrectionMaxAggregateInputType
  }

  export type SellStockCorrectionGroupByOutputType = {
    id: string
    sellId: string | null
    status: $Enums.SellStockCorrectionStatus
    reference: string | null
    notes: string | null
    createdById: string | null
    updatedById: string | null
    total: number
    createdAt: Date
    updatedAt: Date
    _count: SellStockCorrectionCountAggregateOutputType | null
    _avg: SellStockCorrectionAvgAggregateOutputType | null
    _sum: SellStockCorrectionSumAggregateOutputType | null
    _min: SellStockCorrectionMinAggregateOutputType | null
    _max: SellStockCorrectionMaxAggregateOutputType | null
  }

  type GetSellStockCorrectionGroupByPayload<T extends SellStockCorrectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellStockCorrectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellStockCorrectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellStockCorrectionGroupByOutputType[P]>
            : GetScalarType<T[P], SellStockCorrectionGroupByOutputType[P]>
        }
      >
    >


  export type SellStockCorrectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellId?: boolean
    status?: boolean
    reference?: boolean
    notes?: boolean
    createdById?: boolean
    updatedById?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sell?: boolean | SellStockCorrection$sellArgs<ExtArgs>
    createdBy?: boolean | SellStockCorrection$createdByArgs<ExtArgs>
    updatedBy?: boolean | SellStockCorrection$updatedByArgs<ExtArgs>
    items?: boolean | SellStockCorrection$itemsArgs<ExtArgs>
    _count?: boolean | SellStockCorrectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sellStockCorrection"]>



  export type SellStockCorrectionSelectScalar = {
    id?: boolean
    sellId?: boolean
    status?: boolean
    reference?: boolean
    notes?: boolean
    createdById?: boolean
    updatedById?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SellStockCorrectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sellId" | "status" | "reference" | "notes" | "createdById" | "updatedById" | "total" | "createdAt" | "updatedAt", ExtArgs["result"]["sellStockCorrection"]>
  export type SellStockCorrectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sell?: boolean | SellStockCorrection$sellArgs<ExtArgs>
    createdBy?: boolean | SellStockCorrection$createdByArgs<ExtArgs>
    updatedBy?: boolean | SellStockCorrection$updatedByArgs<ExtArgs>
    items?: boolean | SellStockCorrection$itemsArgs<ExtArgs>
    _count?: boolean | SellStockCorrectionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SellStockCorrectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SellStockCorrection"
    objects: {
      sell: Prisma.$SellPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
      items: Prisma.$SellStockCorrectionItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sellId: string | null
      status: $Enums.SellStockCorrectionStatus
      reference: string | null
      notes: string | null
      createdById: string | null
      updatedById: string | null
      total: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sellStockCorrection"]>
    composites: {}
  }

  type SellStockCorrectionGetPayload<S extends boolean | null | undefined | SellStockCorrectionDefaultArgs> = $Result.GetResult<Prisma.$SellStockCorrectionPayload, S>

  type SellStockCorrectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SellStockCorrectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SellStockCorrectionCountAggregateInputType | true
    }

  export interface SellStockCorrectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SellStockCorrection'], meta: { name: 'SellStockCorrection' } }
    /**
     * Find zero or one SellStockCorrection that matches the filter.
     * @param {SellStockCorrectionFindUniqueArgs} args - Arguments to find a SellStockCorrection
     * @example
     * // Get one SellStockCorrection
     * const sellStockCorrection = await prisma.sellStockCorrection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellStockCorrectionFindUniqueArgs>(args: SelectSubset<T, SellStockCorrectionFindUniqueArgs<ExtArgs>>): Prisma__SellStockCorrectionClient<$Result.GetResult<Prisma.$SellStockCorrectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SellStockCorrection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SellStockCorrectionFindUniqueOrThrowArgs} args - Arguments to find a SellStockCorrection
     * @example
     * // Get one SellStockCorrection
     * const sellStockCorrection = await prisma.sellStockCorrection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellStockCorrectionFindUniqueOrThrowArgs>(args: SelectSubset<T, SellStockCorrectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellStockCorrectionClient<$Result.GetResult<Prisma.$SellStockCorrectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellStockCorrection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellStockCorrectionFindFirstArgs} args - Arguments to find a SellStockCorrection
     * @example
     * // Get one SellStockCorrection
     * const sellStockCorrection = await prisma.sellStockCorrection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellStockCorrectionFindFirstArgs>(args?: SelectSubset<T, SellStockCorrectionFindFirstArgs<ExtArgs>>): Prisma__SellStockCorrectionClient<$Result.GetResult<Prisma.$SellStockCorrectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellStockCorrection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellStockCorrectionFindFirstOrThrowArgs} args - Arguments to find a SellStockCorrection
     * @example
     * // Get one SellStockCorrection
     * const sellStockCorrection = await prisma.sellStockCorrection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellStockCorrectionFindFirstOrThrowArgs>(args?: SelectSubset<T, SellStockCorrectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellStockCorrectionClient<$Result.GetResult<Prisma.$SellStockCorrectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SellStockCorrections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellStockCorrectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SellStockCorrections
     * const sellStockCorrections = await prisma.sellStockCorrection.findMany()
     * 
     * // Get first 10 SellStockCorrections
     * const sellStockCorrections = await prisma.sellStockCorrection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellStockCorrectionWithIdOnly = await prisma.sellStockCorrection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellStockCorrectionFindManyArgs>(args?: SelectSubset<T, SellStockCorrectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellStockCorrectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SellStockCorrection.
     * @param {SellStockCorrectionCreateArgs} args - Arguments to create a SellStockCorrection.
     * @example
     * // Create one SellStockCorrection
     * const SellStockCorrection = await prisma.sellStockCorrection.create({
     *   data: {
     *     // ... data to create a SellStockCorrection
     *   }
     * })
     * 
     */
    create<T extends SellStockCorrectionCreateArgs>(args: SelectSubset<T, SellStockCorrectionCreateArgs<ExtArgs>>): Prisma__SellStockCorrectionClient<$Result.GetResult<Prisma.$SellStockCorrectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SellStockCorrections.
     * @param {SellStockCorrectionCreateManyArgs} args - Arguments to create many SellStockCorrections.
     * @example
     * // Create many SellStockCorrections
     * const sellStockCorrection = await prisma.sellStockCorrection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellStockCorrectionCreateManyArgs>(args?: SelectSubset<T, SellStockCorrectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SellStockCorrection.
     * @param {SellStockCorrectionDeleteArgs} args - Arguments to delete one SellStockCorrection.
     * @example
     * // Delete one SellStockCorrection
     * const SellStockCorrection = await prisma.sellStockCorrection.delete({
     *   where: {
     *     // ... filter to delete one SellStockCorrection
     *   }
     * })
     * 
     */
    delete<T extends SellStockCorrectionDeleteArgs>(args: SelectSubset<T, SellStockCorrectionDeleteArgs<ExtArgs>>): Prisma__SellStockCorrectionClient<$Result.GetResult<Prisma.$SellStockCorrectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SellStockCorrection.
     * @param {SellStockCorrectionUpdateArgs} args - Arguments to update one SellStockCorrection.
     * @example
     * // Update one SellStockCorrection
     * const sellStockCorrection = await prisma.sellStockCorrection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellStockCorrectionUpdateArgs>(args: SelectSubset<T, SellStockCorrectionUpdateArgs<ExtArgs>>): Prisma__SellStockCorrectionClient<$Result.GetResult<Prisma.$SellStockCorrectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SellStockCorrections.
     * @param {SellStockCorrectionDeleteManyArgs} args - Arguments to filter SellStockCorrections to delete.
     * @example
     * // Delete a few SellStockCorrections
     * const { count } = await prisma.sellStockCorrection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellStockCorrectionDeleteManyArgs>(args?: SelectSubset<T, SellStockCorrectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellStockCorrections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellStockCorrectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SellStockCorrections
     * const sellStockCorrection = await prisma.sellStockCorrection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellStockCorrectionUpdateManyArgs>(args: SelectSubset<T, SellStockCorrectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SellStockCorrection.
     * @param {SellStockCorrectionUpsertArgs} args - Arguments to update or create a SellStockCorrection.
     * @example
     * // Update or create a SellStockCorrection
     * const sellStockCorrection = await prisma.sellStockCorrection.upsert({
     *   create: {
     *     // ... data to create a SellStockCorrection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SellStockCorrection we want to update
     *   }
     * })
     */
    upsert<T extends SellStockCorrectionUpsertArgs>(args: SelectSubset<T, SellStockCorrectionUpsertArgs<ExtArgs>>): Prisma__SellStockCorrectionClient<$Result.GetResult<Prisma.$SellStockCorrectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SellStockCorrections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellStockCorrectionCountArgs} args - Arguments to filter SellStockCorrections to count.
     * @example
     * // Count the number of SellStockCorrections
     * const count = await prisma.sellStockCorrection.count({
     *   where: {
     *     // ... the filter for the SellStockCorrections we want to count
     *   }
     * })
    **/
    count<T extends SellStockCorrectionCountArgs>(
      args?: Subset<T, SellStockCorrectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellStockCorrectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SellStockCorrection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellStockCorrectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellStockCorrectionAggregateArgs>(args: Subset<T, SellStockCorrectionAggregateArgs>): Prisma.PrismaPromise<GetSellStockCorrectionAggregateType<T>>

    /**
     * Group by SellStockCorrection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellStockCorrectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellStockCorrectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellStockCorrectionGroupByArgs['orderBy'] }
        : { orderBy?: SellStockCorrectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellStockCorrectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellStockCorrectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SellStockCorrection model
   */
  readonly fields: SellStockCorrectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SellStockCorrection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellStockCorrectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sell<T extends SellStockCorrection$sellArgs<ExtArgs> = {}>(args?: Subset<T, SellStockCorrection$sellArgs<ExtArgs>>): Prisma__SellClient<$Result.GetResult<Prisma.$SellPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends SellStockCorrection$createdByArgs<ExtArgs> = {}>(args?: Subset<T, SellStockCorrection$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends SellStockCorrection$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, SellStockCorrection$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends SellStockCorrection$itemsArgs<ExtArgs> = {}>(args?: Subset<T, SellStockCorrection$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellStockCorrectionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SellStockCorrection model
   */
  interface SellStockCorrectionFieldRefs {
    readonly id: FieldRef<"SellStockCorrection", 'String'>
    readonly sellId: FieldRef<"SellStockCorrection", 'String'>
    readonly status: FieldRef<"SellStockCorrection", 'SellStockCorrectionStatus'>
    readonly reference: FieldRef<"SellStockCorrection", 'String'>
    readonly notes: FieldRef<"SellStockCorrection", 'String'>
    readonly createdById: FieldRef<"SellStockCorrection", 'String'>
    readonly updatedById: FieldRef<"SellStockCorrection", 'String'>
    readonly total: FieldRef<"SellStockCorrection", 'Float'>
    readonly createdAt: FieldRef<"SellStockCorrection", 'DateTime'>
    readonly updatedAt: FieldRef<"SellStockCorrection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SellStockCorrection findUnique
   */
  export type SellStockCorrectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrection
     */
    select?: SellStockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrection
     */
    omit?: SellStockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionInclude<ExtArgs> | null
    /**
     * Filter, which SellStockCorrection to fetch.
     */
    where: SellStockCorrectionWhereUniqueInput
  }

  /**
   * SellStockCorrection findUniqueOrThrow
   */
  export type SellStockCorrectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrection
     */
    select?: SellStockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrection
     */
    omit?: SellStockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionInclude<ExtArgs> | null
    /**
     * Filter, which SellStockCorrection to fetch.
     */
    where: SellStockCorrectionWhereUniqueInput
  }

  /**
   * SellStockCorrection findFirst
   */
  export type SellStockCorrectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrection
     */
    select?: SellStockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrection
     */
    omit?: SellStockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionInclude<ExtArgs> | null
    /**
     * Filter, which SellStockCorrection to fetch.
     */
    where?: SellStockCorrectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellStockCorrections to fetch.
     */
    orderBy?: SellStockCorrectionOrderByWithRelationInput | SellStockCorrectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellStockCorrections.
     */
    cursor?: SellStockCorrectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellStockCorrections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellStockCorrections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellStockCorrections.
     */
    distinct?: SellStockCorrectionScalarFieldEnum | SellStockCorrectionScalarFieldEnum[]
  }

  /**
   * SellStockCorrection findFirstOrThrow
   */
  export type SellStockCorrectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrection
     */
    select?: SellStockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrection
     */
    omit?: SellStockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionInclude<ExtArgs> | null
    /**
     * Filter, which SellStockCorrection to fetch.
     */
    where?: SellStockCorrectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellStockCorrections to fetch.
     */
    orderBy?: SellStockCorrectionOrderByWithRelationInput | SellStockCorrectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellStockCorrections.
     */
    cursor?: SellStockCorrectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellStockCorrections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellStockCorrections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellStockCorrections.
     */
    distinct?: SellStockCorrectionScalarFieldEnum | SellStockCorrectionScalarFieldEnum[]
  }

  /**
   * SellStockCorrection findMany
   */
  export type SellStockCorrectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrection
     */
    select?: SellStockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrection
     */
    omit?: SellStockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionInclude<ExtArgs> | null
    /**
     * Filter, which SellStockCorrections to fetch.
     */
    where?: SellStockCorrectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellStockCorrections to fetch.
     */
    orderBy?: SellStockCorrectionOrderByWithRelationInput | SellStockCorrectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SellStockCorrections.
     */
    cursor?: SellStockCorrectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellStockCorrections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellStockCorrections.
     */
    skip?: number
    distinct?: SellStockCorrectionScalarFieldEnum | SellStockCorrectionScalarFieldEnum[]
  }

  /**
   * SellStockCorrection create
   */
  export type SellStockCorrectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrection
     */
    select?: SellStockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrection
     */
    omit?: SellStockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionInclude<ExtArgs> | null
    /**
     * The data needed to create a SellStockCorrection.
     */
    data: XOR<SellStockCorrectionCreateInput, SellStockCorrectionUncheckedCreateInput>
  }

  /**
   * SellStockCorrection createMany
   */
  export type SellStockCorrectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SellStockCorrections.
     */
    data: SellStockCorrectionCreateManyInput | SellStockCorrectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SellStockCorrection update
   */
  export type SellStockCorrectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrection
     */
    select?: SellStockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrection
     */
    omit?: SellStockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionInclude<ExtArgs> | null
    /**
     * The data needed to update a SellStockCorrection.
     */
    data: XOR<SellStockCorrectionUpdateInput, SellStockCorrectionUncheckedUpdateInput>
    /**
     * Choose, which SellStockCorrection to update.
     */
    where: SellStockCorrectionWhereUniqueInput
  }

  /**
   * SellStockCorrection updateMany
   */
  export type SellStockCorrectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SellStockCorrections.
     */
    data: XOR<SellStockCorrectionUpdateManyMutationInput, SellStockCorrectionUncheckedUpdateManyInput>
    /**
     * Filter which SellStockCorrections to update
     */
    where?: SellStockCorrectionWhereInput
    /**
     * Limit how many SellStockCorrections to update.
     */
    limit?: number
  }

  /**
   * SellStockCorrection upsert
   */
  export type SellStockCorrectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrection
     */
    select?: SellStockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrection
     */
    omit?: SellStockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionInclude<ExtArgs> | null
    /**
     * The filter to search for the SellStockCorrection to update in case it exists.
     */
    where: SellStockCorrectionWhereUniqueInput
    /**
     * In case the SellStockCorrection found by the `where` argument doesn't exist, create a new SellStockCorrection with this data.
     */
    create: XOR<SellStockCorrectionCreateInput, SellStockCorrectionUncheckedCreateInput>
    /**
     * In case the SellStockCorrection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellStockCorrectionUpdateInput, SellStockCorrectionUncheckedUpdateInput>
  }

  /**
   * SellStockCorrection delete
   */
  export type SellStockCorrectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrection
     */
    select?: SellStockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrection
     */
    omit?: SellStockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionInclude<ExtArgs> | null
    /**
     * Filter which SellStockCorrection to delete.
     */
    where: SellStockCorrectionWhereUniqueInput
  }

  /**
   * SellStockCorrection deleteMany
   */
  export type SellStockCorrectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellStockCorrections to delete
     */
    where?: SellStockCorrectionWhereInput
    /**
     * Limit how many SellStockCorrections to delete.
     */
    limit?: number
  }

  /**
   * SellStockCorrection.sell
   */
  export type SellStockCorrection$sellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sell
     */
    select?: SellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sell
     */
    omit?: SellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellInclude<ExtArgs> | null
    where?: SellWhereInput
  }

  /**
   * SellStockCorrection.createdBy
   */
  export type SellStockCorrection$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SellStockCorrection.updatedBy
   */
  export type SellStockCorrection$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SellStockCorrection.items
   */
  export type SellStockCorrection$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionItem
     */
    select?: SellStockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrectionItem
     */
    omit?: SellStockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionItemInclude<ExtArgs> | null
    where?: SellStockCorrectionItemWhereInput
    orderBy?: SellStockCorrectionItemOrderByWithRelationInput | SellStockCorrectionItemOrderByWithRelationInput[]
    cursor?: SellStockCorrectionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellStockCorrectionItemScalarFieldEnum | SellStockCorrectionItemScalarFieldEnum[]
  }

  /**
   * SellStockCorrection without action
   */
  export type SellStockCorrectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrection
     */
    select?: SellStockCorrectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrection
     */
    omit?: SellStockCorrectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionInclude<ExtArgs> | null
  }


  /**
   * Model SellStockCorrectionItem
   */

  export type AggregateSellStockCorrectionItem = {
    _count: SellStockCorrectionItemCountAggregateOutputType | null
    _avg: SellStockCorrectionItemAvgAggregateOutputType | null
    _sum: SellStockCorrectionItemSumAggregateOutputType | null
    _min: SellStockCorrectionItemMinAggregateOutputType | null
    _max: SellStockCorrectionItemMaxAggregateOutputType | null
  }

  export type SellStockCorrectionItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
  }

  export type SellStockCorrectionItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
  }

  export type SellStockCorrectionItemMinAggregateOutputType = {
    id: string | null
    correctionId: string | null
    productId: string | null
    shopId: string | null
    unitOfMeasureId: string | null
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SellStockCorrectionItemMaxAggregateOutputType = {
    id: string | null
    correctionId: string | null
    productId: string | null
    shopId: string | null
    unitOfMeasureId: string | null
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SellStockCorrectionItemCountAggregateOutputType = {
    id: number
    correctionId: number
    productId: number
    shopId: number
    unitOfMeasureId: number
    quantity: number
    unitPrice: number
    totalPrice: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SellStockCorrectionItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type SellStockCorrectionItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type SellStockCorrectionItemMinAggregateInputType = {
    id?: true
    correctionId?: true
    productId?: true
    shopId?: true
    unitOfMeasureId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SellStockCorrectionItemMaxAggregateInputType = {
    id?: true
    correctionId?: true
    productId?: true
    shopId?: true
    unitOfMeasureId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SellStockCorrectionItemCountAggregateInputType = {
    id?: true
    correctionId?: true
    productId?: true
    shopId?: true
    unitOfMeasureId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SellStockCorrectionItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellStockCorrectionItem to aggregate.
     */
    where?: SellStockCorrectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellStockCorrectionItems to fetch.
     */
    orderBy?: SellStockCorrectionItemOrderByWithRelationInput | SellStockCorrectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellStockCorrectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellStockCorrectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellStockCorrectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SellStockCorrectionItems
    **/
    _count?: true | SellStockCorrectionItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SellStockCorrectionItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SellStockCorrectionItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellStockCorrectionItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellStockCorrectionItemMaxAggregateInputType
  }

  export type GetSellStockCorrectionItemAggregateType<T extends SellStockCorrectionItemAggregateArgs> = {
        [P in keyof T & keyof AggregateSellStockCorrectionItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSellStockCorrectionItem[P]>
      : GetScalarType<T[P], AggregateSellStockCorrectionItem[P]>
  }




  export type SellStockCorrectionItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellStockCorrectionItemWhereInput
    orderBy?: SellStockCorrectionItemOrderByWithAggregationInput | SellStockCorrectionItemOrderByWithAggregationInput[]
    by: SellStockCorrectionItemScalarFieldEnum[] | SellStockCorrectionItemScalarFieldEnum
    having?: SellStockCorrectionItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellStockCorrectionItemCountAggregateInputType | true
    _avg?: SellStockCorrectionItemAvgAggregateInputType
    _sum?: SellStockCorrectionItemSumAggregateInputType
    _min?: SellStockCorrectionItemMinAggregateInputType
    _max?: SellStockCorrectionItemMaxAggregateInputType
  }

  export type SellStockCorrectionItemGroupByOutputType = {
    id: string
    correctionId: string
    productId: string
    shopId: string | null
    unitOfMeasureId: string
    quantity: number
    unitPrice: number
    totalPrice: number
    createdAt: Date
    updatedAt: Date
    _count: SellStockCorrectionItemCountAggregateOutputType | null
    _avg: SellStockCorrectionItemAvgAggregateOutputType | null
    _sum: SellStockCorrectionItemSumAggregateOutputType | null
    _min: SellStockCorrectionItemMinAggregateOutputType | null
    _max: SellStockCorrectionItemMaxAggregateOutputType | null
  }

  type GetSellStockCorrectionItemGroupByPayload<T extends SellStockCorrectionItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellStockCorrectionItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellStockCorrectionItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellStockCorrectionItemGroupByOutputType[P]>
            : GetScalarType<T[P], SellStockCorrectionItemGroupByOutputType[P]>
        }
      >
    >


  export type SellStockCorrectionItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    correctionId?: boolean
    productId?: boolean
    shopId?: boolean
    unitOfMeasureId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    correction?: boolean | SellStockCorrectionDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    shop?: boolean | SellStockCorrectionItem$shopArgs<ExtArgs>
    unitOfMeasure?: boolean | UnitOfMeasureDefaultArgs<ExtArgs>
    batches?: boolean | SellStockCorrectionItem$batchesArgs<ExtArgs>
    _count?: boolean | SellStockCorrectionItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sellStockCorrectionItem"]>



  export type SellStockCorrectionItemSelectScalar = {
    id?: boolean
    correctionId?: boolean
    productId?: boolean
    shopId?: boolean
    unitOfMeasureId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SellStockCorrectionItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "correctionId" | "productId" | "shopId" | "unitOfMeasureId" | "quantity" | "unitPrice" | "totalPrice" | "createdAt" | "updatedAt", ExtArgs["result"]["sellStockCorrectionItem"]>
  export type SellStockCorrectionItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    correction?: boolean | SellStockCorrectionDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    shop?: boolean | SellStockCorrectionItem$shopArgs<ExtArgs>
    unitOfMeasure?: boolean | UnitOfMeasureDefaultArgs<ExtArgs>
    batches?: boolean | SellStockCorrectionItem$batchesArgs<ExtArgs>
    _count?: boolean | SellStockCorrectionItemCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SellStockCorrectionItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SellStockCorrectionItem"
    objects: {
      correction: Prisma.$SellStockCorrectionPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      shop: Prisma.$ShopPayload<ExtArgs> | null
      unitOfMeasure: Prisma.$UnitOfMeasurePayload<ExtArgs>
      batches: Prisma.$SellStockCorrectionBatchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      correctionId: string
      productId: string
      shopId: string | null
      unitOfMeasureId: string
      quantity: number
      unitPrice: number
      totalPrice: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sellStockCorrectionItem"]>
    composites: {}
  }

  type SellStockCorrectionItemGetPayload<S extends boolean | null | undefined | SellStockCorrectionItemDefaultArgs> = $Result.GetResult<Prisma.$SellStockCorrectionItemPayload, S>

  type SellStockCorrectionItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SellStockCorrectionItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SellStockCorrectionItemCountAggregateInputType | true
    }

  export interface SellStockCorrectionItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SellStockCorrectionItem'], meta: { name: 'SellStockCorrectionItem' } }
    /**
     * Find zero or one SellStockCorrectionItem that matches the filter.
     * @param {SellStockCorrectionItemFindUniqueArgs} args - Arguments to find a SellStockCorrectionItem
     * @example
     * // Get one SellStockCorrectionItem
     * const sellStockCorrectionItem = await prisma.sellStockCorrectionItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellStockCorrectionItemFindUniqueArgs>(args: SelectSubset<T, SellStockCorrectionItemFindUniqueArgs<ExtArgs>>): Prisma__SellStockCorrectionItemClient<$Result.GetResult<Prisma.$SellStockCorrectionItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SellStockCorrectionItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SellStockCorrectionItemFindUniqueOrThrowArgs} args - Arguments to find a SellStockCorrectionItem
     * @example
     * // Get one SellStockCorrectionItem
     * const sellStockCorrectionItem = await prisma.sellStockCorrectionItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellStockCorrectionItemFindUniqueOrThrowArgs>(args: SelectSubset<T, SellStockCorrectionItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellStockCorrectionItemClient<$Result.GetResult<Prisma.$SellStockCorrectionItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellStockCorrectionItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellStockCorrectionItemFindFirstArgs} args - Arguments to find a SellStockCorrectionItem
     * @example
     * // Get one SellStockCorrectionItem
     * const sellStockCorrectionItem = await prisma.sellStockCorrectionItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellStockCorrectionItemFindFirstArgs>(args?: SelectSubset<T, SellStockCorrectionItemFindFirstArgs<ExtArgs>>): Prisma__SellStockCorrectionItemClient<$Result.GetResult<Prisma.$SellStockCorrectionItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellStockCorrectionItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellStockCorrectionItemFindFirstOrThrowArgs} args - Arguments to find a SellStockCorrectionItem
     * @example
     * // Get one SellStockCorrectionItem
     * const sellStockCorrectionItem = await prisma.sellStockCorrectionItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellStockCorrectionItemFindFirstOrThrowArgs>(args?: SelectSubset<T, SellStockCorrectionItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellStockCorrectionItemClient<$Result.GetResult<Prisma.$SellStockCorrectionItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SellStockCorrectionItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellStockCorrectionItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SellStockCorrectionItems
     * const sellStockCorrectionItems = await prisma.sellStockCorrectionItem.findMany()
     * 
     * // Get first 10 SellStockCorrectionItems
     * const sellStockCorrectionItems = await prisma.sellStockCorrectionItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellStockCorrectionItemWithIdOnly = await prisma.sellStockCorrectionItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellStockCorrectionItemFindManyArgs>(args?: SelectSubset<T, SellStockCorrectionItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellStockCorrectionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SellStockCorrectionItem.
     * @param {SellStockCorrectionItemCreateArgs} args - Arguments to create a SellStockCorrectionItem.
     * @example
     * // Create one SellStockCorrectionItem
     * const SellStockCorrectionItem = await prisma.sellStockCorrectionItem.create({
     *   data: {
     *     // ... data to create a SellStockCorrectionItem
     *   }
     * })
     * 
     */
    create<T extends SellStockCorrectionItemCreateArgs>(args: SelectSubset<T, SellStockCorrectionItemCreateArgs<ExtArgs>>): Prisma__SellStockCorrectionItemClient<$Result.GetResult<Prisma.$SellStockCorrectionItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SellStockCorrectionItems.
     * @param {SellStockCorrectionItemCreateManyArgs} args - Arguments to create many SellStockCorrectionItems.
     * @example
     * // Create many SellStockCorrectionItems
     * const sellStockCorrectionItem = await prisma.sellStockCorrectionItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellStockCorrectionItemCreateManyArgs>(args?: SelectSubset<T, SellStockCorrectionItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SellStockCorrectionItem.
     * @param {SellStockCorrectionItemDeleteArgs} args - Arguments to delete one SellStockCorrectionItem.
     * @example
     * // Delete one SellStockCorrectionItem
     * const SellStockCorrectionItem = await prisma.sellStockCorrectionItem.delete({
     *   where: {
     *     // ... filter to delete one SellStockCorrectionItem
     *   }
     * })
     * 
     */
    delete<T extends SellStockCorrectionItemDeleteArgs>(args: SelectSubset<T, SellStockCorrectionItemDeleteArgs<ExtArgs>>): Prisma__SellStockCorrectionItemClient<$Result.GetResult<Prisma.$SellStockCorrectionItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SellStockCorrectionItem.
     * @param {SellStockCorrectionItemUpdateArgs} args - Arguments to update one SellStockCorrectionItem.
     * @example
     * // Update one SellStockCorrectionItem
     * const sellStockCorrectionItem = await prisma.sellStockCorrectionItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellStockCorrectionItemUpdateArgs>(args: SelectSubset<T, SellStockCorrectionItemUpdateArgs<ExtArgs>>): Prisma__SellStockCorrectionItemClient<$Result.GetResult<Prisma.$SellStockCorrectionItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SellStockCorrectionItems.
     * @param {SellStockCorrectionItemDeleteManyArgs} args - Arguments to filter SellStockCorrectionItems to delete.
     * @example
     * // Delete a few SellStockCorrectionItems
     * const { count } = await prisma.sellStockCorrectionItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellStockCorrectionItemDeleteManyArgs>(args?: SelectSubset<T, SellStockCorrectionItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellStockCorrectionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellStockCorrectionItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SellStockCorrectionItems
     * const sellStockCorrectionItem = await prisma.sellStockCorrectionItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellStockCorrectionItemUpdateManyArgs>(args: SelectSubset<T, SellStockCorrectionItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SellStockCorrectionItem.
     * @param {SellStockCorrectionItemUpsertArgs} args - Arguments to update or create a SellStockCorrectionItem.
     * @example
     * // Update or create a SellStockCorrectionItem
     * const sellStockCorrectionItem = await prisma.sellStockCorrectionItem.upsert({
     *   create: {
     *     // ... data to create a SellStockCorrectionItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SellStockCorrectionItem we want to update
     *   }
     * })
     */
    upsert<T extends SellStockCorrectionItemUpsertArgs>(args: SelectSubset<T, SellStockCorrectionItemUpsertArgs<ExtArgs>>): Prisma__SellStockCorrectionItemClient<$Result.GetResult<Prisma.$SellStockCorrectionItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SellStockCorrectionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellStockCorrectionItemCountArgs} args - Arguments to filter SellStockCorrectionItems to count.
     * @example
     * // Count the number of SellStockCorrectionItems
     * const count = await prisma.sellStockCorrectionItem.count({
     *   where: {
     *     // ... the filter for the SellStockCorrectionItems we want to count
     *   }
     * })
    **/
    count<T extends SellStockCorrectionItemCountArgs>(
      args?: Subset<T, SellStockCorrectionItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellStockCorrectionItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SellStockCorrectionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellStockCorrectionItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellStockCorrectionItemAggregateArgs>(args: Subset<T, SellStockCorrectionItemAggregateArgs>): Prisma.PrismaPromise<GetSellStockCorrectionItemAggregateType<T>>

    /**
     * Group by SellStockCorrectionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellStockCorrectionItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellStockCorrectionItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellStockCorrectionItemGroupByArgs['orderBy'] }
        : { orderBy?: SellStockCorrectionItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellStockCorrectionItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellStockCorrectionItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SellStockCorrectionItem model
   */
  readonly fields: SellStockCorrectionItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SellStockCorrectionItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellStockCorrectionItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    correction<T extends SellStockCorrectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SellStockCorrectionDefaultArgs<ExtArgs>>): Prisma__SellStockCorrectionClient<$Result.GetResult<Prisma.$SellStockCorrectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shop<T extends SellStockCorrectionItem$shopArgs<ExtArgs> = {}>(args?: Subset<T, SellStockCorrectionItem$shopArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    unitOfMeasure<T extends UnitOfMeasureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasureDefaultArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    batches<T extends SellStockCorrectionItem$batchesArgs<ExtArgs> = {}>(args?: Subset<T, SellStockCorrectionItem$batchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellStockCorrectionBatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SellStockCorrectionItem model
   */
  interface SellStockCorrectionItemFieldRefs {
    readonly id: FieldRef<"SellStockCorrectionItem", 'String'>
    readonly correctionId: FieldRef<"SellStockCorrectionItem", 'String'>
    readonly productId: FieldRef<"SellStockCorrectionItem", 'String'>
    readonly shopId: FieldRef<"SellStockCorrectionItem", 'String'>
    readonly unitOfMeasureId: FieldRef<"SellStockCorrectionItem", 'String'>
    readonly quantity: FieldRef<"SellStockCorrectionItem", 'Int'>
    readonly unitPrice: FieldRef<"SellStockCorrectionItem", 'Float'>
    readonly totalPrice: FieldRef<"SellStockCorrectionItem", 'Float'>
    readonly createdAt: FieldRef<"SellStockCorrectionItem", 'DateTime'>
    readonly updatedAt: FieldRef<"SellStockCorrectionItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SellStockCorrectionItem findUnique
   */
  export type SellStockCorrectionItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionItem
     */
    select?: SellStockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrectionItem
     */
    omit?: SellStockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionItemInclude<ExtArgs> | null
    /**
     * Filter, which SellStockCorrectionItem to fetch.
     */
    where: SellStockCorrectionItemWhereUniqueInput
  }

  /**
   * SellStockCorrectionItem findUniqueOrThrow
   */
  export type SellStockCorrectionItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionItem
     */
    select?: SellStockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrectionItem
     */
    omit?: SellStockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionItemInclude<ExtArgs> | null
    /**
     * Filter, which SellStockCorrectionItem to fetch.
     */
    where: SellStockCorrectionItemWhereUniqueInput
  }

  /**
   * SellStockCorrectionItem findFirst
   */
  export type SellStockCorrectionItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionItem
     */
    select?: SellStockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrectionItem
     */
    omit?: SellStockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionItemInclude<ExtArgs> | null
    /**
     * Filter, which SellStockCorrectionItem to fetch.
     */
    where?: SellStockCorrectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellStockCorrectionItems to fetch.
     */
    orderBy?: SellStockCorrectionItemOrderByWithRelationInput | SellStockCorrectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellStockCorrectionItems.
     */
    cursor?: SellStockCorrectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellStockCorrectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellStockCorrectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellStockCorrectionItems.
     */
    distinct?: SellStockCorrectionItemScalarFieldEnum | SellStockCorrectionItemScalarFieldEnum[]
  }

  /**
   * SellStockCorrectionItem findFirstOrThrow
   */
  export type SellStockCorrectionItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionItem
     */
    select?: SellStockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrectionItem
     */
    omit?: SellStockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionItemInclude<ExtArgs> | null
    /**
     * Filter, which SellStockCorrectionItem to fetch.
     */
    where?: SellStockCorrectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellStockCorrectionItems to fetch.
     */
    orderBy?: SellStockCorrectionItemOrderByWithRelationInput | SellStockCorrectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellStockCorrectionItems.
     */
    cursor?: SellStockCorrectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellStockCorrectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellStockCorrectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellStockCorrectionItems.
     */
    distinct?: SellStockCorrectionItemScalarFieldEnum | SellStockCorrectionItemScalarFieldEnum[]
  }

  /**
   * SellStockCorrectionItem findMany
   */
  export type SellStockCorrectionItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionItem
     */
    select?: SellStockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrectionItem
     */
    omit?: SellStockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionItemInclude<ExtArgs> | null
    /**
     * Filter, which SellStockCorrectionItems to fetch.
     */
    where?: SellStockCorrectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellStockCorrectionItems to fetch.
     */
    orderBy?: SellStockCorrectionItemOrderByWithRelationInput | SellStockCorrectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SellStockCorrectionItems.
     */
    cursor?: SellStockCorrectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellStockCorrectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellStockCorrectionItems.
     */
    skip?: number
    distinct?: SellStockCorrectionItemScalarFieldEnum | SellStockCorrectionItemScalarFieldEnum[]
  }

  /**
   * SellStockCorrectionItem create
   */
  export type SellStockCorrectionItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionItem
     */
    select?: SellStockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrectionItem
     */
    omit?: SellStockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionItemInclude<ExtArgs> | null
    /**
     * The data needed to create a SellStockCorrectionItem.
     */
    data: XOR<SellStockCorrectionItemCreateInput, SellStockCorrectionItemUncheckedCreateInput>
  }

  /**
   * SellStockCorrectionItem createMany
   */
  export type SellStockCorrectionItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SellStockCorrectionItems.
     */
    data: SellStockCorrectionItemCreateManyInput | SellStockCorrectionItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SellStockCorrectionItem update
   */
  export type SellStockCorrectionItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionItem
     */
    select?: SellStockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrectionItem
     */
    omit?: SellStockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionItemInclude<ExtArgs> | null
    /**
     * The data needed to update a SellStockCorrectionItem.
     */
    data: XOR<SellStockCorrectionItemUpdateInput, SellStockCorrectionItemUncheckedUpdateInput>
    /**
     * Choose, which SellStockCorrectionItem to update.
     */
    where: SellStockCorrectionItemWhereUniqueInput
  }

  /**
   * SellStockCorrectionItem updateMany
   */
  export type SellStockCorrectionItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SellStockCorrectionItems.
     */
    data: XOR<SellStockCorrectionItemUpdateManyMutationInput, SellStockCorrectionItemUncheckedUpdateManyInput>
    /**
     * Filter which SellStockCorrectionItems to update
     */
    where?: SellStockCorrectionItemWhereInput
    /**
     * Limit how many SellStockCorrectionItems to update.
     */
    limit?: number
  }

  /**
   * SellStockCorrectionItem upsert
   */
  export type SellStockCorrectionItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionItem
     */
    select?: SellStockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrectionItem
     */
    omit?: SellStockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionItemInclude<ExtArgs> | null
    /**
     * The filter to search for the SellStockCorrectionItem to update in case it exists.
     */
    where: SellStockCorrectionItemWhereUniqueInput
    /**
     * In case the SellStockCorrectionItem found by the `where` argument doesn't exist, create a new SellStockCorrectionItem with this data.
     */
    create: XOR<SellStockCorrectionItemCreateInput, SellStockCorrectionItemUncheckedCreateInput>
    /**
     * In case the SellStockCorrectionItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellStockCorrectionItemUpdateInput, SellStockCorrectionItemUncheckedUpdateInput>
  }

  /**
   * SellStockCorrectionItem delete
   */
  export type SellStockCorrectionItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionItem
     */
    select?: SellStockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrectionItem
     */
    omit?: SellStockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionItemInclude<ExtArgs> | null
    /**
     * Filter which SellStockCorrectionItem to delete.
     */
    where: SellStockCorrectionItemWhereUniqueInput
  }

  /**
   * SellStockCorrectionItem deleteMany
   */
  export type SellStockCorrectionItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellStockCorrectionItems to delete
     */
    where?: SellStockCorrectionItemWhereInput
    /**
     * Limit how many SellStockCorrectionItems to delete.
     */
    limit?: number
  }

  /**
   * SellStockCorrectionItem.shop
   */
  export type SellStockCorrectionItem$shopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    where?: ShopWhereInput
  }

  /**
   * SellStockCorrectionItem.batches
   */
  export type SellStockCorrectionItem$batchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionBatch
     */
    select?: SellStockCorrectionBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrectionBatch
     */
    omit?: SellStockCorrectionBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionBatchInclude<ExtArgs> | null
    where?: SellStockCorrectionBatchWhereInput
    orderBy?: SellStockCorrectionBatchOrderByWithRelationInput | SellStockCorrectionBatchOrderByWithRelationInput[]
    cursor?: SellStockCorrectionBatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellStockCorrectionBatchScalarFieldEnum | SellStockCorrectionBatchScalarFieldEnum[]
  }

  /**
   * SellStockCorrectionItem without action
   */
  export type SellStockCorrectionItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionItem
     */
    select?: SellStockCorrectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrectionItem
     */
    omit?: SellStockCorrectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionItemInclude<ExtArgs> | null
  }


  /**
   * Model SellStockCorrectionBatch
   */

  export type AggregateSellStockCorrectionBatch = {
    _count: SellStockCorrectionBatchCountAggregateOutputType | null
    _avg: SellStockCorrectionBatchAvgAggregateOutputType | null
    _sum: SellStockCorrectionBatchSumAggregateOutputType | null
    _min: SellStockCorrectionBatchMinAggregateOutputType | null
    _max: SellStockCorrectionBatchMaxAggregateOutputType | null
  }

  export type SellStockCorrectionBatchAvgAggregateOutputType = {
    quantity: number | null
  }

  export type SellStockCorrectionBatchSumAggregateOutputType = {
    quantity: number | null
  }

  export type SellStockCorrectionBatchMinAggregateOutputType = {
    id: string | null
    correctionItemId: string | null
    batchId: string | null
    quantity: number | null
  }

  export type SellStockCorrectionBatchMaxAggregateOutputType = {
    id: string | null
    correctionItemId: string | null
    batchId: string | null
    quantity: number | null
  }

  export type SellStockCorrectionBatchCountAggregateOutputType = {
    id: number
    correctionItemId: number
    batchId: number
    quantity: number
    _all: number
  }


  export type SellStockCorrectionBatchAvgAggregateInputType = {
    quantity?: true
  }

  export type SellStockCorrectionBatchSumAggregateInputType = {
    quantity?: true
  }

  export type SellStockCorrectionBatchMinAggregateInputType = {
    id?: true
    correctionItemId?: true
    batchId?: true
    quantity?: true
  }

  export type SellStockCorrectionBatchMaxAggregateInputType = {
    id?: true
    correctionItemId?: true
    batchId?: true
    quantity?: true
  }

  export type SellStockCorrectionBatchCountAggregateInputType = {
    id?: true
    correctionItemId?: true
    batchId?: true
    quantity?: true
    _all?: true
  }

  export type SellStockCorrectionBatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellStockCorrectionBatch to aggregate.
     */
    where?: SellStockCorrectionBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellStockCorrectionBatches to fetch.
     */
    orderBy?: SellStockCorrectionBatchOrderByWithRelationInput | SellStockCorrectionBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellStockCorrectionBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellStockCorrectionBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellStockCorrectionBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SellStockCorrectionBatches
    **/
    _count?: true | SellStockCorrectionBatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SellStockCorrectionBatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SellStockCorrectionBatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellStockCorrectionBatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellStockCorrectionBatchMaxAggregateInputType
  }

  export type GetSellStockCorrectionBatchAggregateType<T extends SellStockCorrectionBatchAggregateArgs> = {
        [P in keyof T & keyof AggregateSellStockCorrectionBatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSellStockCorrectionBatch[P]>
      : GetScalarType<T[P], AggregateSellStockCorrectionBatch[P]>
  }




  export type SellStockCorrectionBatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellStockCorrectionBatchWhereInput
    orderBy?: SellStockCorrectionBatchOrderByWithAggregationInput | SellStockCorrectionBatchOrderByWithAggregationInput[]
    by: SellStockCorrectionBatchScalarFieldEnum[] | SellStockCorrectionBatchScalarFieldEnum
    having?: SellStockCorrectionBatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellStockCorrectionBatchCountAggregateInputType | true
    _avg?: SellStockCorrectionBatchAvgAggregateInputType
    _sum?: SellStockCorrectionBatchSumAggregateInputType
    _min?: SellStockCorrectionBatchMinAggregateInputType
    _max?: SellStockCorrectionBatchMaxAggregateInputType
  }

  export type SellStockCorrectionBatchGroupByOutputType = {
    id: string
    correctionItemId: string
    batchId: string
    quantity: number
    _count: SellStockCorrectionBatchCountAggregateOutputType | null
    _avg: SellStockCorrectionBatchAvgAggregateOutputType | null
    _sum: SellStockCorrectionBatchSumAggregateOutputType | null
    _min: SellStockCorrectionBatchMinAggregateOutputType | null
    _max: SellStockCorrectionBatchMaxAggregateOutputType | null
  }

  type GetSellStockCorrectionBatchGroupByPayload<T extends SellStockCorrectionBatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellStockCorrectionBatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellStockCorrectionBatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellStockCorrectionBatchGroupByOutputType[P]>
            : GetScalarType<T[P], SellStockCorrectionBatchGroupByOutputType[P]>
        }
      >
    >


  export type SellStockCorrectionBatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    correctionItemId?: boolean
    batchId?: boolean
    quantity?: boolean
    correctionItem?: boolean | SellStockCorrectionItemDefaultArgs<ExtArgs>
    batch?: boolean | ProductBatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sellStockCorrectionBatch"]>



  export type SellStockCorrectionBatchSelectScalar = {
    id?: boolean
    correctionItemId?: boolean
    batchId?: boolean
    quantity?: boolean
  }

  export type SellStockCorrectionBatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "correctionItemId" | "batchId" | "quantity", ExtArgs["result"]["sellStockCorrectionBatch"]>
  export type SellStockCorrectionBatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    correctionItem?: boolean | SellStockCorrectionItemDefaultArgs<ExtArgs>
    batch?: boolean | ProductBatchDefaultArgs<ExtArgs>
  }

  export type $SellStockCorrectionBatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SellStockCorrectionBatch"
    objects: {
      correctionItem: Prisma.$SellStockCorrectionItemPayload<ExtArgs>
      batch: Prisma.$ProductBatchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      correctionItemId: string
      batchId: string
      quantity: number
    }, ExtArgs["result"]["sellStockCorrectionBatch"]>
    composites: {}
  }

  type SellStockCorrectionBatchGetPayload<S extends boolean | null | undefined | SellStockCorrectionBatchDefaultArgs> = $Result.GetResult<Prisma.$SellStockCorrectionBatchPayload, S>

  type SellStockCorrectionBatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SellStockCorrectionBatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SellStockCorrectionBatchCountAggregateInputType | true
    }

  export interface SellStockCorrectionBatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SellStockCorrectionBatch'], meta: { name: 'SellStockCorrectionBatch' } }
    /**
     * Find zero or one SellStockCorrectionBatch that matches the filter.
     * @param {SellStockCorrectionBatchFindUniqueArgs} args - Arguments to find a SellStockCorrectionBatch
     * @example
     * // Get one SellStockCorrectionBatch
     * const sellStockCorrectionBatch = await prisma.sellStockCorrectionBatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellStockCorrectionBatchFindUniqueArgs>(args: SelectSubset<T, SellStockCorrectionBatchFindUniqueArgs<ExtArgs>>): Prisma__SellStockCorrectionBatchClient<$Result.GetResult<Prisma.$SellStockCorrectionBatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SellStockCorrectionBatch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SellStockCorrectionBatchFindUniqueOrThrowArgs} args - Arguments to find a SellStockCorrectionBatch
     * @example
     * // Get one SellStockCorrectionBatch
     * const sellStockCorrectionBatch = await prisma.sellStockCorrectionBatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellStockCorrectionBatchFindUniqueOrThrowArgs>(args: SelectSubset<T, SellStockCorrectionBatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellStockCorrectionBatchClient<$Result.GetResult<Prisma.$SellStockCorrectionBatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellStockCorrectionBatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellStockCorrectionBatchFindFirstArgs} args - Arguments to find a SellStockCorrectionBatch
     * @example
     * // Get one SellStockCorrectionBatch
     * const sellStockCorrectionBatch = await prisma.sellStockCorrectionBatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellStockCorrectionBatchFindFirstArgs>(args?: SelectSubset<T, SellStockCorrectionBatchFindFirstArgs<ExtArgs>>): Prisma__SellStockCorrectionBatchClient<$Result.GetResult<Prisma.$SellStockCorrectionBatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellStockCorrectionBatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellStockCorrectionBatchFindFirstOrThrowArgs} args - Arguments to find a SellStockCorrectionBatch
     * @example
     * // Get one SellStockCorrectionBatch
     * const sellStockCorrectionBatch = await prisma.sellStockCorrectionBatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellStockCorrectionBatchFindFirstOrThrowArgs>(args?: SelectSubset<T, SellStockCorrectionBatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellStockCorrectionBatchClient<$Result.GetResult<Prisma.$SellStockCorrectionBatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SellStockCorrectionBatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellStockCorrectionBatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SellStockCorrectionBatches
     * const sellStockCorrectionBatches = await prisma.sellStockCorrectionBatch.findMany()
     * 
     * // Get first 10 SellStockCorrectionBatches
     * const sellStockCorrectionBatches = await prisma.sellStockCorrectionBatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellStockCorrectionBatchWithIdOnly = await prisma.sellStockCorrectionBatch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellStockCorrectionBatchFindManyArgs>(args?: SelectSubset<T, SellStockCorrectionBatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellStockCorrectionBatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SellStockCorrectionBatch.
     * @param {SellStockCorrectionBatchCreateArgs} args - Arguments to create a SellStockCorrectionBatch.
     * @example
     * // Create one SellStockCorrectionBatch
     * const SellStockCorrectionBatch = await prisma.sellStockCorrectionBatch.create({
     *   data: {
     *     // ... data to create a SellStockCorrectionBatch
     *   }
     * })
     * 
     */
    create<T extends SellStockCorrectionBatchCreateArgs>(args: SelectSubset<T, SellStockCorrectionBatchCreateArgs<ExtArgs>>): Prisma__SellStockCorrectionBatchClient<$Result.GetResult<Prisma.$SellStockCorrectionBatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SellStockCorrectionBatches.
     * @param {SellStockCorrectionBatchCreateManyArgs} args - Arguments to create many SellStockCorrectionBatches.
     * @example
     * // Create many SellStockCorrectionBatches
     * const sellStockCorrectionBatch = await prisma.sellStockCorrectionBatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellStockCorrectionBatchCreateManyArgs>(args?: SelectSubset<T, SellStockCorrectionBatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SellStockCorrectionBatch.
     * @param {SellStockCorrectionBatchDeleteArgs} args - Arguments to delete one SellStockCorrectionBatch.
     * @example
     * // Delete one SellStockCorrectionBatch
     * const SellStockCorrectionBatch = await prisma.sellStockCorrectionBatch.delete({
     *   where: {
     *     // ... filter to delete one SellStockCorrectionBatch
     *   }
     * })
     * 
     */
    delete<T extends SellStockCorrectionBatchDeleteArgs>(args: SelectSubset<T, SellStockCorrectionBatchDeleteArgs<ExtArgs>>): Prisma__SellStockCorrectionBatchClient<$Result.GetResult<Prisma.$SellStockCorrectionBatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SellStockCorrectionBatch.
     * @param {SellStockCorrectionBatchUpdateArgs} args - Arguments to update one SellStockCorrectionBatch.
     * @example
     * // Update one SellStockCorrectionBatch
     * const sellStockCorrectionBatch = await prisma.sellStockCorrectionBatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellStockCorrectionBatchUpdateArgs>(args: SelectSubset<T, SellStockCorrectionBatchUpdateArgs<ExtArgs>>): Prisma__SellStockCorrectionBatchClient<$Result.GetResult<Prisma.$SellStockCorrectionBatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SellStockCorrectionBatches.
     * @param {SellStockCorrectionBatchDeleteManyArgs} args - Arguments to filter SellStockCorrectionBatches to delete.
     * @example
     * // Delete a few SellStockCorrectionBatches
     * const { count } = await prisma.sellStockCorrectionBatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellStockCorrectionBatchDeleteManyArgs>(args?: SelectSubset<T, SellStockCorrectionBatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellStockCorrectionBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellStockCorrectionBatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SellStockCorrectionBatches
     * const sellStockCorrectionBatch = await prisma.sellStockCorrectionBatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellStockCorrectionBatchUpdateManyArgs>(args: SelectSubset<T, SellStockCorrectionBatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SellStockCorrectionBatch.
     * @param {SellStockCorrectionBatchUpsertArgs} args - Arguments to update or create a SellStockCorrectionBatch.
     * @example
     * // Update or create a SellStockCorrectionBatch
     * const sellStockCorrectionBatch = await prisma.sellStockCorrectionBatch.upsert({
     *   create: {
     *     // ... data to create a SellStockCorrectionBatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SellStockCorrectionBatch we want to update
     *   }
     * })
     */
    upsert<T extends SellStockCorrectionBatchUpsertArgs>(args: SelectSubset<T, SellStockCorrectionBatchUpsertArgs<ExtArgs>>): Prisma__SellStockCorrectionBatchClient<$Result.GetResult<Prisma.$SellStockCorrectionBatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SellStockCorrectionBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellStockCorrectionBatchCountArgs} args - Arguments to filter SellStockCorrectionBatches to count.
     * @example
     * // Count the number of SellStockCorrectionBatches
     * const count = await prisma.sellStockCorrectionBatch.count({
     *   where: {
     *     // ... the filter for the SellStockCorrectionBatches we want to count
     *   }
     * })
    **/
    count<T extends SellStockCorrectionBatchCountArgs>(
      args?: Subset<T, SellStockCorrectionBatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellStockCorrectionBatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SellStockCorrectionBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellStockCorrectionBatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellStockCorrectionBatchAggregateArgs>(args: Subset<T, SellStockCorrectionBatchAggregateArgs>): Prisma.PrismaPromise<GetSellStockCorrectionBatchAggregateType<T>>

    /**
     * Group by SellStockCorrectionBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellStockCorrectionBatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellStockCorrectionBatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellStockCorrectionBatchGroupByArgs['orderBy'] }
        : { orderBy?: SellStockCorrectionBatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellStockCorrectionBatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellStockCorrectionBatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SellStockCorrectionBatch model
   */
  readonly fields: SellStockCorrectionBatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SellStockCorrectionBatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellStockCorrectionBatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    correctionItem<T extends SellStockCorrectionItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SellStockCorrectionItemDefaultArgs<ExtArgs>>): Prisma__SellStockCorrectionItemClient<$Result.GetResult<Prisma.$SellStockCorrectionItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    batch<T extends ProductBatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductBatchDefaultArgs<ExtArgs>>): Prisma__ProductBatchClient<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SellStockCorrectionBatch model
   */
  interface SellStockCorrectionBatchFieldRefs {
    readonly id: FieldRef<"SellStockCorrectionBatch", 'String'>
    readonly correctionItemId: FieldRef<"SellStockCorrectionBatch", 'String'>
    readonly batchId: FieldRef<"SellStockCorrectionBatch", 'String'>
    readonly quantity: FieldRef<"SellStockCorrectionBatch", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SellStockCorrectionBatch findUnique
   */
  export type SellStockCorrectionBatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionBatch
     */
    select?: SellStockCorrectionBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrectionBatch
     */
    omit?: SellStockCorrectionBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionBatchInclude<ExtArgs> | null
    /**
     * Filter, which SellStockCorrectionBatch to fetch.
     */
    where: SellStockCorrectionBatchWhereUniqueInput
  }

  /**
   * SellStockCorrectionBatch findUniqueOrThrow
   */
  export type SellStockCorrectionBatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionBatch
     */
    select?: SellStockCorrectionBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrectionBatch
     */
    omit?: SellStockCorrectionBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionBatchInclude<ExtArgs> | null
    /**
     * Filter, which SellStockCorrectionBatch to fetch.
     */
    where: SellStockCorrectionBatchWhereUniqueInput
  }

  /**
   * SellStockCorrectionBatch findFirst
   */
  export type SellStockCorrectionBatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionBatch
     */
    select?: SellStockCorrectionBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrectionBatch
     */
    omit?: SellStockCorrectionBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionBatchInclude<ExtArgs> | null
    /**
     * Filter, which SellStockCorrectionBatch to fetch.
     */
    where?: SellStockCorrectionBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellStockCorrectionBatches to fetch.
     */
    orderBy?: SellStockCorrectionBatchOrderByWithRelationInput | SellStockCorrectionBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellStockCorrectionBatches.
     */
    cursor?: SellStockCorrectionBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellStockCorrectionBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellStockCorrectionBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellStockCorrectionBatches.
     */
    distinct?: SellStockCorrectionBatchScalarFieldEnum | SellStockCorrectionBatchScalarFieldEnum[]
  }

  /**
   * SellStockCorrectionBatch findFirstOrThrow
   */
  export type SellStockCorrectionBatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionBatch
     */
    select?: SellStockCorrectionBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrectionBatch
     */
    omit?: SellStockCorrectionBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionBatchInclude<ExtArgs> | null
    /**
     * Filter, which SellStockCorrectionBatch to fetch.
     */
    where?: SellStockCorrectionBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellStockCorrectionBatches to fetch.
     */
    orderBy?: SellStockCorrectionBatchOrderByWithRelationInput | SellStockCorrectionBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellStockCorrectionBatches.
     */
    cursor?: SellStockCorrectionBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellStockCorrectionBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellStockCorrectionBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellStockCorrectionBatches.
     */
    distinct?: SellStockCorrectionBatchScalarFieldEnum | SellStockCorrectionBatchScalarFieldEnum[]
  }

  /**
   * SellStockCorrectionBatch findMany
   */
  export type SellStockCorrectionBatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionBatch
     */
    select?: SellStockCorrectionBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrectionBatch
     */
    omit?: SellStockCorrectionBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionBatchInclude<ExtArgs> | null
    /**
     * Filter, which SellStockCorrectionBatches to fetch.
     */
    where?: SellStockCorrectionBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellStockCorrectionBatches to fetch.
     */
    orderBy?: SellStockCorrectionBatchOrderByWithRelationInput | SellStockCorrectionBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SellStockCorrectionBatches.
     */
    cursor?: SellStockCorrectionBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellStockCorrectionBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellStockCorrectionBatches.
     */
    skip?: number
    distinct?: SellStockCorrectionBatchScalarFieldEnum | SellStockCorrectionBatchScalarFieldEnum[]
  }

  /**
   * SellStockCorrectionBatch create
   */
  export type SellStockCorrectionBatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionBatch
     */
    select?: SellStockCorrectionBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrectionBatch
     */
    omit?: SellStockCorrectionBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionBatchInclude<ExtArgs> | null
    /**
     * The data needed to create a SellStockCorrectionBatch.
     */
    data: XOR<SellStockCorrectionBatchCreateInput, SellStockCorrectionBatchUncheckedCreateInput>
  }

  /**
   * SellStockCorrectionBatch createMany
   */
  export type SellStockCorrectionBatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SellStockCorrectionBatches.
     */
    data: SellStockCorrectionBatchCreateManyInput | SellStockCorrectionBatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SellStockCorrectionBatch update
   */
  export type SellStockCorrectionBatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionBatch
     */
    select?: SellStockCorrectionBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrectionBatch
     */
    omit?: SellStockCorrectionBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionBatchInclude<ExtArgs> | null
    /**
     * The data needed to update a SellStockCorrectionBatch.
     */
    data: XOR<SellStockCorrectionBatchUpdateInput, SellStockCorrectionBatchUncheckedUpdateInput>
    /**
     * Choose, which SellStockCorrectionBatch to update.
     */
    where: SellStockCorrectionBatchWhereUniqueInput
  }

  /**
   * SellStockCorrectionBatch updateMany
   */
  export type SellStockCorrectionBatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SellStockCorrectionBatches.
     */
    data: XOR<SellStockCorrectionBatchUpdateManyMutationInput, SellStockCorrectionBatchUncheckedUpdateManyInput>
    /**
     * Filter which SellStockCorrectionBatches to update
     */
    where?: SellStockCorrectionBatchWhereInput
    /**
     * Limit how many SellStockCorrectionBatches to update.
     */
    limit?: number
  }

  /**
   * SellStockCorrectionBatch upsert
   */
  export type SellStockCorrectionBatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionBatch
     */
    select?: SellStockCorrectionBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrectionBatch
     */
    omit?: SellStockCorrectionBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionBatchInclude<ExtArgs> | null
    /**
     * The filter to search for the SellStockCorrectionBatch to update in case it exists.
     */
    where: SellStockCorrectionBatchWhereUniqueInput
    /**
     * In case the SellStockCorrectionBatch found by the `where` argument doesn't exist, create a new SellStockCorrectionBatch with this data.
     */
    create: XOR<SellStockCorrectionBatchCreateInput, SellStockCorrectionBatchUncheckedCreateInput>
    /**
     * In case the SellStockCorrectionBatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellStockCorrectionBatchUpdateInput, SellStockCorrectionBatchUncheckedUpdateInput>
  }

  /**
   * SellStockCorrectionBatch delete
   */
  export type SellStockCorrectionBatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionBatch
     */
    select?: SellStockCorrectionBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrectionBatch
     */
    omit?: SellStockCorrectionBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionBatchInclude<ExtArgs> | null
    /**
     * Filter which SellStockCorrectionBatch to delete.
     */
    where: SellStockCorrectionBatchWhereUniqueInput
  }

  /**
   * SellStockCorrectionBatch deleteMany
   */
  export type SellStockCorrectionBatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellStockCorrectionBatches to delete
     */
    where?: SellStockCorrectionBatchWhereInput
    /**
     * Limit how many SellStockCorrectionBatches to delete.
     */
    limit?: number
  }

  /**
   * SellStockCorrectionBatch without action
   */
  export type SellStockCorrectionBatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellStockCorrectionBatch
     */
    select?: SellStockCorrectionBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellStockCorrectionBatch
     */
    omit?: SellStockCorrectionBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellStockCorrectionBatchInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    type: $Enums.NotificationType | null
    read: boolean | null
    relatedEntityType: $Enums.RelatedEntityType | null
    relatedEntityId: string | null
    createdAt: Date | null
    readAt: Date | null
    storeId: string | null
    shopId: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    type: $Enums.NotificationType | null
    read: boolean | null
    relatedEntityType: $Enums.RelatedEntityType | null
    relatedEntityId: string | null
    createdAt: Date | null
    readAt: Date | null
    storeId: string | null
    shopId: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    title: number
    message: number
    type: number
    read: number
    relatedEntityType: number
    relatedEntityId: number
    createdAt: number
    readAt: number
    storeId: number
    shopId: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    read?: true
    relatedEntityType?: true
    relatedEntityId?: true
    createdAt?: true
    readAt?: true
    storeId?: true
    shopId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    read?: true
    relatedEntityType?: true
    relatedEntityId?: true
    createdAt?: true
    readAt?: true
    storeId?: true
    shopId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    read?: true
    relatedEntityType?: true
    relatedEntityId?: true
    createdAt?: true
    readAt?: true
    storeId?: true
    shopId?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    title: string
    message: string
    type: $Enums.NotificationType
    read: boolean
    relatedEntityType: $Enums.RelatedEntityType | null
    relatedEntityId: string | null
    createdAt: Date
    readAt: Date | null
    storeId: string | null
    shopId: string | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    read?: boolean
    relatedEntityType?: boolean
    relatedEntityId?: boolean
    createdAt?: boolean
    readAt?: boolean
    storeId?: boolean
    shopId?: boolean
    store?: boolean | Notification$storeArgs<ExtArgs>
    shop?: boolean | Notification$shopArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>



  export type NotificationSelectScalar = {
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    read?: boolean
    relatedEntityType?: boolean
    relatedEntityId?: boolean
    createdAt?: boolean
    readAt?: boolean
    storeId?: boolean
    shopId?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "message" | "type" | "read" | "relatedEntityType" | "relatedEntityId" | "createdAt" | "readAt" | "storeId" | "shopId", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | Notification$storeArgs<ExtArgs>
    shop?: boolean | Notification$shopArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      store: Prisma.$StorePayload<ExtArgs> | null
      shop: Prisma.$ShopPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      message: string
      type: $Enums.NotificationType
      read: boolean
      relatedEntityType: $Enums.RelatedEntityType | null
      relatedEntityId: string | null
      createdAt: Date
      readAt: Date | null
      storeId: string | null
      shopId: string | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends Notification$storeArgs<ExtArgs> = {}>(args?: Subset<T, Notification$storeArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    shop<T extends Notification$shopArgs<ExtArgs> = {}>(args?: Subset<T, Notification$shopArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly relatedEntityType: FieldRef<"Notification", 'RelatedEntityType'>
    readonly relatedEntityId: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly storeId: FieldRef<"Notification", 'String'>
    readonly shopId: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.store
   */
  export type Notification$storeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    where?: StoreWhereInput
  }

  /**
   * Notification.shop
   */
  export type Notification$shopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    where?: ShopWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    userCode: 'userCode',
    email: 'email',
    admin: 'admin',
    password: 'password',
    branchId: 'branchId',
    roleId: 'roleId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLoginAt: 'lastLoginAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    permissionId: 'permissionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    address: 'address',
    description: 'description',
    tinAddress: 'tinAddress',
    TIN: 'TIN',
    From: 'From',
    logo: 'logo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const BranchScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    phone: 'phone',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]


  export const ShopScalarFieldEnum: {
    id: 'id',
    name: 'name',
    branchId: 'branchId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShopScalarFieldEnum = (typeof ShopScalarFieldEnum)[keyof typeof ShopScalarFieldEnum]


  export const StoreScalarFieldEnum: {
    id: 'id',
    name: 'name',
    branchId: 'branchId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StoreScalarFieldEnum = (typeof StoreScalarFieldEnum)[keyof typeof StoreScalarFieldEnum]


  export const StoreStockScalarFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    batchId: 'batchId',
    quantity: 'quantity',
    status: 'status',
    unitOfMeasureId: 'unitOfMeasureId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StoreStockScalarFieldEnum = (typeof StoreStockScalarFieldEnum)[keyof typeof StoreStockScalarFieldEnum]


  export const ShopStockScalarFieldEnum: {
    id: 'id',
    shopId: 'shopId',
    batchId: 'batchId',
    unitOfMeasureId: 'unitOfMeasureId',
    quantity: 'quantity',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShopStockScalarFieldEnum = (typeof ShopStockScalarFieldEnum)[keyof typeof ShopStockScalarFieldEnum]


  export const StockLedgerScalarFieldEnum: {
    id: 'id',
    invoiceNo: 'invoiceNo',
    batchId: 'batchId',
    storeId: 'storeId',
    shopId: 'shopId',
    movementType: 'movementType',
    quantity: 'quantity',
    unitOfMeasureId: 'unitOfMeasureId',
    reference: 'reference',
    userId: 'userId',
    notes: 'notes',
    movementDate: 'movementDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StockLedgerScalarFieldEnum = (typeof StockLedgerScalarFieldEnum)[keyof typeof StockLedgerScalarFieldEnum]


  export const LogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LogScalarFieldEnum = (typeof LogScalarFieldEnum)[keyof typeof LogScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    companyName: 'companyName',
    phone1: 'phone1',
    phone2: 'phone2',
    tinNumber: 'tinNumber',
    address: 'address',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contactName: 'contactName',
    phone: 'phone',
    email: 'email',
    address: 'address',
    city: 'city',
    country: 'country',
    tinNumber: 'tinNumber',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const SubCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    categoryId: 'categoryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubCategoryScalarFieldEnum = (typeof SubCategoryScalarFieldEnum)[keyof typeof SubCategoryScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    productCode: 'productCode',
    name: 'name',
    generic: 'generic',
    description: 'description',
    categoryId: 'categoryId',
    subCategoryId: 'subCategoryId',
    sellPrice: 'sellPrice',
    imageUrl: 'imageUrl',
    unitOfMeasureId: 'unitOfMeasureId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const AdditionalPriceScalarFieldEnum: {
    id: 'id',
    label: 'label',
    price: 'price',
    productId: 'productId',
    shopId: 'shopId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdditionalPriceScalarFieldEnum = (typeof AdditionalPriceScalarFieldEnum)[keyof typeof AdditionalPriceScalarFieldEnum]


  export const ProductBatchScalarFieldEnum: {
    id: 'id',
    batchNumber: 'batchNumber',
    expiryDate: 'expiryDate',
    productId: 'productId',
    price: 'price',
    stock: 'stock',
    warningQuantity: 'warningQuantity',
    storeId: 'storeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductBatchScalarFieldEnum = (typeof ProductBatchScalarFieldEnum)[keyof typeof ProductBatchScalarFieldEnum]


  export const UnitOfMeasureScalarFieldEnum: {
    id: 'id',
    name: 'name',
    symbol: 'symbol',
    base: 'base'
  };

  export type UnitOfMeasureScalarFieldEnum = (typeof UnitOfMeasureScalarFieldEnum)[keyof typeof UnitOfMeasureScalarFieldEnum]


  export const PurchaseScalarFieldEnum: {
    id: 'id',
    invoiceNo: 'invoiceNo',
    supplierId: 'supplierId',
    storeId: 'storeId',
    paymentStatus: 'paymentStatus',
    totalProducts: 'totalProducts',
    subTotal: 'subTotal',
    grandTotal: 'grandTotal',
    notes: 'notes',
    purchaseDate: 'purchaseDate',
    createdById: 'createdById',
    updatedById: 'updatedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseScalarFieldEnum = (typeof PurchaseScalarFieldEnum)[keyof typeof PurchaseScalarFieldEnum]


  export const PurchaseItemScalarFieldEnum: {
    id: 'id',
    purchaseId: 'purchaseId',
    productId: 'productId',
    batchId: 'batchId',
    unitOfMeasureId: 'unitOfMeasureId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseItemScalarFieldEnum = (typeof PurchaseItemScalarFieldEnum)[keyof typeof PurchaseItemScalarFieldEnum]


  export const TransferScalarFieldEnum: {
    id: 'id',
    shortCode: 'shortCode',
    sourceType: 'sourceType',
    sourceStoreId: 'sourceStoreId',
    sourceShopId: 'sourceShopId',
    destinationType: 'destinationType',
    destStoreId: 'destStoreId',
    destShopId: 'destShopId',
    reference: 'reference',
    notes: 'notes',
    status: 'status',
    movementDate: 'movementDate',
    createdById: 'createdById',
    updatedById: 'updatedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransferScalarFieldEnum = (typeof TransferScalarFieldEnum)[keyof typeof TransferScalarFieldEnum]


  export const TransferItemScalarFieldEnum: {
    id: 'id',
    transferId: 'transferId',
    productId: 'productId',
    batchId: 'batchId',
    unitOfMeasureId: 'unitOfMeasureId',
    quantity: 'quantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransferItemScalarFieldEnum = (typeof TransferItemScalarFieldEnum)[keyof typeof TransferItemScalarFieldEnum]


  export const StockCorrectionScalarFieldEnum: {
    id: 'id',
    shortCode: 'shortCode',
    storeId: 'storeId',
    shopId: 'shopId',
    reason: 'reason',
    status: 'status',
    purchaseId: 'purchaseId',
    transferId: 'transferId',
    reference: 'reference',
    notes: 'notes',
    createdById: 'createdById',
    updatedById: 'updatedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StockCorrectionScalarFieldEnum = (typeof StockCorrectionScalarFieldEnum)[keyof typeof StockCorrectionScalarFieldEnum]


  export const StockCorrectionItemScalarFieldEnum: {
    id: 'id',
    correctionId: 'correctionId',
    productId: 'productId',
    batchId: 'batchId',
    unitOfMeasureId: 'unitOfMeasureId',
    quantity: 'quantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StockCorrectionItemScalarFieldEnum = (typeof StockCorrectionItemScalarFieldEnum)[keyof typeof StockCorrectionItemScalarFieldEnum]


  export const SellScalarFieldEnum: {
    id: 'id',
    invoiceNo: 'invoiceNo',
    saleStatus: 'saleStatus',
    locked: 'locked',
    lockedAt: 'lockedAt',
    branchId: 'branchId',
    customerId: 'customerId',
    totalProducts: 'totalProducts',
    subTotal: 'subTotal',
    discount: 'discount',
    vat: 'vat',
    grandTotal: 'grandTotal',
    NetTotal: 'NetTotal',
    notes: 'notes',
    saleDate: 'saleDate',
    createdById: 'createdById',
    updatedById: 'updatedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SellScalarFieldEnum = (typeof SellScalarFieldEnum)[keyof typeof SellScalarFieldEnum]


  export const SellItemScalarFieldEnum: {
    id: 'id',
    sellId: 'sellId',
    productId: 'productId',
    shopId: 'shopId',
    unitOfMeasureId: 'unitOfMeasureId',
    itemSaleStatus: 'itemSaleStatus',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SellItemScalarFieldEnum = (typeof SellItemScalarFieldEnum)[keyof typeof SellItemScalarFieldEnum]


  export const SellItemBatchScalarFieldEnum: {
    id: 'id',
    sellItemId: 'sellItemId',
    batchId: 'batchId',
    quantity: 'quantity'
  };

  export type SellItemBatchScalarFieldEnum = (typeof SellItemBatchScalarFieldEnum)[keyof typeof SellItemBatchScalarFieldEnum]


  export const AddToCartScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    branchId: 'branchId',
    isCheckedOut: 'isCheckedOut',
    isWaitlist: 'isWaitlist',
    customerId: 'customerId',
    totalItems: 'totalItems',
    totalAmount: 'totalAmount',
    createdById: 'createdById',
    updatedById: 'updatedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AddToCartScalarFieldEnum = (typeof AddToCartScalarFieldEnum)[keyof typeof AddToCartScalarFieldEnum]


  export const CartItemScalarFieldEnum: {
    id: 'id',
    cartId: 'cartId',
    isWaitlist: 'isWaitlist',
    shopId: 'shopId',
    productId: 'productId',
    unitOfMeasureId: 'unitOfMeasureId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CartItemScalarFieldEnum = (typeof CartItemScalarFieldEnum)[keyof typeof CartItemScalarFieldEnum]


  export const WaitlistScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    customerId: 'customerId',
    branchId: 'branchId',
    cartId: 'cartId',
    cartItemId: 'cartItemId',
    productId: 'productId',
    quantity: 'quantity',
    note: 'note',
    shopId: 'shopId',
    createdById: 'createdById',
    updatedById: 'updatedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WaitlistScalarFieldEnum = (typeof WaitlistScalarFieldEnum)[keyof typeof WaitlistScalarFieldEnum]


  export const SellStockCorrectionScalarFieldEnum: {
    id: 'id',
    sellId: 'sellId',
    status: 'status',
    reference: 'reference',
    notes: 'notes',
    createdById: 'createdById',
    updatedById: 'updatedById',
    total: 'total',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SellStockCorrectionScalarFieldEnum = (typeof SellStockCorrectionScalarFieldEnum)[keyof typeof SellStockCorrectionScalarFieldEnum]


  export const SellStockCorrectionItemScalarFieldEnum: {
    id: 'id',
    correctionId: 'correctionId',
    productId: 'productId',
    shopId: 'shopId',
    unitOfMeasureId: 'unitOfMeasureId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SellStockCorrectionItemScalarFieldEnum = (typeof SellStockCorrectionItemScalarFieldEnum)[keyof typeof SellStockCorrectionItemScalarFieldEnum]


  export const SellStockCorrectionBatchScalarFieldEnum: {
    id: 'id',
    correctionItemId: 'correctionItemId',
    batchId: 'batchId',
    quantity: 'quantity'
  };

  export type SellStockCorrectionBatchScalarFieldEnum = (typeof SellStockCorrectionBatchScalarFieldEnum)[keyof typeof SellStockCorrectionBatchScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    message: 'message',
    type: 'type',
    read: 'read',
    relatedEntityType: 'relatedEntityType',
    relatedEntityId: 'relatedEntityId',
    createdAt: 'createdAt',
    readAt: 'readAt',
    storeId: 'storeId',
    shopId: 'shopId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    userCode: 'userCode',
    email: 'email',
    password: 'password',
    branchId: 'branchId',
    roleId: 'roleId'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const RoleOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type RoleOrderByRelevanceFieldEnum = (typeof RoleOrderByRelevanceFieldEnum)[keyof typeof RoleOrderByRelevanceFieldEnum]


  export const PermissionOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type PermissionOrderByRelevanceFieldEnum = (typeof PermissionOrderByRelevanceFieldEnum)[keyof typeof PermissionOrderByRelevanceFieldEnum]


  export const RolePermissionOrderByRelevanceFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    permissionId: 'permissionId'
  };

  export type RolePermissionOrderByRelevanceFieldEnum = (typeof RolePermissionOrderByRelevanceFieldEnum)[keyof typeof RolePermissionOrderByRelevanceFieldEnum]


  export const CompanyOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    address: 'address',
    description: 'description',
    tinAddress: 'tinAddress',
    TIN: 'TIN',
    From: 'From',
    logo: 'logo'
  };

  export type CompanyOrderByRelevanceFieldEnum = (typeof CompanyOrderByRelevanceFieldEnum)[keyof typeof CompanyOrderByRelevanceFieldEnum]


  export const BranchOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    phone: 'phone',
    email: 'email'
  };

  export type BranchOrderByRelevanceFieldEnum = (typeof BranchOrderByRelevanceFieldEnum)[keyof typeof BranchOrderByRelevanceFieldEnum]


  export const ShopOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    branchId: 'branchId'
  };

  export type ShopOrderByRelevanceFieldEnum = (typeof ShopOrderByRelevanceFieldEnum)[keyof typeof ShopOrderByRelevanceFieldEnum]


  export const StoreOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    branchId: 'branchId'
  };

  export type StoreOrderByRelevanceFieldEnum = (typeof StoreOrderByRelevanceFieldEnum)[keyof typeof StoreOrderByRelevanceFieldEnum]


  export const StoreStockOrderByRelevanceFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    batchId: 'batchId',
    unitOfMeasureId: 'unitOfMeasureId'
  };

  export type StoreStockOrderByRelevanceFieldEnum = (typeof StoreStockOrderByRelevanceFieldEnum)[keyof typeof StoreStockOrderByRelevanceFieldEnum]


  export const ShopStockOrderByRelevanceFieldEnum: {
    id: 'id',
    shopId: 'shopId',
    batchId: 'batchId',
    unitOfMeasureId: 'unitOfMeasureId'
  };

  export type ShopStockOrderByRelevanceFieldEnum = (typeof ShopStockOrderByRelevanceFieldEnum)[keyof typeof ShopStockOrderByRelevanceFieldEnum]


  export const StockLedgerOrderByRelevanceFieldEnum: {
    id: 'id',
    invoiceNo: 'invoiceNo',
    batchId: 'batchId',
    storeId: 'storeId',
    shopId: 'shopId',
    unitOfMeasureId: 'unitOfMeasureId',
    reference: 'reference',
    userId: 'userId',
    notes: 'notes'
  };

  export type StockLedgerOrderByRelevanceFieldEnum = (typeof StockLedgerOrderByRelevanceFieldEnum)[keyof typeof StockLedgerOrderByRelevanceFieldEnum]


  export const LogOrderByRelevanceFieldEnum: {
    id: 'id',
    action: 'action',
    userId: 'userId'
  };

  export type LogOrderByRelevanceFieldEnum = (typeof LogOrderByRelevanceFieldEnum)[keyof typeof LogOrderByRelevanceFieldEnum]


  export const CustomerOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    companyName: 'companyName',
    phone1: 'phone1',
    phone2: 'phone2',
    tinNumber: 'tinNumber',
    address: 'address'
  };

  export type CustomerOrderByRelevanceFieldEnum = (typeof CustomerOrderByRelevanceFieldEnum)[keyof typeof CustomerOrderByRelevanceFieldEnum]


  export const SupplierOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    contactName: 'contactName',
    phone: 'phone',
    email: 'email',
    address: 'address',
    city: 'city',
    country: 'country',
    tinNumber: 'tinNumber',
    notes: 'notes'
  };

  export type SupplierOrderByRelevanceFieldEnum = (typeof SupplierOrderByRelevanceFieldEnum)[keyof typeof SupplierOrderByRelevanceFieldEnum]


  export const CategoryOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type CategoryOrderByRelevanceFieldEnum = (typeof CategoryOrderByRelevanceFieldEnum)[keyof typeof CategoryOrderByRelevanceFieldEnum]


  export const SubCategoryOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    categoryId: 'categoryId'
  };

  export type SubCategoryOrderByRelevanceFieldEnum = (typeof SubCategoryOrderByRelevanceFieldEnum)[keyof typeof SubCategoryOrderByRelevanceFieldEnum]


  export const ProductOrderByRelevanceFieldEnum: {
    id: 'id',
    productCode: 'productCode',
    name: 'name',
    generic: 'generic',
    description: 'description',
    categoryId: 'categoryId',
    subCategoryId: 'subCategoryId',
    imageUrl: 'imageUrl',
    unitOfMeasureId: 'unitOfMeasureId'
  };

  export type ProductOrderByRelevanceFieldEnum = (typeof ProductOrderByRelevanceFieldEnum)[keyof typeof ProductOrderByRelevanceFieldEnum]


  export const AdditionalPriceOrderByRelevanceFieldEnum: {
    id: 'id',
    label: 'label',
    productId: 'productId',
    shopId: 'shopId'
  };

  export type AdditionalPriceOrderByRelevanceFieldEnum = (typeof AdditionalPriceOrderByRelevanceFieldEnum)[keyof typeof AdditionalPriceOrderByRelevanceFieldEnum]


  export const ProductBatchOrderByRelevanceFieldEnum: {
    id: 'id',
    batchNumber: 'batchNumber',
    productId: 'productId',
    storeId: 'storeId'
  };

  export type ProductBatchOrderByRelevanceFieldEnum = (typeof ProductBatchOrderByRelevanceFieldEnum)[keyof typeof ProductBatchOrderByRelevanceFieldEnum]


  export const UnitOfMeasureOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    symbol: 'symbol'
  };

  export type UnitOfMeasureOrderByRelevanceFieldEnum = (typeof UnitOfMeasureOrderByRelevanceFieldEnum)[keyof typeof UnitOfMeasureOrderByRelevanceFieldEnum]


  export const PurchaseOrderByRelevanceFieldEnum: {
    id: 'id',
    invoiceNo: 'invoiceNo',
    supplierId: 'supplierId',
    storeId: 'storeId',
    notes: 'notes',
    createdById: 'createdById',
    updatedById: 'updatedById'
  };

  export type PurchaseOrderByRelevanceFieldEnum = (typeof PurchaseOrderByRelevanceFieldEnum)[keyof typeof PurchaseOrderByRelevanceFieldEnum]


  export const PurchaseItemOrderByRelevanceFieldEnum: {
    id: 'id',
    purchaseId: 'purchaseId',
    productId: 'productId',
    batchId: 'batchId',
    unitOfMeasureId: 'unitOfMeasureId'
  };

  export type PurchaseItemOrderByRelevanceFieldEnum = (typeof PurchaseItemOrderByRelevanceFieldEnum)[keyof typeof PurchaseItemOrderByRelevanceFieldEnum]


  export const TransferOrderByRelevanceFieldEnum: {
    id: 'id',
    shortCode: 'shortCode',
    sourceStoreId: 'sourceStoreId',
    sourceShopId: 'sourceShopId',
    destStoreId: 'destStoreId',
    destShopId: 'destShopId',
    reference: 'reference',
    notes: 'notes',
    createdById: 'createdById',
    updatedById: 'updatedById'
  };

  export type TransferOrderByRelevanceFieldEnum = (typeof TransferOrderByRelevanceFieldEnum)[keyof typeof TransferOrderByRelevanceFieldEnum]


  export const TransferItemOrderByRelevanceFieldEnum: {
    id: 'id',
    transferId: 'transferId',
    productId: 'productId',
    batchId: 'batchId',
    unitOfMeasureId: 'unitOfMeasureId'
  };

  export type TransferItemOrderByRelevanceFieldEnum = (typeof TransferItemOrderByRelevanceFieldEnum)[keyof typeof TransferItemOrderByRelevanceFieldEnum]


  export const StockCorrectionOrderByRelevanceFieldEnum: {
    id: 'id',
    shortCode: 'shortCode',
    storeId: 'storeId',
    shopId: 'shopId',
    purchaseId: 'purchaseId',
    transferId: 'transferId',
    reference: 'reference',
    notes: 'notes',
    createdById: 'createdById',
    updatedById: 'updatedById'
  };

  export type StockCorrectionOrderByRelevanceFieldEnum = (typeof StockCorrectionOrderByRelevanceFieldEnum)[keyof typeof StockCorrectionOrderByRelevanceFieldEnum]


  export const StockCorrectionItemOrderByRelevanceFieldEnum: {
    id: 'id',
    correctionId: 'correctionId',
    productId: 'productId',
    batchId: 'batchId',
    unitOfMeasureId: 'unitOfMeasureId'
  };

  export type StockCorrectionItemOrderByRelevanceFieldEnum = (typeof StockCorrectionItemOrderByRelevanceFieldEnum)[keyof typeof StockCorrectionItemOrderByRelevanceFieldEnum]


  export const SellOrderByRelevanceFieldEnum: {
    id: 'id',
    invoiceNo: 'invoiceNo',
    branchId: 'branchId',
    customerId: 'customerId',
    notes: 'notes',
    createdById: 'createdById',
    updatedById: 'updatedById'
  };

  export type SellOrderByRelevanceFieldEnum = (typeof SellOrderByRelevanceFieldEnum)[keyof typeof SellOrderByRelevanceFieldEnum]


  export const SellItemOrderByRelevanceFieldEnum: {
    id: 'id',
    sellId: 'sellId',
    productId: 'productId',
    shopId: 'shopId',
    unitOfMeasureId: 'unitOfMeasureId'
  };

  export type SellItemOrderByRelevanceFieldEnum = (typeof SellItemOrderByRelevanceFieldEnum)[keyof typeof SellItemOrderByRelevanceFieldEnum]


  export const SellItemBatchOrderByRelevanceFieldEnum: {
    id: 'id',
    sellItemId: 'sellItemId',
    batchId: 'batchId'
  };

  export type SellItemBatchOrderByRelevanceFieldEnum = (typeof SellItemBatchOrderByRelevanceFieldEnum)[keyof typeof SellItemBatchOrderByRelevanceFieldEnum]


  export const AddToCartOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    branchId: 'branchId',
    customerId: 'customerId',
    createdById: 'createdById',
    updatedById: 'updatedById'
  };

  export type AddToCartOrderByRelevanceFieldEnum = (typeof AddToCartOrderByRelevanceFieldEnum)[keyof typeof AddToCartOrderByRelevanceFieldEnum]


  export const CartItemOrderByRelevanceFieldEnum: {
    id: 'id',
    cartId: 'cartId',
    shopId: 'shopId',
    productId: 'productId',
    unitOfMeasureId: 'unitOfMeasureId',
    notes: 'notes'
  };

  export type CartItemOrderByRelevanceFieldEnum = (typeof CartItemOrderByRelevanceFieldEnum)[keyof typeof CartItemOrderByRelevanceFieldEnum]


  export const WaitlistOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    customerId: 'customerId',
    branchId: 'branchId',
    cartId: 'cartId',
    cartItemId: 'cartItemId',
    productId: 'productId',
    note: 'note',
    shopId: 'shopId',
    createdById: 'createdById',
    updatedById: 'updatedById'
  };

  export type WaitlistOrderByRelevanceFieldEnum = (typeof WaitlistOrderByRelevanceFieldEnum)[keyof typeof WaitlistOrderByRelevanceFieldEnum]


  export const SellStockCorrectionOrderByRelevanceFieldEnum: {
    id: 'id',
    sellId: 'sellId',
    reference: 'reference',
    notes: 'notes',
    createdById: 'createdById',
    updatedById: 'updatedById'
  };

  export type SellStockCorrectionOrderByRelevanceFieldEnum = (typeof SellStockCorrectionOrderByRelevanceFieldEnum)[keyof typeof SellStockCorrectionOrderByRelevanceFieldEnum]


  export const SellStockCorrectionItemOrderByRelevanceFieldEnum: {
    id: 'id',
    correctionId: 'correctionId',
    productId: 'productId',
    shopId: 'shopId',
    unitOfMeasureId: 'unitOfMeasureId'
  };

  export type SellStockCorrectionItemOrderByRelevanceFieldEnum = (typeof SellStockCorrectionItemOrderByRelevanceFieldEnum)[keyof typeof SellStockCorrectionItemOrderByRelevanceFieldEnum]


  export const SellStockCorrectionBatchOrderByRelevanceFieldEnum: {
    id: 'id',
    correctionItemId: 'correctionItemId',
    batchId: 'batchId'
  };

  export type SellStockCorrectionBatchOrderByRelevanceFieldEnum = (typeof SellStockCorrectionBatchOrderByRelevanceFieldEnum)[keyof typeof SellStockCorrectionBatchOrderByRelevanceFieldEnum]


  export const NotificationOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    message: 'message',
    relatedEntityId: 'relatedEntityId',
    storeId: 'storeId',
    shopId: 'shopId'
  };

  export type NotificationOrderByRelevanceFieldEnum = (typeof NotificationOrderByRelevanceFieldEnum)[keyof typeof NotificationOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'StockStatus'
   */
  export type EnumStockStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StockStatus'>
    


  /**
   * Reference to a field of type 'StockMovementType'
   */
  export type EnumStockMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StockMovementType'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'TransferEntityType'
   */
  export type EnumTransferEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferEntityType'>
    


  /**
   * Reference to a field of type 'TransferStatus'
   */
  export type EnumTransferStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferStatus'>
    


  /**
   * Reference to a field of type 'StockCorrectionReason'
   */
  export type EnumStockCorrectionReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StockCorrectionReason'>
    


  /**
   * Reference to a field of type 'StockCorrectionStatus'
   */
  export type EnumStockCorrectionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StockCorrectionStatus'>
    


  /**
   * Reference to a field of type 'SaleStatus'
   */
  export type EnumSaleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SaleStatus'>
    


  /**
   * Reference to a field of type 'ItemSaleStatus'
   */
  export type EnumItemSaleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemSaleStatus'>
    


  /**
   * Reference to a field of type 'SellStockCorrectionStatus'
   */
  export type EnumSellStockCorrectionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SellStockCorrectionStatus'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'RelatedEntityType'
   */
  export type EnumRelatedEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RelatedEntityType'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    userCode?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    admin?: BoolFilter<"User"> | boolean
    password?: StringFilter<"User"> | string
    branchId?: StringNullableFilter<"User"> | string | null
    roleId?: StringFilter<"User"> | string
    status?: EnumStatusFilter<"User"> | $Enums.Status
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    shops?: ShopListRelationFilter
    stores?: StoreListRelationFilter
    Log?: LogListRelationFilter
    StockLedger?: StockLedgerListRelationFilter
    CreatorPurchase?: PurchaseListRelationFilter
    UpdatedPurchase?: PurchaseListRelationFilter
    CreatedTransfer?: TransferListRelationFilter
    UpdatedTransfer?: TransferListRelationFilter
    StockCorrection?: StockCorrectionListRelationFilter
    UpdateStockCorrection?: StockCorrectionListRelationFilter
    Sell?: SellListRelationFilter
    UpdateSell?: SellListRelationFilter
    SellStockCorrection?: SellStockCorrectionListRelationFilter
    UpdateSellStockCorrection?: SellStockCorrectionListRelationFilter
    AllAddToCart?: AddToCartListRelationFilter
    CreatedAddToCart?: AddToCartListRelationFilter
    AddToCart?: AddToCartListRelationFilter
    waitlists?: WaitlistListRelationFilter
    waitlistsCreated?: WaitlistListRelationFilter
    waitlistsUpdated?: WaitlistListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    userCode?: SortOrderInput | SortOrder
    email?: SortOrder
    admin?: SortOrder
    password?: SortOrder
    branchId?: SortOrderInput | SortOrder
    roleId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    branch?: BranchOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
    shops?: ShopOrderByRelationAggregateInput
    stores?: StoreOrderByRelationAggregateInput
    Log?: LogOrderByRelationAggregateInput
    StockLedger?: StockLedgerOrderByRelationAggregateInput
    CreatorPurchase?: PurchaseOrderByRelationAggregateInput
    UpdatedPurchase?: PurchaseOrderByRelationAggregateInput
    CreatedTransfer?: TransferOrderByRelationAggregateInput
    UpdatedTransfer?: TransferOrderByRelationAggregateInput
    StockCorrection?: StockCorrectionOrderByRelationAggregateInput
    UpdateStockCorrection?: StockCorrectionOrderByRelationAggregateInput
    Sell?: SellOrderByRelationAggregateInput
    UpdateSell?: SellOrderByRelationAggregateInput
    SellStockCorrection?: SellStockCorrectionOrderByRelationAggregateInput
    UpdateSellStockCorrection?: SellStockCorrectionOrderByRelationAggregateInput
    AllAddToCart?: AddToCartOrderByRelationAggregateInput
    CreatedAddToCart?: AddToCartOrderByRelationAggregateInput
    AddToCart?: AddToCartOrderByRelationAggregateInput
    waitlists?: WaitlistOrderByRelationAggregateInput
    waitlistsCreated?: WaitlistOrderByRelationAggregateInput
    waitlistsUpdated?: WaitlistOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    userCode?: StringNullableFilter<"User"> | string | null
    admin?: BoolFilter<"User"> | boolean
    password?: StringFilter<"User"> | string
    branchId?: StringNullableFilter<"User"> | string | null
    roleId?: StringFilter<"User"> | string
    status?: EnumStatusFilter<"User"> | $Enums.Status
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    shops?: ShopListRelationFilter
    stores?: StoreListRelationFilter
    Log?: LogListRelationFilter
    StockLedger?: StockLedgerListRelationFilter
    CreatorPurchase?: PurchaseListRelationFilter
    UpdatedPurchase?: PurchaseListRelationFilter
    CreatedTransfer?: TransferListRelationFilter
    UpdatedTransfer?: TransferListRelationFilter
    StockCorrection?: StockCorrectionListRelationFilter
    UpdateStockCorrection?: StockCorrectionListRelationFilter
    Sell?: SellListRelationFilter
    UpdateSell?: SellListRelationFilter
    SellStockCorrection?: SellStockCorrectionListRelationFilter
    UpdateSellStockCorrection?: SellStockCorrectionListRelationFilter
    AllAddToCart?: AddToCartListRelationFilter
    CreatedAddToCart?: AddToCartListRelationFilter
    AddToCart?: AddToCartListRelationFilter
    waitlists?: WaitlistListRelationFilter
    waitlistsCreated?: WaitlistListRelationFilter
    waitlistsUpdated?: WaitlistListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    userCode?: SortOrderInput | SortOrder
    email?: SortOrder
    admin?: SortOrder
    password?: SortOrder
    branchId?: SortOrderInput | SortOrder
    roleId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    userCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    admin?: BoolWithAggregatesFilter<"User"> | boolean
    password?: StringWithAggregatesFilter<"User"> | string
    branchId?: StringNullableWithAggregatesFilter<"User"> | string | null
    roleId?: StringWithAggregatesFilter<"User"> | string
    status?: EnumStatusWithAggregatesFilter<"User"> | $Enums.Status
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    permissions?: RolePermissionListRelationFilter
    users?: UserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    permissions?: RolePermissionOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    _relevance?: RoleOrderByRelevanceInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    permissions?: RolePermissionListRelationFilter
    users?: UserListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: StringFilter<"Permission"> | string
    name?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    roles?: RolePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roles?: RolePermissionOrderByRelationAggregateInput
    _relevance?: PermissionOrderByRelevanceInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    description?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    roles?: RolePermissionListRelationFilter
  }, "id" | "name">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permission"> | string
    name?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    id?: StringFilter<"RolePermission"> | string
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    updatedAt?: DateTimeFilter<"RolePermission"> | Date | string
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    permission?: PermissionOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
    _relevance?: RolePermissionOrderByRelevanceInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roleId_permissionId?: RolePermissionRoleIdPermissionIdCompoundUniqueInput
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    updatedAt?: DateTimeFilter<"RolePermission"> | Date | string
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "id" | "roleId_permissionId">

  export type RolePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RolePermission"> | string
    roleId?: StringWithAggregatesFilter<"RolePermission"> | string
    permissionId?: StringWithAggregatesFilter<"RolePermission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RolePermission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RolePermission"> | Date | string
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    email?: StringNullableFilter<"Company"> | string | null
    phone?: StringNullableFilter<"Company"> | string | null
    address?: StringNullableFilter<"Company"> | string | null
    description?: StringNullableFilter<"Company"> | string | null
    tinAddress?: StringNullableFilter<"Company"> | string | null
    TIN?: StringNullableFilter<"Company"> | string | null
    From?: StringNullableFilter<"Company"> | string | null
    logo?: StringNullableFilter<"Company"> | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    tinAddress?: SortOrderInput | SortOrder
    TIN?: SortOrderInput | SortOrder
    From?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: CompanyOrderByRelevanceInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    phone?: StringNullableFilter<"Company"> | string | null
    address?: StringNullableFilter<"Company"> | string | null
    description?: StringNullableFilter<"Company"> | string | null
    tinAddress?: StringNullableFilter<"Company"> | string | null
    TIN?: StringNullableFilter<"Company"> | string | null
    From?: StringNullableFilter<"Company"> | string | null
    logo?: StringNullableFilter<"Company"> | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
  }, "id" | "email">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    tinAddress?: SortOrderInput | SortOrder
    TIN?: SortOrderInput | SortOrder
    From?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    email?: StringNullableWithAggregatesFilter<"Company"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Company"> | string | null
    address?: StringNullableWithAggregatesFilter<"Company"> | string | null
    description?: StringNullableWithAggregatesFilter<"Company"> | string | null
    tinAddress?: StringNullableWithAggregatesFilter<"Company"> | string | null
    TIN?: StringNullableWithAggregatesFilter<"Company"> | string | null
    From?: StringNullableWithAggregatesFilter<"Company"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Company"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type BranchWhereInput = {
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    id?: StringFilter<"Branch"> | string
    name?: StringFilter<"Branch"> | string
    address?: StringNullableFilter<"Branch"> | string | null
    phone?: StringNullableFilter<"Branch"> | string | null
    email?: StringNullableFilter<"Branch"> | string | null
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    Shop?: ShopListRelationFilter
    Store?: StoreListRelationFilter
    User?: UserListRelationFilter
    Sell?: SellListRelationFilter
    AddToCart?: AddToCartListRelationFilter
    waitlists?: WaitlistListRelationFilter
  }

  export type BranchOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Shop?: ShopOrderByRelationAggregateInput
    Store?: StoreOrderByRelationAggregateInput
    User?: UserOrderByRelationAggregateInput
    Sell?: SellOrderByRelationAggregateInput
    AddToCart?: AddToCartOrderByRelationAggregateInput
    waitlists?: WaitlistOrderByRelationAggregateInput
    _relevance?: BranchOrderByRelevanceInput
  }

  export type BranchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    name?: StringFilter<"Branch"> | string
    address?: StringNullableFilter<"Branch"> | string | null
    phone?: StringNullableFilter<"Branch"> | string | null
    email?: StringNullableFilter<"Branch"> | string | null
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    Shop?: ShopListRelationFilter
    Store?: StoreListRelationFilter
    User?: UserListRelationFilter
    Sell?: SellListRelationFilter
    AddToCart?: AddToCartListRelationFilter
    waitlists?: WaitlistListRelationFilter
  }, "id">

  export type BranchOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BranchCountOrderByAggregateInput
    _max?: BranchMaxOrderByAggregateInput
    _min?: BranchMinOrderByAggregateInput
  }

  export type BranchScalarWhereWithAggregatesInput = {
    AND?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    OR?: BranchScalarWhereWithAggregatesInput[]
    NOT?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Branch"> | string
    name?: StringWithAggregatesFilter<"Branch"> | string
    address?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    email?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
  }

  export type ShopWhereInput = {
    AND?: ShopWhereInput | ShopWhereInput[]
    OR?: ShopWhereInput[]
    NOT?: ShopWhereInput | ShopWhereInput[]
    id?: StringFilter<"Shop"> | string
    name?: StringFilter<"Shop"> | string
    branchId?: StringFilter<"Shop"> | string
    createdAt?: DateTimeFilter<"Shop"> | Date | string
    updatedAt?: DateTimeFilter<"Shop"> | Date | string
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    ShopStock?: ShopStockListRelationFilter
    StockLedger?: StockLedgerListRelationFilter
    SourceTransfer?: TransferListRelationFilter
    DestinatTransfer?: TransferListRelationFilter
    StockCorrection?: StockCorrectionListRelationFilter
    AdditionalPrice?: AdditionalPriceListRelationFilter
    SellItem?: SellItemListRelationFilter
    SellStockCorrectionItem?: SellStockCorrectionItemListRelationFilter
    User?: UserListRelationFilter
    CartItem?: CartItemListRelationFilter
    waitlists?: WaitlistListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type ShopOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    ShopStock?: ShopStockOrderByRelationAggregateInput
    StockLedger?: StockLedgerOrderByRelationAggregateInput
    SourceTransfer?: TransferOrderByRelationAggregateInput
    DestinatTransfer?: TransferOrderByRelationAggregateInput
    StockCorrection?: StockCorrectionOrderByRelationAggregateInput
    AdditionalPrice?: AdditionalPriceOrderByRelationAggregateInput
    SellItem?: SellItemOrderByRelationAggregateInput
    SellStockCorrectionItem?: SellStockCorrectionItemOrderByRelationAggregateInput
    User?: UserOrderByRelationAggregateInput
    CartItem?: CartItemOrderByRelationAggregateInput
    waitlists?: WaitlistOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    _relevance?: ShopOrderByRelevanceInput
  }

  export type ShopWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShopWhereInput | ShopWhereInput[]
    OR?: ShopWhereInput[]
    NOT?: ShopWhereInput | ShopWhereInput[]
    name?: StringFilter<"Shop"> | string
    branchId?: StringFilter<"Shop"> | string
    createdAt?: DateTimeFilter<"Shop"> | Date | string
    updatedAt?: DateTimeFilter<"Shop"> | Date | string
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    ShopStock?: ShopStockListRelationFilter
    StockLedger?: StockLedgerListRelationFilter
    SourceTransfer?: TransferListRelationFilter
    DestinatTransfer?: TransferListRelationFilter
    StockCorrection?: StockCorrectionListRelationFilter
    AdditionalPrice?: AdditionalPriceListRelationFilter
    SellItem?: SellItemListRelationFilter
    SellStockCorrectionItem?: SellStockCorrectionItemListRelationFilter
    User?: UserListRelationFilter
    CartItem?: CartItemListRelationFilter
    waitlists?: WaitlistListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type ShopOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShopCountOrderByAggregateInput
    _max?: ShopMaxOrderByAggregateInput
    _min?: ShopMinOrderByAggregateInput
  }

  export type ShopScalarWhereWithAggregatesInput = {
    AND?: ShopScalarWhereWithAggregatesInput | ShopScalarWhereWithAggregatesInput[]
    OR?: ShopScalarWhereWithAggregatesInput[]
    NOT?: ShopScalarWhereWithAggregatesInput | ShopScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Shop"> | string
    name?: StringWithAggregatesFilter<"Shop"> | string
    branchId?: StringWithAggregatesFilter<"Shop"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Shop"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Shop"> | Date | string
  }

  export type StoreWhereInput = {
    AND?: StoreWhereInput | StoreWhereInput[]
    OR?: StoreWhereInput[]
    NOT?: StoreWhereInput | StoreWhereInput[]
    id?: StringFilter<"Store"> | string
    name?: StringFilter<"Store"> | string
    branchId?: StringFilter<"Store"> | string
    createdAt?: DateTimeFilter<"Store"> | Date | string
    updatedAt?: DateTimeFilter<"Store"> | Date | string
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    ProductBatch?: ProductBatchListRelationFilter
    StoreStock?: StoreStockListRelationFilter
    StockLedger?: StockLedgerListRelationFilter
    Purchase?: PurchaseListRelationFilter
    SourceTransfer?: TransferListRelationFilter
    DestinatTransfer?: TransferListRelationFilter
    StockCorrection?: StockCorrectionListRelationFilter
    User?: UserListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type StoreOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    ProductBatch?: ProductBatchOrderByRelationAggregateInput
    StoreStock?: StoreStockOrderByRelationAggregateInput
    StockLedger?: StockLedgerOrderByRelationAggregateInput
    Purchase?: PurchaseOrderByRelationAggregateInput
    SourceTransfer?: TransferOrderByRelationAggregateInput
    DestinatTransfer?: TransferOrderByRelationAggregateInput
    StockCorrection?: StockCorrectionOrderByRelationAggregateInput
    User?: UserOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    _relevance?: StoreOrderByRelevanceInput
  }

  export type StoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StoreWhereInput | StoreWhereInput[]
    OR?: StoreWhereInput[]
    NOT?: StoreWhereInput | StoreWhereInput[]
    name?: StringFilter<"Store"> | string
    branchId?: StringFilter<"Store"> | string
    createdAt?: DateTimeFilter<"Store"> | Date | string
    updatedAt?: DateTimeFilter<"Store"> | Date | string
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    ProductBatch?: ProductBatchListRelationFilter
    StoreStock?: StoreStockListRelationFilter
    StockLedger?: StockLedgerListRelationFilter
    Purchase?: PurchaseListRelationFilter
    SourceTransfer?: TransferListRelationFilter
    DestinatTransfer?: TransferListRelationFilter
    StockCorrection?: StockCorrectionListRelationFilter
    User?: UserListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type StoreOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StoreCountOrderByAggregateInput
    _max?: StoreMaxOrderByAggregateInput
    _min?: StoreMinOrderByAggregateInput
  }

  export type StoreScalarWhereWithAggregatesInput = {
    AND?: StoreScalarWhereWithAggregatesInput | StoreScalarWhereWithAggregatesInput[]
    OR?: StoreScalarWhereWithAggregatesInput[]
    NOT?: StoreScalarWhereWithAggregatesInput | StoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Store"> | string
    name?: StringWithAggregatesFilter<"Store"> | string
    branchId?: StringWithAggregatesFilter<"Store"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Store"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Store"> | Date | string
  }

  export type StoreStockWhereInput = {
    AND?: StoreStockWhereInput | StoreStockWhereInput[]
    OR?: StoreStockWhereInput[]
    NOT?: StoreStockWhereInput | StoreStockWhereInput[]
    id?: StringFilter<"StoreStock"> | string
    storeId?: StringFilter<"StoreStock"> | string
    batchId?: StringFilter<"StoreStock"> | string
    quantity?: IntFilter<"StoreStock"> | number
    status?: EnumStockStatusFilter<"StoreStock"> | $Enums.StockStatus
    unitOfMeasureId?: StringFilter<"StoreStock"> | string
    createdAt?: DateTimeFilter<"StoreStock"> | Date | string
    updatedAt?: DateTimeFilter<"StoreStock"> | Date | string
    store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
    batch?: XOR<ProductBatchScalarRelationFilter, ProductBatchWhereInput>
    unitOfMeasure?: XOR<UnitOfMeasureScalarRelationFilter, UnitOfMeasureWhereInput>
  }

  export type StoreStockOrderByWithRelationInput = {
    id?: SortOrder
    storeId?: SortOrder
    batchId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    unitOfMeasureId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: StoreOrderByWithRelationInput
    batch?: ProductBatchOrderByWithRelationInput
    unitOfMeasure?: UnitOfMeasureOrderByWithRelationInput
    _relevance?: StoreStockOrderByRelevanceInput
  }

  export type StoreStockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storeId_batchId?: StoreStockStoreIdBatchIdCompoundUniqueInput
    AND?: StoreStockWhereInput | StoreStockWhereInput[]
    OR?: StoreStockWhereInput[]
    NOT?: StoreStockWhereInput | StoreStockWhereInput[]
    storeId?: StringFilter<"StoreStock"> | string
    batchId?: StringFilter<"StoreStock"> | string
    quantity?: IntFilter<"StoreStock"> | number
    status?: EnumStockStatusFilter<"StoreStock"> | $Enums.StockStatus
    unitOfMeasureId?: StringFilter<"StoreStock"> | string
    createdAt?: DateTimeFilter<"StoreStock"> | Date | string
    updatedAt?: DateTimeFilter<"StoreStock"> | Date | string
    store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
    batch?: XOR<ProductBatchScalarRelationFilter, ProductBatchWhereInput>
    unitOfMeasure?: XOR<UnitOfMeasureScalarRelationFilter, UnitOfMeasureWhereInput>
  }, "id" | "storeId_batchId">

  export type StoreStockOrderByWithAggregationInput = {
    id?: SortOrder
    storeId?: SortOrder
    batchId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    unitOfMeasureId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StoreStockCountOrderByAggregateInput
    _avg?: StoreStockAvgOrderByAggregateInput
    _max?: StoreStockMaxOrderByAggregateInput
    _min?: StoreStockMinOrderByAggregateInput
    _sum?: StoreStockSumOrderByAggregateInput
  }

  export type StoreStockScalarWhereWithAggregatesInput = {
    AND?: StoreStockScalarWhereWithAggregatesInput | StoreStockScalarWhereWithAggregatesInput[]
    OR?: StoreStockScalarWhereWithAggregatesInput[]
    NOT?: StoreStockScalarWhereWithAggregatesInput | StoreStockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoreStock"> | string
    storeId?: StringWithAggregatesFilter<"StoreStock"> | string
    batchId?: StringWithAggregatesFilter<"StoreStock"> | string
    quantity?: IntWithAggregatesFilter<"StoreStock"> | number
    status?: EnumStockStatusWithAggregatesFilter<"StoreStock"> | $Enums.StockStatus
    unitOfMeasureId?: StringWithAggregatesFilter<"StoreStock"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StoreStock"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StoreStock"> | Date | string
  }

  export type ShopStockWhereInput = {
    AND?: ShopStockWhereInput | ShopStockWhereInput[]
    OR?: ShopStockWhereInput[]
    NOT?: ShopStockWhereInput | ShopStockWhereInput[]
    id?: StringFilter<"ShopStock"> | string
    shopId?: StringFilter<"ShopStock"> | string
    batchId?: StringFilter<"ShopStock"> | string
    unitOfMeasureId?: StringFilter<"ShopStock"> | string
    quantity?: IntFilter<"ShopStock"> | number
    status?: EnumStockStatusFilter<"ShopStock"> | $Enums.StockStatus
    createdAt?: DateTimeFilter<"ShopStock"> | Date | string
    updatedAt?: DateTimeFilter<"ShopStock"> | Date | string
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    batch?: XOR<ProductBatchScalarRelationFilter, ProductBatchWhereInput>
    unitOfMeasure?: XOR<UnitOfMeasureScalarRelationFilter, UnitOfMeasureWhereInput>
  }

  export type ShopStockOrderByWithRelationInput = {
    id?: SortOrder
    shopId?: SortOrder
    batchId?: SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shop?: ShopOrderByWithRelationInput
    batch?: ProductBatchOrderByWithRelationInput
    unitOfMeasure?: UnitOfMeasureOrderByWithRelationInput
    _relevance?: ShopStockOrderByRelevanceInput
  }

  export type ShopStockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shopId_batchId?: ShopStockShopIdBatchIdCompoundUniqueInput
    AND?: ShopStockWhereInput | ShopStockWhereInput[]
    OR?: ShopStockWhereInput[]
    NOT?: ShopStockWhereInput | ShopStockWhereInput[]
    shopId?: StringFilter<"ShopStock"> | string
    batchId?: StringFilter<"ShopStock"> | string
    unitOfMeasureId?: StringFilter<"ShopStock"> | string
    quantity?: IntFilter<"ShopStock"> | number
    status?: EnumStockStatusFilter<"ShopStock"> | $Enums.StockStatus
    createdAt?: DateTimeFilter<"ShopStock"> | Date | string
    updatedAt?: DateTimeFilter<"ShopStock"> | Date | string
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    batch?: XOR<ProductBatchScalarRelationFilter, ProductBatchWhereInput>
    unitOfMeasure?: XOR<UnitOfMeasureScalarRelationFilter, UnitOfMeasureWhereInput>
  }, "id" | "shopId_batchId">

  export type ShopStockOrderByWithAggregationInput = {
    id?: SortOrder
    shopId?: SortOrder
    batchId?: SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShopStockCountOrderByAggregateInput
    _avg?: ShopStockAvgOrderByAggregateInput
    _max?: ShopStockMaxOrderByAggregateInput
    _min?: ShopStockMinOrderByAggregateInput
    _sum?: ShopStockSumOrderByAggregateInput
  }

  export type ShopStockScalarWhereWithAggregatesInput = {
    AND?: ShopStockScalarWhereWithAggregatesInput | ShopStockScalarWhereWithAggregatesInput[]
    OR?: ShopStockScalarWhereWithAggregatesInput[]
    NOT?: ShopStockScalarWhereWithAggregatesInput | ShopStockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShopStock"> | string
    shopId?: StringWithAggregatesFilter<"ShopStock"> | string
    batchId?: StringWithAggregatesFilter<"ShopStock"> | string
    unitOfMeasureId?: StringWithAggregatesFilter<"ShopStock"> | string
    quantity?: IntWithAggregatesFilter<"ShopStock"> | number
    status?: EnumStockStatusWithAggregatesFilter<"ShopStock"> | $Enums.StockStatus
    createdAt?: DateTimeWithAggregatesFilter<"ShopStock"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShopStock"> | Date | string
  }

  export type StockLedgerWhereInput = {
    AND?: StockLedgerWhereInput | StockLedgerWhereInput[]
    OR?: StockLedgerWhereInput[]
    NOT?: StockLedgerWhereInput | StockLedgerWhereInput[]
    id?: StringFilter<"StockLedger"> | string
    invoiceNo?: StringNullableFilter<"StockLedger"> | string | null
    batchId?: StringFilter<"StockLedger"> | string
    storeId?: StringNullableFilter<"StockLedger"> | string | null
    shopId?: StringNullableFilter<"StockLedger"> | string | null
    movementType?: EnumStockMovementTypeFilter<"StockLedger"> | $Enums.StockMovementType
    quantity?: IntFilter<"StockLedger"> | number
    unitOfMeasureId?: StringFilter<"StockLedger"> | string
    reference?: StringNullableFilter<"StockLedger"> | string | null
    userId?: StringNullableFilter<"StockLedger"> | string | null
    notes?: StringNullableFilter<"StockLedger"> | string | null
    movementDate?: DateTimeFilter<"StockLedger"> | Date | string
    createdAt?: DateTimeFilter<"StockLedger"> | Date | string
    updatedAt?: DateTimeFilter<"StockLedger"> | Date | string
    batch?: XOR<ProductBatchScalarRelationFilter, ProductBatchWhereInput>
    store?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
    shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
    unitOfMeasure?: XOR<UnitOfMeasureScalarRelationFilter, UnitOfMeasureWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type StockLedgerOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNo?: SortOrderInput | SortOrder
    batchId?: SortOrder
    storeId?: SortOrderInput | SortOrder
    shopId?: SortOrderInput | SortOrder
    movementType?: SortOrder
    quantity?: SortOrder
    unitOfMeasureId?: SortOrder
    reference?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    movementDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    batch?: ProductBatchOrderByWithRelationInput
    store?: StoreOrderByWithRelationInput
    shop?: ShopOrderByWithRelationInput
    unitOfMeasure?: UnitOfMeasureOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: StockLedgerOrderByRelevanceInput
  }

  export type StockLedgerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNo?: string
    AND?: StockLedgerWhereInput | StockLedgerWhereInput[]
    OR?: StockLedgerWhereInput[]
    NOT?: StockLedgerWhereInput | StockLedgerWhereInput[]
    batchId?: StringFilter<"StockLedger"> | string
    storeId?: StringNullableFilter<"StockLedger"> | string | null
    shopId?: StringNullableFilter<"StockLedger"> | string | null
    movementType?: EnumStockMovementTypeFilter<"StockLedger"> | $Enums.StockMovementType
    quantity?: IntFilter<"StockLedger"> | number
    unitOfMeasureId?: StringFilter<"StockLedger"> | string
    reference?: StringNullableFilter<"StockLedger"> | string | null
    userId?: StringNullableFilter<"StockLedger"> | string | null
    notes?: StringNullableFilter<"StockLedger"> | string | null
    movementDate?: DateTimeFilter<"StockLedger"> | Date | string
    createdAt?: DateTimeFilter<"StockLedger"> | Date | string
    updatedAt?: DateTimeFilter<"StockLedger"> | Date | string
    batch?: XOR<ProductBatchScalarRelationFilter, ProductBatchWhereInput>
    store?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
    shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
    unitOfMeasure?: XOR<UnitOfMeasureScalarRelationFilter, UnitOfMeasureWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "invoiceNo">

  export type StockLedgerOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNo?: SortOrderInput | SortOrder
    batchId?: SortOrder
    storeId?: SortOrderInput | SortOrder
    shopId?: SortOrderInput | SortOrder
    movementType?: SortOrder
    quantity?: SortOrder
    unitOfMeasureId?: SortOrder
    reference?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    movementDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StockLedgerCountOrderByAggregateInput
    _avg?: StockLedgerAvgOrderByAggregateInput
    _max?: StockLedgerMaxOrderByAggregateInput
    _min?: StockLedgerMinOrderByAggregateInput
    _sum?: StockLedgerSumOrderByAggregateInput
  }

  export type StockLedgerScalarWhereWithAggregatesInput = {
    AND?: StockLedgerScalarWhereWithAggregatesInput | StockLedgerScalarWhereWithAggregatesInput[]
    OR?: StockLedgerScalarWhereWithAggregatesInput[]
    NOT?: StockLedgerScalarWhereWithAggregatesInput | StockLedgerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockLedger"> | string
    invoiceNo?: StringNullableWithAggregatesFilter<"StockLedger"> | string | null
    batchId?: StringWithAggregatesFilter<"StockLedger"> | string
    storeId?: StringNullableWithAggregatesFilter<"StockLedger"> | string | null
    shopId?: StringNullableWithAggregatesFilter<"StockLedger"> | string | null
    movementType?: EnumStockMovementTypeWithAggregatesFilter<"StockLedger"> | $Enums.StockMovementType
    quantity?: IntWithAggregatesFilter<"StockLedger"> | number
    unitOfMeasureId?: StringWithAggregatesFilter<"StockLedger"> | string
    reference?: StringNullableWithAggregatesFilter<"StockLedger"> | string | null
    userId?: StringNullableWithAggregatesFilter<"StockLedger"> | string | null
    notes?: StringNullableWithAggregatesFilter<"StockLedger"> | string | null
    movementDate?: DateTimeWithAggregatesFilter<"StockLedger"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"StockLedger"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StockLedger"> | Date | string
  }

  export type LogWhereInput = {
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    id?: StringFilter<"Log"> | string
    action?: StringFilter<"Log"> | string
    userId?: StringNullableFilter<"Log"> | string | null
    createdAt?: DateTimeFilter<"Log"> | Date | string
    updatedAt?: DateTimeFilter<"Log"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type LogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: LogOrderByRelevanceInput
  }

  export type LogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    action?: StringFilter<"Log"> | string
    userId?: StringNullableFilter<"Log"> | string | null
    createdAt?: DateTimeFilter<"Log"> | Date | string
    updatedAt?: DateTimeFilter<"Log"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type LogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LogCountOrderByAggregateInput
    _max?: LogMaxOrderByAggregateInput
    _min?: LogMinOrderByAggregateInput
  }

  export type LogScalarWhereWithAggregatesInput = {
    AND?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    OR?: LogScalarWhereWithAggregatesInput[]
    NOT?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Log"> | string
    action?: StringWithAggregatesFilter<"Log"> | string
    userId?: StringNullableWithAggregatesFilter<"Log"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Log"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Log"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    companyName?: StringNullableFilter<"Customer"> | string | null
    phone1?: StringFilter<"Customer"> | string
    phone2?: StringNullableFilter<"Customer"> | string | null
    tinNumber?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    Sell?: SellListRelationFilter
    AddToCart?: AddToCartListRelationFilter
    waitlists?: WaitlistListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    companyName?: SortOrderInput | SortOrder
    phone1?: SortOrder
    phone2?: SortOrderInput | SortOrder
    tinNumber?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Sell?: SellOrderByRelationAggregateInput
    AddToCart?: AddToCartOrderByRelationAggregateInput
    waitlists?: WaitlistOrderByRelationAggregateInput
    _relevance?: CustomerOrderByRelevanceInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringFilter<"Customer"> | string
    companyName?: StringNullableFilter<"Customer"> | string | null
    phone1?: StringFilter<"Customer"> | string
    phone2?: StringNullableFilter<"Customer"> | string | null
    tinNumber?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    Sell?: SellListRelationFilter
    AddToCart?: AddToCartListRelationFilter
    waitlists?: WaitlistListRelationFilter
  }, "id">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    companyName?: SortOrderInput | SortOrder
    phone1?: SortOrder
    phone2?: SortOrderInput | SortOrder
    tinNumber?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    name?: StringWithAggregatesFilter<"Customer"> | string
    companyName?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    phone1?: StringWithAggregatesFilter<"Customer"> | string
    phone2?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    tinNumber?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    contactName?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    city?: StringNullableFilter<"Supplier"> | string | null
    country?: StringNullableFilter<"Supplier"> | string | null
    tinNumber?: StringNullableFilter<"Supplier"> | string | null
    notes?: StringNullableFilter<"Supplier"> | string | null
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    Purchase?: PurchaseListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contactName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    tinNumber?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Purchase?: PurchaseOrderByRelationAggregateInput
    _relevance?: SupplierOrderByRelevanceInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    name?: StringFilter<"Supplier"> | string
    contactName?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    city?: StringNullableFilter<"Supplier"> | string | null
    country?: StringNullableFilter<"Supplier"> | string | null
    tinNumber?: StringNullableFilter<"Supplier"> | string | null
    notes?: StringNullableFilter<"Supplier"> | string | null
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    Purchase?: PurchaseListRelationFilter
  }, "id">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contactName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    tinNumber?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Supplier"> | string
    name?: StringWithAggregatesFilter<"Supplier"> | string
    contactName?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    email?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    address?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    city?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    country?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    tinNumber?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    products?: ProductListRelationFilter
    subCategories?: SubCategoryListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    subCategories?: SubCategoryOrderByRelationAggregateInput
    _relevance?: CategoryOrderByRelevanceInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    products?: ProductListRelationFilter
    subCategories?: SubCategoryListRelationFilter
  }, "id">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type SubCategoryWhereInput = {
    AND?: SubCategoryWhereInput | SubCategoryWhereInput[]
    OR?: SubCategoryWhereInput[]
    NOT?: SubCategoryWhereInput | SubCategoryWhereInput[]
    id?: StringFilter<"SubCategory"> | string
    name?: StringFilter<"SubCategory"> | string
    categoryId?: StringFilter<"SubCategory"> | string
    createdAt?: DateTimeFilter<"SubCategory"> | Date | string
    updatedAt?: DateTimeFilter<"SubCategory"> | Date | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    products?: ProductListRelationFilter
  }

  export type SubCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: CategoryOrderByWithRelationInput
    products?: ProductOrderByRelationAggregateInput
    _relevance?: SubCategoryOrderByRelevanceInput
  }

  export type SubCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubCategoryWhereInput | SubCategoryWhereInput[]
    OR?: SubCategoryWhereInput[]
    NOT?: SubCategoryWhereInput | SubCategoryWhereInput[]
    name?: StringFilter<"SubCategory"> | string
    categoryId?: StringFilter<"SubCategory"> | string
    createdAt?: DateTimeFilter<"SubCategory"> | Date | string
    updatedAt?: DateTimeFilter<"SubCategory"> | Date | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    products?: ProductListRelationFilter
  }, "id">

  export type SubCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubCategoryCountOrderByAggregateInput
    _max?: SubCategoryMaxOrderByAggregateInput
    _min?: SubCategoryMinOrderByAggregateInput
  }

  export type SubCategoryScalarWhereWithAggregatesInput = {
    AND?: SubCategoryScalarWhereWithAggregatesInput | SubCategoryScalarWhereWithAggregatesInput[]
    OR?: SubCategoryScalarWhereWithAggregatesInput[]
    NOT?: SubCategoryScalarWhereWithAggregatesInput | SubCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubCategory"> | string
    name?: StringWithAggregatesFilter<"SubCategory"> | string
    categoryId?: StringWithAggregatesFilter<"SubCategory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SubCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubCategory"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    productCode?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    generic?: StringNullableFilter<"Product"> | string | null
    description?: StringNullableFilter<"Product"> | string | null
    categoryId?: StringFilter<"Product"> | string
    subCategoryId?: StringNullableFilter<"Product"> | string | null
    sellPrice?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFilter<"Product"> | string
    unitOfMeasureId?: StringFilter<"Product"> | string
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    subCategory?: XOR<SubCategoryNullableScalarRelationFilter, SubCategoryWhereInput> | null
    unitOfMeasure?: XOR<UnitOfMeasureScalarRelationFilter, UnitOfMeasureWhereInput>
    batches?: ProductBatchListRelationFilter
    PurchaseItem?: PurchaseItemListRelationFilter
    TransferItem?: TransferItemListRelationFilter
    StockCorrectionItem?: StockCorrectionItemListRelationFilter
    CartItem?: CartItemListRelationFilter
    AdditionalPrice?: AdditionalPriceListRelationFilter
    SellItem?: SellItemListRelationFilter
    SellStockCorrectionItem?: SellStockCorrectionItemListRelationFilter
    waitlists?: WaitlistListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    productCode?: SortOrder
    name?: SortOrder
    generic?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    subCategoryId?: SortOrderInput | SortOrder
    sellPrice?: SortOrderInput | SortOrder
    imageUrl?: SortOrder
    unitOfMeasureId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: CategoryOrderByWithRelationInput
    subCategory?: SubCategoryOrderByWithRelationInput
    unitOfMeasure?: UnitOfMeasureOrderByWithRelationInput
    batches?: ProductBatchOrderByRelationAggregateInput
    PurchaseItem?: PurchaseItemOrderByRelationAggregateInput
    TransferItem?: TransferItemOrderByRelationAggregateInput
    StockCorrectionItem?: StockCorrectionItemOrderByRelationAggregateInput
    CartItem?: CartItemOrderByRelationAggregateInput
    AdditionalPrice?: AdditionalPriceOrderByRelationAggregateInput
    SellItem?: SellItemOrderByRelationAggregateInput
    SellStockCorrectionItem?: SellStockCorrectionItemOrderByRelationAggregateInput
    waitlists?: WaitlistOrderByRelationAggregateInput
    _relevance?: ProductOrderByRelevanceInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productCode?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    generic?: StringNullableFilter<"Product"> | string | null
    description?: StringNullableFilter<"Product"> | string | null
    categoryId?: StringFilter<"Product"> | string
    subCategoryId?: StringNullableFilter<"Product"> | string | null
    sellPrice?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFilter<"Product"> | string
    unitOfMeasureId?: StringFilter<"Product"> | string
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    subCategory?: XOR<SubCategoryNullableScalarRelationFilter, SubCategoryWhereInput> | null
    unitOfMeasure?: XOR<UnitOfMeasureScalarRelationFilter, UnitOfMeasureWhereInput>
    batches?: ProductBatchListRelationFilter
    PurchaseItem?: PurchaseItemListRelationFilter
    TransferItem?: TransferItemListRelationFilter
    StockCorrectionItem?: StockCorrectionItemListRelationFilter
    CartItem?: CartItemListRelationFilter
    AdditionalPrice?: AdditionalPriceListRelationFilter
    SellItem?: SellItemListRelationFilter
    SellStockCorrectionItem?: SellStockCorrectionItemListRelationFilter
    waitlists?: WaitlistListRelationFilter
  }, "id" | "productCode">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    productCode?: SortOrder
    name?: SortOrder
    generic?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    subCategoryId?: SortOrderInput | SortOrder
    sellPrice?: SortOrderInput | SortOrder
    imageUrl?: SortOrder
    unitOfMeasureId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    productCode?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    generic?: StringNullableWithAggregatesFilter<"Product"> | string | null
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    categoryId?: StringWithAggregatesFilter<"Product"> | string
    subCategoryId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    sellPrice?: DecimalNullableWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringWithAggregatesFilter<"Product"> | string
    unitOfMeasureId?: StringWithAggregatesFilter<"Product"> | string
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type AdditionalPriceWhereInput = {
    AND?: AdditionalPriceWhereInput | AdditionalPriceWhereInput[]
    OR?: AdditionalPriceWhereInput[]
    NOT?: AdditionalPriceWhereInput | AdditionalPriceWhereInput[]
    id?: StringFilter<"AdditionalPrice"> | string
    label?: StringNullableFilter<"AdditionalPrice"> | string | null
    price?: FloatFilter<"AdditionalPrice"> | number
    productId?: StringFilter<"AdditionalPrice"> | string
    shopId?: StringNullableFilter<"AdditionalPrice"> | string | null
    createdAt?: DateTimeFilter<"AdditionalPrice"> | Date | string
    updatedAt?: DateTimeFilter<"AdditionalPrice"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
  }

  export type AdditionalPriceOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrderInput | SortOrder
    price?: SortOrder
    productId?: SortOrder
    shopId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    shop?: ShopOrderByWithRelationInput
    _relevance?: AdditionalPriceOrderByRelevanceInput
  }

  export type AdditionalPriceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_label?: AdditionalPriceProductIdLabelCompoundUniqueInput
    AND?: AdditionalPriceWhereInput | AdditionalPriceWhereInput[]
    OR?: AdditionalPriceWhereInput[]
    NOT?: AdditionalPriceWhereInput | AdditionalPriceWhereInput[]
    label?: StringNullableFilter<"AdditionalPrice"> | string | null
    price?: FloatFilter<"AdditionalPrice"> | number
    productId?: StringFilter<"AdditionalPrice"> | string
    shopId?: StringNullableFilter<"AdditionalPrice"> | string | null
    createdAt?: DateTimeFilter<"AdditionalPrice"> | Date | string
    updatedAt?: DateTimeFilter<"AdditionalPrice"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
  }, "id" | "productId_label">

  export type AdditionalPriceOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrderInput | SortOrder
    price?: SortOrder
    productId?: SortOrder
    shopId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdditionalPriceCountOrderByAggregateInput
    _avg?: AdditionalPriceAvgOrderByAggregateInput
    _max?: AdditionalPriceMaxOrderByAggregateInput
    _min?: AdditionalPriceMinOrderByAggregateInput
    _sum?: AdditionalPriceSumOrderByAggregateInput
  }

  export type AdditionalPriceScalarWhereWithAggregatesInput = {
    AND?: AdditionalPriceScalarWhereWithAggregatesInput | AdditionalPriceScalarWhereWithAggregatesInput[]
    OR?: AdditionalPriceScalarWhereWithAggregatesInput[]
    NOT?: AdditionalPriceScalarWhereWithAggregatesInput | AdditionalPriceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdditionalPrice"> | string
    label?: StringNullableWithAggregatesFilter<"AdditionalPrice"> | string | null
    price?: FloatWithAggregatesFilter<"AdditionalPrice"> | number
    productId?: StringWithAggregatesFilter<"AdditionalPrice"> | string
    shopId?: StringNullableWithAggregatesFilter<"AdditionalPrice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AdditionalPrice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdditionalPrice"> | Date | string
  }

  export type ProductBatchWhereInput = {
    AND?: ProductBatchWhereInput | ProductBatchWhereInput[]
    OR?: ProductBatchWhereInput[]
    NOT?: ProductBatchWhereInput | ProductBatchWhereInput[]
    id?: StringFilter<"ProductBatch"> | string
    batchNumber?: StringFilter<"ProductBatch"> | string
    expiryDate?: DateTimeNullableFilter<"ProductBatch"> | Date | string | null
    productId?: StringFilter<"ProductBatch"> | string
    price?: FloatNullableFilter<"ProductBatch"> | number | null
    stock?: IntNullableFilter<"ProductBatch"> | number | null
    warningQuantity?: IntNullableFilter<"ProductBatch"> | number | null
    storeId?: StringNullableFilter<"ProductBatch"> | string | null
    createdAt?: DateTimeFilter<"ProductBatch"> | Date | string
    updatedAt?: DateTimeFilter<"ProductBatch"> | Date | string
    store?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    ShopStock?: ShopStockListRelationFilter
    StoreStock?: StoreStockListRelationFilter
    StockLedger?: StockLedgerListRelationFilter
    PurchaseItem?: PurchaseItemListRelationFilter
    TransferItem?: TransferItemListRelationFilter
    StockCorrectionItem?: StockCorrectionItemListRelationFilter
    SellItemBatch?: SellItemBatchListRelationFilter
    SellStockCorrectionBatch?: SellStockCorrectionBatchListRelationFilter
  }

  export type ProductBatchOrderByWithRelationInput = {
    id?: SortOrder
    batchNumber?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    productId?: SortOrder
    price?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    warningQuantity?: SortOrderInput | SortOrder
    storeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: StoreOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    ShopStock?: ShopStockOrderByRelationAggregateInput
    StoreStock?: StoreStockOrderByRelationAggregateInput
    StockLedger?: StockLedgerOrderByRelationAggregateInput
    PurchaseItem?: PurchaseItemOrderByRelationAggregateInput
    TransferItem?: TransferItemOrderByRelationAggregateInput
    StockCorrectionItem?: StockCorrectionItemOrderByRelationAggregateInput
    SellItemBatch?: SellItemBatchOrderByRelationAggregateInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchOrderByRelationAggregateInput
    _relevance?: ProductBatchOrderByRelevanceInput
  }

  export type ProductBatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    batchNumber?: string
    AND?: ProductBatchWhereInput | ProductBatchWhereInput[]
    OR?: ProductBatchWhereInput[]
    NOT?: ProductBatchWhereInput | ProductBatchWhereInput[]
    expiryDate?: DateTimeNullableFilter<"ProductBatch"> | Date | string | null
    productId?: StringFilter<"ProductBatch"> | string
    price?: FloatNullableFilter<"ProductBatch"> | number | null
    stock?: IntNullableFilter<"ProductBatch"> | number | null
    warningQuantity?: IntNullableFilter<"ProductBatch"> | number | null
    storeId?: StringNullableFilter<"ProductBatch"> | string | null
    createdAt?: DateTimeFilter<"ProductBatch"> | Date | string
    updatedAt?: DateTimeFilter<"ProductBatch"> | Date | string
    store?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    ShopStock?: ShopStockListRelationFilter
    StoreStock?: StoreStockListRelationFilter
    StockLedger?: StockLedgerListRelationFilter
    PurchaseItem?: PurchaseItemListRelationFilter
    TransferItem?: TransferItemListRelationFilter
    StockCorrectionItem?: StockCorrectionItemListRelationFilter
    SellItemBatch?: SellItemBatchListRelationFilter
    SellStockCorrectionBatch?: SellStockCorrectionBatchListRelationFilter
  }, "id" | "batchNumber">

  export type ProductBatchOrderByWithAggregationInput = {
    id?: SortOrder
    batchNumber?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    productId?: SortOrder
    price?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    warningQuantity?: SortOrderInput | SortOrder
    storeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductBatchCountOrderByAggregateInput
    _avg?: ProductBatchAvgOrderByAggregateInput
    _max?: ProductBatchMaxOrderByAggregateInput
    _min?: ProductBatchMinOrderByAggregateInput
    _sum?: ProductBatchSumOrderByAggregateInput
  }

  export type ProductBatchScalarWhereWithAggregatesInput = {
    AND?: ProductBatchScalarWhereWithAggregatesInput | ProductBatchScalarWhereWithAggregatesInput[]
    OR?: ProductBatchScalarWhereWithAggregatesInput[]
    NOT?: ProductBatchScalarWhereWithAggregatesInput | ProductBatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductBatch"> | string
    batchNumber?: StringWithAggregatesFilter<"ProductBatch"> | string
    expiryDate?: DateTimeNullableWithAggregatesFilter<"ProductBatch"> | Date | string | null
    productId?: StringWithAggregatesFilter<"ProductBatch"> | string
    price?: FloatNullableWithAggregatesFilter<"ProductBatch"> | number | null
    stock?: IntNullableWithAggregatesFilter<"ProductBatch"> | number | null
    warningQuantity?: IntNullableWithAggregatesFilter<"ProductBatch"> | number | null
    storeId?: StringNullableWithAggregatesFilter<"ProductBatch"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductBatch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductBatch"> | Date | string
  }

  export type UnitOfMeasureWhereInput = {
    AND?: UnitOfMeasureWhereInput | UnitOfMeasureWhereInput[]
    OR?: UnitOfMeasureWhereInput[]
    NOT?: UnitOfMeasureWhereInput | UnitOfMeasureWhereInput[]
    id?: StringFilter<"UnitOfMeasure"> | string
    name?: StringFilter<"UnitOfMeasure"> | string
    symbol?: StringNullableFilter<"UnitOfMeasure"> | string | null
    base?: BoolFilter<"UnitOfMeasure"> | boolean
    products?: ProductListRelationFilter
    PurchaseItem?: PurchaseItemListRelationFilter
    TransferItem?: TransferItemListRelationFilter
    StockLedger?: StockLedgerListRelationFilter
    ShopStock?: ShopStockListRelationFilter
    StoreStock?: StoreStockListRelationFilter
    StockCorrectionItem?: StockCorrectionItemListRelationFilter
    SellItem?: SellItemListRelationFilter
    SellStockCorrectionItem?: SellStockCorrectionItemListRelationFilter
    CartItem?: CartItemListRelationFilter
  }

  export type UnitOfMeasureOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrderInput | SortOrder
    base?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    PurchaseItem?: PurchaseItemOrderByRelationAggregateInput
    TransferItem?: TransferItemOrderByRelationAggregateInput
    StockLedger?: StockLedgerOrderByRelationAggregateInput
    ShopStock?: ShopStockOrderByRelationAggregateInput
    StoreStock?: StoreStockOrderByRelationAggregateInput
    StockCorrectionItem?: StockCorrectionItemOrderByRelationAggregateInput
    SellItem?: SellItemOrderByRelationAggregateInput
    SellStockCorrectionItem?: SellStockCorrectionItemOrderByRelationAggregateInput
    CartItem?: CartItemOrderByRelationAggregateInput
    _relevance?: UnitOfMeasureOrderByRelevanceInput
  }

  export type UnitOfMeasureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: UnitOfMeasureWhereInput | UnitOfMeasureWhereInput[]
    OR?: UnitOfMeasureWhereInput[]
    NOT?: UnitOfMeasureWhereInput | UnitOfMeasureWhereInput[]
    symbol?: StringNullableFilter<"UnitOfMeasure"> | string | null
    base?: BoolFilter<"UnitOfMeasure"> | boolean
    products?: ProductListRelationFilter
    PurchaseItem?: PurchaseItemListRelationFilter
    TransferItem?: TransferItemListRelationFilter
    StockLedger?: StockLedgerListRelationFilter
    ShopStock?: ShopStockListRelationFilter
    StoreStock?: StoreStockListRelationFilter
    StockCorrectionItem?: StockCorrectionItemListRelationFilter
    SellItem?: SellItemListRelationFilter
    SellStockCorrectionItem?: SellStockCorrectionItemListRelationFilter
    CartItem?: CartItemListRelationFilter
  }, "id" | "name">

  export type UnitOfMeasureOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrderInput | SortOrder
    base?: SortOrder
    _count?: UnitOfMeasureCountOrderByAggregateInput
    _max?: UnitOfMeasureMaxOrderByAggregateInput
    _min?: UnitOfMeasureMinOrderByAggregateInput
  }

  export type UnitOfMeasureScalarWhereWithAggregatesInput = {
    AND?: UnitOfMeasureScalarWhereWithAggregatesInput | UnitOfMeasureScalarWhereWithAggregatesInput[]
    OR?: UnitOfMeasureScalarWhereWithAggregatesInput[]
    NOT?: UnitOfMeasureScalarWhereWithAggregatesInput | UnitOfMeasureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UnitOfMeasure"> | string
    name?: StringWithAggregatesFilter<"UnitOfMeasure"> | string
    symbol?: StringNullableWithAggregatesFilter<"UnitOfMeasure"> | string | null
    base?: BoolWithAggregatesFilter<"UnitOfMeasure"> | boolean
  }

  export type PurchaseWhereInput = {
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    id?: StringFilter<"Purchase"> | string
    invoiceNo?: StringFilter<"Purchase"> | string
    supplierId?: StringFilter<"Purchase"> | string
    storeId?: StringFilter<"Purchase"> | string
    paymentStatus?: EnumPaymentStatusFilter<"Purchase"> | $Enums.PaymentStatus
    totalProducts?: IntFilter<"Purchase"> | number
    subTotal?: FloatFilter<"Purchase"> | number
    grandTotal?: FloatFilter<"Purchase"> | number
    notes?: StringNullableFilter<"Purchase"> | string | null
    purchaseDate?: DateTimeFilter<"Purchase"> | Date | string
    createdById?: StringNullableFilter<"Purchase"> | string | null
    updatedById?: StringNullableFilter<"Purchase"> | string | null
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
    store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: PurchaseItemListRelationFilter
    StockCorrection?: StockCorrectionListRelationFilter
  }

  export type PurchaseOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    supplierId?: SortOrder
    storeId?: SortOrder
    paymentStatus?: SortOrder
    totalProducts?: SortOrder
    subTotal?: SortOrder
    grandTotal?: SortOrder
    notes?: SortOrderInput | SortOrder
    purchaseDate?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplier?: SupplierOrderByWithRelationInput
    store?: StoreOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
    items?: PurchaseItemOrderByRelationAggregateInput
    StockCorrection?: StockCorrectionOrderByRelationAggregateInput
    _relevance?: PurchaseOrderByRelevanceInput
  }

  export type PurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNo?: string
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    supplierId?: StringFilter<"Purchase"> | string
    storeId?: StringFilter<"Purchase"> | string
    paymentStatus?: EnumPaymentStatusFilter<"Purchase"> | $Enums.PaymentStatus
    totalProducts?: IntFilter<"Purchase"> | number
    subTotal?: FloatFilter<"Purchase"> | number
    grandTotal?: FloatFilter<"Purchase"> | number
    notes?: StringNullableFilter<"Purchase"> | string | null
    purchaseDate?: DateTimeFilter<"Purchase"> | Date | string
    createdById?: StringNullableFilter<"Purchase"> | string | null
    updatedById?: StringNullableFilter<"Purchase"> | string | null
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
    store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: PurchaseItemListRelationFilter
    StockCorrection?: StockCorrectionListRelationFilter
  }, "id" | "invoiceNo">

  export type PurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    supplierId?: SortOrder
    storeId?: SortOrder
    paymentStatus?: SortOrder
    totalProducts?: SortOrder
    subTotal?: SortOrder
    grandTotal?: SortOrder
    notes?: SortOrderInput | SortOrder
    purchaseDate?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseCountOrderByAggregateInput
    _avg?: PurchaseAvgOrderByAggregateInput
    _max?: PurchaseMaxOrderByAggregateInput
    _min?: PurchaseMinOrderByAggregateInput
    _sum?: PurchaseSumOrderByAggregateInput
  }

  export type PurchaseScalarWhereWithAggregatesInput = {
    AND?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    OR?: PurchaseScalarWhereWithAggregatesInput[]
    NOT?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Purchase"> | string
    invoiceNo?: StringWithAggregatesFilter<"Purchase"> | string
    supplierId?: StringWithAggregatesFilter<"Purchase"> | string
    storeId?: StringWithAggregatesFilter<"Purchase"> | string
    paymentStatus?: EnumPaymentStatusWithAggregatesFilter<"Purchase"> | $Enums.PaymentStatus
    totalProducts?: IntWithAggregatesFilter<"Purchase"> | number
    subTotal?: FloatWithAggregatesFilter<"Purchase"> | number
    grandTotal?: FloatWithAggregatesFilter<"Purchase"> | number
    notes?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
    purchaseDate?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
    updatedById?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
  }

  export type PurchaseItemWhereInput = {
    AND?: PurchaseItemWhereInput | PurchaseItemWhereInput[]
    OR?: PurchaseItemWhereInput[]
    NOT?: PurchaseItemWhereInput | PurchaseItemWhereInput[]
    id?: StringFilter<"PurchaseItem"> | string
    purchaseId?: StringFilter<"PurchaseItem"> | string
    productId?: StringFilter<"PurchaseItem"> | string
    batchId?: StringFilter<"PurchaseItem"> | string
    unitOfMeasureId?: StringFilter<"PurchaseItem"> | string
    quantity?: IntFilter<"PurchaseItem"> | number
    unitPrice?: FloatFilter<"PurchaseItem"> | number
    totalPrice?: FloatFilter<"PurchaseItem"> | number
    createdAt?: DateTimeFilter<"PurchaseItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseItem"> | Date | string
    purchase?: XOR<PurchaseScalarRelationFilter, PurchaseWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    batch?: XOR<ProductBatchScalarRelationFilter, ProductBatchWhereInput>
    unitOfMeasure?: XOR<UnitOfMeasureScalarRelationFilter, UnitOfMeasureWhereInput>
  }

  export type PurchaseItemOrderByWithRelationInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    productId?: SortOrder
    batchId?: SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchase?: PurchaseOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    batch?: ProductBatchOrderByWithRelationInput
    unitOfMeasure?: UnitOfMeasureOrderByWithRelationInput
    _relevance?: PurchaseItemOrderByRelevanceInput
  }

  export type PurchaseItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseItemWhereInput | PurchaseItemWhereInput[]
    OR?: PurchaseItemWhereInput[]
    NOT?: PurchaseItemWhereInput | PurchaseItemWhereInput[]
    purchaseId?: StringFilter<"PurchaseItem"> | string
    productId?: StringFilter<"PurchaseItem"> | string
    batchId?: StringFilter<"PurchaseItem"> | string
    unitOfMeasureId?: StringFilter<"PurchaseItem"> | string
    quantity?: IntFilter<"PurchaseItem"> | number
    unitPrice?: FloatFilter<"PurchaseItem"> | number
    totalPrice?: FloatFilter<"PurchaseItem"> | number
    createdAt?: DateTimeFilter<"PurchaseItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseItem"> | Date | string
    purchase?: XOR<PurchaseScalarRelationFilter, PurchaseWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    batch?: XOR<ProductBatchScalarRelationFilter, ProductBatchWhereInput>
    unitOfMeasure?: XOR<UnitOfMeasureScalarRelationFilter, UnitOfMeasureWhereInput>
  }, "id">

  export type PurchaseItemOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    productId?: SortOrder
    batchId?: SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseItemCountOrderByAggregateInput
    _avg?: PurchaseItemAvgOrderByAggregateInput
    _max?: PurchaseItemMaxOrderByAggregateInput
    _min?: PurchaseItemMinOrderByAggregateInput
    _sum?: PurchaseItemSumOrderByAggregateInput
  }

  export type PurchaseItemScalarWhereWithAggregatesInput = {
    AND?: PurchaseItemScalarWhereWithAggregatesInput | PurchaseItemScalarWhereWithAggregatesInput[]
    OR?: PurchaseItemScalarWhereWithAggregatesInput[]
    NOT?: PurchaseItemScalarWhereWithAggregatesInput | PurchaseItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseItem"> | string
    purchaseId?: StringWithAggregatesFilter<"PurchaseItem"> | string
    productId?: StringWithAggregatesFilter<"PurchaseItem"> | string
    batchId?: StringWithAggregatesFilter<"PurchaseItem"> | string
    unitOfMeasureId?: StringWithAggregatesFilter<"PurchaseItem"> | string
    quantity?: IntWithAggregatesFilter<"PurchaseItem"> | number
    unitPrice?: FloatWithAggregatesFilter<"PurchaseItem"> | number
    totalPrice?: FloatWithAggregatesFilter<"PurchaseItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseItem"> | Date | string
  }

  export type TransferWhereInput = {
    AND?: TransferWhereInput | TransferWhereInput[]
    OR?: TransferWhereInput[]
    NOT?: TransferWhereInput | TransferWhereInput[]
    id?: StringFilter<"Transfer"> | string
    shortCode?: StringFilter<"Transfer"> | string
    sourceType?: EnumTransferEntityTypeFilter<"Transfer"> | $Enums.TransferEntityType
    sourceStoreId?: StringNullableFilter<"Transfer"> | string | null
    sourceShopId?: StringNullableFilter<"Transfer"> | string | null
    destinationType?: EnumTransferEntityTypeFilter<"Transfer"> | $Enums.TransferEntityType
    destStoreId?: StringNullableFilter<"Transfer"> | string | null
    destShopId?: StringNullableFilter<"Transfer"> | string | null
    reference?: StringNullableFilter<"Transfer"> | string | null
    notes?: StringNullableFilter<"Transfer"> | string | null
    status?: EnumTransferStatusFilter<"Transfer"> | $Enums.TransferStatus
    movementDate?: DateTimeFilter<"Transfer"> | Date | string
    createdById?: StringNullableFilter<"Transfer"> | string | null
    updatedById?: StringNullableFilter<"Transfer"> | string | null
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeFilter<"Transfer"> | Date | string
    sourceStore?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
    sourceShop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
    destStore?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
    destShop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: TransferItemListRelationFilter
    StockCorrection?: StockCorrectionListRelationFilter
  }

  export type TransferOrderByWithRelationInput = {
    id?: SortOrder
    shortCode?: SortOrder
    sourceType?: SortOrder
    sourceStoreId?: SortOrderInput | SortOrder
    sourceShopId?: SortOrderInput | SortOrder
    destinationType?: SortOrder
    destStoreId?: SortOrderInput | SortOrder
    destShopId?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    movementDate?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sourceStore?: StoreOrderByWithRelationInput
    sourceShop?: ShopOrderByWithRelationInput
    destStore?: StoreOrderByWithRelationInput
    destShop?: ShopOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
    items?: TransferItemOrderByRelationAggregateInput
    StockCorrection?: StockCorrectionOrderByRelationAggregateInput
    _relevance?: TransferOrderByRelevanceInput
  }

  export type TransferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shortCode?: string
    AND?: TransferWhereInput | TransferWhereInput[]
    OR?: TransferWhereInput[]
    NOT?: TransferWhereInput | TransferWhereInput[]
    sourceType?: EnumTransferEntityTypeFilter<"Transfer"> | $Enums.TransferEntityType
    sourceStoreId?: StringNullableFilter<"Transfer"> | string | null
    sourceShopId?: StringNullableFilter<"Transfer"> | string | null
    destinationType?: EnumTransferEntityTypeFilter<"Transfer"> | $Enums.TransferEntityType
    destStoreId?: StringNullableFilter<"Transfer"> | string | null
    destShopId?: StringNullableFilter<"Transfer"> | string | null
    reference?: StringNullableFilter<"Transfer"> | string | null
    notes?: StringNullableFilter<"Transfer"> | string | null
    status?: EnumTransferStatusFilter<"Transfer"> | $Enums.TransferStatus
    movementDate?: DateTimeFilter<"Transfer"> | Date | string
    createdById?: StringNullableFilter<"Transfer"> | string | null
    updatedById?: StringNullableFilter<"Transfer"> | string | null
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeFilter<"Transfer"> | Date | string
    sourceStore?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
    sourceShop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
    destStore?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
    destShop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: TransferItemListRelationFilter
    StockCorrection?: StockCorrectionListRelationFilter
  }, "id" | "shortCode">

  export type TransferOrderByWithAggregationInput = {
    id?: SortOrder
    shortCode?: SortOrder
    sourceType?: SortOrder
    sourceStoreId?: SortOrderInput | SortOrder
    sourceShopId?: SortOrderInput | SortOrder
    destinationType?: SortOrder
    destStoreId?: SortOrderInput | SortOrder
    destShopId?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    movementDate?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransferCountOrderByAggregateInput
    _max?: TransferMaxOrderByAggregateInput
    _min?: TransferMinOrderByAggregateInput
  }

  export type TransferScalarWhereWithAggregatesInput = {
    AND?: TransferScalarWhereWithAggregatesInput | TransferScalarWhereWithAggregatesInput[]
    OR?: TransferScalarWhereWithAggregatesInput[]
    NOT?: TransferScalarWhereWithAggregatesInput | TransferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transfer"> | string
    shortCode?: StringWithAggregatesFilter<"Transfer"> | string
    sourceType?: EnumTransferEntityTypeWithAggregatesFilter<"Transfer"> | $Enums.TransferEntityType
    sourceStoreId?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    sourceShopId?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    destinationType?: EnumTransferEntityTypeWithAggregatesFilter<"Transfer"> | $Enums.TransferEntityType
    destStoreId?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    destShopId?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    reference?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    status?: EnumTransferStatusWithAggregatesFilter<"Transfer"> | $Enums.TransferStatus
    movementDate?: DateTimeWithAggregatesFilter<"Transfer"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    updatedById?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transfer"> | Date | string
  }

  export type TransferItemWhereInput = {
    AND?: TransferItemWhereInput | TransferItemWhereInput[]
    OR?: TransferItemWhereInput[]
    NOT?: TransferItemWhereInput | TransferItemWhereInput[]
    id?: StringFilter<"TransferItem"> | string
    transferId?: StringFilter<"TransferItem"> | string
    productId?: StringFilter<"TransferItem"> | string
    batchId?: StringFilter<"TransferItem"> | string
    unitOfMeasureId?: StringFilter<"TransferItem"> | string
    quantity?: IntFilter<"TransferItem"> | number
    createdAt?: DateTimeFilter<"TransferItem"> | Date | string
    updatedAt?: DateTimeFilter<"TransferItem"> | Date | string
    transfer?: XOR<TransferScalarRelationFilter, TransferWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    batch?: XOR<ProductBatchScalarRelationFilter, ProductBatchWhereInput>
    unitOfMeasure?: XOR<UnitOfMeasureScalarRelationFilter, UnitOfMeasureWhereInput>
  }

  export type TransferItemOrderByWithRelationInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    batchId?: SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transfer?: TransferOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    batch?: ProductBatchOrderByWithRelationInput
    unitOfMeasure?: UnitOfMeasureOrderByWithRelationInput
    _relevance?: TransferItemOrderByRelevanceInput
  }

  export type TransferItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransferItemWhereInput | TransferItemWhereInput[]
    OR?: TransferItemWhereInput[]
    NOT?: TransferItemWhereInput | TransferItemWhereInput[]
    transferId?: StringFilter<"TransferItem"> | string
    productId?: StringFilter<"TransferItem"> | string
    batchId?: StringFilter<"TransferItem"> | string
    unitOfMeasureId?: StringFilter<"TransferItem"> | string
    quantity?: IntFilter<"TransferItem"> | number
    createdAt?: DateTimeFilter<"TransferItem"> | Date | string
    updatedAt?: DateTimeFilter<"TransferItem"> | Date | string
    transfer?: XOR<TransferScalarRelationFilter, TransferWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    batch?: XOR<ProductBatchScalarRelationFilter, ProductBatchWhereInput>
    unitOfMeasure?: XOR<UnitOfMeasureScalarRelationFilter, UnitOfMeasureWhereInput>
  }, "id">

  export type TransferItemOrderByWithAggregationInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    batchId?: SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransferItemCountOrderByAggregateInput
    _avg?: TransferItemAvgOrderByAggregateInput
    _max?: TransferItemMaxOrderByAggregateInput
    _min?: TransferItemMinOrderByAggregateInput
    _sum?: TransferItemSumOrderByAggregateInput
  }

  export type TransferItemScalarWhereWithAggregatesInput = {
    AND?: TransferItemScalarWhereWithAggregatesInput | TransferItemScalarWhereWithAggregatesInput[]
    OR?: TransferItemScalarWhereWithAggregatesInput[]
    NOT?: TransferItemScalarWhereWithAggregatesInput | TransferItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransferItem"> | string
    transferId?: StringWithAggregatesFilter<"TransferItem"> | string
    productId?: StringWithAggregatesFilter<"TransferItem"> | string
    batchId?: StringWithAggregatesFilter<"TransferItem"> | string
    unitOfMeasureId?: StringWithAggregatesFilter<"TransferItem"> | string
    quantity?: IntWithAggregatesFilter<"TransferItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TransferItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TransferItem"> | Date | string
  }

  export type StockCorrectionWhereInput = {
    AND?: StockCorrectionWhereInput | StockCorrectionWhereInput[]
    OR?: StockCorrectionWhereInput[]
    NOT?: StockCorrectionWhereInput | StockCorrectionWhereInput[]
    id?: StringFilter<"StockCorrection"> | string
    shortCode?: StringFilter<"StockCorrection"> | string
    storeId?: StringNullableFilter<"StockCorrection"> | string | null
    shopId?: StringNullableFilter<"StockCorrection"> | string | null
    reason?: EnumStockCorrectionReasonFilter<"StockCorrection"> | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFilter<"StockCorrection"> | $Enums.StockCorrectionStatus
    purchaseId?: StringNullableFilter<"StockCorrection"> | string | null
    transferId?: StringNullableFilter<"StockCorrection"> | string | null
    reference?: StringNullableFilter<"StockCorrection"> | string | null
    notes?: StringNullableFilter<"StockCorrection"> | string | null
    createdById?: StringNullableFilter<"StockCorrection"> | string | null
    updatedById?: StringNullableFilter<"StockCorrection"> | string | null
    createdAt?: DateTimeFilter<"StockCorrection"> | Date | string
    updatedAt?: DateTimeFilter<"StockCorrection"> | Date | string
    store?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
    shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
    purchase?: XOR<PurchaseNullableScalarRelationFilter, PurchaseWhereInput> | null
    transfer?: XOR<TransferNullableScalarRelationFilter, TransferWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: StockCorrectionItemListRelationFilter
  }

  export type StockCorrectionOrderByWithRelationInput = {
    id?: SortOrder
    shortCode?: SortOrder
    storeId?: SortOrderInput | SortOrder
    shopId?: SortOrderInput | SortOrder
    reason?: SortOrder
    status?: SortOrder
    purchaseId?: SortOrderInput | SortOrder
    transferId?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: StoreOrderByWithRelationInput
    shop?: ShopOrderByWithRelationInput
    purchase?: PurchaseOrderByWithRelationInput
    transfer?: TransferOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
    items?: StockCorrectionItemOrderByRelationAggregateInput
    _relevance?: StockCorrectionOrderByRelevanceInput
  }

  export type StockCorrectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shortCode?: string
    AND?: StockCorrectionWhereInput | StockCorrectionWhereInput[]
    OR?: StockCorrectionWhereInput[]
    NOT?: StockCorrectionWhereInput | StockCorrectionWhereInput[]
    storeId?: StringNullableFilter<"StockCorrection"> | string | null
    shopId?: StringNullableFilter<"StockCorrection"> | string | null
    reason?: EnumStockCorrectionReasonFilter<"StockCorrection"> | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFilter<"StockCorrection"> | $Enums.StockCorrectionStatus
    purchaseId?: StringNullableFilter<"StockCorrection"> | string | null
    transferId?: StringNullableFilter<"StockCorrection"> | string | null
    reference?: StringNullableFilter<"StockCorrection"> | string | null
    notes?: StringNullableFilter<"StockCorrection"> | string | null
    createdById?: StringNullableFilter<"StockCorrection"> | string | null
    updatedById?: StringNullableFilter<"StockCorrection"> | string | null
    createdAt?: DateTimeFilter<"StockCorrection"> | Date | string
    updatedAt?: DateTimeFilter<"StockCorrection"> | Date | string
    store?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
    shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
    purchase?: XOR<PurchaseNullableScalarRelationFilter, PurchaseWhereInput> | null
    transfer?: XOR<TransferNullableScalarRelationFilter, TransferWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: StockCorrectionItemListRelationFilter
  }, "id" | "shortCode">

  export type StockCorrectionOrderByWithAggregationInput = {
    id?: SortOrder
    shortCode?: SortOrder
    storeId?: SortOrderInput | SortOrder
    shopId?: SortOrderInput | SortOrder
    reason?: SortOrder
    status?: SortOrder
    purchaseId?: SortOrderInput | SortOrder
    transferId?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StockCorrectionCountOrderByAggregateInput
    _max?: StockCorrectionMaxOrderByAggregateInput
    _min?: StockCorrectionMinOrderByAggregateInput
  }

  export type StockCorrectionScalarWhereWithAggregatesInput = {
    AND?: StockCorrectionScalarWhereWithAggregatesInput | StockCorrectionScalarWhereWithAggregatesInput[]
    OR?: StockCorrectionScalarWhereWithAggregatesInput[]
    NOT?: StockCorrectionScalarWhereWithAggregatesInput | StockCorrectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockCorrection"> | string
    shortCode?: StringWithAggregatesFilter<"StockCorrection"> | string
    storeId?: StringNullableWithAggregatesFilter<"StockCorrection"> | string | null
    shopId?: StringNullableWithAggregatesFilter<"StockCorrection"> | string | null
    reason?: EnumStockCorrectionReasonWithAggregatesFilter<"StockCorrection"> | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusWithAggregatesFilter<"StockCorrection"> | $Enums.StockCorrectionStatus
    purchaseId?: StringNullableWithAggregatesFilter<"StockCorrection"> | string | null
    transferId?: StringNullableWithAggregatesFilter<"StockCorrection"> | string | null
    reference?: StringNullableWithAggregatesFilter<"StockCorrection"> | string | null
    notes?: StringNullableWithAggregatesFilter<"StockCorrection"> | string | null
    createdById?: StringNullableWithAggregatesFilter<"StockCorrection"> | string | null
    updatedById?: StringNullableWithAggregatesFilter<"StockCorrection"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StockCorrection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StockCorrection"> | Date | string
  }

  export type StockCorrectionItemWhereInput = {
    AND?: StockCorrectionItemWhereInput | StockCorrectionItemWhereInput[]
    OR?: StockCorrectionItemWhereInput[]
    NOT?: StockCorrectionItemWhereInput | StockCorrectionItemWhereInput[]
    id?: StringFilter<"StockCorrectionItem"> | string
    correctionId?: StringFilter<"StockCorrectionItem"> | string
    productId?: StringFilter<"StockCorrectionItem"> | string
    batchId?: StringNullableFilter<"StockCorrectionItem"> | string | null
    unitOfMeasureId?: StringFilter<"StockCorrectionItem"> | string
    quantity?: IntFilter<"StockCorrectionItem"> | number
    createdAt?: DateTimeFilter<"StockCorrectionItem"> | Date | string
    updatedAt?: DateTimeFilter<"StockCorrectionItem"> | Date | string
    correction?: XOR<StockCorrectionScalarRelationFilter, StockCorrectionWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    batch?: XOR<ProductBatchNullableScalarRelationFilter, ProductBatchWhereInput> | null
    unitOfMeasure?: XOR<UnitOfMeasureScalarRelationFilter, UnitOfMeasureWhereInput>
  }

  export type StockCorrectionItemOrderByWithRelationInput = {
    id?: SortOrder
    correctionId?: SortOrder
    productId?: SortOrder
    batchId?: SortOrderInput | SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    correction?: StockCorrectionOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    batch?: ProductBatchOrderByWithRelationInput
    unitOfMeasure?: UnitOfMeasureOrderByWithRelationInput
    _relevance?: StockCorrectionItemOrderByRelevanceInput
  }

  export type StockCorrectionItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockCorrectionItemWhereInput | StockCorrectionItemWhereInput[]
    OR?: StockCorrectionItemWhereInput[]
    NOT?: StockCorrectionItemWhereInput | StockCorrectionItemWhereInput[]
    correctionId?: StringFilter<"StockCorrectionItem"> | string
    productId?: StringFilter<"StockCorrectionItem"> | string
    batchId?: StringNullableFilter<"StockCorrectionItem"> | string | null
    unitOfMeasureId?: StringFilter<"StockCorrectionItem"> | string
    quantity?: IntFilter<"StockCorrectionItem"> | number
    createdAt?: DateTimeFilter<"StockCorrectionItem"> | Date | string
    updatedAt?: DateTimeFilter<"StockCorrectionItem"> | Date | string
    correction?: XOR<StockCorrectionScalarRelationFilter, StockCorrectionWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    batch?: XOR<ProductBatchNullableScalarRelationFilter, ProductBatchWhereInput> | null
    unitOfMeasure?: XOR<UnitOfMeasureScalarRelationFilter, UnitOfMeasureWhereInput>
  }, "id">

  export type StockCorrectionItemOrderByWithAggregationInput = {
    id?: SortOrder
    correctionId?: SortOrder
    productId?: SortOrder
    batchId?: SortOrderInput | SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StockCorrectionItemCountOrderByAggregateInput
    _avg?: StockCorrectionItemAvgOrderByAggregateInput
    _max?: StockCorrectionItemMaxOrderByAggregateInput
    _min?: StockCorrectionItemMinOrderByAggregateInput
    _sum?: StockCorrectionItemSumOrderByAggregateInput
  }

  export type StockCorrectionItemScalarWhereWithAggregatesInput = {
    AND?: StockCorrectionItemScalarWhereWithAggregatesInput | StockCorrectionItemScalarWhereWithAggregatesInput[]
    OR?: StockCorrectionItemScalarWhereWithAggregatesInput[]
    NOT?: StockCorrectionItemScalarWhereWithAggregatesInput | StockCorrectionItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockCorrectionItem"> | string
    correctionId?: StringWithAggregatesFilter<"StockCorrectionItem"> | string
    productId?: StringWithAggregatesFilter<"StockCorrectionItem"> | string
    batchId?: StringNullableWithAggregatesFilter<"StockCorrectionItem"> | string | null
    unitOfMeasureId?: StringWithAggregatesFilter<"StockCorrectionItem"> | string
    quantity?: IntWithAggregatesFilter<"StockCorrectionItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"StockCorrectionItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StockCorrectionItem"> | Date | string
  }

  export type SellWhereInput = {
    AND?: SellWhereInput | SellWhereInput[]
    OR?: SellWhereInput[]
    NOT?: SellWhereInput | SellWhereInput[]
    id?: StringFilter<"Sell"> | string
    invoiceNo?: StringFilter<"Sell"> | string
    saleStatus?: EnumSaleStatusFilter<"Sell"> | $Enums.SaleStatus
    locked?: BoolFilter<"Sell"> | boolean
    lockedAt?: DateTimeNullableFilter<"Sell"> | Date | string | null
    branchId?: StringNullableFilter<"Sell"> | string | null
    customerId?: StringNullableFilter<"Sell"> | string | null
    totalProducts?: IntFilter<"Sell"> | number
    subTotal?: FloatFilter<"Sell"> | number
    discount?: FloatFilter<"Sell"> | number
    vat?: FloatFilter<"Sell"> | number
    grandTotal?: FloatFilter<"Sell"> | number
    NetTotal?: FloatFilter<"Sell"> | number
    notes?: StringNullableFilter<"Sell"> | string | null
    saleDate?: DateTimeFilter<"Sell"> | Date | string
    createdById?: StringNullableFilter<"Sell"> | string | null
    updatedById?: StringNullableFilter<"Sell"> | string | null
    createdAt?: DateTimeFilter<"Sell"> | Date | string
    updatedAt?: DateTimeFilter<"Sell"> | Date | string
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: SellItemListRelationFilter
    SellStockCorrection?: SellStockCorrectionListRelationFilter
  }

  export type SellOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    saleStatus?: SortOrder
    locked?: SortOrder
    lockedAt?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    totalProducts?: SortOrder
    subTotal?: SortOrder
    discount?: SortOrder
    vat?: SortOrder
    grandTotal?: SortOrder
    NetTotal?: SortOrder
    notes?: SortOrderInput | SortOrder
    saleDate?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
    items?: SellItemOrderByRelationAggregateInput
    SellStockCorrection?: SellStockCorrectionOrderByRelationAggregateInput
    _relevance?: SellOrderByRelevanceInput
  }

  export type SellWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNo?: string
    AND?: SellWhereInput | SellWhereInput[]
    OR?: SellWhereInput[]
    NOT?: SellWhereInput | SellWhereInput[]
    saleStatus?: EnumSaleStatusFilter<"Sell"> | $Enums.SaleStatus
    locked?: BoolFilter<"Sell"> | boolean
    lockedAt?: DateTimeNullableFilter<"Sell"> | Date | string | null
    branchId?: StringNullableFilter<"Sell"> | string | null
    customerId?: StringNullableFilter<"Sell"> | string | null
    totalProducts?: IntFilter<"Sell"> | number
    subTotal?: FloatFilter<"Sell"> | number
    discount?: FloatFilter<"Sell"> | number
    vat?: FloatFilter<"Sell"> | number
    grandTotal?: FloatFilter<"Sell"> | number
    NetTotal?: FloatFilter<"Sell"> | number
    notes?: StringNullableFilter<"Sell"> | string | null
    saleDate?: DateTimeFilter<"Sell"> | Date | string
    createdById?: StringNullableFilter<"Sell"> | string | null
    updatedById?: StringNullableFilter<"Sell"> | string | null
    createdAt?: DateTimeFilter<"Sell"> | Date | string
    updatedAt?: DateTimeFilter<"Sell"> | Date | string
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: SellItemListRelationFilter
    SellStockCorrection?: SellStockCorrectionListRelationFilter
  }, "id" | "invoiceNo">

  export type SellOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    saleStatus?: SortOrder
    locked?: SortOrder
    lockedAt?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    totalProducts?: SortOrder
    subTotal?: SortOrder
    discount?: SortOrder
    vat?: SortOrder
    grandTotal?: SortOrder
    NetTotal?: SortOrder
    notes?: SortOrderInput | SortOrder
    saleDate?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SellCountOrderByAggregateInput
    _avg?: SellAvgOrderByAggregateInput
    _max?: SellMaxOrderByAggregateInput
    _min?: SellMinOrderByAggregateInput
    _sum?: SellSumOrderByAggregateInput
  }

  export type SellScalarWhereWithAggregatesInput = {
    AND?: SellScalarWhereWithAggregatesInput | SellScalarWhereWithAggregatesInput[]
    OR?: SellScalarWhereWithAggregatesInput[]
    NOT?: SellScalarWhereWithAggregatesInput | SellScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sell"> | string
    invoiceNo?: StringWithAggregatesFilter<"Sell"> | string
    saleStatus?: EnumSaleStatusWithAggregatesFilter<"Sell"> | $Enums.SaleStatus
    locked?: BoolWithAggregatesFilter<"Sell"> | boolean
    lockedAt?: DateTimeNullableWithAggregatesFilter<"Sell"> | Date | string | null
    branchId?: StringNullableWithAggregatesFilter<"Sell"> | string | null
    customerId?: StringNullableWithAggregatesFilter<"Sell"> | string | null
    totalProducts?: IntWithAggregatesFilter<"Sell"> | number
    subTotal?: FloatWithAggregatesFilter<"Sell"> | number
    discount?: FloatWithAggregatesFilter<"Sell"> | number
    vat?: FloatWithAggregatesFilter<"Sell"> | number
    grandTotal?: FloatWithAggregatesFilter<"Sell"> | number
    NetTotal?: FloatWithAggregatesFilter<"Sell"> | number
    notes?: StringNullableWithAggregatesFilter<"Sell"> | string | null
    saleDate?: DateTimeWithAggregatesFilter<"Sell"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"Sell"> | string | null
    updatedById?: StringNullableWithAggregatesFilter<"Sell"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Sell"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sell"> | Date | string
  }

  export type SellItemWhereInput = {
    AND?: SellItemWhereInput | SellItemWhereInput[]
    OR?: SellItemWhereInput[]
    NOT?: SellItemWhereInput | SellItemWhereInput[]
    id?: StringFilter<"SellItem"> | string
    sellId?: StringFilter<"SellItem"> | string
    productId?: StringFilter<"SellItem"> | string
    shopId?: StringFilter<"SellItem"> | string
    unitOfMeasureId?: StringFilter<"SellItem"> | string
    itemSaleStatus?: EnumItemSaleStatusFilter<"SellItem"> | $Enums.ItemSaleStatus
    quantity?: IntFilter<"SellItem"> | number
    unitPrice?: FloatFilter<"SellItem"> | number
    totalPrice?: FloatFilter<"SellItem"> | number
    createdAt?: DateTimeFilter<"SellItem"> | Date | string
    updatedAt?: DateTimeFilter<"SellItem"> | Date | string
    sell?: XOR<SellScalarRelationFilter, SellWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    unitOfMeasure?: XOR<UnitOfMeasureScalarRelationFilter, UnitOfMeasureWhereInput>
    batches?: SellItemBatchListRelationFilter
  }

  export type SellItemOrderByWithRelationInput = {
    id?: SortOrder
    sellId?: SortOrder
    productId?: SortOrder
    shopId?: SortOrder
    unitOfMeasureId?: SortOrder
    itemSaleStatus?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sell?: SellOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    shop?: ShopOrderByWithRelationInput
    unitOfMeasure?: UnitOfMeasureOrderByWithRelationInput
    batches?: SellItemBatchOrderByRelationAggregateInput
    _relevance?: SellItemOrderByRelevanceInput
  }

  export type SellItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SellItemWhereInput | SellItemWhereInput[]
    OR?: SellItemWhereInput[]
    NOT?: SellItemWhereInput | SellItemWhereInput[]
    sellId?: StringFilter<"SellItem"> | string
    productId?: StringFilter<"SellItem"> | string
    shopId?: StringFilter<"SellItem"> | string
    unitOfMeasureId?: StringFilter<"SellItem"> | string
    itemSaleStatus?: EnumItemSaleStatusFilter<"SellItem"> | $Enums.ItemSaleStatus
    quantity?: IntFilter<"SellItem"> | number
    unitPrice?: FloatFilter<"SellItem"> | number
    totalPrice?: FloatFilter<"SellItem"> | number
    createdAt?: DateTimeFilter<"SellItem"> | Date | string
    updatedAt?: DateTimeFilter<"SellItem"> | Date | string
    sell?: XOR<SellScalarRelationFilter, SellWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    unitOfMeasure?: XOR<UnitOfMeasureScalarRelationFilter, UnitOfMeasureWhereInput>
    batches?: SellItemBatchListRelationFilter
  }, "id">

  export type SellItemOrderByWithAggregationInput = {
    id?: SortOrder
    sellId?: SortOrder
    productId?: SortOrder
    shopId?: SortOrder
    unitOfMeasureId?: SortOrder
    itemSaleStatus?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SellItemCountOrderByAggregateInput
    _avg?: SellItemAvgOrderByAggregateInput
    _max?: SellItemMaxOrderByAggregateInput
    _min?: SellItemMinOrderByAggregateInput
    _sum?: SellItemSumOrderByAggregateInput
  }

  export type SellItemScalarWhereWithAggregatesInput = {
    AND?: SellItemScalarWhereWithAggregatesInput | SellItemScalarWhereWithAggregatesInput[]
    OR?: SellItemScalarWhereWithAggregatesInput[]
    NOT?: SellItemScalarWhereWithAggregatesInput | SellItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SellItem"> | string
    sellId?: StringWithAggregatesFilter<"SellItem"> | string
    productId?: StringWithAggregatesFilter<"SellItem"> | string
    shopId?: StringWithAggregatesFilter<"SellItem"> | string
    unitOfMeasureId?: StringWithAggregatesFilter<"SellItem"> | string
    itemSaleStatus?: EnumItemSaleStatusWithAggregatesFilter<"SellItem"> | $Enums.ItemSaleStatus
    quantity?: IntWithAggregatesFilter<"SellItem"> | number
    unitPrice?: FloatWithAggregatesFilter<"SellItem"> | number
    totalPrice?: FloatWithAggregatesFilter<"SellItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SellItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SellItem"> | Date | string
  }

  export type SellItemBatchWhereInput = {
    AND?: SellItemBatchWhereInput | SellItemBatchWhereInput[]
    OR?: SellItemBatchWhereInput[]
    NOT?: SellItemBatchWhereInput | SellItemBatchWhereInput[]
    id?: StringFilter<"SellItemBatch"> | string
    sellItemId?: StringFilter<"SellItemBatch"> | string
    batchId?: StringFilter<"SellItemBatch"> | string
    quantity?: IntFilter<"SellItemBatch"> | number
    sellItem?: XOR<SellItemScalarRelationFilter, SellItemWhereInput>
    batch?: XOR<ProductBatchScalarRelationFilter, ProductBatchWhereInput>
  }

  export type SellItemBatchOrderByWithRelationInput = {
    id?: SortOrder
    sellItemId?: SortOrder
    batchId?: SortOrder
    quantity?: SortOrder
    sellItem?: SellItemOrderByWithRelationInput
    batch?: ProductBatchOrderByWithRelationInput
    _relevance?: SellItemBatchOrderByRelevanceInput
  }

  export type SellItemBatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sellItemId_batchId?: SellItemBatchSellItemIdBatchIdCompoundUniqueInput
    AND?: SellItemBatchWhereInput | SellItemBatchWhereInput[]
    OR?: SellItemBatchWhereInput[]
    NOT?: SellItemBatchWhereInput | SellItemBatchWhereInput[]
    sellItemId?: StringFilter<"SellItemBatch"> | string
    batchId?: StringFilter<"SellItemBatch"> | string
    quantity?: IntFilter<"SellItemBatch"> | number
    sellItem?: XOR<SellItemScalarRelationFilter, SellItemWhereInput>
    batch?: XOR<ProductBatchScalarRelationFilter, ProductBatchWhereInput>
  }, "id" | "sellItemId_batchId">

  export type SellItemBatchOrderByWithAggregationInput = {
    id?: SortOrder
    sellItemId?: SortOrder
    batchId?: SortOrder
    quantity?: SortOrder
    _count?: SellItemBatchCountOrderByAggregateInput
    _avg?: SellItemBatchAvgOrderByAggregateInput
    _max?: SellItemBatchMaxOrderByAggregateInput
    _min?: SellItemBatchMinOrderByAggregateInput
    _sum?: SellItemBatchSumOrderByAggregateInput
  }

  export type SellItemBatchScalarWhereWithAggregatesInput = {
    AND?: SellItemBatchScalarWhereWithAggregatesInput | SellItemBatchScalarWhereWithAggregatesInput[]
    OR?: SellItemBatchScalarWhereWithAggregatesInput[]
    NOT?: SellItemBatchScalarWhereWithAggregatesInput | SellItemBatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SellItemBatch"> | string
    sellItemId?: StringWithAggregatesFilter<"SellItemBatch"> | string
    batchId?: StringWithAggregatesFilter<"SellItemBatch"> | string
    quantity?: IntWithAggregatesFilter<"SellItemBatch"> | number
  }

  export type AddToCartWhereInput = {
    AND?: AddToCartWhereInput | AddToCartWhereInput[]
    OR?: AddToCartWhereInput[]
    NOT?: AddToCartWhereInput | AddToCartWhereInput[]
    id?: StringFilter<"AddToCart"> | string
    userId?: StringFilter<"AddToCart"> | string
    branchId?: StringNullableFilter<"AddToCart"> | string | null
    isCheckedOut?: BoolFilter<"AddToCart"> | boolean
    isWaitlist?: BoolFilter<"AddToCart"> | boolean
    customerId?: StringNullableFilter<"AddToCart"> | string | null
    totalItems?: IntFilter<"AddToCart"> | number
    totalAmount?: FloatFilter<"AddToCart"> | number
    createdById?: StringNullableFilter<"AddToCart"> | string | null
    updatedById?: StringNullableFilter<"AddToCart"> | string | null
    createdAt?: DateTimeFilter<"AddToCart"> | Date | string
    updatedAt?: DateTimeFilter<"AddToCart"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: CartItemListRelationFilter
    waitlists?: WaitlistListRelationFilter
  }

  export type AddToCartOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    isCheckedOut?: SortOrder
    isWaitlist?: SortOrder
    customerId?: SortOrderInput | SortOrder
    totalItems?: SortOrder
    totalAmount?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
    items?: CartItemOrderByRelationAggregateInput
    waitlists?: WaitlistOrderByRelationAggregateInput
    _relevance?: AddToCartOrderByRelevanceInput
  }

  export type AddToCartWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AddToCartWhereInput | AddToCartWhereInput[]
    OR?: AddToCartWhereInput[]
    NOT?: AddToCartWhereInput | AddToCartWhereInput[]
    userId?: StringFilter<"AddToCart"> | string
    branchId?: StringNullableFilter<"AddToCart"> | string | null
    isCheckedOut?: BoolFilter<"AddToCart"> | boolean
    isWaitlist?: BoolFilter<"AddToCart"> | boolean
    customerId?: StringNullableFilter<"AddToCart"> | string | null
    totalItems?: IntFilter<"AddToCart"> | number
    totalAmount?: FloatFilter<"AddToCart"> | number
    createdById?: StringNullableFilter<"AddToCart"> | string | null
    updatedById?: StringNullableFilter<"AddToCart"> | string | null
    createdAt?: DateTimeFilter<"AddToCart"> | Date | string
    updatedAt?: DateTimeFilter<"AddToCart"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: CartItemListRelationFilter
    waitlists?: WaitlistListRelationFilter
  }, "id">

  export type AddToCartOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    isCheckedOut?: SortOrder
    isWaitlist?: SortOrder
    customerId?: SortOrderInput | SortOrder
    totalItems?: SortOrder
    totalAmount?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AddToCartCountOrderByAggregateInput
    _avg?: AddToCartAvgOrderByAggregateInput
    _max?: AddToCartMaxOrderByAggregateInput
    _min?: AddToCartMinOrderByAggregateInput
    _sum?: AddToCartSumOrderByAggregateInput
  }

  export type AddToCartScalarWhereWithAggregatesInput = {
    AND?: AddToCartScalarWhereWithAggregatesInput | AddToCartScalarWhereWithAggregatesInput[]
    OR?: AddToCartScalarWhereWithAggregatesInput[]
    NOT?: AddToCartScalarWhereWithAggregatesInput | AddToCartScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AddToCart"> | string
    userId?: StringWithAggregatesFilter<"AddToCart"> | string
    branchId?: StringNullableWithAggregatesFilter<"AddToCart"> | string | null
    isCheckedOut?: BoolWithAggregatesFilter<"AddToCart"> | boolean
    isWaitlist?: BoolWithAggregatesFilter<"AddToCart"> | boolean
    customerId?: StringNullableWithAggregatesFilter<"AddToCart"> | string | null
    totalItems?: IntWithAggregatesFilter<"AddToCart"> | number
    totalAmount?: FloatWithAggregatesFilter<"AddToCart"> | number
    createdById?: StringNullableWithAggregatesFilter<"AddToCart"> | string | null
    updatedById?: StringNullableWithAggregatesFilter<"AddToCart"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AddToCart"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AddToCart"> | Date | string
  }

  export type CartItemWhereInput = {
    AND?: CartItemWhereInput | CartItemWhereInput[]
    OR?: CartItemWhereInput[]
    NOT?: CartItemWhereInput | CartItemWhereInput[]
    id?: StringFilter<"CartItem"> | string
    cartId?: StringFilter<"CartItem"> | string
    isWaitlist?: BoolFilter<"CartItem"> | boolean
    shopId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    unitOfMeasureId?: StringNullableFilter<"CartItem"> | string | null
    quantity?: IntFilter<"CartItem"> | number
    unitPrice?: FloatFilter<"CartItem"> | number
    totalPrice?: FloatFilter<"CartItem"> | number
    notes?: StringNullableFilter<"CartItem"> | string | null
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
    cart?: XOR<AddToCartScalarRelationFilter, AddToCartWhereInput>
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    unitOfMeasure?: XOR<UnitOfMeasureNullableScalarRelationFilter, UnitOfMeasureWhereInput> | null
    waitlists?: WaitlistListRelationFilter
  }

  export type CartItemOrderByWithRelationInput = {
    id?: SortOrder
    cartId?: SortOrder
    isWaitlist?: SortOrder
    shopId?: SortOrder
    productId?: SortOrder
    unitOfMeasureId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cart?: AddToCartOrderByWithRelationInput
    shop?: ShopOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    unitOfMeasure?: UnitOfMeasureOrderByWithRelationInput
    waitlists?: WaitlistOrderByRelationAggregateInput
    _relevance?: CartItemOrderByRelevanceInput
  }

  export type CartItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CartItemWhereInput | CartItemWhereInput[]
    OR?: CartItemWhereInput[]
    NOT?: CartItemWhereInput | CartItemWhereInput[]
    cartId?: StringFilter<"CartItem"> | string
    isWaitlist?: BoolFilter<"CartItem"> | boolean
    shopId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    unitOfMeasureId?: StringNullableFilter<"CartItem"> | string | null
    quantity?: IntFilter<"CartItem"> | number
    unitPrice?: FloatFilter<"CartItem"> | number
    totalPrice?: FloatFilter<"CartItem"> | number
    notes?: StringNullableFilter<"CartItem"> | string | null
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
    cart?: XOR<AddToCartScalarRelationFilter, AddToCartWhereInput>
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    unitOfMeasure?: XOR<UnitOfMeasureNullableScalarRelationFilter, UnitOfMeasureWhereInput> | null
    waitlists?: WaitlistListRelationFilter
  }, "id">

  export type CartItemOrderByWithAggregationInput = {
    id?: SortOrder
    cartId?: SortOrder
    isWaitlist?: SortOrder
    shopId?: SortOrder
    productId?: SortOrder
    unitOfMeasureId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CartItemCountOrderByAggregateInput
    _avg?: CartItemAvgOrderByAggregateInput
    _max?: CartItemMaxOrderByAggregateInput
    _min?: CartItemMinOrderByAggregateInput
    _sum?: CartItemSumOrderByAggregateInput
  }

  export type CartItemScalarWhereWithAggregatesInput = {
    AND?: CartItemScalarWhereWithAggregatesInput | CartItemScalarWhereWithAggregatesInput[]
    OR?: CartItemScalarWhereWithAggregatesInput[]
    NOT?: CartItemScalarWhereWithAggregatesInput | CartItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CartItem"> | string
    cartId?: StringWithAggregatesFilter<"CartItem"> | string
    isWaitlist?: BoolWithAggregatesFilter<"CartItem"> | boolean
    shopId?: StringWithAggregatesFilter<"CartItem"> | string
    productId?: StringWithAggregatesFilter<"CartItem"> | string
    unitOfMeasureId?: StringNullableWithAggregatesFilter<"CartItem"> | string | null
    quantity?: IntWithAggregatesFilter<"CartItem"> | number
    unitPrice?: FloatWithAggregatesFilter<"CartItem"> | number
    totalPrice?: FloatWithAggregatesFilter<"CartItem"> | number
    notes?: StringNullableWithAggregatesFilter<"CartItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CartItem"> | Date | string
  }

  export type WaitlistWhereInput = {
    AND?: WaitlistWhereInput | WaitlistWhereInput[]
    OR?: WaitlistWhereInput[]
    NOT?: WaitlistWhereInput | WaitlistWhereInput[]
    id?: StringFilter<"Waitlist"> | string
    userId?: StringNullableFilter<"Waitlist"> | string | null
    customerId?: StringNullableFilter<"Waitlist"> | string | null
    branchId?: StringNullableFilter<"Waitlist"> | string | null
    cartId?: StringNullableFilter<"Waitlist"> | string | null
    cartItemId?: StringNullableFilter<"Waitlist"> | string | null
    productId?: StringNullableFilter<"Waitlist"> | string | null
    quantity?: IntFilter<"Waitlist"> | number
    note?: StringNullableFilter<"Waitlist"> | string | null
    shopId?: StringNullableFilter<"Waitlist"> | string | null
    createdById?: StringNullableFilter<"Waitlist"> | string | null
    updatedById?: StringNullableFilter<"Waitlist"> | string | null
    createdAt?: DateTimeFilter<"Waitlist"> | Date | string
    updatedAt?: DateTimeFilter<"Waitlist"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    cart?: XOR<AddToCartNullableScalarRelationFilter, AddToCartWhereInput> | null
    cartItem?: XOR<CartItemNullableScalarRelationFilter, CartItemWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type WaitlistOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    cartId?: SortOrderInput | SortOrder
    cartItemId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    note?: SortOrderInput | SortOrder
    shopId?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    cart?: AddToCartOrderByWithRelationInput
    cartItem?: CartItemOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    shop?: ShopOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
    _relevance?: WaitlistOrderByRelevanceInput
  }

  export type WaitlistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WaitlistWhereInput | WaitlistWhereInput[]
    OR?: WaitlistWhereInput[]
    NOT?: WaitlistWhereInput | WaitlistWhereInput[]
    userId?: StringNullableFilter<"Waitlist"> | string | null
    customerId?: StringNullableFilter<"Waitlist"> | string | null
    branchId?: StringNullableFilter<"Waitlist"> | string | null
    cartId?: StringNullableFilter<"Waitlist"> | string | null
    cartItemId?: StringNullableFilter<"Waitlist"> | string | null
    productId?: StringNullableFilter<"Waitlist"> | string | null
    quantity?: IntFilter<"Waitlist"> | number
    note?: StringNullableFilter<"Waitlist"> | string | null
    shopId?: StringNullableFilter<"Waitlist"> | string | null
    createdById?: StringNullableFilter<"Waitlist"> | string | null
    updatedById?: StringNullableFilter<"Waitlist"> | string | null
    createdAt?: DateTimeFilter<"Waitlist"> | Date | string
    updatedAt?: DateTimeFilter<"Waitlist"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    cart?: XOR<AddToCartNullableScalarRelationFilter, AddToCartWhereInput> | null
    cartItem?: XOR<CartItemNullableScalarRelationFilter, CartItemWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type WaitlistOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    cartId?: SortOrderInput | SortOrder
    cartItemId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    note?: SortOrderInput | SortOrder
    shopId?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WaitlistCountOrderByAggregateInput
    _avg?: WaitlistAvgOrderByAggregateInput
    _max?: WaitlistMaxOrderByAggregateInput
    _min?: WaitlistMinOrderByAggregateInput
    _sum?: WaitlistSumOrderByAggregateInput
  }

  export type WaitlistScalarWhereWithAggregatesInput = {
    AND?: WaitlistScalarWhereWithAggregatesInput | WaitlistScalarWhereWithAggregatesInput[]
    OR?: WaitlistScalarWhereWithAggregatesInput[]
    NOT?: WaitlistScalarWhereWithAggregatesInput | WaitlistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Waitlist"> | string
    userId?: StringNullableWithAggregatesFilter<"Waitlist"> | string | null
    customerId?: StringNullableWithAggregatesFilter<"Waitlist"> | string | null
    branchId?: StringNullableWithAggregatesFilter<"Waitlist"> | string | null
    cartId?: StringNullableWithAggregatesFilter<"Waitlist"> | string | null
    cartItemId?: StringNullableWithAggregatesFilter<"Waitlist"> | string | null
    productId?: StringNullableWithAggregatesFilter<"Waitlist"> | string | null
    quantity?: IntWithAggregatesFilter<"Waitlist"> | number
    note?: StringNullableWithAggregatesFilter<"Waitlist"> | string | null
    shopId?: StringNullableWithAggregatesFilter<"Waitlist"> | string | null
    createdById?: StringNullableWithAggregatesFilter<"Waitlist"> | string | null
    updatedById?: StringNullableWithAggregatesFilter<"Waitlist"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Waitlist"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Waitlist"> | Date | string
  }

  export type SellStockCorrectionWhereInput = {
    AND?: SellStockCorrectionWhereInput | SellStockCorrectionWhereInput[]
    OR?: SellStockCorrectionWhereInput[]
    NOT?: SellStockCorrectionWhereInput | SellStockCorrectionWhereInput[]
    id?: StringFilter<"SellStockCorrection"> | string
    sellId?: StringNullableFilter<"SellStockCorrection"> | string | null
    status?: EnumSellStockCorrectionStatusFilter<"SellStockCorrection"> | $Enums.SellStockCorrectionStatus
    reference?: StringNullableFilter<"SellStockCorrection"> | string | null
    notes?: StringNullableFilter<"SellStockCorrection"> | string | null
    createdById?: StringNullableFilter<"SellStockCorrection"> | string | null
    updatedById?: StringNullableFilter<"SellStockCorrection"> | string | null
    total?: FloatFilter<"SellStockCorrection"> | number
    createdAt?: DateTimeFilter<"SellStockCorrection"> | Date | string
    updatedAt?: DateTimeFilter<"SellStockCorrection"> | Date | string
    sell?: XOR<SellNullableScalarRelationFilter, SellWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: SellStockCorrectionItemListRelationFilter
  }

  export type SellStockCorrectionOrderByWithRelationInput = {
    id?: SortOrder
    sellId?: SortOrderInput | SortOrder
    status?: SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sell?: SellOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
    items?: SellStockCorrectionItemOrderByRelationAggregateInput
    _relevance?: SellStockCorrectionOrderByRelevanceInput
  }

  export type SellStockCorrectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SellStockCorrectionWhereInput | SellStockCorrectionWhereInput[]
    OR?: SellStockCorrectionWhereInput[]
    NOT?: SellStockCorrectionWhereInput | SellStockCorrectionWhereInput[]
    sellId?: StringNullableFilter<"SellStockCorrection"> | string | null
    status?: EnumSellStockCorrectionStatusFilter<"SellStockCorrection"> | $Enums.SellStockCorrectionStatus
    reference?: StringNullableFilter<"SellStockCorrection"> | string | null
    notes?: StringNullableFilter<"SellStockCorrection"> | string | null
    createdById?: StringNullableFilter<"SellStockCorrection"> | string | null
    updatedById?: StringNullableFilter<"SellStockCorrection"> | string | null
    total?: FloatFilter<"SellStockCorrection"> | number
    createdAt?: DateTimeFilter<"SellStockCorrection"> | Date | string
    updatedAt?: DateTimeFilter<"SellStockCorrection"> | Date | string
    sell?: XOR<SellNullableScalarRelationFilter, SellWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: SellStockCorrectionItemListRelationFilter
  }, "id">

  export type SellStockCorrectionOrderByWithAggregationInput = {
    id?: SortOrder
    sellId?: SortOrderInput | SortOrder
    status?: SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SellStockCorrectionCountOrderByAggregateInput
    _avg?: SellStockCorrectionAvgOrderByAggregateInput
    _max?: SellStockCorrectionMaxOrderByAggregateInput
    _min?: SellStockCorrectionMinOrderByAggregateInput
    _sum?: SellStockCorrectionSumOrderByAggregateInput
  }

  export type SellStockCorrectionScalarWhereWithAggregatesInput = {
    AND?: SellStockCorrectionScalarWhereWithAggregatesInput | SellStockCorrectionScalarWhereWithAggregatesInput[]
    OR?: SellStockCorrectionScalarWhereWithAggregatesInput[]
    NOT?: SellStockCorrectionScalarWhereWithAggregatesInput | SellStockCorrectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SellStockCorrection"> | string
    sellId?: StringNullableWithAggregatesFilter<"SellStockCorrection"> | string | null
    status?: EnumSellStockCorrectionStatusWithAggregatesFilter<"SellStockCorrection"> | $Enums.SellStockCorrectionStatus
    reference?: StringNullableWithAggregatesFilter<"SellStockCorrection"> | string | null
    notes?: StringNullableWithAggregatesFilter<"SellStockCorrection"> | string | null
    createdById?: StringNullableWithAggregatesFilter<"SellStockCorrection"> | string | null
    updatedById?: StringNullableWithAggregatesFilter<"SellStockCorrection"> | string | null
    total?: FloatWithAggregatesFilter<"SellStockCorrection"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SellStockCorrection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SellStockCorrection"> | Date | string
  }

  export type SellStockCorrectionItemWhereInput = {
    AND?: SellStockCorrectionItemWhereInput | SellStockCorrectionItemWhereInput[]
    OR?: SellStockCorrectionItemWhereInput[]
    NOT?: SellStockCorrectionItemWhereInput | SellStockCorrectionItemWhereInput[]
    id?: StringFilter<"SellStockCorrectionItem"> | string
    correctionId?: StringFilter<"SellStockCorrectionItem"> | string
    productId?: StringFilter<"SellStockCorrectionItem"> | string
    shopId?: StringNullableFilter<"SellStockCorrectionItem"> | string | null
    unitOfMeasureId?: StringFilter<"SellStockCorrectionItem"> | string
    quantity?: IntFilter<"SellStockCorrectionItem"> | number
    unitPrice?: FloatFilter<"SellStockCorrectionItem"> | number
    totalPrice?: FloatFilter<"SellStockCorrectionItem"> | number
    createdAt?: DateTimeFilter<"SellStockCorrectionItem"> | Date | string
    updatedAt?: DateTimeFilter<"SellStockCorrectionItem"> | Date | string
    correction?: XOR<SellStockCorrectionScalarRelationFilter, SellStockCorrectionWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
    unitOfMeasure?: XOR<UnitOfMeasureScalarRelationFilter, UnitOfMeasureWhereInput>
    batches?: SellStockCorrectionBatchListRelationFilter
  }

  export type SellStockCorrectionItemOrderByWithRelationInput = {
    id?: SortOrder
    correctionId?: SortOrder
    productId?: SortOrder
    shopId?: SortOrderInput | SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    correction?: SellStockCorrectionOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    shop?: ShopOrderByWithRelationInput
    unitOfMeasure?: UnitOfMeasureOrderByWithRelationInput
    batches?: SellStockCorrectionBatchOrderByRelationAggregateInput
    _relevance?: SellStockCorrectionItemOrderByRelevanceInput
  }

  export type SellStockCorrectionItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SellStockCorrectionItemWhereInput | SellStockCorrectionItemWhereInput[]
    OR?: SellStockCorrectionItemWhereInput[]
    NOT?: SellStockCorrectionItemWhereInput | SellStockCorrectionItemWhereInput[]
    correctionId?: StringFilter<"SellStockCorrectionItem"> | string
    productId?: StringFilter<"SellStockCorrectionItem"> | string
    shopId?: StringNullableFilter<"SellStockCorrectionItem"> | string | null
    unitOfMeasureId?: StringFilter<"SellStockCorrectionItem"> | string
    quantity?: IntFilter<"SellStockCorrectionItem"> | number
    unitPrice?: FloatFilter<"SellStockCorrectionItem"> | number
    totalPrice?: FloatFilter<"SellStockCorrectionItem"> | number
    createdAt?: DateTimeFilter<"SellStockCorrectionItem"> | Date | string
    updatedAt?: DateTimeFilter<"SellStockCorrectionItem"> | Date | string
    correction?: XOR<SellStockCorrectionScalarRelationFilter, SellStockCorrectionWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
    unitOfMeasure?: XOR<UnitOfMeasureScalarRelationFilter, UnitOfMeasureWhereInput>
    batches?: SellStockCorrectionBatchListRelationFilter
  }, "id">

  export type SellStockCorrectionItemOrderByWithAggregationInput = {
    id?: SortOrder
    correctionId?: SortOrder
    productId?: SortOrder
    shopId?: SortOrderInput | SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SellStockCorrectionItemCountOrderByAggregateInput
    _avg?: SellStockCorrectionItemAvgOrderByAggregateInput
    _max?: SellStockCorrectionItemMaxOrderByAggregateInput
    _min?: SellStockCorrectionItemMinOrderByAggregateInput
    _sum?: SellStockCorrectionItemSumOrderByAggregateInput
  }

  export type SellStockCorrectionItemScalarWhereWithAggregatesInput = {
    AND?: SellStockCorrectionItemScalarWhereWithAggregatesInput | SellStockCorrectionItemScalarWhereWithAggregatesInput[]
    OR?: SellStockCorrectionItemScalarWhereWithAggregatesInput[]
    NOT?: SellStockCorrectionItemScalarWhereWithAggregatesInput | SellStockCorrectionItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SellStockCorrectionItem"> | string
    correctionId?: StringWithAggregatesFilter<"SellStockCorrectionItem"> | string
    productId?: StringWithAggregatesFilter<"SellStockCorrectionItem"> | string
    shopId?: StringNullableWithAggregatesFilter<"SellStockCorrectionItem"> | string | null
    unitOfMeasureId?: StringWithAggregatesFilter<"SellStockCorrectionItem"> | string
    quantity?: IntWithAggregatesFilter<"SellStockCorrectionItem"> | number
    unitPrice?: FloatWithAggregatesFilter<"SellStockCorrectionItem"> | number
    totalPrice?: FloatWithAggregatesFilter<"SellStockCorrectionItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SellStockCorrectionItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SellStockCorrectionItem"> | Date | string
  }

  export type SellStockCorrectionBatchWhereInput = {
    AND?: SellStockCorrectionBatchWhereInput | SellStockCorrectionBatchWhereInput[]
    OR?: SellStockCorrectionBatchWhereInput[]
    NOT?: SellStockCorrectionBatchWhereInput | SellStockCorrectionBatchWhereInput[]
    id?: StringFilter<"SellStockCorrectionBatch"> | string
    correctionItemId?: StringFilter<"SellStockCorrectionBatch"> | string
    batchId?: StringFilter<"SellStockCorrectionBatch"> | string
    quantity?: IntFilter<"SellStockCorrectionBatch"> | number
    correctionItem?: XOR<SellStockCorrectionItemScalarRelationFilter, SellStockCorrectionItemWhereInput>
    batch?: XOR<ProductBatchScalarRelationFilter, ProductBatchWhereInput>
  }

  export type SellStockCorrectionBatchOrderByWithRelationInput = {
    id?: SortOrder
    correctionItemId?: SortOrder
    batchId?: SortOrder
    quantity?: SortOrder
    correctionItem?: SellStockCorrectionItemOrderByWithRelationInput
    batch?: ProductBatchOrderByWithRelationInput
    _relevance?: SellStockCorrectionBatchOrderByRelevanceInput
  }

  export type SellStockCorrectionBatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    correctionItemId_batchId?: SellStockCorrectionBatchCorrectionItemIdBatchIdCompoundUniqueInput
    AND?: SellStockCorrectionBatchWhereInput | SellStockCorrectionBatchWhereInput[]
    OR?: SellStockCorrectionBatchWhereInput[]
    NOT?: SellStockCorrectionBatchWhereInput | SellStockCorrectionBatchWhereInput[]
    correctionItemId?: StringFilter<"SellStockCorrectionBatch"> | string
    batchId?: StringFilter<"SellStockCorrectionBatch"> | string
    quantity?: IntFilter<"SellStockCorrectionBatch"> | number
    correctionItem?: XOR<SellStockCorrectionItemScalarRelationFilter, SellStockCorrectionItemWhereInput>
    batch?: XOR<ProductBatchScalarRelationFilter, ProductBatchWhereInput>
  }, "id" | "correctionItemId_batchId">

  export type SellStockCorrectionBatchOrderByWithAggregationInput = {
    id?: SortOrder
    correctionItemId?: SortOrder
    batchId?: SortOrder
    quantity?: SortOrder
    _count?: SellStockCorrectionBatchCountOrderByAggregateInput
    _avg?: SellStockCorrectionBatchAvgOrderByAggregateInput
    _max?: SellStockCorrectionBatchMaxOrderByAggregateInput
    _min?: SellStockCorrectionBatchMinOrderByAggregateInput
    _sum?: SellStockCorrectionBatchSumOrderByAggregateInput
  }

  export type SellStockCorrectionBatchScalarWhereWithAggregatesInput = {
    AND?: SellStockCorrectionBatchScalarWhereWithAggregatesInput | SellStockCorrectionBatchScalarWhereWithAggregatesInput[]
    OR?: SellStockCorrectionBatchScalarWhereWithAggregatesInput[]
    NOT?: SellStockCorrectionBatchScalarWhereWithAggregatesInput | SellStockCorrectionBatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SellStockCorrectionBatch"> | string
    correctionItemId?: StringWithAggregatesFilter<"SellStockCorrectionBatch"> | string
    batchId?: StringWithAggregatesFilter<"SellStockCorrectionBatch"> | string
    quantity?: IntWithAggregatesFilter<"SellStockCorrectionBatch"> | number
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    read?: BoolFilter<"Notification"> | boolean
    relatedEntityType?: EnumRelatedEntityTypeNullableFilter<"Notification"> | $Enums.RelatedEntityType | null
    relatedEntityId?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    storeId?: StringNullableFilter<"Notification"> | string | null
    shopId?: StringNullableFilter<"Notification"> | string | null
    store?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
    shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    relatedEntityType?: SortOrderInput | SortOrder
    relatedEntityId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    storeId?: SortOrderInput | SortOrder
    shopId?: SortOrderInput | SortOrder
    store?: StoreOrderByWithRelationInput
    shop?: ShopOrderByWithRelationInput
    _relevance?: NotificationOrderByRelevanceInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    read?: BoolFilter<"Notification"> | boolean
    relatedEntityType?: EnumRelatedEntityTypeNullableFilter<"Notification"> | $Enums.RelatedEntityType | null
    relatedEntityId?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    storeId?: StringNullableFilter<"Notification"> | string | null
    shopId?: StringNullableFilter<"Notification"> | string | null
    store?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
    shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    relatedEntityType?: SortOrderInput | SortOrder
    relatedEntityId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    storeId?: SortOrderInput | SortOrder
    shopId?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    relatedEntityType?: EnumRelatedEntityTypeNullableWithAggregatesFilter<"Notification"> | $Enums.RelatedEntityType | null
    relatedEntityId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    storeId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    shopId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
  }

  export type UserCreateInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    branch?: BranchCreateNestedOneWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    shops?: ShopCreateNestedManyWithoutUserInput
    stores?: StoreCreateNestedManyWithoutUserInput
    Log?: LogCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionCreateNestedManyWithoutUpdatedByInput
    Sell?: SellCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    branchId?: string | null
    roleId: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    shops?: ShopUncheckedCreateNestedManyWithoutUserInput
    stores?: StoreUncheckedCreateNestedManyWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseUncheckedCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferUncheckedCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    Sell?: SellUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellUncheckedCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartUncheckedCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartUncheckedCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistUncheckedCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: BranchUpdateOneWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    shops?: ShopUpdateManyWithoutUserNestedInput
    stores?: StoreUpdateManyWithoutUserNestedInput
    Log?: LogUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shops?: ShopUncheckedUpdateManyWithoutUserNestedInput
    stores?: StoreUncheckedUpdateManyWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUncheckedUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUncheckedUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUncheckedUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUncheckedUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUncheckedUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUncheckedUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    branchId?: string | null
    roleId: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    permission: PermissionCreateNestedOneWithoutRolesInput
    role: RoleCreateNestedOneWithoutPermissionsInput
  }

  export type RolePermissionUncheckedCreateInput = {
    id?: string
    roleId: string
    permissionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolePermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyInput = {
    id?: string
    roleId: string
    permissionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolePermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    description?: string | null
    tinAddress?: string | null
    TIN?: string | null
    From?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    description?: string | null
    tinAddress?: string | null
    TIN?: string | null
    From?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tinAddress?: NullableStringFieldUpdateOperationsInput | string | null
    TIN?: NullableStringFieldUpdateOperationsInput | string | null
    From?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tinAddress?: NullableStringFieldUpdateOperationsInput | string | null
    TIN?: NullableStringFieldUpdateOperationsInput | string | null
    From?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    description?: string | null
    tinAddress?: string | null
    TIN?: string | null
    From?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tinAddress?: NullableStringFieldUpdateOperationsInput | string | null
    TIN?: NullableStringFieldUpdateOperationsInput | string | null
    From?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tinAddress?: NullableStringFieldUpdateOperationsInput | string | null
    TIN?: NullableStringFieldUpdateOperationsInput | string | null
    From?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchCreateInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Shop?: ShopCreateNestedManyWithoutBranchInput
    Store?: StoreCreateNestedManyWithoutBranchInput
    User?: UserCreateNestedManyWithoutBranchInput
    Sell?: SellCreateNestedManyWithoutBranchInput
    AddToCart?: AddToCartCreateNestedManyWithoutBranchInput
    waitlists?: WaitlistCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Shop?: ShopUncheckedCreateNestedManyWithoutBranchInput
    Store?: StoreUncheckedCreateNestedManyWithoutBranchInput
    User?: UserUncheckedCreateNestedManyWithoutBranchInput
    Sell?: SellUncheckedCreateNestedManyWithoutBranchInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutBranchInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Shop?: ShopUpdateManyWithoutBranchNestedInput
    Store?: StoreUpdateManyWithoutBranchNestedInput
    User?: UserUpdateManyWithoutBranchNestedInput
    Sell?: SellUpdateManyWithoutBranchNestedInput
    AddToCart?: AddToCartUpdateManyWithoutBranchNestedInput
    waitlists?: WaitlistUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Shop?: ShopUncheckedUpdateManyWithoutBranchNestedInput
    Store?: StoreUncheckedUpdateManyWithoutBranchNestedInput
    User?: UserUncheckedUpdateManyWithoutBranchNestedInput
    Sell?: SellUncheckedUpdateManyWithoutBranchNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutBranchNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateManyInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutShopInput
    ShopStock?: ShopStockCreateNestedManyWithoutShopInput
    StockLedger?: StockLedgerCreateNestedManyWithoutShopInput
    SourceTransfer?: TransferCreateNestedManyWithoutSourceShopInput
    DestinatTransfer?: TransferCreateNestedManyWithoutDestShopInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutShopInput
    AdditionalPrice?: AdditionalPriceCreateNestedManyWithoutShopInput
    SellItem?: SellItemCreateNestedManyWithoutShopInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutShopInput
    User?: UserCreateNestedManyWithoutShopsInput
    CartItem?: CartItemCreateNestedManyWithoutShopInput
    waitlists?: WaitlistCreateNestedManyWithoutShopInput
    notifications?: NotificationCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateInput = {
    id?: string
    name: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutShopInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutShopInput
    SourceTransfer?: TransferUncheckedCreateNestedManyWithoutSourceShopInput
    DestinatTransfer?: TransferUncheckedCreateNestedManyWithoutDestShopInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutShopInput
    AdditionalPrice?: AdditionalPriceUncheckedCreateNestedManyWithoutShopInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutShopInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutShopInput
    User?: UserUncheckedCreateNestedManyWithoutShopsInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutShopInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutShopInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutShopNestedInput
    ShopStock?: ShopStockUpdateManyWithoutShopNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutShopNestedInput
    SourceTransfer?: TransferUpdateManyWithoutSourceShopNestedInput
    DestinatTransfer?: TransferUpdateManyWithoutDestShopNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutShopNestedInput
    AdditionalPrice?: AdditionalPriceUpdateManyWithoutShopNestedInput
    SellItem?: SellItemUpdateManyWithoutShopNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutShopNestedInput
    User?: UserUpdateManyWithoutShopsNestedInput
    CartItem?: CartItemUpdateManyWithoutShopNestedInput
    waitlists?: WaitlistUpdateManyWithoutShopNestedInput
    notifications?: NotificationUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopStock?: ShopStockUncheckedUpdateManyWithoutShopNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutShopNestedInput
    SourceTransfer?: TransferUncheckedUpdateManyWithoutSourceShopNestedInput
    DestinatTransfer?: TransferUncheckedUpdateManyWithoutDestShopNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutShopNestedInput
    AdditionalPrice?: AdditionalPriceUncheckedUpdateManyWithoutShopNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutShopNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutShopNestedInput
    User?: UserUncheckedUpdateManyWithoutShopsNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutShopNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutShopNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ShopCreateManyInput = {
    id?: string
    name: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutStoreInput
    ProductBatch?: ProductBatchCreateNestedManyWithoutStoreInput
    StoreStock?: StoreStockCreateNestedManyWithoutStoreInput
    StockLedger?: StockLedgerCreateNestedManyWithoutStoreInput
    Purchase?: PurchaseCreateNestedManyWithoutStoreInput
    SourceTransfer?: TransferCreateNestedManyWithoutSourceStoreInput
    DestinatTransfer?: TransferCreateNestedManyWithoutDestStoreInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutStoreInput
    User?: UserCreateNestedManyWithoutStoresInput
    notifications?: NotificationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateInput = {
    id?: string
    name: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ProductBatch?: ProductBatchUncheckedCreateNestedManyWithoutStoreInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutStoreInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutStoreInput
    Purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    SourceTransfer?: TransferUncheckedCreateNestedManyWithoutSourceStoreInput
    DestinatTransfer?: TransferUncheckedCreateNestedManyWithoutDestStoreInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutStoreInput
    User?: UserUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStoreNestedInput
    ProductBatch?: ProductBatchUpdateManyWithoutStoreNestedInput
    StoreStock?: StoreStockUpdateManyWithoutStoreNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutStoreNestedInput
    Purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    SourceTransfer?: TransferUpdateManyWithoutSourceStoreNestedInput
    DestinatTransfer?: TransferUpdateManyWithoutDestStoreNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutStoreNestedInput
    User?: UserUpdateManyWithoutStoresNestedInput
    notifications?: NotificationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductBatch?: ProductBatchUncheckedUpdateManyWithoutStoreNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutStoreNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutStoreNestedInput
    Purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    SourceTransfer?: TransferUncheckedUpdateManyWithoutSourceStoreNestedInput
    DestinatTransfer?: TransferUncheckedUpdateManyWithoutDestStoreNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutStoreNestedInput
    User?: UserUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreCreateManyInput = {
    id?: string
    name: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreStockCreateInput = {
    id?: string
    quantity: number
    status?: $Enums.StockStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutStoreStockInput
    batch: ProductBatchCreateNestedOneWithoutStoreStockInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutStoreStockInput
  }

  export type StoreStockUncheckedCreateInput = {
    id?: string
    storeId: string
    batchId: string
    quantity: number
    status?: $Enums.StockStatus
    unitOfMeasureId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreStockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutStoreStockNestedInput
    batch?: ProductBatchUpdateOneRequiredWithoutStoreStockNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutStoreStockNestedInput
  }

  export type StoreStockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreStockCreateManyInput = {
    id?: string
    storeId: string
    batchId: string
    quantity: number
    status?: $Enums.StockStatus
    unitOfMeasureId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreStockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreStockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopStockCreateInput = {
    id?: string
    quantity: number
    status?: $Enums.StockStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    shop: ShopCreateNestedOneWithoutShopStockInput
    batch: ProductBatchCreateNestedOneWithoutShopStockInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutShopStockInput
  }

  export type ShopStockUncheckedCreateInput = {
    id?: string
    shopId: string
    batchId: string
    unitOfMeasureId: string
    quantity: number
    status?: $Enums.StockStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopStockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shop?: ShopUpdateOneRequiredWithoutShopStockNestedInput
    batch?: ProductBatchUpdateOneRequiredWithoutShopStockNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutShopStockNestedInput
  }

  export type ShopStockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopStockCreateManyInput = {
    id?: string
    shopId: string
    batchId: string
    unitOfMeasureId: string
    quantity: number
    status?: $Enums.StockStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopStockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopStockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLedgerCreateInput = {
    id?: string
    invoiceNo?: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    reference?: string | null
    notes?: string | null
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    batch: ProductBatchCreateNestedOneWithoutStockLedgerInput
    store?: StoreCreateNestedOneWithoutStockLedgerInput
    shop?: ShopCreateNestedOneWithoutStockLedgerInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutStockLedgerInput
    user?: UserCreateNestedOneWithoutStockLedgerInput
  }

  export type StockLedgerUncheckedCreateInput = {
    id?: string
    invoiceNo?: string | null
    batchId: string
    storeId?: string | null
    shopId?: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    unitOfMeasureId: string
    reference?: string | null
    userId?: string | null
    notes?: string | null
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockLedgerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: ProductBatchUpdateOneRequiredWithoutStockLedgerNestedInput
    store?: StoreUpdateOneWithoutStockLedgerNestedInput
    shop?: ShopUpdateOneWithoutStockLedgerNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutStockLedgerNestedInput
    user?: UserUpdateOneWithoutStockLedgerNestedInput
  }

  export type StockLedgerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    batchId?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLedgerCreateManyInput = {
    id?: string
    invoiceNo?: string | null
    batchId: string
    storeId?: string | null
    shopId?: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    unitOfMeasureId: string
    reference?: string | null
    userId?: string | null
    notes?: string | null
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockLedgerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLedgerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    batchId?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogCreateInput = {
    id?: string
    action: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutLogInput
  }

  export type LogUncheckedCreateInput = {
    id?: string
    action: string
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutLogNestedInput
  }

  export type LogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogCreateManyInput = {
    id?: string
    action: string
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    name: string
    companyName?: string | null
    phone1: string
    phone2?: string | null
    tinNumber?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Sell?: SellCreateNestedManyWithoutCustomerInput
    AddToCart?: AddToCartCreateNestedManyWithoutCustomerInput
    waitlists?: WaitlistCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    name: string
    companyName?: string | null
    phone1: string
    phone2?: string | null
    tinNumber?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Sell?: SellUncheckedCreateNestedManyWithoutCustomerInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutCustomerInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    phone1?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    tinNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Sell?: SellUpdateManyWithoutCustomerNestedInput
    AddToCart?: AddToCartUpdateManyWithoutCustomerNestedInput
    waitlists?: WaitlistUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    phone1?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    tinNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Sell?: SellUncheckedUpdateManyWithoutCustomerNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutCustomerNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    name: string
    companyName?: string | null
    phone1: string
    phone2?: string | null
    tinNumber?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    phone1?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    tinNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    phone1?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    tinNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierCreateInput = {
    id?: string
    name: string
    contactName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    tinNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Purchase?: PurchaseCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: string
    name: string
    contactName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    tinNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Purchase?: PurchaseUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    tinNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Purchase?: PurchaseUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    tinNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Purchase?: PurchaseUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id?: string
    name: string
    contactName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    tinNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    tinNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    tinNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutCategoryInput
    subCategories?: SubCategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
    subCategories?: SubCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutCategoryNestedInput
    subCategories?: SubCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
    subCategories?: SubCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubCategoryCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutSubCategoriesInput
    products?: ProductCreateNestedManyWithoutSubCategoryInput
  }

  export type SubCategoryUncheckedCreateInput = {
    id?: string
    name: string
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutSubCategoryInput
  }

  export type SubCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutSubCategoriesNestedInput
    products?: ProductUpdateManyWithoutSubCategoryNestedInput
  }

  export type SubCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutSubCategoryNestedInput
  }

  export type SubCategoryCreateManyInput = {
    id?: string
    name: string
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    subCategory?: SubCategoryCreateNestedOneWithoutProductsInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutProductsInput
    batches?: ProductBatchCreateNestedManyWithoutProductInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutProductInput
    TransferItem?: TransferItemCreateNestedManyWithoutProductInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutProductInput
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    AdditionalPrice?: AdditionalPriceCreateNestedManyWithoutProductInput
    SellItem?: SellItemCreateNestedManyWithoutProductInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutProductInput
    waitlists?: WaitlistCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    categoryId: string
    subCategoryId?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    unitOfMeasureId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: ProductBatchUncheckedCreateNestedManyWithoutProductInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutProductInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutProductInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    AdditionalPrice?: AdditionalPriceUncheckedCreateNestedManyWithoutProductInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutProductInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutProductInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    subCategory?: SubCategoryUpdateOneWithoutProductsNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutProductsNestedInput
    batches?: ProductBatchUpdateManyWithoutProductNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutProductNestedInput
    TransferItem?: TransferItemUpdateManyWithoutProductNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    AdditionalPrice?: AdditionalPriceUpdateManyWithoutProductNestedInput
    SellItem?: SellItemUpdateManyWithoutProductNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutProductNestedInput
    waitlists?: WaitlistUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    subCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: ProductBatchUncheckedUpdateManyWithoutProductNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    AdditionalPrice?: AdditionalPriceUncheckedUpdateManyWithoutProductNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutProductNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutProductNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    categoryId: string
    subCategoryId?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    unitOfMeasureId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    subCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdditionalPriceCreateInput = {
    id?: string
    label?: string | null
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutAdditionalPriceInput
    shop?: ShopCreateNestedOneWithoutAdditionalPriceInput
  }

  export type AdditionalPriceUncheckedCreateInput = {
    id?: string
    label?: string | null
    price: number
    productId: string
    shopId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdditionalPriceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutAdditionalPriceNestedInput
    shop?: ShopUpdateOneWithoutAdditionalPriceNestedInput
  }

  export type AdditionalPriceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdditionalPriceCreateManyInput = {
    id?: string
    label?: string | null
    price: number
    productId: string
    shopId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdditionalPriceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdditionalPriceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductBatchCreateInput = {
    id?: string
    batchNumber: string
    expiryDate?: Date | string | null
    price?: number | null
    stock?: number | null
    warningQuantity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store?: StoreCreateNestedOneWithoutProductBatchInput
    product: ProductCreateNestedOneWithoutBatchesInput
    ShopStock?: ShopStockCreateNestedManyWithoutBatchInput
    StoreStock?: StoreStockCreateNestedManyWithoutBatchInput
    StockLedger?: StockLedgerCreateNestedManyWithoutBatchInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutBatchInput
    TransferItem?: TransferItemCreateNestedManyWithoutBatchInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutBatchInput
    SellItemBatch?: SellItemBatchCreateNestedManyWithoutBatchInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchCreateNestedManyWithoutBatchInput
  }

  export type ProductBatchUncheckedCreateInput = {
    id?: string
    batchNumber: string
    expiryDate?: Date | string | null
    productId: string
    price?: number | null
    stock?: number | null
    warningQuantity?: number | null
    storeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutBatchInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutBatchInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutBatchInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutBatchInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutBatchInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutBatchInput
    SellItemBatch?: SellItemBatchUncheckedCreateNestedManyWithoutBatchInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUncheckedCreateNestedManyWithoutBatchInput
  }

  export type ProductBatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    warningQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneWithoutProductBatchNestedInput
    product?: ProductUpdateOneRequiredWithoutBatchesNestedInput
    ShopStock?: ShopStockUpdateManyWithoutBatchNestedInput
    StoreStock?: StoreStockUpdateManyWithoutBatchNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutBatchNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutBatchNestedInput
    TransferItem?: TransferItemUpdateManyWithoutBatchNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutBatchNestedInput
    SellItemBatch?: SellItemBatchUpdateManyWithoutBatchNestedInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUpdateManyWithoutBatchNestedInput
  }

  export type ProductBatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productId?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    warningQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopStock?: ShopStockUncheckedUpdateManyWithoutBatchNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutBatchNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutBatchNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutBatchNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutBatchNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutBatchNestedInput
    SellItemBatch?: SellItemBatchUncheckedUpdateManyWithoutBatchNestedInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type ProductBatchCreateManyInput = {
    id?: string
    batchNumber: string
    expiryDate?: Date | string | null
    productId: string
    price?: number | null
    stock?: number | null
    warningQuantity?: number | null
    storeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductBatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    warningQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductBatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productId?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    warningQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitOfMeasureCreateInput = {
    id?: string
    name: string
    symbol?: string | null
    base?: boolean
    products?: ProductCreateNestedManyWithoutUnitOfMeasureInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutUnitOfMeasureInput
    TransferItem?: TransferItemCreateNestedManyWithoutUnitOfMeasureInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUnitOfMeasureInput
    ShopStock?: ShopStockCreateNestedManyWithoutUnitOfMeasureInput
    StoreStock?: StoreStockCreateNestedManyWithoutUnitOfMeasureInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutUnitOfMeasureInput
    SellItem?: SellItemCreateNestedManyWithoutUnitOfMeasureInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutUnitOfMeasureInput
    CartItem?: CartItemCreateNestedManyWithoutUnitOfMeasureInput
  }

  export type UnitOfMeasureUncheckedCreateInput = {
    id?: string
    name: string
    symbol?: string | null
    base?: boolean
    products?: ProductUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
  }

  export type UnitOfMeasureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    base?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductUpdateManyWithoutUnitOfMeasureNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutUnitOfMeasureNestedInput
    TransferItem?: TransferItemUpdateManyWithoutUnitOfMeasureNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUnitOfMeasureNestedInput
    ShopStock?: ShopStockUpdateManyWithoutUnitOfMeasureNestedInput
    StoreStock?: StoreStockUpdateManyWithoutUnitOfMeasureNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutUnitOfMeasureNestedInput
    SellItem?: SellItemUpdateManyWithoutUnitOfMeasureNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutUnitOfMeasureNestedInput
    CartItem?: CartItemUpdateManyWithoutUnitOfMeasureNestedInput
  }

  export type UnitOfMeasureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    base?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    ShopStock?: ShopStockUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
  }

  export type UnitOfMeasureCreateManyInput = {
    id?: string
    name: string
    symbol?: string | null
    base?: boolean
  }

  export type UnitOfMeasureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    base?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UnitOfMeasureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    base?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PurchaseCreateInput = {
    id?: string
    invoiceNo: string
    paymentStatus?: $Enums.PaymentStatus
    totalProducts?: number
    subTotal?: number
    grandTotal?: number
    notes?: string | null
    purchaseDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutPurchaseInput
    store: StoreCreateNestedOneWithoutPurchaseInput
    createdBy?: UserCreateNestedOneWithoutCreatorPurchaseInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedPurchaseInput
    items?: PurchaseItemCreateNestedManyWithoutPurchaseInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateInput = {
    id?: string
    invoiceNo: string
    supplierId: string
    storeId: string
    paymentStatus?: $Enums.PaymentStatus
    totalProducts?: number
    subTotal?: number
    grandTotal?: number
    notes?: string | null
    purchaseDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseItemUncheckedCreateNestedManyWithoutPurchaseInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseNestedInput
    store?: StoreUpdateOneRequiredWithoutPurchaseNestedInput
    createdBy?: UserUpdateOneWithoutCreatorPurchaseNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedPurchaseNestedInput
    items?: PurchaseItemUpdateManyWithoutPurchaseNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseItemUncheckedUpdateManyWithoutPurchaseNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseCreateManyInput = {
    id?: string
    invoiceNo: string
    supplierId: string
    storeId: string
    paymentStatus?: $Enums.PaymentStatus
    totalProducts?: number
    subTotal?: number
    grandTotal?: number
    notes?: string | null
    purchaseDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemCreateInput = {
    id?: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchase: PurchaseCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutPurchaseItemInput
    batch: ProductBatchCreateNestedOneWithoutPurchaseItemInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutPurchaseItemInput
  }

  export type PurchaseItemUncheckedCreateInput = {
    id?: string
    purchaseId: string
    productId: string
    batchId: string
    unitOfMeasureId: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchaseItemNestedInput
    batch?: ProductBatchUpdateOneRequiredWithoutPurchaseItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutPurchaseItemNestedInput
  }

  export type PurchaseItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemCreateManyInput = {
    id?: string
    purchaseId: string
    productId: string
    batchId: string
    unitOfMeasureId: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferCreateInput = {
    id?: string
    shortCode: string
    sourceType: $Enums.TransferEntityType
    destinationType: $Enums.TransferEntityType
    reference?: string | null
    notes?: string | null
    status?: $Enums.TransferStatus
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceStore?: StoreCreateNestedOneWithoutSourceTransferInput
    sourceShop?: ShopCreateNestedOneWithoutSourceTransferInput
    destStore?: StoreCreateNestedOneWithoutDestinatTransferInput
    destShop?: ShopCreateNestedOneWithoutDestinatTransferInput
    createdBy?: UserCreateNestedOneWithoutCreatedTransferInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedTransferInput
    items?: TransferItemCreateNestedManyWithoutTransferInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateInput = {
    id?: string
    shortCode: string
    sourceType: $Enums.TransferEntityType
    sourceStoreId?: string | null
    sourceShopId?: string | null
    destinationType: $Enums.TransferEntityType
    destStoreId?: string | null
    destShopId?: string | null
    reference?: string | null
    notes?: string | null
    status?: $Enums.TransferStatus
    movementDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferItemUncheckedCreateNestedManyWithoutTransferInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    destinationType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceStore?: StoreUpdateOneWithoutSourceTransferNestedInput
    sourceShop?: ShopUpdateOneWithoutSourceTransferNestedInput
    destStore?: StoreUpdateOneWithoutDestinatTransferNestedInput
    destShop?: ShopUpdateOneWithoutDestinatTransferNestedInput
    createdBy?: UserUpdateOneWithoutCreatedTransferNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedTransferNestedInput
    items?: TransferItemUpdateManyWithoutTransferNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceShopId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    destStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destShopId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferItemUncheckedUpdateManyWithoutTransferNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferCreateManyInput = {
    id?: string
    shortCode: string
    sourceType: $Enums.TransferEntityType
    sourceStoreId?: string | null
    sourceShopId?: string | null
    destinationType: $Enums.TransferEntityType
    destStoreId?: string | null
    destShopId?: string | null
    reference?: string | null
    notes?: string | null
    status?: $Enums.TransferStatus
    movementDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    destinationType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceShopId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    destStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destShopId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemCreateInput = {
    id?: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transfer: TransferCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutTransferItemInput
    batch: ProductBatchCreateNestedOneWithoutTransferItemInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutTransferItemInput
  }

  export type TransferItemUncheckedCreateInput = {
    id?: string
    transferId: string
    productId: string
    batchId: string
    unitOfMeasureId: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transfer?: TransferUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutTransferItemNestedInput
    batch?: ProductBatchUpdateOneRequiredWithoutTransferItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutTransferItemNestedInput
  }

  export type TransferItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemCreateManyInput = {
    id?: string
    transferId: string
    productId: string
    batchId: string
    unitOfMeasureId: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCorrectionCreateInput = {
    id?: string
    shortCode: string
    reason: $Enums.StockCorrectionReason
    status?: $Enums.StockCorrectionStatus
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store?: StoreCreateNestedOneWithoutStockCorrectionInput
    shop?: ShopCreateNestedOneWithoutStockCorrectionInput
    purchase?: PurchaseCreateNestedOneWithoutStockCorrectionInput
    transfer?: TransferCreateNestedOneWithoutStockCorrectionInput
    createdBy?: UserCreateNestedOneWithoutStockCorrectionInput
    updatedBy?: UserCreateNestedOneWithoutUpdateStockCorrectionInput
    items?: StockCorrectionItemCreateNestedManyWithoutCorrectionInput
  }

  export type StockCorrectionUncheckedCreateInput = {
    id?: string
    shortCode: string
    storeId?: string | null
    shopId?: string | null
    reason: $Enums.StockCorrectionReason
    status?: $Enums.StockCorrectionStatus
    purchaseId?: string | null
    transferId?: string | null
    reference?: string | null
    notes?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: StockCorrectionItemUncheckedCreateNestedManyWithoutCorrectionInput
  }

  export type StockCorrectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    reason?: EnumStockCorrectionReasonFieldUpdateOperationsInput | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFieldUpdateOperationsInput | $Enums.StockCorrectionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneWithoutStockCorrectionNestedInput
    shop?: ShopUpdateOneWithoutStockCorrectionNestedInput
    purchase?: PurchaseUpdateOneWithoutStockCorrectionNestedInput
    transfer?: TransferUpdateOneWithoutStockCorrectionNestedInput
    createdBy?: UserUpdateOneWithoutStockCorrectionNestedInput
    updatedBy?: UserUpdateOneWithoutUpdateStockCorrectionNestedInput
    items?: StockCorrectionItemUpdateManyWithoutCorrectionNestedInput
  }

  export type StockCorrectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: EnumStockCorrectionReasonFieldUpdateOperationsInput | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFieldUpdateOperationsInput | $Enums.StockCorrectionStatus
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    transferId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: StockCorrectionItemUncheckedUpdateManyWithoutCorrectionNestedInput
  }

  export type StockCorrectionCreateManyInput = {
    id?: string
    shortCode: string
    storeId?: string | null
    shopId?: string | null
    reason: $Enums.StockCorrectionReason
    status?: $Enums.StockCorrectionStatus
    purchaseId?: string | null
    transferId?: string | null
    reference?: string | null
    notes?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockCorrectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    reason?: EnumStockCorrectionReasonFieldUpdateOperationsInput | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFieldUpdateOperationsInput | $Enums.StockCorrectionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCorrectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: EnumStockCorrectionReasonFieldUpdateOperationsInput | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFieldUpdateOperationsInput | $Enums.StockCorrectionStatus
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    transferId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCorrectionItemCreateInput = {
    id?: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    correction: StockCorrectionCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutStockCorrectionItemInput
    batch?: ProductBatchCreateNestedOneWithoutStockCorrectionItemInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutStockCorrectionItemInput
  }

  export type StockCorrectionItemUncheckedCreateInput = {
    id?: string
    correctionId: string
    productId: string
    batchId?: string | null
    unitOfMeasureId: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockCorrectionItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    correction?: StockCorrectionUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutStockCorrectionItemNestedInput
    batch?: ProductBatchUpdateOneWithoutStockCorrectionItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutStockCorrectionItemNestedInput
  }

  export type StockCorrectionItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    correctionId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCorrectionItemCreateManyInput = {
    id?: string
    correctionId: string
    productId: string
    batchId?: string | null
    unitOfMeasureId: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockCorrectionItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCorrectionItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    correctionId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellCreateInput = {
    id?: string
    invoiceNo: string
    saleStatus?: $Enums.SaleStatus
    locked?: boolean
    lockedAt?: Date | string | null
    totalProducts?: number
    subTotal?: number
    discount?: number
    vat?: number
    grandTotal?: number
    NetTotal?: number
    notes?: string | null
    saleDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutSellInput
    customer?: CustomerCreateNestedOneWithoutSellInput
    createdBy?: UserCreateNestedOneWithoutSellInput
    updatedBy?: UserCreateNestedOneWithoutUpdateSellInput
    items?: SellItemCreateNestedManyWithoutSellInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutSellInput
  }

  export type SellUncheckedCreateInput = {
    id?: string
    invoiceNo: string
    saleStatus?: $Enums.SaleStatus
    locked?: boolean
    lockedAt?: Date | string | null
    branchId?: string | null
    customerId?: string | null
    totalProducts?: number
    subTotal?: number
    discount?: number
    vat?: number
    grandTotal?: number
    NetTotal?: number
    notes?: string | null
    saleDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SellItemUncheckedCreateNestedManyWithoutSellInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutSellInput
  }

  export type SellUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleStatus?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    locked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutSellNestedInput
    customer?: CustomerUpdateOneWithoutSellNestedInput
    createdBy?: UserUpdateOneWithoutSellNestedInput
    updatedBy?: UserUpdateOneWithoutUpdateSellNestedInput
    items?: SellItemUpdateManyWithoutSellNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutSellNestedInput
  }

  export type SellUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleStatus?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    locked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SellItemUncheckedUpdateManyWithoutSellNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutSellNestedInput
  }

  export type SellCreateManyInput = {
    id?: string
    invoiceNo: string
    saleStatus?: $Enums.SaleStatus
    locked?: boolean
    lockedAt?: Date | string | null
    branchId?: string | null
    customerId?: string | null
    totalProducts?: number
    subTotal?: number
    discount?: number
    vat?: number
    grandTotal?: number
    NetTotal?: number
    notes?: string | null
    saleDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleStatus?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    locked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleStatus?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    locked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellItemCreateInput = {
    id?: string
    itemSaleStatus?: $Enums.ItemSaleStatus
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sell: SellCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutSellItemInput
    shop: ShopCreateNestedOneWithoutSellItemInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutSellItemInput
    batches?: SellItemBatchCreateNestedManyWithoutSellItemInput
  }

  export type SellItemUncheckedCreateInput = {
    id?: string
    sellId: string
    productId: string
    shopId: string
    unitOfMeasureId: string
    itemSaleStatus?: $Enums.ItemSaleStatus
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: SellItemBatchUncheckedCreateNestedManyWithoutSellItemInput
  }

  export type SellItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemSaleStatus?: EnumItemSaleStatusFieldUpdateOperationsInput | $Enums.ItemSaleStatus
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sell?: SellUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutSellItemNestedInput
    shop?: ShopUpdateOneRequiredWithoutSellItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutSellItemNestedInput
    batches?: SellItemBatchUpdateManyWithoutSellItemNestedInput
  }

  export type SellItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    itemSaleStatus?: EnumItemSaleStatusFieldUpdateOperationsInput | $Enums.ItemSaleStatus
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: SellItemBatchUncheckedUpdateManyWithoutSellItemNestedInput
  }

  export type SellItemCreateManyInput = {
    id?: string
    sellId: string
    productId: string
    shopId: string
    unitOfMeasureId: string
    itemSaleStatus?: $Enums.ItemSaleStatus
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemSaleStatus?: EnumItemSaleStatusFieldUpdateOperationsInput | $Enums.ItemSaleStatus
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    itemSaleStatus?: EnumItemSaleStatusFieldUpdateOperationsInput | $Enums.ItemSaleStatus
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellItemBatchCreateInput = {
    id?: string
    quantity?: number
    sellItem: SellItemCreateNestedOneWithoutBatchesInput
    batch: ProductBatchCreateNestedOneWithoutSellItemBatchInput
  }

  export type SellItemBatchUncheckedCreateInput = {
    id?: string
    sellItemId: string
    batchId: string
    quantity?: number
  }

  export type SellItemBatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    sellItem?: SellItemUpdateOneRequiredWithoutBatchesNestedInput
    batch?: ProductBatchUpdateOneRequiredWithoutSellItemBatchNestedInput
  }

  export type SellItemBatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellItemId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type SellItemBatchCreateManyInput = {
    id?: string
    sellItemId: string
    batchId: string
    quantity?: number
  }

  export type SellItemBatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type SellItemBatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellItemId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type AddToCartCreateInput = {
    id?: string
    isCheckedOut?: boolean
    isWaitlist?: boolean
    totalItems?: number
    totalAmount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAllAddToCartInput
    branch?: BranchCreateNestedOneWithoutAddToCartInput
    customer?: CustomerCreateNestedOneWithoutAddToCartInput
    createdBy?: UserCreateNestedOneWithoutCreatedAddToCartInput
    updatedBy?: UserCreateNestedOneWithoutAddToCartInput
    items?: CartItemCreateNestedManyWithoutCartInput
    waitlists?: WaitlistCreateNestedManyWithoutCartInput
  }

  export type AddToCartUncheckedCreateInput = {
    id?: string
    userId: string
    branchId?: string | null
    isCheckedOut?: boolean
    isWaitlist?: boolean
    customerId?: string | null
    totalItems?: number
    totalAmount?: number
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemUncheckedCreateNestedManyWithoutCartInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutCartInput
  }

  export type AddToCartUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    totalItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAllAddToCartNestedInput
    branch?: BranchUpdateOneWithoutAddToCartNestedInput
    customer?: CustomerUpdateOneWithoutAddToCartNestedInput
    createdBy?: UserUpdateOneWithoutCreatedAddToCartNestedInput
    updatedBy?: UserUpdateOneWithoutAddToCartNestedInput
    items?: CartItemUpdateManyWithoutCartNestedInput
    waitlists?: WaitlistUpdateManyWithoutCartNestedInput
  }

  export type AddToCartUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUncheckedUpdateManyWithoutCartNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutCartNestedInput
  }

  export type AddToCartCreateManyInput = {
    id?: string
    userId: string
    branchId?: string | null
    isCheckedOut?: boolean
    isWaitlist?: boolean
    customerId?: string | null
    totalItems?: number
    totalAmount?: number
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddToCartUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    totalItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddToCartUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateInput = {
    id?: string
    isWaitlist?: boolean
    quantity: number
    unitPrice?: number
    totalPrice?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cart: AddToCartCreateNestedOneWithoutItemsInput
    shop: ShopCreateNestedOneWithoutCartItemInput
    product: ProductCreateNestedOneWithoutCartItemInput
    unitOfMeasure?: UnitOfMeasureCreateNestedOneWithoutCartItemInput
    waitlists?: WaitlistCreateNestedManyWithoutCartItemInput
  }

  export type CartItemUncheckedCreateInput = {
    id?: string
    cartId: string
    isWaitlist?: boolean
    shopId: string
    productId: string
    unitOfMeasureId?: string | null
    quantity: number
    unitPrice?: number
    totalPrice?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutCartItemInput
  }

  export type CartItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cart?: AddToCartUpdateOneRequiredWithoutItemsNestedInput
    shop?: ShopUpdateOneRequiredWithoutCartItemNestedInput
    product?: ProductUpdateOneRequiredWithoutCartItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneWithoutCartItemNestedInput
    waitlists?: WaitlistUpdateManyWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    shopId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    waitlists?: WaitlistUncheckedUpdateManyWithoutCartItemNestedInput
  }

  export type CartItemCreateManyInput = {
    id?: string
    cartId: string
    isWaitlist?: boolean
    shopId: string
    productId: string
    unitOfMeasureId?: string | null
    quantity: number
    unitPrice?: number
    totalPrice?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    shopId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitlistCreateInput = {
    id?: string
    quantity?: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutWaitlistsInput
    customer?: CustomerCreateNestedOneWithoutWaitlistsInput
    branch?: BranchCreateNestedOneWithoutWaitlistsInput
    cart?: AddToCartCreateNestedOneWithoutWaitlistsInput
    cartItem?: CartItemCreateNestedOneWithoutWaitlistsInput
    product?: ProductCreateNestedOneWithoutWaitlistsInput
    shop?: ShopCreateNestedOneWithoutWaitlistsInput
    createdBy?: UserCreateNestedOneWithoutWaitlistsCreatedInput
    updatedBy?: UserCreateNestedOneWithoutWaitlistsUpdatedInput
  }

  export type WaitlistUncheckedCreateInput = {
    id?: string
    userId?: string | null
    customerId?: string | null
    branchId?: string | null
    cartId?: string | null
    cartItemId?: string | null
    productId?: string | null
    quantity?: number
    note?: string | null
    shopId?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaitlistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutWaitlistsNestedInput
    customer?: CustomerUpdateOneWithoutWaitlistsNestedInput
    branch?: BranchUpdateOneWithoutWaitlistsNestedInput
    cart?: AddToCartUpdateOneWithoutWaitlistsNestedInput
    cartItem?: CartItemUpdateOneWithoutWaitlistsNestedInput
    product?: ProductUpdateOneWithoutWaitlistsNestedInput
    shop?: ShopUpdateOneWithoutWaitlistsNestedInput
    createdBy?: UserUpdateOneWithoutWaitlistsCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutWaitlistsUpdatedNestedInput
  }

  export type WaitlistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    cartId?: NullableStringFieldUpdateOperationsInput | string | null
    cartItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitlistCreateManyInput = {
    id?: string
    userId?: string | null
    customerId?: string | null
    branchId?: string | null
    cartId?: string | null
    cartItemId?: string | null
    productId?: string | null
    quantity?: number
    note?: string | null
    shopId?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaitlistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitlistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    cartId?: NullableStringFieldUpdateOperationsInput | string | null
    cartItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellStockCorrectionCreateInput = {
    id?: string
    status?: $Enums.SellStockCorrectionStatus
    reference?: string | null
    notes?: string | null
    total?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sell?: SellCreateNestedOneWithoutSellStockCorrectionInput
    createdBy?: UserCreateNestedOneWithoutSellStockCorrectionInput
    updatedBy?: UserCreateNestedOneWithoutUpdateSellStockCorrectionInput
    items?: SellStockCorrectionItemCreateNestedManyWithoutCorrectionInput
  }

  export type SellStockCorrectionUncheckedCreateInput = {
    id?: string
    sellId?: string | null
    status?: $Enums.SellStockCorrectionStatus
    reference?: string | null
    notes?: string | null
    createdById?: string | null
    updatedById?: string | null
    total?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutCorrectionInput
  }

  export type SellStockCorrectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSellStockCorrectionStatusFieldUpdateOperationsInput | $Enums.SellStockCorrectionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sell?: SellUpdateOneWithoutSellStockCorrectionNestedInput
    createdBy?: UserUpdateOneWithoutSellStockCorrectionNestedInput
    updatedBy?: UserUpdateOneWithoutUpdateSellStockCorrectionNestedInput
    items?: SellStockCorrectionItemUpdateManyWithoutCorrectionNestedInput
  }

  export type SellStockCorrectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSellStockCorrectionStatusFieldUpdateOperationsInput | $Enums.SellStockCorrectionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SellStockCorrectionItemUncheckedUpdateManyWithoutCorrectionNestedInput
  }

  export type SellStockCorrectionCreateManyInput = {
    id?: string
    sellId?: string | null
    status?: $Enums.SellStockCorrectionStatus
    reference?: string | null
    notes?: string | null
    createdById?: string | null
    updatedById?: string | null
    total?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellStockCorrectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSellStockCorrectionStatusFieldUpdateOperationsInput | $Enums.SellStockCorrectionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellStockCorrectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSellStockCorrectionStatusFieldUpdateOperationsInput | $Enums.SellStockCorrectionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellStockCorrectionItemCreateInput = {
    id?: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    correction: SellStockCorrectionCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutSellStockCorrectionItemInput
    shop?: ShopCreateNestedOneWithoutSellStockCorrectionItemInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutSellStockCorrectionItemInput
    batches?: SellStockCorrectionBatchCreateNestedManyWithoutCorrectionItemInput
  }

  export type SellStockCorrectionItemUncheckedCreateInput = {
    id?: string
    correctionId: string
    productId: string
    shopId?: string | null
    unitOfMeasureId: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: SellStockCorrectionBatchUncheckedCreateNestedManyWithoutCorrectionItemInput
  }

  export type SellStockCorrectionItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    correction?: SellStockCorrectionUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutSellStockCorrectionItemNestedInput
    shop?: ShopUpdateOneWithoutSellStockCorrectionItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutSellStockCorrectionItemNestedInput
    batches?: SellStockCorrectionBatchUpdateManyWithoutCorrectionItemNestedInput
  }

  export type SellStockCorrectionItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    correctionId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: SellStockCorrectionBatchUncheckedUpdateManyWithoutCorrectionItemNestedInput
  }

  export type SellStockCorrectionItemCreateManyInput = {
    id?: string
    correctionId: string
    productId: string
    shopId?: string | null
    unitOfMeasureId: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellStockCorrectionItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellStockCorrectionItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    correctionId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellStockCorrectionBatchCreateInput = {
    id?: string
    quantity?: number
    correctionItem: SellStockCorrectionItemCreateNestedOneWithoutBatchesInput
    batch: ProductBatchCreateNestedOneWithoutSellStockCorrectionBatchInput
  }

  export type SellStockCorrectionBatchUncheckedCreateInput = {
    id?: string
    correctionItemId: string
    batchId: string
    quantity?: number
  }

  export type SellStockCorrectionBatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    correctionItem?: SellStockCorrectionItemUpdateOneRequiredWithoutBatchesNestedInput
    batch?: ProductBatchUpdateOneRequiredWithoutSellStockCorrectionBatchNestedInput
  }

  export type SellStockCorrectionBatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    correctionItemId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type SellStockCorrectionBatchCreateManyInput = {
    id?: string
    correctionItemId: string
    batchId: string
    quantity?: number
  }

  export type SellStockCorrectionBatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type SellStockCorrectionBatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    correctionItemId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    read?: boolean
    relatedEntityType?: $Enums.RelatedEntityType | null
    relatedEntityId?: string | null
    createdAt?: Date | string
    readAt?: Date | string | null
    store?: StoreCreateNestedOneWithoutNotificationsInput
    shop?: ShopCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    read?: boolean
    relatedEntityType?: $Enums.RelatedEntityType | null
    relatedEntityId?: string | null
    createdAt?: Date | string
    readAt?: Date | string | null
    storeId?: string | null
    shopId?: string | null
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    relatedEntityType?: NullableEnumRelatedEntityTypeFieldUpdateOperationsInput | $Enums.RelatedEntityType | null
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    store?: StoreUpdateOneWithoutNotificationsNestedInput
    shop?: ShopUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    relatedEntityType?: NullableEnumRelatedEntityTypeFieldUpdateOperationsInput | $Enums.RelatedEntityType | null
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateManyInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    read?: boolean
    relatedEntityType?: $Enums.RelatedEntityType | null
    relatedEntityId?: string | null
    createdAt?: Date | string
    readAt?: Date | string | null
    storeId?: string | null
    shopId?: string | null
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    relatedEntityType?: NullableEnumRelatedEntityTypeFieldUpdateOperationsInput | $Enums.RelatedEntityType | null
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    relatedEntityType?: NullableEnumRelatedEntityTypeFieldUpdateOperationsInput | $Enums.RelatedEntityType | null
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BranchNullableScalarRelationFilter = {
    is?: BranchWhereInput | null
    isNot?: BranchWhereInput | null
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type ShopListRelationFilter = {
    every?: ShopWhereInput
    some?: ShopWhereInput
    none?: ShopWhereInput
  }

  export type StoreListRelationFilter = {
    every?: StoreWhereInput
    some?: StoreWhereInput
    none?: StoreWhereInput
  }

  export type LogListRelationFilter = {
    every?: LogWhereInput
    some?: LogWhereInput
    none?: LogWhereInput
  }

  export type StockLedgerListRelationFilter = {
    every?: StockLedgerWhereInput
    some?: StockLedgerWhereInput
    none?: StockLedgerWhereInput
  }

  export type PurchaseListRelationFilter = {
    every?: PurchaseWhereInput
    some?: PurchaseWhereInput
    none?: PurchaseWhereInput
  }

  export type TransferListRelationFilter = {
    every?: TransferWhereInput
    some?: TransferWhereInput
    none?: TransferWhereInput
  }

  export type StockCorrectionListRelationFilter = {
    every?: StockCorrectionWhereInput
    some?: StockCorrectionWhereInput
    none?: StockCorrectionWhereInput
  }

  export type SellListRelationFilter = {
    every?: SellWhereInput
    some?: SellWhereInput
    none?: SellWhereInput
  }

  export type SellStockCorrectionListRelationFilter = {
    every?: SellStockCorrectionWhereInput
    some?: SellStockCorrectionWhereInput
    none?: SellStockCorrectionWhereInput
  }

  export type AddToCartListRelationFilter = {
    every?: AddToCartWhereInput
    some?: AddToCartWhereInput
    none?: AddToCartWhereInput
  }

  export type WaitlistListRelationFilter = {
    every?: WaitlistWhereInput
    some?: WaitlistWhereInput
    none?: WaitlistWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ShopOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockLedgerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockCorrectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SellOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SellStockCorrectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddToCartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WaitlistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    userCode?: SortOrder
    email?: SortOrder
    admin?: SortOrder
    password?: SortOrder
    branchId?: SortOrder
    roleId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    userCode?: SortOrder
    email?: SortOrder
    admin?: SortOrder
    password?: SortOrder
    branchId?: SortOrder
    roleId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    userCode?: SortOrder
    email?: SortOrder
    admin?: SortOrder
    password?: SortOrder
    branchId?: SortOrder
    roleId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleOrderByRelevanceInput = {
    fields: RoleOrderByRelevanceFieldEnum | RoleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionOrderByRelevanceInput = {
    fields: PermissionOrderByRelevanceFieldEnum | PermissionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionScalarRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RolePermissionOrderByRelevanceInput = {
    fields: RolePermissionOrderByRelevanceFieldEnum | RolePermissionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RolePermissionRoleIdPermissionIdCompoundUniqueInput = {
    roleId: string
    permissionId: string
  }

  export type RolePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyOrderByRelevanceInput = {
    fields: CompanyOrderByRelevanceFieldEnum | CompanyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    description?: SortOrder
    tinAddress?: SortOrder
    TIN?: SortOrder
    From?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    description?: SortOrder
    tinAddress?: SortOrder
    TIN?: SortOrder
    From?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    description?: SortOrder
    tinAddress?: SortOrder
    TIN?: SortOrder
    From?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchOrderByRelevanceInput = {
    fields: BranchOrderByRelevanceFieldEnum | BranchOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BranchCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchScalarRelationFilter = {
    is?: BranchWhereInput
    isNot?: BranchWhereInput
  }

  export type ShopStockListRelationFilter = {
    every?: ShopStockWhereInput
    some?: ShopStockWhereInput
    none?: ShopStockWhereInput
  }

  export type AdditionalPriceListRelationFilter = {
    every?: AdditionalPriceWhereInput
    some?: AdditionalPriceWhereInput
    none?: AdditionalPriceWhereInput
  }

  export type SellItemListRelationFilter = {
    every?: SellItemWhereInput
    some?: SellItemWhereInput
    none?: SellItemWhereInput
  }

  export type SellStockCorrectionItemListRelationFilter = {
    every?: SellStockCorrectionItemWhereInput
    some?: SellStockCorrectionItemWhereInput
    none?: SellStockCorrectionItemWhereInput
  }

  export type CartItemListRelationFilter = {
    every?: CartItemWhereInput
    some?: CartItemWhereInput
    none?: CartItemWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ShopStockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdditionalPriceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SellItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SellStockCorrectionItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CartItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopOrderByRelevanceInput = {
    fields: ShopOrderByRelevanceFieldEnum | ShopOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ShopCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductBatchListRelationFilter = {
    every?: ProductBatchWhereInput
    some?: ProductBatchWhereInput
    none?: ProductBatchWhereInput
  }

  export type StoreStockListRelationFilter = {
    every?: StoreStockWhereInput
    some?: StoreStockWhereInput
    none?: StoreStockWhereInput
  }

  export type ProductBatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreStockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreOrderByRelevanceInput = {
    fields: StoreOrderByRelevanceFieldEnum | StoreOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StoreCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumStockStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StockStatus | EnumStockStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StockStatus[]
    notIn?: $Enums.StockStatus[]
    not?: NestedEnumStockStatusFilter<$PrismaModel> | $Enums.StockStatus
  }

  export type StoreScalarRelationFilter = {
    is?: StoreWhereInput
    isNot?: StoreWhereInput
  }

  export type ProductBatchScalarRelationFilter = {
    is?: ProductBatchWhereInput
    isNot?: ProductBatchWhereInput
  }

  export type UnitOfMeasureScalarRelationFilter = {
    is?: UnitOfMeasureWhereInput
    isNot?: UnitOfMeasureWhereInput
  }

  export type StoreStockOrderByRelevanceInput = {
    fields: StoreStockOrderByRelevanceFieldEnum | StoreStockOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StoreStockStoreIdBatchIdCompoundUniqueInput = {
    storeId: string
    batchId: string
  }

  export type StoreStockCountOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    batchId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    unitOfMeasureId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreStockAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type StoreStockMaxOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    batchId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    unitOfMeasureId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreStockMinOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    batchId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    unitOfMeasureId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreStockSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumStockStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StockStatus | EnumStockStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StockStatus[]
    notIn?: $Enums.StockStatus[]
    not?: NestedEnumStockStatusWithAggregatesFilter<$PrismaModel> | $Enums.StockStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStockStatusFilter<$PrismaModel>
    _max?: NestedEnumStockStatusFilter<$PrismaModel>
  }

  export type ShopScalarRelationFilter = {
    is?: ShopWhereInput
    isNot?: ShopWhereInput
  }

  export type ShopStockOrderByRelevanceInput = {
    fields: ShopStockOrderByRelevanceFieldEnum | ShopStockOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ShopStockShopIdBatchIdCompoundUniqueInput = {
    shopId: string
    batchId: string
  }

  export type ShopStockCountOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    batchId?: SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopStockAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type ShopStockMaxOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    batchId?: SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopStockMinOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    batchId?: SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopStockSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumStockMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StockMovementType | EnumStockMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StockMovementType[]
    notIn?: $Enums.StockMovementType[]
    not?: NestedEnumStockMovementTypeFilter<$PrismaModel> | $Enums.StockMovementType
  }

  export type StoreNullableScalarRelationFilter = {
    is?: StoreWhereInput | null
    isNot?: StoreWhereInput | null
  }

  export type ShopNullableScalarRelationFilter = {
    is?: ShopWhereInput | null
    isNot?: ShopWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type StockLedgerOrderByRelevanceInput = {
    fields: StockLedgerOrderByRelevanceFieldEnum | StockLedgerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StockLedgerCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    batchId?: SortOrder
    storeId?: SortOrder
    shopId?: SortOrder
    movementType?: SortOrder
    quantity?: SortOrder
    unitOfMeasureId?: SortOrder
    reference?: SortOrder
    userId?: SortOrder
    notes?: SortOrder
    movementDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockLedgerAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type StockLedgerMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    batchId?: SortOrder
    storeId?: SortOrder
    shopId?: SortOrder
    movementType?: SortOrder
    quantity?: SortOrder
    unitOfMeasureId?: SortOrder
    reference?: SortOrder
    userId?: SortOrder
    notes?: SortOrder
    movementDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockLedgerMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    batchId?: SortOrder
    storeId?: SortOrder
    shopId?: SortOrder
    movementType?: SortOrder
    quantity?: SortOrder
    unitOfMeasureId?: SortOrder
    reference?: SortOrder
    userId?: SortOrder
    notes?: SortOrder
    movementDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockLedgerSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumStockMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StockMovementType | EnumStockMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StockMovementType[]
    notIn?: $Enums.StockMovementType[]
    not?: NestedEnumStockMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.StockMovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStockMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumStockMovementTypeFilter<$PrismaModel>
  }

  export type LogOrderByRelevanceInput = {
    fields: LogOrderByRelevanceFieldEnum | LogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerOrderByRelevanceInput = {
    fields: CustomerOrderByRelevanceFieldEnum | CustomerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    companyName?: SortOrder
    phone1?: SortOrder
    phone2?: SortOrder
    tinNumber?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    companyName?: SortOrder
    phone1?: SortOrder
    phone2?: SortOrder
    tinNumber?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    companyName?: SortOrder
    phone1?: SortOrder
    phone2?: SortOrder
    tinNumber?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierOrderByRelevanceInput = {
    fields: SupplierOrderByRelevanceFieldEnum | SupplierOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    tinNumber?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    tinNumber?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    tinNumber?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type SubCategoryListRelationFilter = {
    every?: SubCategoryWhereInput
    some?: SubCategoryWhereInput
    none?: SubCategoryWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelevanceInput = {
    fields: CategoryOrderByRelevanceFieldEnum | CategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type SubCategoryOrderByRelevanceInput = {
    fields: SubCategoryOrderByRelevanceFieldEnum | SubCategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type SubCategoryNullableScalarRelationFilter = {
    is?: SubCategoryWhereInput | null
    isNot?: SubCategoryWhereInput | null
  }

  export type PurchaseItemListRelationFilter = {
    every?: PurchaseItemWhereInput
    some?: PurchaseItemWhereInput
    none?: PurchaseItemWhereInput
  }

  export type TransferItemListRelationFilter = {
    every?: TransferItemWhereInput
    some?: TransferItemWhereInput
    none?: TransferItemWhereInput
  }

  export type StockCorrectionItemListRelationFilter = {
    every?: StockCorrectionItemWhereInput
    some?: StockCorrectionItemWhereInput
    none?: StockCorrectionItemWhereInput
  }

  export type PurchaseItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransferItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockCorrectionItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelevanceInput = {
    fields: ProductOrderByRelevanceFieldEnum | ProductOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    productCode?: SortOrder
    name?: SortOrder
    generic?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    subCategoryId?: SortOrder
    sellPrice?: SortOrder
    imageUrl?: SortOrder
    unitOfMeasureId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    sellPrice?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    productCode?: SortOrder
    name?: SortOrder
    generic?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    subCategoryId?: SortOrder
    sellPrice?: SortOrder
    imageUrl?: SortOrder
    unitOfMeasureId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    productCode?: SortOrder
    name?: SortOrder
    generic?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    subCategoryId?: SortOrder
    sellPrice?: SortOrder
    imageUrl?: SortOrder
    unitOfMeasureId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    sellPrice?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type AdditionalPriceOrderByRelevanceInput = {
    fields: AdditionalPriceOrderByRelevanceFieldEnum | AdditionalPriceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdditionalPriceProductIdLabelCompoundUniqueInput = {
    productId: string
    label: string
  }

  export type AdditionalPriceCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    price?: SortOrder
    productId?: SortOrder
    shopId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdditionalPriceAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type AdditionalPriceMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    price?: SortOrder
    productId?: SortOrder
    shopId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdditionalPriceMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    price?: SortOrder
    productId?: SortOrder
    shopId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdditionalPriceSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type SellItemBatchListRelationFilter = {
    every?: SellItemBatchWhereInput
    some?: SellItemBatchWhereInput
    none?: SellItemBatchWhereInput
  }

  export type SellStockCorrectionBatchListRelationFilter = {
    every?: SellStockCorrectionBatchWhereInput
    some?: SellStockCorrectionBatchWhereInput
    none?: SellStockCorrectionBatchWhereInput
  }

  export type SellItemBatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SellStockCorrectionBatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductBatchOrderByRelevanceInput = {
    fields: ProductBatchOrderByRelevanceFieldEnum | ProductBatchOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductBatchCountOrderByAggregateInput = {
    id?: SortOrder
    batchNumber?: SortOrder
    expiryDate?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    warningQuantity?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductBatchAvgOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
    warningQuantity?: SortOrder
  }

  export type ProductBatchMaxOrderByAggregateInput = {
    id?: SortOrder
    batchNumber?: SortOrder
    expiryDate?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    warningQuantity?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductBatchMinOrderByAggregateInput = {
    id?: SortOrder
    batchNumber?: SortOrder
    expiryDate?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    warningQuantity?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductBatchSumOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
    warningQuantity?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UnitOfMeasureOrderByRelevanceInput = {
    fields: UnitOfMeasureOrderByRelevanceFieldEnum | UnitOfMeasureOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UnitOfMeasureCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    base?: SortOrder
  }

  export type UnitOfMeasureMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    base?: SortOrder
  }

  export type UnitOfMeasureMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    base?: SortOrder
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type SupplierScalarRelationFilter = {
    is?: SupplierWhereInput
    isNot?: SupplierWhereInput
  }

  export type PurchaseOrderByRelevanceInput = {
    fields: PurchaseOrderByRelevanceFieldEnum | PurchaseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    supplierId?: SortOrder
    storeId?: SortOrder
    paymentStatus?: SortOrder
    totalProducts?: SortOrder
    subTotal?: SortOrder
    grandTotal?: SortOrder
    notes?: SortOrder
    purchaseDate?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseAvgOrderByAggregateInput = {
    totalProducts?: SortOrder
    subTotal?: SortOrder
    grandTotal?: SortOrder
  }

  export type PurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    supplierId?: SortOrder
    storeId?: SortOrder
    paymentStatus?: SortOrder
    totalProducts?: SortOrder
    subTotal?: SortOrder
    grandTotal?: SortOrder
    notes?: SortOrder
    purchaseDate?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    supplierId?: SortOrder
    storeId?: SortOrder
    paymentStatus?: SortOrder
    totalProducts?: SortOrder
    subTotal?: SortOrder
    grandTotal?: SortOrder
    notes?: SortOrder
    purchaseDate?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseSumOrderByAggregateInput = {
    totalProducts?: SortOrder
    subTotal?: SortOrder
    grandTotal?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type PurchaseScalarRelationFilter = {
    is?: PurchaseWhereInput
    isNot?: PurchaseWhereInput
  }

  export type PurchaseItemOrderByRelevanceInput = {
    fields: PurchaseItemOrderByRelevanceFieldEnum | PurchaseItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PurchaseItemCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    productId?: SortOrder
    batchId?: SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type PurchaseItemMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    productId?: SortOrder
    batchId?: SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseItemMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    productId?: SortOrder
    batchId?: SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type EnumTransferEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferEntityType | EnumTransferEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransferEntityType[]
    notIn?: $Enums.TransferEntityType[]
    not?: NestedEnumTransferEntityTypeFilter<$PrismaModel> | $Enums.TransferEntityType
  }

  export type EnumTransferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[]
    notIn?: $Enums.TransferStatus[]
    not?: NestedEnumTransferStatusFilter<$PrismaModel> | $Enums.TransferStatus
  }

  export type TransferOrderByRelevanceInput = {
    fields: TransferOrderByRelevanceFieldEnum | TransferOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TransferCountOrderByAggregateInput = {
    id?: SortOrder
    shortCode?: SortOrder
    sourceType?: SortOrder
    sourceStoreId?: SortOrder
    sourceShopId?: SortOrder
    destinationType?: SortOrder
    destStoreId?: SortOrder
    destShopId?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    movementDate?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferMaxOrderByAggregateInput = {
    id?: SortOrder
    shortCode?: SortOrder
    sourceType?: SortOrder
    sourceStoreId?: SortOrder
    sourceShopId?: SortOrder
    destinationType?: SortOrder
    destStoreId?: SortOrder
    destShopId?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    movementDate?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferMinOrderByAggregateInput = {
    id?: SortOrder
    shortCode?: SortOrder
    sourceType?: SortOrder
    sourceStoreId?: SortOrder
    sourceShopId?: SortOrder
    destinationType?: SortOrder
    destStoreId?: SortOrder
    destShopId?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    movementDate?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTransferEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferEntityType | EnumTransferEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransferEntityType[]
    notIn?: $Enums.TransferEntityType[]
    not?: NestedEnumTransferEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransferEntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumTransferEntityTypeFilter<$PrismaModel>
  }

  export type EnumTransferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[]
    notIn?: $Enums.TransferStatus[]
    not?: NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferStatusFilter<$PrismaModel>
    _max?: NestedEnumTransferStatusFilter<$PrismaModel>
  }

  export type TransferScalarRelationFilter = {
    is?: TransferWhereInput
    isNot?: TransferWhereInput
  }

  export type TransferItemOrderByRelevanceInput = {
    fields: TransferItemOrderByRelevanceFieldEnum | TransferItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TransferItemCountOrderByAggregateInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    batchId?: SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type TransferItemMaxOrderByAggregateInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    batchId?: SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferItemMinOrderByAggregateInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    batchId?: SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferItemSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumStockCorrectionReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.StockCorrectionReason | EnumStockCorrectionReasonFieldRefInput<$PrismaModel>
    in?: $Enums.StockCorrectionReason[]
    notIn?: $Enums.StockCorrectionReason[]
    not?: NestedEnumStockCorrectionReasonFilter<$PrismaModel> | $Enums.StockCorrectionReason
  }

  export type EnumStockCorrectionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StockCorrectionStatus | EnumStockCorrectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StockCorrectionStatus[]
    notIn?: $Enums.StockCorrectionStatus[]
    not?: NestedEnumStockCorrectionStatusFilter<$PrismaModel> | $Enums.StockCorrectionStatus
  }

  export type PurchaseNullableScalarRelationFilter = {
    is?: PurchaseWhereInput | null
    isNot?: PurchaseWhereInput | null
  }

  export type TransferNullableScalarRelationFilter = {
    is?: TransferWhereInput | null
    isNot?: TransferWhereInput | null
  }

  export type StockCorrectionOrderByRelevanceInput = {
    fields: StockCorrectionOrderByRelevanceFieldEnum | StockCorrectionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StockCorrectionCountOrderByAggregateInput = {
    id?: SortOrder
    shortCode?: SortOrder
    storeId?: SortOrder
    shopId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    purchaseId?: SortOrder
    transferId?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockCorrectionMaxOrderByAggregateInput = {
    id?: SortOrder
    shortCode?: SortOrder
    storeId?: SortOrder
    shopId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    purchaseId?: SortOrder
    transferId?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockCorrectionMinOrderByAggregateInput = {
    id?: SortOrder
    shortCode?: SortOrder
    storeId?: SortOrder
    shopId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    purchaseId?: SortOrder
    transferId?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStockCorrectionReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StockCorrectionReason | EnumStockCorrectionReasonFieldRefInput<$PrismaModel>
    in?: $Enums.StockCorrectionReason[]
    notIn?: $Enums.StockCorrectionReason[]
    not?: NestedEnumStockCorrectionReasonWithAggregatesFilter<$PrismaModel> | $Enums.StockCorrectionReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStockCorrectionReasonFilter<$PrismaModel>
    _max?: NestedEnumStockCorrectionReasonFilter<$PrismaModel>
  }

  export type EnumStockCorrectionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StockCorrectionStatus | EnumStockCorrectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StockCorrectionStatus[]
    notIn?: $Enums.StockCorrectionStatus[]
    not?: NestedEnumStockCorrectionStatusWithAggregatesFilter<$PrismaModel> | $Enums.StockCorrectionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStockCorrectionStatusFilter<$PrismaModel>
    _max?: NestedEnumStockCorrectionStatusFilter<$PrismaModel>
  }

  export type StockCorrectionScalarRelationFilter = {
    is?: StockCorrectionWhereInput
    isNot?: StockCorrectionWhereInput
  }

  export type ProductBatchNullableScalarRelationFilter = {
    is?: ProductBatchWhereInput | null
    isNot?: ProductBatchWhereInput | null
  }

  export type StockCorrectionItemOrderByRelevanceInput = {
    fields: StockCorrectionItemOrderByRelevanceFieldEnum | StockCorrectionItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StockCorrectionItemCountOrderByAggregateInput = {
    id?: SortOrder
    correctionId?: SortOrder
    productId?: SortOrder
    batchId?: SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockCorrectionItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type StockCorrectionItemMaxOrderByAggregateInput = {
    id?: SortOrder
    correctionId?: SortOrder
    productId?: SortOrder
    batchId?: SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockCorrectionItemMinOrderByAggregateInput = {
    id?: SortOrder
    correctionId?: SortOrder
    productId?: SortOrder
    batchId?: SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockCorrectionItemSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumSaleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SaleStatus | EnumSaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SaleStatus[]
    notIn?: $Enums.SaleStatus[]
    not?: NestedEnumSaleStatusFilter<$PrismaModel> | $Enums.SaleStatus
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type SellOrderByRelevanceInput = {
    fields: SellOrderByRelevanceFieldEnum | SellOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SellCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    saleStatus?: SortOrder
    locked?: SortOrder
    lockedAt?: SortOrder
    branchId?: SortOrder
    customerId?: SortOrder
    totalProducts?: SortOrder
    subTotal?: SortOrder
    discount?: SortOrder
    vat?: SortOrder
    grandTotal?: SortOrder
    NetTotal?: SortOrder
    notes?: SortOrder
    saleDate?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellAvgOrderByAggregateInput = {
    totalProducts?: SortOrder
    subTotal?: SortOrder
    discount?: SortOrder
    vat?: SortOrder
    grandTotal?: SortOrder
    NetTotal?: SortOrder
  }

  export type SellMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    saleStatus?: SortOrder
    locked?: SortOrder
    lockedAt?: SortOrder
    branchId?: SortOrder
    customerId?: SortOrder
    totalProducts?: SortOrder
    subTotal?: SortOrder
    discount?: SortOrder
    vat?: SortOrder
    grandTotal?: SortOrder
    NetTotal?: SortOrder
    notes?: SortOrder
    saleDate?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    saleStatus?: SortOrder
    locked?: SortOrder
    lockedAt?: SortOrder
    branchId?: SortOrder
    customerId?: SortOrder
    totalProducts?: SortOrder
    subTotal?: SortOrder
    discount?: SortOrder
    vat?: SortOrder
    grandTotal?: SortOrder
    NetTotal?: SortOrder
    notes?: SortOrder
    saleDate?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellSumOrderByAggregateInput = {
    totalProducts?: SortOrder
    subTotal?: SortOrder
    discount?: SortOrder
    vat?: SortOrder
    grandTotal?: SortOrder
    NetTotal?: SortOrder
  }

  export type EnumSaleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SaleStatus | EnumSaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SaleStatus[]
    notIn?: $Enums.SaleStatus[]
    not?: NestedEnumSaleStatusWithAggregatesFilter<$PrismaModel> | $Enums.SaleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSaleStatusFilter<$PrismaModel>
    _max?: NestedEnumSaleStatusFilter<$PrismaModel>
  }

  export type EnumItemSaleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemSaleStatus | EnumItemSaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ItemSaleStatus[]
    notIn?: $Enums.ItemSaleStatus[]
    not?: NestedEnumItemSaleStatusFilter<$PrismaModel> | $Enums.ItemSaleStatus
  }

  export type SellScalarRelationFilter = {
    is?: SellWhereInput
    isNot?: SellWhereInput
  }

  export type SellItemOrderByRelevanceInput = {
    fields: SellItemOrderByRelevanceFieldEnum | SellItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SellItemCountOrderByAggregateInput = {
    id?: SortOrder
    sellId?: SortOrder
    productId?: SortOrder
    shopId?: SortOrder
    unitOfMeasureId?: SortOrder
    itemSaleStatus?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type SellItemMaxOrderByAggregateInput = {
    id?: SortOrder
    sellId?: SortOrder
    productId?: SortOrder
    shopId?: SortOrder
    unitOfMeasureId?: SortOrder
    itemSaleStatus?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellItemMinOrderByAggregateInput = {
    id?: SortOrder
    sellId?: SortOrder
    productId?: SortOrder
    shopId?: SortOrder
    unitOfMeasureId?: SortOrder
    itemSaleStatus?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type EnumItemSaleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemSaleStatus | EnumItemSaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ItemSaleStatus[]
    notIn?: $Enums.ItemSaleStatus[]
    not?: NestedEnumItemSaleStatusWithAggregatesFilter<$PrismaModel> | $Enums.ItemSaleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemSaleStatusFilter<$PrismaModel>
    _max?: NestedEnumItemSaleStatusFilter<$PrismaModel>
  }

  export type SellItemScalarRelationFilter = {
    is?: SellItemWhereInput
    isNot?: SellItemWhereInput
  }

  export type SellItemBatchOrderByRelevanceInput = {
    fields: SellItemBatchOrderByRelevanceFieldEnum | SellItemBatchOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SellItemBatchSellItemIdBatchIdCompoundUniqueInput = {
    sellItemId: string
    batchId: string
  }

  export type SellItemBatchCountOrderByAggregateInput = {
    id?: SortOrder
    sellItemId?: SortOrder
    batchId?: SortOrder
    quantity?: SortOrder
  }

  export type SellItemBatchAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type SellItemBatchMaxOrderByAggregateInput = {
    id?: SortOrder
    sellItemId?: SortOrder
    batchId?: SortOrder
    quantity?: SortOrder
  }

  export type SellItemBatchMinOrderByAggregateInput = {
    id?: SortOrder
    sellItemId?: SortOrder
    batchId?: SortOrder
    quantity?: SortOrder
  }

  export type SellItemBatchSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AddToCartOrderByRelevanceInput = {
    fields: AddToCartOrderByRelevanceFieldEnum | AddToCartOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AddToCartCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    isCheckedOut?: SortOrder
    isWaitlist?: SortOrder
    customerId?: SortOrder
    totalItems?: SortOrder
    totalAmount?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddToCartAvgOrderByAggregateInput = {
    totalItems?: SortOrder
    totalAmount?: SortOrder
  }

  export type AddToCartMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    isCheckedOut?: SortOrder
    isWaitlist?: SortOrder
    customerId?: SortOrder
    totalItems?: SortOrder
    totalAmount?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddToCartMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    isCheckedOut?: SortOrder
    isWaitlist?: SortOrder
    customerId?: SortOrder
    totalItems?: SortOrder
    totalAmount?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddToCartSumOrderByAggregateInput = {
    totalItems?: SortOrder
    totalAmount?: SortOrder
  }

  export type AddToCartScalarRelationFilter = {
    is?: AddToCartWhereInput
    isNot?: AddToCartWhereInput
  }

  export type UnitOfMeasureNullableScalarRelationFilter = {
    is?: UnitOfMeasureWhereInput | null
    isNot?: UnitOfMeasureWhereInput | null
  }

  export type CartItemOrderByRelevanceInput = {
    fields: CartItemOrderByRelevanceFieldEnum | CartItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CartItemCountOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    isWaitlist?: SortOrder
    shopId?: SortOrder
    productId?: SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type CartItemMaxOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    isWaitlist?: SortOrder
    shopId?: SortOrder
    productId?: SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartItemMinOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    isWaitlist?: SortOrder
    shopId?: SortOrder
    productId?: SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type AddToCartNullableScalarRelationFilter = {
    is?: AddToCartWhereInput | null
    isNot?: AddToCartWhereInput | null
  }

  export type CartItemNullableScalarRelationFilter = {
    is?: CartItemWhereInput | null
    isNot?: CartItemWhereInput | null
  }

  export type ProductNullableScalarRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type WaitlistOrderByRelevanceInput = {
    fields: WaitlistOrderByRelevanceFieldEnum | WaitlistOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WaitlistCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    customerId?: SortOrder
    branchId?: SortOrder
    cartId?: SortOrder
    cartItemId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    note?: SortOrder
    shopId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WaitlistAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type WaitlistMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    customerId?: SortOrder
    branchId?: SortOrder
    cartId?: SortOrder
    cartItemId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    note?: SortOrder
    shopId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WaitlistMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    customerId?: SortOrder
    branchId?: SortOrder
    cartId?: SortOrder
    cartItemId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    note?: SortOrder
    shopId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WaitlistSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumSellStockCorrectionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SellStockCorrectionStatus | EnumSellStockCorrectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SellStockCorrectionStatus[]
    notIn?: $Enums.SellStockCorrectionStatus[]
    not?: NestedEnumSellStockCorrectionStatusFilter<$PrismaModel> | $Enums.SellStockCorrectionStatus
  }

  export type SellNullableScalarRelationFilter = {
    is?: SellWhereInput | null
    isNot?: SellWhereInput | null
  }

  export type SellStockCorrectionOrderByRelevanceInput = {
    fields: SellStockCorrectionOrderByRelevanceFieldEnum | SellStockCorrectionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SellStockCorrectionCountOrderByAggregateInput = {
    id?: SortOrder
    sellId?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellStockCorrectionAvgOrderByAggregateInput = {
    total?: SortOrder
  }

  export type SellStockCorrectionMaxOrderByAggregateInput = {
    id?: SortOrder
    sellId?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellStockCorrectionMinOrderByAggregateInput = {
    id?: SortOrder
    sellId?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellStockCorrectionSumOrderByAggregateInput = {
    total?: SortOrder
  }

  export type EnumSellStockCorrectionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SellStockCorrectionStatus | EnumSellStockCorrectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SellStockCorrectionStatus[]
    notIn?: $Enums.SellStockCorrectionStatus[]
    not?: NestedEnumSellStockCorrectionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SellStockCorrectionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSellStockCorrectionStatusFilter<$PrismaModel>
    _max?: NestedEnumSellStockCorrectionStatusFilter<$PrismaModel>
  }

  export type SellStockCorrectionScalarRelationFilter = {
    is?: SellStockCorrectionWhereInput
    isNot?: SellStockCorrectionWhereInput
  }

  export type SellStockCorrectionItemOrderByRelevanceInput = {
    fields: SellStockCorrectionItemOrderByRelevanceFieldEnum | SellStockCorrectionItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SellStockCorrectionItemCountOrderByAggregateInput = {
    id?: SortOrder
    correctionId?: SortOrder
    productId?: SortOrder
    shopId?: SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellStockCorrectionItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type SellStockCorrectionItemMaxOrderByAggregateInput = {
    id?: SortOrder
    correctionId?: SortOrder
    productId?: SortOrder
    shopId?: SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellStockCorrectionItemMinOrderByAggregateInput = {
    id?: SortOrder
    correctionId?: SortOrder
    productId?: SortOrder
    shopId?: SortOrder
    unitOfMeasureId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellStockCorrectionItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type SellStockCorrectionItemScalarRelationFilter = {
    is?: SellStockCorrectionItemWhereInput
    isNot?: SellStockCorrectionItemWhereInput
  }

  export type SellStockCorrectionBatchOrderByRelevanceInput = {
    fields: SellStockCorrectionBatchOrderByRelevanceFieldEnum | SellStockCorrectionBatchOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SellStockCorrectionBatchCorrectionItemIdBatchIdCompoundUniqueInput = {
    correctionItemId: string
    batchId: string
  }

  export type SellStockCorrectionBatchCountOrderByAggregateInput = {
    id?: SortOrder
    correctionItemId?: SortOrder
    batchId?: SortOrder
    quantity?: SortOrder
  }

  export type SellStockCorrectionBatchAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type SellStockCorrectionBatchMaxOrderByAggregateInput = {
    id?: SortOrder
    correctionItemId?: SortOrder
    batchId?: SortOrder
    quantity?: SortOrder
  }

  export type SellStockCorrectionBatchMinOrderByAggregateInput = {
    id?: SortOrder
    correctionItemId?: SortOrder
    batchId?: SortOrder
    quantity?: SortOrder
  }

  export type SellStockCorrectionBatchSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type EnumRelatedEntityTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RelatedEntityType | EnumRelatedEntityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RelatedEntityType[] | null
    notIn?: $Enums.RelatedEntityType[] | null
    not?: NestedEnumRelatedEntityTypeNullableFilter<$PrismaModel> | $Enums.RelatedEntityType | null
  }

  export type NotificationOrderByRelevanceInput = {
    fields: NotificationOrderByRelevanceFieldEnum | NotificationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    relatedEntityType?: SortOrder
    relatedEntityId?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
    storeId?: SortOrder
    shopId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    relatedEntityType?: SortOrder
    relatedEntityId?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
    storeId?: SortOrder
    shopId?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    relatedEntityType?: SortOrder
    relatedEntityId?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
    storeId?: SortOrder
    shopId?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumRelatedEntityTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RelatedEntityType | EnumRelatedEntityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RelatedEntityType[] | null
    notIn?: $Enums.RelatedEntityType[] | null
    not?: NestedEnumRelatedEntityTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.RelatedEntityType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRelatedEntityTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumRelatedEntityTypeNullableFilter<$PrismaModel>
  }

  export type BranchCreateNestedOneWithoutUserInput = {
    create?: XOR<BranchCreateWithoutUserInput, BranchUncheckedCreateWithoutUserInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUserInput
    connect?: BranchWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type ShopCreateNestedManyWithoutUserInput = {
    create?: XOR<ShopCreateWithoutUserInput, ShopUncheckedCreateWithoutUserInput> | ShopCreateWithoutUserInput[] | ShopUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutUserInput | ShopCreateOrConnectWithoutUserInput[]
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
  }

  export type StoreCreateNestedManyWithoutUserInput = {
    create?: XOR<StoreCreateWithoutUserInput, StoreUncheckedCreateWithoutUserInput> | StoreCreateWithoutUserInput[] | StoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoreCreateOrConnectWithoutUserInput | StoreCreateOrConnectWithoutUserInput[]
    connect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
  }

  export type LogCreateNestedManyWithoutUserInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type StockLedgerCreateNestedManyWithoutUserInput = {
    create?: XOR<StockLedgerCreateWithoutUserInput, StockLedgerUncheckedCreateWithoutUserInput> | StockLedgerCreateWithoutUserInput[] | StockLedgerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutUserInput | StockLedgerCreateOrConnectWithoutUserInput[]
    createMany?: StockLedgerCreateManyUserInputEnvelope
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
  }

  export type PurchaseCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PurchaseCreateWithoutCreatedByInput, PurchaseUncheckedCreateWithoutCreatedByInput> | PurchaseCreateWithoutCreatedByInput[] | PurchaseUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutCreatedByInput | PurchaseCreateOrConnectWithoutCreatedByInput[]
    createMany?: PurchaseCreateManyCreatedByInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type PurchaseCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<PurchaseCreateWithoutUpdatedByInput, PurchaseUncheckedCreateWithoutUpdatedByInput> | PurchaseCreateWithoutUpdatedByInput[] | PurchaseUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutUpdatedByInput | PurchaseCreateOrConnectWithoutUpdatedByInput[]
    createMany?: PurchaseCreateManyUpdatedByInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TransferCreateWithoutCreatedByInput, TransferUncheckedCreateWithoutCreatedByInput> | TransferCreateWithoutCreatedByInput[] | TransferUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutCreatedByInput | TransferCreateOrConnectWithoutCreatedByInput[]
    createMany?: TransferCreateManyCreatedByInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<TransferCreateWithoutUpdatedByInput, TransferUncheckedCreateWithoutUpdatedByInput> | TransferCreateWithoutUpdatedByInput[] | TransferUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutUpdatedByInput | TransferCreateOrConnectWithoutUpdatedByInput[]
    createMany?: TransferCreateManyUpdatedByInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type StockCorrectionCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<StockCorrectionCreateWithoutCreatedByInput, StockCorrectionUncheckedCreateWithoutCreatedByInput> | StockCorrectionCreateWithoutCreatedByInput[] | StockCorrectionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StockCorrectionCreateOrConnectWithoutCreatedByInput | StockCorrectionCreateOrConnectWithoutCreatedByInput[]
    createMany?: StockCorrectionCreateManyCreatedByInputEnvelope
    connect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
  }

  export type StockCorrectionCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<StockCorrectionCreateWithoutUpdatedByInput, StockCorrectionUncheckedCreateWithoutUpdatedByInput> | StockCorrectionCreateWithoutUpdatedByInput[] | StockCorrectionUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: StockCorrectionCreateOrConnectWithoutUpdatedByInput | StockCorrectionCreateOrConnectWithoutUpdatedByInput[]
    createMany?: StockCorrectionCreateManyUpdatedByInputEnvelope
    connect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
  }

  export type SellCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SellCreateWithoutCreatedByInput, SellUncheckedCreateWithoutCreatedByInput> | SellCreateWithoutCreatedByInput[] | SellUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SellCreateOrConnectWithoutCreatedByInput | SellCreateOrConnectWithoutCreatedByInput[]
    createMany?: SellCreateManyCreatedByInputEnvelope
    connect?: SellWhereUniqueInput | SellWhereUniqueInput[]
  }

  export type SellCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<SellCreateWithoutUpdatedByInput, SellUncheckedCreateWithoutUpdatedByInput> | SellCreateWithoutUpdatedByInput[] | SellUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: SellCreateOrConnectWithoutUpdatedByInput | SellCreateOrConnectWithoutUpdatedByInput[]
    createMany?: SellCreateManyUpdatedByInputEnvelope
    connect?: SellWhereUniqueInput | SellWhereUniqueInput[]
  }

  export type SellStockCorrectionCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SellStockCorrectionCreateWithoutCreatedByInput, SellStockCorrectionUncheckedCreateWithoutCreatedByInput> | SellStockCorrectionCreateWithoutCreatedByInput[] | SellStockCorrectionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SellStockCorrectionCreateOrConnectWithoutCreatedByInput | SellStockCorrectionCreateOrConnectWithoutCreatedByInput[]
    createMany?: SellStockCorrectionCreateManyCreatedByInputEnvelope
    connect?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
  }

  export type SellStockCorrectionCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<SellStockCorrectionCreateWithoutUpdatedByInput, SellStockCorrectionUncheckedCreateWithoutUpdatedByInput> | SellStockCorrectionCreateWithoutUpdatedByInput[] | SellStockCorrectionUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: SellStockCorrectionCreateOrConnectWithoutUpdatedByInput | SellStockCorrectionCreateOrConnectWithoutUpdatedByInput[]
    createMany?: SellStockCorrectionCreateManyUpdatedByInputEnvelope
    connect?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
  }

  export type AddToCartCreateNestedManyWithoutUserInput = {
    create?: XOR<AddToCartCreateWithoutUserInput, AddToCartUncheckedCreateWithoutUserInput> | AddToCartCreateWithoutUserInput[] | AddToCartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddToCartCreateOrConnectWithoutUserInput | AddToCartCreateOrConnectWithoutUserInput[]
    createMany?: AddToCartCreateManyUserInputEnvelope
    connect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
  }

  export type AddToCartCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AddToCartCreateWithoutCreatedByInput, AddToCartUncheckedCreateWithoutCreatedByInput> | AddToCartCreateWithoutCreatedByInput[] | AddToCartUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AddToCartCreateOrConnectWithoutCreatedByInput | AddToCartCreateOrConnectWithoutCreatedByInput[]
    createMany?: AddToCartCreateManyCreatedByInputEnvelope
    connect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
  }

  export type AddToCartCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<AddToCartCreateWithoutUpdatedByInput, AddToCartUncheckedCreateWithoutUpdatedByInput> | AddToCartCreateWithoutUpdatedByInput[] | AddToCartUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: AddToCartCreateOrConnectWithoutUpdatedByInput | AddToCartCreateOrConnectWithoutUpdatedByInput[]
    createMany?: AddToCartCreateManyUpdatedByInputEnvelope
    connect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
  }

  export type WaitlistCreateNestedManyWithoutUserInput = {
    create?: XOR<WaitlistCreateWithoutUserInput, WaitlistUncheckedCreateWithoutUserInput> | WaitlistCreateWithoutUserInput[] | WaitlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutUserInput | WaitlistCreateOrConnectWithoutUserInput[]
    createMany?: WaitlistCreateManyUserInputEnvelope
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
  }

  export type WaitlistCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<WaitlistCreateWithoutCreatedByInput, WaitlistUncheckedCreateWithoutCreatedByInput> | WaitlistCreateWithoutCreatedByInput[] | WaitlistUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutCreatedByInput | WaitlistCreateOrConnectWithoutCreatedByInput[]
    createMany?: WaitlistCreateManyCreatedByInputEnvelope
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
  }

  export type WaitlistCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<WaitlistCreateWithoutUpdatedByInput, WaitlistUncheckedCreateWithoutUpdatedByInput> | WaitlistCreateWithoutUpdatedByInput[] | WaitlistUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutUpdatedByInput | WaitlistCreateOrConnectWithoutUpdatedByInput[]
    createMany?: WaitlistCreateManyUpdatedByInputEnvelope
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
  }

  export type ShopUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ShopCreateWithoutUserInput, ShopUncheckedCreateWithoutUserInput> | ShopCreateWithoutUserInput[] | ShopUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutUserInput | ShopCreateOrConnectWithoutUserInput[]
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
  }

  export type StoreUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StoreCreateWithoutUserInput, StoreUncheckedCreateWithoutUserInput> | StoreCreateWithoutUserInput[] | StoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoreCreateOrConnectWithoutUserInput | StoreCreateOrConnectWithoutUserInput[]
    connect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
  }

  export type LogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type StockLedgerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StockLedgerCreateWithoutUserInput, StockLedgerUncheckedCreateWithoutUserInput> | StockLedgerCreateWithoutUserInput[] | StockLedgerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutUserInput | StockLedgerCreateOrConnectWithoutUserInput[]
    createMany?: StockLedgerCreateManyUserInputEnvelope
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PurchaseCreateWithoutCreatedByInput, PurchaseUncheckedCreateWithoutCreatedByInput> | PurchaseCreateWithoutCreatedByInput[] | PurchaseUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutCreatedByInput | PurchaseCreateOrConnectWithoutCreatedByInput[]
    createMany?: PurchaseCreateManyCreatedByInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<PurchaseCreateWithoutUpdatedByInput, PurchaseUncheckedCreateWithoutUpdatedByInput> | PurchaseCreateWithoutUpdatedByInput[] | PurchaseUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutUpdatedByInput | PurchaseCreateOrConnectWithoutUpdatedByInput[]
    createMany?: PurchaseCreateManyUpdatedByInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TransferCreateWithoutCreatedByInput, TransferUncheckedCreateWithoutCreatedByInput> | TransferCreateWithoutCreatedByInput[] | TransferUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutCreatedByInput | TransferCreateOrConnectWithoutCreatedByInput[]
    createMany?: TransferCreateManyCreatedByInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<TransferCreateWithoutUpdatedByInput, TransferUncheckedCreateWithoutUpdatedByInput> | TransferCreateWithoutUpdatedByInput[] | TransferUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutUpdatedByInput | TransferCreateOrConnectWithoutUpdatedByInput[]
    createMany?: TransferCreateManyUpdatedByInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type StockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<StockCorrectionCreateWithoutCreatedByInput, StockCorrectionUncheckedCreateWithoutCreatedByInput> | StockCorrectionCreateWithoutCreatedByInput[] | StockCorrectionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StockCorrectionCreateOrConnectWithoutCreatedByInput | StockCorrectionCreateOrConnectWithoutCreatedByInput[]
    createMany?: StockCorrectionCreateManyCreatedByInputEnvelope
    connect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
  }

  export type StockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<StockCorrectionCreateWithoutUpdatedByInput, StockCorrectionUncheckedCreateWithoutUpdatedByInput> | StockCorrectionCreateWithoutUpdatedByInput[] | StockCorrectionUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: StockCorrectionCreateOrConnectWithoutUpdatedByInput | StockCorrectionCreateOrConnectWithoutUpdatedByInput[]
    createMany?: StockCorrectionCreateManyUpdatedByInputEnvelope
    connect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
  }

  export type SellUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SellCreateWithoutCreatedByInput, SellUncheckedCreateWithoutCreatedByInput> | SellCreateWithoutCreatedByInput[] | SellUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SellCreateOrConnectWithoutCreatedByInput | SellCreateOrConnectWithoutCreatedByInput[]
    createMany?: SellCreateManyCreatedByInputEnvelope
    connect?: SellWhereUniqueInput | SellWhereUniqueInput[]
  }

  export type SellUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<SellCreateWithoutUpdatedByInput, SellUncheckedCreateWithoutUpdatedByInput> | SellCreateWithoutUpdatedByInput[] | SellUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: SellCreateOrConnectWithoutUpdatedByInput | SellCreateOrConnectWithoutUpdatedByInput[]
    createMany?: SellCreateManyUpdatedByInputEnvelope
    connect?: SellWhereUniqueInput | SellWhereUniqueInput[]
  }

  export type SellStockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SellStockCorrectionCreateWithoutCreatedByInput, SellStockCorrectionUncheckedCreateWithoutCreatedByInput> | SellStockCorrectionCreateWithoutCreatedByInput[] | SellStockCorrectionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SellStockCorrectionCreateOrConnectWithoutCreatedByInput | SellStockCorrectionCreateOrConnectWithoutCreatedByInput[]
    createMany?: SellStockCorrectionCreateManyCreatedByInputEnvelope
    connect?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
  }

  export type SellStockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<SellStockCorrectionCreateWithoutUpdatedByInput, SellStockCorrectionUncheckedCreateWithoutUpdatedByInput> | SellStockCorrectionCreateWithoutUpdatedByInput[] | SellStockCorrectionUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: SellStockCorrectionCreateOrConnectWithoutUpdatedByInput | SellStockCorrectionCreateOrConnectWithoutUpdatedByInput[]
    createMany?: SellStockCorrectionCreateManyUpdatedByInputEnvelope
    connect?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
  }

  export type AddToCartUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AddToCartCreateWithoutUserInput, AddToCartUncheckedCreateWithoutUserInput> | AddToCartCreateWithoutUserInput[] | AddToCartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddToCartCreateOrConnectWithoutUserInput | AddToCartCreateOrConnectWithoutUserInput[]
    createMany?: AddToCartCreateManyUserInputEnvelope
    connect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
  }

  export type AddToCartUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AddToCartCreateWithoutCreatedByInput, AddToCartUncheckedCreateWithoutCreatedByInput> | AddToCartCreateWithoutCreatedByInput[] | AddToCartUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AddToCartCreateOrConnectWithoutCreatedByInput | AddToCartCreateOrConnectWithoutCreatedByInput[]
    createMany?: AddToCartCreateManyCreatedByInputEnvelope
    connect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
  }

  export type AddToCartUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<AddToCartCreateWithoutUpdatedByInput, AddToCartUncheckedCreateWithoutUpdatedByInput> | AddToCartCreateWithoutUpdatedByInput[] | AddToCartUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: AddToCartCreateOrConnectWithoutUpdatedByInput | AddToCartCreateOrConnectWithoutUpdatedByInput[]
    createMany?: AddToCartCreateManyUpdatedByInputEnvelope
    connect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
  }

  export type WaitlistUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WaitlistCreateWithoutUserInput, WaitlistUncheckedCreateWithoutUserInput> | WaitlistCreateWithoutUserInput[] | WaitlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutUserInput | WaitlistCreateOrConnectWithoutUserInput[]
    createMany?: WaitlistCreateManyUserInputEnvelope
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
  }

  export type WaitlistUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<WaitlistCreateWithoutCreatedByInput, WaitlistUncheckedCreateWithoutCreatedByInput> | WaitlistCreateWithoutCreatedByInput[] | WaitlistUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutCreatedByInput | WaitlistCreateOrConnectWithoutCreatedByInput[]
    createMany?: WaitlistCreateManyCreatedByInputEnvelope
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
  }

  export type WaitlistUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<WaitlistCreateWithoutUpdatedByInput, WaitlistUncheckedCreateWithoutUpdatedByInput> | WaitlistCreateWithoutUpdatedByInput[] | WaitlistUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutUpdatedByInput | WaitlistCreateOrConnectWithoutUpdatedByInput[]
    createMany?: WaitlistCreateManyUpdatedByInputEnvelope
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BranchUpdateOneWithoutUserNestedInput = {
    create?: XOR<BranchCreateWithoutUserInput, BranchUncheckedCreateWithoutUserInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUserInput
    upsert?: BranchUpsertWithoutUserInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutUserInput, BranchUpdateWithoutUserInput>, BranchUncheckedUpdateWithoutUserInput>
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type ShopUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShopCreateWithoutUserInput, ShopUncheckedCreateWithoutUserInput> | ShopCreateWithoutUserInput[] | ShopUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutUserInput | ShopCreateOrConnectWithoutUserInput[]
    upsert?: ShopUpsertWithWhereUniqueWithoutUserInput | ShopUpsertWithWhereUniqueWithoutUserInput[]
    set?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    disconnect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    delete?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    update?: ShopUpdateWithWhereUniqueWithoutUserInput | ShopUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShopUpdateManyWithWhereWithoutUserInput | ShopUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShopScalarWhereInput | ShopScalarWhereInput[]
  }

  export type StoreUpdateManyWithoutUserNestedInput = {
    create?: XOR<StoreCreateWithoutUserInput, StoreUncheckedCreateWithoutUserInput> | StoreCreateWithoutUserInput[] | StoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoreCreateOrConnectWithoutUserInput | StoreCreateOrConnectWithoutUserInput[]
    upsert?: StoreUpsertWithWhereUniqueWithoutUserInput | StoreUpsertWithWhereUniqueWithoutUserInput[]
    set?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    disconnect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    delete?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    connect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    update?: StoreUpdateWithWhereUniqueWithoutUserInput | StoreUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StoreUpdateManyWithWhereWithoutUserInput | StoreUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StoreScalarWhereInput | StoreScalarWhereInput[]
  }

  export type LogUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutUserInput | LogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutUserInput | LogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogUpdateManyWithWhereWithoutUserInput | LogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type StockLedgerUpdateManyWithoutUserNestedInput = {
    create?: XOR<StockLedgerCreateWithoutUserInput, StockLedgerUncheckedCreateWithoutUserInput> | StockLedgerCreateWithoutUserInput[] | StockLedgerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutUserInput | StockLedgerCreateOrConnectWithoutUserInput[]
    upsert?: StockLedgerUpsertWithWhereUniqueWithoutUserInput | StockLedgerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StockLedgerCreateManyUserInputEnvelope
    set?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    disconnect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    delete?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    update?: StockLedgerUpdateWithWhereUniqueWithoutUserInput | StockLedgerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StockLedgerUpdateManyWithWhereWithoutUserInput | StockLedgerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StockLedgerScalarWhereInput | StockLedgerScalarWhereInput[]
  }

  export type PurchaseUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PurchaseCreateWithoutCreatedByInput, PurchaseUncheckedCreateWithoutCreatedByInput> | PurchaseCreateWithoutCreatedByInput[] | PurchaseUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutCreatedByInput | PurchaseCreateOrConnectWithoutCreatedByInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutCreatedByInput | PurchaseUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PurchaseCreateManyCreatedByInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutCreatedByInput | PurchaseUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutCreatedByInput | PurchaseUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type PurchaseUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<PurchaseCreateWithoutUpdatedByInput, PurchaseUncheckedCreateWithoutUpdatedByInput> | PurchaseCreateWithoutUpdatedByInput[] | PurchaseUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutUpdatedByInput | PurchaseCreateOrConnectWithoutUpdatedByInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutUpdatedByInput | PurchaseUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: PurchaseCreateManyUpdatedByInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutUpdatedByInput | PurchaseUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutUpdatedByInput | PurchaseUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TransferCreateWithoutCreatedByInput, TransferUncheckedCreateWithoutCreatedByInput> | TransferCreateWithoutCreatedByInput[] | TransferUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutCreatedByInput | TransferCreateOrConnectWithoutCreatedByInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutCreatedByInput | TransferUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TransferCreateManyCreatedByInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutCreatedByInput | TransferUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutCreatedByInput | TransferUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<TransferCreateWithoutUpdatedByInput, TransferUncheckedCreateWithoutUpdatedByInput> | TransferCreateWithoutUpdatedByInput[] | TransferUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutUpdatedByInput | TransferCreateOrConnectWithoutUpdatedByInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutUpdatedByInput | TransferUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: TransferCreateManyUpdatedByInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutUpdatedByInput | TransferUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutUpdatedByInput | TransferUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type StockCorrectionUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<StockCorrectionCreateWithoutCreatedByInput, StockCorrectionUncheckedCreateWithoutCreatedByInput> | StockCorrectionCreateWithoutCreatedByInput[] | StockCorrectionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StockCorrectionCreateOrConnectWithoutCreatedByInput | StockCorrectionCreateOrConnectWithoutCreatedByInput[]
    upsert?: StockCorrectionUpsertWithWhereUniqueWithoutCreatedByInput | StockCorrectionUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: StockCorrectionCreateManyCreatedByInputEnvelope
    set?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    disconnect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    delete?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    connect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    update?: StockCorrectionUpdateWithWhereUniqueWithoutCreatedByInput | StockCorrectionUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: StockCorrectionUpdateManyWithWhereWithoutCreatedByInput | StockCorrectionUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: StockCorrectionScalarWhereInput | StockCorrectionScalarWhereInput[]
  }

  export type StockCorrectionUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<StockCorrectionCreateWithoutUpdatedByInput, StockCorrectionUncheckedCreateWithoutUpdatedByInput> | StockCorrectionCreateWithoutUpdatedByInput[] | StockCorrectionUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: StockCorrectionCreateOrConnectWithoutUpdatedByInput | StockCorrectionCreateOrConnectWithoutUpdatedByInput[]
    upsert?: StockCorrectionUpsertWithWhereUniqueWithoutUpdatedByInput | StockCorrectionUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: StockCorrectionCreateManyUpdatedByInputEnvelope
    set?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    disconnect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    delete?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    connect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    update?: StockCorrectionUpdateWithWhereUniqueWithoutUpdatedByInput | StockCorrectionUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: StockCorrectionUpdateManyWithWhereWithoutUpdatedByInput | StockCorrectionUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: StockCorrectionScalarWhereInput | StockCorrectionScalarWhereInput[]
  }

  export type SellUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SellCreateWithoutCreatedByInput, SellUncheckedCreateWithoutCreatedByInput> | SellCreateWithoutCreatedByInput[] | SellUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SellCreateOrConnectWithoutCreatedByInput | SellCreateOrConnectWithoutCreatedByInput[]
    upsert?: SellUpsertWithWhereUniqueWithoutCreatedByInput | SellUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SellCreateManyCreatedByInputEnvelope
    set?: SellWhereUniqueInput | SellWhereUniqueInput[]
    disconnect?: SellWhereUniqueInput | SellWhereUniqueInput[]
    delete?: SellWhereUniqueInput | SellWhereUniqueInput[]
    connect?: SellWhereUniqueInput | SellWhereUniqueInput[]
    update?: SellUpdateWithWhereUniqueWithoutCreatedByInput | SellUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SellUpdateManyWithWhereWithoutCreatedByInput | SellUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SellScalarWhereInput | SellScalarWhereInput[]
  }

  export type SellUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<SellCreateWithoutUpdatedByInput, SellUncheckedCreateWithoutUpdatedByInput> | SellCreateWithoutUpdatedByInput[] | SellUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: SellCreateOrConnectWithoutUpdatedByInput | SellCreateOrConnectWithoutUpdatedByInput[]
    upsert?: SellUpsertWithWhereUniqueWithoutUpdatedByInput | SellUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: SellCreateManyUpdatedByInputEnvelope
    set?: SellWhereUniqueInput | SellWhereUniqueInput[]
    disconnect?: SellWhereUniqueInput | SellWhereUniqueInput[]
    delete?: SellWhereUniqueInput | SellWhereUniqueInput[]
    connect?: SellWhereUniqueInput | SellWhereUniqueInput[]
    update?: SellUpdateWithWhereUniqueWithoutUpdatedByInput | SellUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: SellUpdateManyWithWhereWithoutUpdatedByInput | SellUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: SellScalarWhereInput | SellScalarWhereInput[]
  }

  export type SellStockCorrectionUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SellStockCorrectionCreateWithoutCreatedByInput, SellStockCorrectionUncheckedCreateWithoutCreatedByInput> | SellStockCorrectionCreateWithoutCreatedByInput[] | SellStockCorrectionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SellStockCorrectionCreateOrConnectWithoutCreatedByInput | SellStockCorrectionCreateOrConnectWithoutCreatedByInput[]
    upsert?: SellStockCorrectionUpsertWithWhereUniqueWithoutCreatedByInput | SellStockCorrectionUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SellStockCorrectionCreateManyCreatedByInputEnvelope
    set?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
    disconnect?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
    delete?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
    connect?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
    update?: SellStockCorrectionUpdateWithWhereUniqueWithoutCreatedByInput | SellStockCorrectionUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SellStockCorrectionUpdateManyWithWhereWithoutCreatedByInput | SellStockCorrectionUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SellStockCorrectionScalarWhereInput | SellStockCorrectionScalarWhereInput[]
  }

  export type SellStockCorrectionUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<SellStockCorrectionCreateWithoutUpdatedByInput, SellStockCorrectionUncheckedCreateWithoutUpdatedByInput> | SellStockCorrectionCreateWithoutUpdatedByInput[] | SellStockCorrectionUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: SellStockCorrectionCreateOrConnectWithoutUpdatedByInput | SellStockCorrectionCreateOrConnectWithoutUpdatedByInput[]
    upsert?: SellStockCorrectionUpsertWithWhereUniqueWithoutUpdatedByInput | SellStockCorrectionUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: SellStockCorrectionCreateManyUpdatedByInputEnvelope
    set?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
    disconnect?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
    delete?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
    connect?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
    update?: SellStockCorrectionUpdateWithWhereUniqueWithoutUpdatedByInput | SellStockCorrectionUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: SellStockCorrectionUpdateManyWithWhereWithoutUpdatedByInput | SellStockCorrectionUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: SellStockCorrectionScalarWhereInput | SellStockCorrectionScalarWhereInput[]
  }

  export type AddToCartUpdateManyWithoutUserNestedInput = {
    create?: XOR<AddToCartCreateWithoutUserInput, AddToCartUncheckedCreateWithoutUserInput> | AddToCartCreateWithoutUserInput[] | AddToCartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddToCartCreateOrConnectWithoutUserInput | AddToCartCreateOrConnectWithoutUserInput[]
    upsert?: AddToCartUpsertWithWhereUniqueWithoutUserInput | AddToCartUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AddToCartCreateManyUserInputEnvelope
    set?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    disconnect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    delete?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    connect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    update?: AddToCartUpdateWithWhereUniqueWithoutUserInput | AddToCartUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AddToCartUpdateManyWithWhereWithoutUserInput | AddToCartUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AddToCartScalarWhereInput | AddToCartScalarWhereInput[]
  }

  export type AddToCartUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AddToCartCreateWithoutCreatedByInput, AddToCartUncheckedCreateWithoutCreatedByInput> | AddToCartCreateWithoutCreatedByInput[] | AddToCartUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AddToCartCreateOrConnectWithoutCreatedByInput | AddToCartCreateOrConnectWithoutCreatedByInput[]
    upsert?: AddToCartUpsertWithWhereUniqueWithoutCreatedByInput | AddToCartUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AddToCartCreateManyCreatedByInputEnvelope
    set?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    disconnect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    delete?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    connect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    update?: AddToCartUpdateWithWhereUniqueWithoutCreatedByInput | AddToCartUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AddToCartUpdateManyWithWhereWithoutCreatedByInput | AddToCartUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AddToCartScalarWhereInput | AddToCartScalarWhereInput[]
  }

  export type AddToCartUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<AddToCartCreateWithoutUpdatedByInput, AddToCartUncheckedCreateWithoutUpdatedByInput> | AddToCartCreateWithoutUpdatedByInput[] | AddToCartUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: AddToCartCreateOrConnectWithoutUpdatedByInput | AddToCartCreateOrConnectWithoutUpdatedByInput[]
    upsert?: AddToCartUpsertWithWhereUniqueWithoutUpdatedByInput | AddToCartUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: AddToCartCreateManyUpdatedByInputEnvelope
    set?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    disconnect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    delete?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    connect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    update?: AddToCartUpdateWithWhereUniqueWithoutUpdatedByInput | AddToCartUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: AddToCartUpdateManyWithWhereWithoutUpdatedByInput | AddToCartUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: AddToCartScalarWhereInput | AddToCartScalarWhereInput[]
  }

  export type WaitlistUpdateManyWithoutUserNestedInput = {
    create?: XOR<WaitlistCreateWithoutUserInput, WaitlistUncheckedCreateWithoutUserInput> | WaitlistCreateWithoutUserInput[] | WaitlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutUserInput | WaitlistCreateOrConnectWithoutUserInput[]
    upsert?: WaitlistUpsertWithWhereUniqueWithoutUserInput | WaitlistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WaitlistCreateManyUserInputEnvelope
    set?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    disconnect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    delete?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    update?: WaitlistUpdateWithWhereUniqueWithoutUserInput | WaitlistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WaitlistUpdateManyWithWhereWithoutUserInput | WaitlistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WaitlistScalarWhereInput | WaitlistScalarWhereInput[]
  }

  export type WaitlistUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<WaitlistCreateWithoutCreatedByInput, WaitlistUncheckedCreateWithoutCreatedByInput> | WaitlistCreateWithoutCreatedByInput[] | WaitlistUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutCreatedByInput | WaitlistCreateOrConnectWithoutCreatedByInput[]
    upsert?: WaitlistUpsertWithWhereUniqueWithoutCreatedByInput | WaitlistUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: WaitlistCreateManyCreatedByInputEnvelope
    set?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    disconnect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    delete?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    update?: WaitlistUpdateWithWhereUniqueWithoutCreatedByInput | WaitlistUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: WaitlistUpdateManyWithWhereWithoutCreatedByInput | WaitlistUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: WaitlistScalarWhereInput | WaitlistScalarWhereInput[]
  }

  export type WaitlistUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<WaitlistCreateWithoutUpdatedByInput, WaitlistUncheckedCreateWithoutUpdatedByInput> | WaitlistCreateWithoutUpdatedByInput[] | WaitlistUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutUpdatedByInput | WaitlistCreateOrConnectWithoutUpdatedByInput[]
    upsert?: WaitlistUpsertWithWhereUniqueWithoutUpdatedByInput | WaitlistUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: WaitlistCreateManyUpdatedByInputEnvelope
    set?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    disconnect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    delete?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    update?: WaitlistUpdateWithWhereUniqueWithoutUpdatedByInput | WaitlistUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: WaitlistUpdateManyWithWhereWithoutUpdatedByInput | WaitlistUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: WaitlistScalarWhereInput | WaitlistScalarWhereInput[]
  }

  export type ShopUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShopCreateWithoutUserInput, ShopUncheckedCreateWithoutUserInput> | ShopCreateWithoutUserInput[] | ShopUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutUserInput | ShopCreateOrConnectWithoutUserInput[]
    upsert?: ShopUpsertWithWhereUniqueWithoutUserInput | ShopUpsertWithWhereUniqueWithoutUserInput[]
    set?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    disconnect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    delete?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    update?: ShopUpdateWithWhereUniqueWithoutUserInput | ShopUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShopUpdateManyWithWhereWithoutUserInput | ShopUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShopScalarWhereInput | ShopScalarWhereInput[]
  }

  export type StoreUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StoreCreateWithoutUserInput, StoreUncheckedCreateWithoutUserInput> | StoreCreateWithoutUserInput[] | StoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoreCreateOrConnectWithoutUserInput | StoreCreateOrConnectWithoutUserInput[]
    upsert?: StoreUpsertWithWhereUniqueWithoutUserInput | StoreUpsertWithWhereUniqueWithoutUserInput[]
    set?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    disconnect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    delete?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    connect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    update?: StoreUpdateWithWhereUniqueWithoutUserInput | StoreUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StoreUpdateManyWithWhereWithoutUserInput | StoreUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StoreScalarWhereInput | StoreScalarWhereInput[]
  }

  export type LogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutUserInput | LogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutUserInput | LogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogUpdateManyWithWhereWithoutUserInput | LogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type StockLedgerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StockLedgerCreateWithoutUserInput, StockLedgerUncheckedCreateWithoutUserInput> | StockLedgerCreateWithoutUserInput[] | StockLedgerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutUserInput | StockLedgerCreateOrConnectWithoutUserInput[]
    upsert?: StockLedgerUpsertWithWhereUniqueWithoutUserInput | StockLedgerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StockLedgerCreateManyUserInputEnvelope
    set?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    disconnect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    delete?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    update?: StockLedgerUpdateWithWhereUniqueWithoutUserInput | StockLedgerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StockLedgerUpdateManyWithWhereWithoutUserInput | StockLedgerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StockLedgerScalarWhereInput | StockLedgerScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PurchaseCreateWithoutCreatedByInput, PurchaseUncheckedCreateWithoutCreatedByInput> | PurchaseCreateWithoutCreatedByInput[] | PurchaseUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutCreatedByInput | PurchaseCreateOrConnectWithoutCreatedByInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutCreatedByInput | PurchaseUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PurchaseCreateManyCreatedByInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutCreatedByInput | PurchaseUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutCreatedByInput | PurchaseUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<PurchaseCreateWithoutUpdatedByInput, PurchaseUncheckedCreateWithoutUpdatedByInput> | PurchaseCreateWithoutUpdatedByInput[] | PurchaseUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutUpdatedByInput | PurchaseCreateOrConnectWithoutUpdatedByInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutUpdatedByInput | PurchaseUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: PurchaseCreateManyUpdatedByInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutUpdatedByInput | PurchaseUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutUpdatedByInput | PurchaseUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TransferCreateWithoutCreatedByInput, TransferUncheckedCreateWithoutCreatedByInput> | TransferCreateWithoutCreatedByInput[] | TransferUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutCreatedByInput | TransferCreateOrConnectWithoutCreatedByInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutCreatedByInput | TransferUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TransferCreateManyCreatedByInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutCreatedByInput | TransferUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutCreatedByInput | TransferUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<TransferCreateWithoutUpdatedByInput, TransferUncheckedCreateWithoutUpdatedByInput> | TransferCreateWithoutUpdatedByInput[] | TransferUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutUpdatedByInput | TransferCreateOrConnectWithoutUpdatedByInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutUpdatedByInput | TransferUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: TransferCreateManyUpdatedByInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutUpdatedByInput | TransferUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutUpdatedByInput | TransferUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type StockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<StockCorrectionCreateWithoutCreatedByInput, StockCorrectionUncheckedCreateWithoutCreatedByInput> | StockCorrectionCreateWithoutCreatedByInput[] | StockCorrectionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StockCorrectionCreateOrConnectWithoutCreatedByInput | StockCorrectionCreateOrConnectWithoutCreatedByInput[]
    upsert?: StockCorrectionUpsertWithWhereUniqueWithoutCreatedByInput | StockCorrectionUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: StockCorrectionCreateManyCreatedByInputEnvelope
    set?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    disconnect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    delete?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    connect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    update?: StockCorrectionUpdateWithWhereUniqueWithoutCreatedByInput | StockCorrectionUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: StockCorrectionUpdateManyWithWhereWithoutCreatedByInput | StockCorrectionUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: StockCorrectionScalarWhereInput | StockCorrectionScalarWhereInput[]
  }

  export type StockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<StockCorrectionCreateWithoutUpdatedByInput, StockCorrectionUncheckedCreateWithoutUpdatedByInput> | StockCorrectionCreateWithoutUpdatedByInput[] | StockCorrectionUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: StockCorrectionCreateOrConnectWithoutUpdatedByInput | StockCorrectionCreateOrConnectWithoutUpdatedByInput[]
    upsert?: StockCorrectionUpsertWithWhereUniqueWithoutUpdatedByInput | StockCorrectionUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: StockCorrectionCreateManyUpdatedByInputEnvelope
    set?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    disconnect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    delete?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    connect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    update?: StockCorrectionUpdateWithWhereUniqueWithoutUpdatedByInput | StockCorrectionUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: StockCorrectionUpdateManyWithWhereWithoutUpdatedByInput | StockCorrectionUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: StockCorrectionScalarWhereInput | StockCorrectionScalarWhereInput[]
  }

  export type SellUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SellCreateWithoutCreatedByInput, SellUncheckedCreateWithoutCreatedByInput> | SellCreateWithoutCreatedByInput[] | SellUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SellCreateOrConnectWithoutCreatedByInput | SellCreateOrConnectWithoutCreatedByInput[]
    upsert?: SellUpsertWithWhereUniqueWithoutCreatedByInput | SellUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SellCreateManyCreatedByInputEnvelope
    set?: SellWhereUniqueInput | SellWhereUniqueInput[]
    disconnect?: SellWhereUniqueInput | SellWhereUniqueInput[]
    delete?: SellWhereUniqueInput | SellWhereUniqueInput[]
    connect?: SellWhereUniqueInput | SellWhereUniqueInput[]
    update?: SellUpdateWithWhereUniqueWithoutCreatedByInput | SellUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SellUpdateManyWithWhereWithoutCreatedByInput | SellUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SellScalarWhereInput | SellScalarWhereInput[]
  }

  export type SellUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<SellCreateWithoutUpdatedByInput, SellUncheckedCreateWithoutUpdatedByInput> | SellCreateWithoutUpdatedByInput[] | SellUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: SellCreateOrConnectWithoutUpdatedByInput | SellCreateOrConnectWithoutUpdatedByInput[]
    upsert?: SellUpsertWithWhereUniqueWithoutUpdatedByInput | SellUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: SellCreateManyUpdatedByInputEnvelope
    set?: SellWhereUniqueInput | SellWhereUniqueInput[]
    disconnect?: SellWhereUniqueInput | SellWhereUniqueInput[]
    delete?: SellWhereUniqueInput | SellWhereUniqueInput[]
    connect?: SellWhereUniqueInput | SellWhereUniqueInput[]
    update?: SellUpdateWithWhereUniqueWithoutUpdatedByInput | SellUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: SellUpdateManyWithWhereWithoutUpdatedByInput | SellUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: SellScalarWhereInput | SellScalarWhereInput[]
  }

  export type SellStockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SellStockCorrectionCreateWithoutCreatedByInput, SellStockCorrectionUncheckedCreateWithoutCreatedByInput> | SellStockCorrectionCreateWithoutCreatedByInput[] | SellStockCorrectionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SellStockCorrectionCreateOrConnectWithoutCreatedByInput | SellStockCorrectionCreateOrConnectWithoutCreatedByInput[]
    upsert?: SellStockCorrectionUpsertWithWhereUniqueWithoutCreatedByInput | SellStockCorrectionUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SellStockCorrectionCreateManyCreatedByInputEnvelope
    set?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
    disconnect?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
    delete?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
    connect?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
    update?: SellStockCorrectionUpdateWithWhereUniqueWithoutCreatedByInput | SellStockCorrectionUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SellStockCorrectionUpdateManyWithWhereWithoutCreatedByInput | SellStockCorrectionUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SellStockCorrectionScalarWhereInput | SellStockCorrectionScalarWhereInput[]
  }

  export type SellStockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<SellStockCorrectionCreateWithoutUpdatedByInput, SellStockCorrectionUncheckedCreateWithoutUpdatedByInput> | SellStockCorrectionCreateWithoutUpdatedByInput[] | SellStockCorrectionUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: SellStockCorrectionCreateOrConnectWithoutUpdatedByInput | SellStockCorrectionCreateOrConnectWithoutUpdatedByInput[]
    upsert?: SellStockCorrectionUpsertWithWhereUniqueWithoutUpdatedByInput | SellStockCorrectionUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: SellStockCorrectionCreateManyUpdatedByInputEnvelope
    set?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
    disconnect?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
    delete?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
    connect?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
    update?: SellStockCorrectionUpdateWithWhereUniqueWithoutUpdatedByInput | SellStockCorrectionUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: SellStockCorrectionUpdateManyWithWhereWithoutUpdatedByInput | SellStockCorrectionUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: SellStockCorrectionScalarWhereInput | SellStockCorrectionScalarWhereInput[]
  }

  export type AddToCartUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AddToCartCreateWithoutUserInput, AddToCartUncheckedCreateWithoutUserInput> | AddToCartCreateWithoutUserInput[] | AddToCartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddToCartCreateOrConnectWithoutUserInput | AddToCartCreateOrConnectWithoutUserInput[]
    upsert?: AddToCartUpsertWithWhereUniqueWithoutUserInput | AddToCartUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AddToCartCreateManyUserInputEnvelope
    set?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    disconnect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    delete?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    connect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    update?: AddToCartUpdateWithWhereUniqueWithoutUserInput | AddToCartUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AddToCartUpdateManyWithWhereWithoutUserInput | AddToCartUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AddToCartScalarWhereInput | AddToCartScalarWhereInput[]
  }

  export type AddToCartUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AddToCartCreateWithoutCreatedByInput, AddToCartUncheckedCreateWithoutCreatedByInput> | AddToCartCreateWithoutCreatedByInput[] | AddToCartUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AddToCartCreateOrConnectWithoutCreatedByInput | AddToCartCreateOrConnectWithoutCreatedByInput[]
    upsert?: AddToCartUpsertWithWhereUniqueWithoutCreatedByInput | AddToCartUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AddToCartCreateManyCreatedByInputEnvelope
    set?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    disconnect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    delete?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    connect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    update?: AddToCartUpdateWithWhereUniqueWithoutCreatedByInput | AddToCartUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AddToCartUpdateManyWithWhereWithoutCreatedByInput | AddToCartUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AddToCartScalarWhereInput | AddToCartScalarWhereInput[]
  }

  export type AddToCartUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<AddToCartCreateWithoutUpdatedByInput, AddToCartUncheckedCreateWithoutUpdatedByInput> | AddToCartCreateWithoutUpdatedByInput[] | AddToCartUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: AddToCartCreateOrConnectWithoutUpdatedByInput | AddToCartCreateOrConnectWithoutUpdatedByInput[]
    upsert?: AddToCartUpsertWithWhereUniqueWithoutUpdatedByInput | AddToCartUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: AddToCartCreateManyUpdatedByInputEnvelope
    set?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    disconnect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    delete?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    connect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    update?: AddToCartUpdateWithWhereUniqueWithoutUpdatedByInput | AddToCartUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: AddToCartUpdateManyWithWhereWithoutUpdatedByInput | AddToCartUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: AddToCartScalarWhereInput | AddToCartScalarWhereInput[]
  }

  export type WaitlistUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WaitlistCreateWithoutUserInput, WaitlistUncheckedCreateWithoutUserInput> | WaitlistCreateWithoutUserInput[] | WaitlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutUserInput | WaitlistCreateOrConnectWithoutUserInput[]
    upsert?: WaitlistUpsertWithWhereUniqueWithoutUserInput | WaitlistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WaitlistCreateManyUserInputEnvelope
    set?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    disconnect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    delete?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    update?: WaitlistUpdateWithWhereUniqueWithoutUserInput | WaitlistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WaitlistUpdateManyWithWhereWithoutUserInput | WaitlistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WaitlistScalarWhereInput | WaitlistScalarWhereInput[]
  }

  export type WaitlistUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<WaitlistCreateWithoutCreatedByInput, WaitlistUncheckedCreateWithoutCreatedByInput> | WaitlistCreateWithoutCreatedByInput[] | WaitlistUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutCreatedByInput | WaitlistCreateOrConnectWithoutCreatedByInput[]
    upsert?: WaitlistUpsertWithWhereUniqueWithoutCreatedByInput | WaitlistUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: WaitlistCreateManyCreatedByInputEnvelope
    set?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    disconnect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    delete?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    update?: WaitlistUpdateWithWhereUniqueWithoutCreatedByInput | WaitlistUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: WaitlistUpdateManyWithWhereWithoutCreatedByInput | WaitlistUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: WaitlistScalarWhereInput | WaitlistScalarWhereInput[]
  }

  export type WaitlistUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<WaitlistCreateWithoutUpdatedByInput, WaitlistUncheckedCreateWithoutUpdatedByInput> | WaitlistCreateWithoutUpdatedByInput[] | WaitlistUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutUpdatedByInput | WaitlistCreateOrConnectWithoutUpdatedByInput[]
    upsert?: WaitlistUpsertWithWhereUniqueWithoutUpdatedByInput | WaitlistUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: WaitlistCreateManyUpdatedByInputEnvelope
    set?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    disconnect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    delete?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    update?: WaitlistUpdateWithWhereUniqueWithoutUpdatedByInput | WaitlistUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: WaitlistUpdateManyWithWhereWithoutUpdatedByInput | WaitlistUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: WaitlistScalarWhereInput | WaitlistScalarWhereInput[]
  }

  export type RolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type PermissionCreateNestedOneWithoutRolesInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput
    connect?: PermissionWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
  }

  export type PermissionUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput
    upsert?: PermissionUpsertWithoutRolesInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRolesInput, PermissionUpdateWithoutRolesInput>, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    upsert?: RoleUpsertWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutPermissionsInput, RoleUpdateWithoutPermissionsInput>, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type ShopCreateNestedManyWithoutBranchInput = {
    create?: XOR<ShopCreateWithoutBranchInput, ShopUncheckedCreateWithoutBranchInput> | ShopCreateWithoutBranchInput[] | ShopUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutBranchInput | ShopCreateOrConnectWithoutBranchInput[]
    createMany?: ShopCreateManyBranchInputEnvelope
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
  }

  export type StoreCreateNestedManyWithoutBranchInput = {
    create?: XOR<StoreCreateWithoutBranchInput, StoreUncheckedCreateWithoutBranchInput> | StoreCreateWithoutBranchInput[] | StoreUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StoreCreateOrConnectWithoutBranchInput | StoreCreateOrConnectWithoutBranchInput[]
    createMany?: StoreCreateManyBranchInputEnvelope
    connect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SellCreateNestedManyWithoutBranchInput = {
    create?: XOR<SellCreateWithoutBranchInput, SellUncheckedCreateWithoutBranchInput> | SellCreateWithoutBranchInput[] | SellUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SellCreateOrConnectWithoutBranchInput | SellCreateOrConnectWithoutBranchInput[]
    createMany?: SellCreateManyBranchInputEnvelope
    connect?: SellWhereUniqueInput | SellWhereUniqueInput[]
  }

  export type AddToCartCreateNestedManyWithoutBranchInput = {
    create?: XOR<AddToCartCreateWithoutBranchInput, AddToCartUncheckedCreateWithoutBranchInput> | AddToCartCreateWithoutBranchInput[] | AddToCartUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AddToCartCreateOrConnectWithoutBranchInput | AddToCartCreateOrConnectWithoutBranchInput[]
    createMany?: AddToCartCreateManyBranchInputEnvelope
    connect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
  }

  export type WaitlistCreateNestedManyWithoutBranchInput = {
    create?: XOR<WaitlistCreateWithoutBranchInput, WaitlistUncheckedCreateWithoutBranchInput> | WaitlistCreateWithoutBranchInput[] | WaitlistUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutBranchInput | WaitlistCreateOrConnectWithoutBranchInput[]
    createMany?: WaitlistCreateManyBranchInputEnvelope
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
  }

  export type ShopUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<ShopCreateWithoutBranchInput, ShopUncheckedCreateWithoutBranchInput> | ShopCreateWithoutBranchInput[] | ShopUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutBranchInput | ShopCreateOrConnectWithoutBranchInput[]
    createMany?: ShopCreateManyBranchInputEnvelope
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
  }

  export type StoreUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<StoreCreateWithoutBranchInput, StoreUncheckedCreateWithoutBranchInput> | StoreCreateWithoutBranchInput[] | StoreUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StoreCreateOrConnectWithoutBranchInput | StoreCreateOrConnectWithoutBranchInput[]
    createMany?: StoreCreateManyBranchInputEnvelope
    connect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SellUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<SellCreateWithoutBranchInput, SellUncheckedCreateWithoutBranchInput> | SellCreateWithoutBranchInput[] | SellUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SellCreateOrConnectWithoutBranchInput | SellCreateOrConnectWithoutBranchInput[]
    createMany?: SellCreateManyBranchInputEnvelope
    connect?: SellWhereUniqueInput | SellWhereUniqueInput[]
  }

  export type AddToCartUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<AddToCartCreateWithoutBranchInput, AddToCartUncheckedCreateWithoutBranchInput> | AddToCartCreateWithoutBranchInput[] | AddToCartUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AddToCartCreateOrConnectWithoutBranchInput | AddToCartCreateOrConnectWithoutBranchInput[]
    createMany?: AddToCartCreateManyBranchInputEnvelope
    connect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
  }

  export type WaitlistUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<WaitlistCreateWithoutBranchInput, WaitlistUncheckedCreateWithoutBranchInput> | WaitlistCreateWithoutBranchInput[] | WaitlistUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutBranchInput | WaitlistCreateOrConnectWithoutBranchInput[]
    createMany?: WaitlistCreateManyBranchInputEnvelope
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
  }

  export type ShopUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ShopCreateWithoutBranchInput, ShopUncheckedCreateWithoutBranchInput> | ShopCreateWithoutBranchInput[] | ShopUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutBranchInput | ShopCreateOrConnectWithoutBranchInput[]
    upsert?: ShopUpsertWithWhereUniqueWithoutBranchInput | ShopUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ShopCreateManyBranchInputEnvelope
    set?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    disconnect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    delete?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    update?: ShopUpdateWithWhereUniqueWithoutBranchInput | ShopUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ShopUpdateManyWithWhereWithoutBranchInput | ShopUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ShopScalarWhereInput | ShopScalarWhereInput[]
  }

  export type StoreUpdateManyWithoutBranchNestedInput = {
    create?: XOR<StoreCreateWithoutBranchInput, StoreUncheckedCreateWithoutBranchInput> | StoreCreateWithoutBranchInput[] | StoreUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StoreCreateOrConnectWithoutBranchInput | StoreCreateOrConnectWithoutBranchInput[]
    upsert?: StoreUpsertWithWhereUniqueWithoutBranchInput | StoreUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: StoreCreateManyBranchInputEnvelope
    set?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    disconnect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    delete?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    connect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    update?: StoreUpdateWithWhereUniqueWithoutBranchInput | StoreUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: StoreUpdateManyWithWhereWithoutBranchInput | StoreUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: StoreScalarWhereInput | StoreScalarWhereInput[]
  }

  export type UserUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBranchInput | UserUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBranchInput | UserUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBranchInput | UserUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SellUpdateManyWithoutBranchNestedInput = {
    create?: XOR<SellCreateWithoutBranchInput, SellUncheckedCreateWithoutBranchInput> | SellCreateWithoutBranchInput[] | SellUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SellCreateOrConnectWithoutBranchInput | SellCreateOrConnectWithoutBranchInput[]
    upsert?: SellUpsertWithWhereUniqueWithoutBranchInput | SellUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: SellCreateManyBranchInputEnvelope
    set?: SellWhereUniqueInput | SellWhereUniqueInput[]
    disconnect?: SellWhereUniqueInput | SellWhereUniqueInput[]
    delete?: SellWhereUniqueInput | SellWhereUniqueInput[]
    connect?: SellWhereUniqueInput | SellWhereUniqueInput[]
    update?: SellUpdateWithWhereUniqueWithoutBranchInput | SellUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: SellUpdateManyWithWhereWithoutBranchInput | SellUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: SellScalarWhereInput | SellScalarWhereInput[]
  }

  export type AddToCartUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AddToCartCreateWithoutBranchInput, AddToCartUncheckedCreateWithoutBranchInput> | AddToCartCreateWithoutBranchInput[] | AddToCartUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AddToCartCreateOrConnectWithoutBranchInput | AddToCartCreateOrConnectWithoutBranchInput[]
    upsert?: AddToCartUpsertWithWhereUniqueWithoutBranchInput | AddToCartUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AddToCartCreateManyBranchInputEnvelope
    set?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    disconnect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    delete?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    connect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    update?: AddToCartUpdateWithWhereUniqueWithoutBranchInput | AddToCartUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AddToCartUpdateManyWithWhereWithoutBranchInput | AddToCartUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AddToCartScalarWhereInput | AddToCartScalarWhereInput[]
  }

  export type WaitlistUpdateManyWithoutBranchNestedInput = {
    create?: XOR<WaitlistCreateWithoutBranchInput, WaitlistUncheckedCreateWithoutBranchInput> | WaitlistCreateWithoutBranchInput[] | WaitlistUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutBranchInput | WaitlistCreateOrConnectWithoutBranchInput[]
    upsert?: WaitlistUpsertWithWhereUniqueWithoutBranchInput | WaitlistUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: WaitlistCreateManyBranchInputEnvelope
    set?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    disconnect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    delete?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    update?: WaitlistUpdateWithWhereUniqueWithoutBranchInput | WaitlistUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: WaitlistUpdateManyWithWhereWithoutBranchInput | WaitlistUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: WaitlistScalarWhereInput | WaitlistScalarWhereInput[]
  }

  export type ShopUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ShopCreateWithoutBranchInput, ShopUncheckedCreateWithoutBranchInput> | ShopCreateWithoutBranchInput[] | ShopUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutBranchInput | ShopCreateOrConnectWithoutBranchInput[]
    upsert?: ShopUpsertWithWhereUniqueWithoutBranchInput | ShopUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ShopCreateManyBranchInputEnvelope
    set?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    disconnect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    delete?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    update?: ShopUpdateWithWhereUniqueWithoutBranchInput | ShopUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ShopUpdateManyWithWhereWithoutBranchInput | ShopUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ShopScalarWhereInput | ShopScalarWhereInput[]
  }

  export type StoreUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<StoreCreateWithoutBranchInput, StoreUncheckedCreateWithoutBranchInput> | StoreCreateWithoutBranchInput[] | StoreUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StoreCreateOrConnectWithoutBranchInput | StoreCreateOrConnectWithoutBranchInput[]
    upsert?: StoreUpsertWithWhereUniqueWithoutBranchInput | StoreUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: StoreCreateManyBranchInputEnvelope
    set?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    disconnect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    delete?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    connect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    update?: StoreUpdateWithWhereUniqueWithoutBranchInput | StoreUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: StoreUpdateManyWithWhereWithoutBranchInput | StoreUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: StoreScalarWhereInput | StoreScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBranchInput | UserUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBranchInput | UserUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBranchInput | UserUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SellUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<SellCreateWithoutBranchInput, SellUncheckedCreateWithoutBranchInput> | SellCreateWithoutBranchInput[] | SellUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SellCreateOrConnectWithoutBranchInput | SellCreateOrConnectWithoutBranchInput[]
    upsert?: SellUpsertWithWhereUniqueWithoutBranchInput | SellUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: SellCreateManyBranchInputEnvelope
    set?: SellWhereUniqueInput | SellWhereUniqueInput[]
    disconnect?: SellWhereUniqueInput | SellWhereUniqueInput[]
    delete?: SellWhereUniqueInput | SellWhereUniqueInput[]
    connect?: SellWhereUniqueInput | SellWhereUniqueInput[]
    update?: SellUpdateWithWhereUniqueWithoutBranchInput | SellUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: SellUpdateManyWithWhereWithoutBranchInput | SellUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: SellScalarWhereInput | SellScalarWhereInput[]
  }

  export type AddToCartUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AddToCartCreateWithoutBranchInput, AddToCartUncheckedCreateWithoutBranchInput> | AddToCartCreateWithoutBranchInput[] | AddToCartUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AddToCartCreateOrConnectWithoutBranchInput | AddToCartCreateOrConnectWithoutBranchInput[]
    upsert?: AddToCartUpsertWithWhereUniqueWithoutBranchInput | AddToCartUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AddToCartCreateManyBranchInputEnvelope
    set?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    disconnect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    delete?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    connect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    update?: AddToCartUpdateWithWhereUniqueWithoutBranchInput | AddToCartUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AddToCartUpdateManyWithWhereWithoutBranchInput | AddToCartUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AddToCartScalarWhereInput | AddToCartScalarWhereInput[]
  }

  export type WaitlistUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<WaitlistCreateWithoutBranchInput, WaitlistUncheckedCreateWithoutBranchInput> | WaitlistCreateWithoutBranchInput[] | WaitlistUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutBranchInput | WaitlistCreateOrConnectWithoutBranchInput[]
    upsert?: WaitlistUpsertWithWhereUniqueWithoutBranchInput | WaitlistUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: WaitlistCreateManyBranchInputEnvelope
    set?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    disconnect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    delete?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    update?: WaitlistUpdateWithWhereUniqueWithoutBranchInput | WaitlistUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: WaitlistUpdateManyWithWhereWithoutBranchInput | WaitlistUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: WaitlistScalarWhereInput | WaitlistScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutShopInput = {
    create?: XOR<BranchCreateWithoutShopInput, BranchUncheckedCreateWithoutShopInput>
    connectOrCreate?: BranchCreateOrConnectWithoutShopInput
    connect?: BranchWhereUniqueInput
  }

  export type ShopStockCreateNestedManyWithoutShopInput = {
    create?: XOR<ShopStockCreateWithoutShopInput, ShopStockUncheckedCreateWithoutShopInput> | ShopStockCreateWithoutShopInput[] | ShopStockUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopStockCreateOrConnectWithoutShopInput | ShopStockCreateOrConnectWithoutShopInput[]
    createMany?: ShopStockCreateManyShopInputEnvelope
    connect?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
  }

  export type StockLedgerCreateNestedManyWithoutShopInput = {
    create?: XOR<StockLedgerCreateWithoutShopInput, StockLedgerUncheckedCreateWithoutShopInput> | StockLedgerCreateWithoutShopInput[] | StockLedgerUncheckedCreateWithoutShopInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutShopInput | StockLedgerCreateOrConnectWithoutShopInput[]
    createMany?: StockLedgerCreateManyShopInputEnvelope
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutSourceShopInput = {
    create?: XOR<TransferCreateWithoutSourceShopInput, TransferUncheckedCreateWithoutSourceShopInput> | TransferCreateWithoutSourceShopInput[] | TransferUncheckedCreateWithoutSourceShopInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutSourceShopInput | TransferCreateOrConnectWithoutSourceShopInput[]
    createMany?: TransferCreateManySourceShopInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutDestShopInput = {
    create?: XOR<TransferCreateWithoutDestShopInput, TransferUncheckedCreateWithoutDestShopInput> | TransferCreateWithoutDestShopInput[] | TransferUncheckedCreateWithoutDestShopInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutDestShopInput | TransferCreateOrConnectWithoutDestShopInput[]
    createMany?: TransferCreateManyDestShopInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type StockCorrectionCreateNestedManyWithoutShopInput = {
    create?: XOR<StockCorrectionCreateWithoutShopInput, StockCorrectionUncheckedCreateWithoutShopInput> | StockCorrectionCreateWithoutShopInput[] | StockCorrectionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: StockCorrectionCreateOrConnectWithoutShopInput | StockCorrectionCreateOrConnectWithoutShopInput[]
    createMany?: StockCorrectionCreateManyShopInputEnvelope
    connect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
  }

  export type AdditionalPriceCreateNestedManyWithoutShopInput = {
    create?: XOR<AdditionalPriceCreateWithoutShopInput, AdditionalPriceUncheckedCreateWithoutShopInput> | AdditionalPriceCreateWithoutShopInput[] | AdditionalPriceUncheckedCreateWithoutShopInput[]
    connectOrCreate?: AdditionalPriceCreateOrConnectWithoutShopInput | AdditionalPriceCreateOrConnectWithoutShopInput[]
    createMany?: AdditionalPriceCreateManyShopInputEnvelope
    connect?: AdditionalPriceWhereUniqueInput | AdditionalPriceWhereUniqueInput[]
  }

  export type SellItemCreateNestedManyWithoutShopInput = {
    create?: XOR<SellItemCreateWithoutShopInput, SellItemUncheckedCreateWithoutShopInput> | SellItemCreateWithoutShopInput[] | SellItemUncheckedCreateWithoutShopInput[]
    connectOrCreate?: SellItemCreateOrConnectWithoutShopInput | SellItemCreateOrConnectWithoutShopInput[]
    createMany?: SellItemCreateManyShopInputEnvelope
    connect?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
  }

  export type SellStockCorrectionItemCreateNestedManyWithoutShopInput = {
    create?: XOR<SellStockCorrectionItemCreateWithoutShopInput, SellStockCorrectionItemUncheckedCreateWithoutShopInput> | SellStockCorrectionItemCreateWithoutShopInput[] | SellStockCorrectionItemUncheckedCreateWithoutShopInput[]
    connectOrCreate?: SellStockCorrectionItemCreateOrConnectWithoutShopInput | SellStockCorrectionItemCreateOrConnectWithoutShopInput[]
    createMany?: SellStockCorrectionItemCreateManyShopInputEnvelope
    connect?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutShopsInput = {
    create?: XOR<UserCreateWithoutShopsInput, UserUncheckedCreateWithoutShopsInput> | UserCreateWithoutShopsInput[] | UserUncheckedCreateWithoutShopsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutShopsInput | UserCreateOrConnectWithoutShopsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CartItemCreateNestedManyWithoutShopInput = {
    create?: XOR<CartItemCreateWithoutShopInput, CartItemUncheckedCreateWithoutShopInput> | CartItemCreateWithoutShopInput[] | CartItemUncheckedCreateWithoutShopInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutShopInput | CartItemCreateOrConnectWithoutShopInput[]
    createMany?: CartItemCreateManyShopInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type WaitlistCreateNestedManyWithoutShopInput = {
    create?: XOR<WaitlistCreateWithoutShopInput, WaitlistUncheckedCreateWithoutShopInput> | WaitlistCreateWithoutShopInput[] | WaitlistUncheckedCreateWithoutShopInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutShopInput | WaitlistCreateOrConnectWithoutShopInput[]
    createMany?: WaitlistCreateManyShopInputEnvelope
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutShopInput = {
    create?: XOR<NotificationCreateWithoutShopInput, NotificationUncheckedCreateWithoutShopInput> | NotificationCreateWithoutShopInput[] | NotificationUncheckedCreateWithoutShopInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutShopInput | NotificationCreateOrConnectWithoutShopInput[]
    createMany?: NotificationCreateManyShopInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ShopStockUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<ShopStockCreateWithoutShopInput, ShopStockUncheckedCreateWithoutShopInput> | ShopStockCreateWithoutShopInput[] | ShopStockUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopStockCreateOrConnectWithoutShopInput | ShopStockCreateOrConnectWithoutShopInput[]
    createMany?: ShopStockCreateManyShopInputEnvelope
    connect?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
  }

  export type StockLedgerUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<StockLedgerCreateWithoutShopInput, StockLedgerUncheckedCreateWithoutShopInput> | StockLedgerCreateWithoutShopInput[] | StockLedgerUncheckedCreateWithoutShopInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutShopInput | StockLedgerCreateOrConnectWithoutShopInput[]
    createMany?: StockLedgerCreateManyShopInputEnvelope
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutSourceShopInput = {
    create?: XOR<TransferCreateWithoutSourceShopInput, TransferUncheckedCreateWithoutSourceShopInput> | TransferCreateWithoutSourceShopInput[] | TransferUncheckedCreateWithoutSourceShopInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutSourceShopInput | TransferCreateOrConnectWithoutSourceShopInput[]
    createMany?: TransferCreateManySourceShopInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutDestShopInput = {
    create?: XOR<TransferCreateWithoutDestShopInput, TransferUncheckedCreateWithoutDestShopInput> | TransferCreateWithoutDestShopInput[] | TransferUncheckedCreateWithoutDestShopInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutDestShopInput | TransferCreateOrConnectWithoutDestShopInput[]
    createMany?: TransferCreateManyDestShopInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type StockCorrectionUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<StockCorrectionCreateWithoutShopInput, StockCorrectionUncheckedCreateWithoutShopInput> | StockCorrectionCreateWithoutShopInput[] | StockCorrectionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: StockCorrectionCreateOrConnectWithoutShopInput | StockCorrectionCreateOrConnectWithoutShopInput[]
    createMany?: StockCorrectionCreateManyShopInputEnvelope
    connect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
  }

  export type AdditionalPriceUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<AdditionalPriceCreateWithoutShopInput, AdditionalPriceUncheckedCreateWithoutShopInput> | AdditionalPriceCreateWithoutShopInput[] | AdditionalPriceUncheckedCreateWithoutShopInput[]
    connectOrCreate?: AdditionalPriceCreateOrConnectWithoutShopInput | AdditionalPriceCreateOrConnectWithoutShopInput[]
    createMany?: AdditionalPriceCreateManyShopInputEnvelope
    connect?: AdditionalPriceWhereUniqueInput | AdditionalPriceWhereUniqueInput[]
  }

  export type SellItemUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<SellItemCreateWithoutShopInput, SellItemUncheckedCreateWithoutShopInput> | SellItemCreateWithoutShopInput[] | SellItemUncheckedCreateWithoutShopInput[]
    connectOrCreate?: SellItemCreateOrConnectWithoutShopInput | SellItemCreateOrConnectWithoutShopInput[]
    createMany?: SellItemCreateManyShopInputEnvelope
    connect?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
  }

  export type SellStockCorrectionItemUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<SellStockCorrectionItemCreateWithoutShopInput, SellStockCorrectionItemUncheckedCreateWithoutShopInput> | SellStockCorrectionItemCreateWithoutShopInput[] | SellStockCorrectionItemUncheckedCreateWithoutShopInput[]
    connectOrCreate?: SellStockCorrectionItemCreateOrConnectWithoutShopInput | SellStockCorrectionItemCreateOrConnectWithoutShopInput[]
    createMany?: SellStockCorrectionItemCreateManyShopInputEnvelope
    connect?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutShopsInput = {
    create?: XOR<UserCreateWithoutShopsInput, UserUncheckedCreateWithoutShopsInput> | UserCreateWithoutShopsInput[] | UserUncheckedCreateWithoutShopsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutShopsInput | UserCreateOrConnectWithoutShopsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CartItemUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<CartItemCreateWithoutShopInput, CartItemUncheckedCreateWithoutShopInput> | CartItemCreateWithoutShopInput[] | CartItemUncheckedCreateWithoutShopInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutShopInput | CartItemCreateOrConnectWithoutShopInput[]
    createMany?: CartItemCreateManyShopInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type WaitlistUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<WaitlistCreateWithoutShopInput, WaitlistUncheckedCreateWithoutShopInput> | WaitlistCreateWithoutShopInput[] | WaitlistUncheckedCreateWithoutShopInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutShopInput | WaitlistCreateOrConnectWithoutShopInput[]
    createMany?: WaitlistCreateManyShopInputEnvelope
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<NotificationCreateWithoutShopInput, NotificationUncheckedCreateWithoutShopInput> | NotificationCreateWithoutShopInput[] | NotificationUncheckedCreateWithoutShopInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutShopInput | NotificationCreateOrConnectWithoutShopInput[]
    createMany?: NotificationCreateManyShopInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type BranchUpdateOneRequiredWithoutShopNestedInput = {
    create?: XOR<BranchCreateWithoutShopInput, BranchUncheckedCreateWithoutShopInput>
    connectOrCreate?: BranchCreateOrConnectWithoutShopInput
    upsert?: BranchUpsertWithoutShopInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutShopInput, BranchUpdateWithoutShopInput>, BranchUncheckedUpdateWithoutShopInput>
  }

  export type ShopStockUpdateManyWithoutShopNestedInput = {
    create?: XOR<ShopStockCreateWithoutShopInput, ShopStockUncheckedCreateWithoutShopInput> | ShopStockCreateWithoutShopInput[] | ShopStockUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopStockCreateOrConnectWithoutShopInput | ShopStockCreateOrConnectWithoutShopInput[]
    upsert?: ShopStockUpsertWithWhereUniqueWithoutShopInput | ShopStockUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: ShopStockCreateManyShopInputEnvelope
    set?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
    disconnect?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
    delete?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
    connect?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
    update?: ShopStockUpdateWithWhereUniqueWithoutShopInput | ShopStockUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: ShopStockUpdateManyWithWhereWithoutShopInput | ShopStockUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: ShopStockScalarWhereInput | ShopStockScalarWhereInput[]
  }

  export type StockLedgerUpdateManyWithoutShopNestedInput = {
    create?: XOR<StockLedgerCreateWithoutShopInput, StockLedgerUncheckedCreateWithoutShopInput> | StockLedgerCreateWithoutShopInput[] | StockLedgerUncheckedCreateWithoutShopInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutShopInput | StockLedgerCreateOrConnectWithoutShopInput[]
    upsert?: StockLedgerUpsertWithWhereUniqueWithoutShopInput | StockLedgerUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: StockLedgerCreateManyShopInputEnvelope
    set?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    disconnect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    delete?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    update?: StockLedgerUpdateWithWhereUniqueWithoutShopInput | StockLedgerUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: StockLedgerUpdateManyWithWhereWithoutShopInput | StockLedgerUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: StockLedgerScalarWhereInput | StockLedgerScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutSourceShopNestedInput = {
    create?: XOR<TransferCreateWithoutSourceShopInput, TransferUncheckedCreateWithoutSourceShopInput> | TransferCreateWithoutSourceShopInput[] | TransferUncheckedCreateWithoutSourceShopInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutSourceShopInput | TransferCreateOrConnectWithoutSourceShopInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutSourceShopInput | TransferUpsertWithWhereUniqueWithoutSourceShopInput[]
    createMany?: TransferCreateManySourceShopInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutSourceShopInput | TransferUpdateWithWhereUniqueWithoutSourceShopInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutSourceShopInput | TransferUpdateManyWithWhereWithoutSourceShopInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutDestShopNestedInput = {
    create?: XOR<TransferCreateWithoutDestShopInput, TransferUncheckedCreateWithoutDestShopInput> | TransferCreateWithoutDestShopInput[] | TransferUncheckedCreateWithoutDestShopInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutDestShopInput | TransferCreateOrConnectWithoutDestShopInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutDestShopInput | TransferUpsertWithWhereUniqueWithoutDestShopInput[]
    createMany?: TransferCreateManyDestShopInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutDestShopInput | TransferUpdateWithWhereUniqueWithoutDestShopInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutDestShopInput | TransferUpdateManyWithWhereWithoutDestShopInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type StockCorrectionUpdateManyWithoutShopNestedInput = {
    create?: XOR<StockCorrectionCreateWithoutShopInput, StockCorrectionUncheckedCreateWithoutShopInput> | StockCorrectionCreateWithoutShopInput[] | StockCorrectionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: StockCorrectionCreateOrConnectWithoutShopInput | StockCorrectionCreateOrConnectWithoutShopInput[]
    upsert?: StockCorrectionUpsertWithWhereUniqueWithoutShopInput | StockCorrectionUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: StockCorrectionCreateManyShopInputEnvelope
    set?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    disconnect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    delete?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    connect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    update?: StockCorrectionUpdateWithWhereUniqueWithoutShopInput | StockCorrectionUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: StockCorrectionUpdateManyWithWhereWithoutShopInput | StockCorrectionUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: StockCorrectionScalarWhereInput | StockCorrectionScalarWhereInput[]
  }

  export type AdditionalPriceUpdateManyWithoutShopNestedInput = {
    create?: XOR<AdditionalPriceCreateWithoutShopInput, AdditionalPriceUncheckedCreateWithoutShopInput> | AdditionalPriceCreateWithoutShopInput[] | AdditionalPriceUncheckedCreateWithoutShopInput[]
    connectOrCreate?: AdditionalPriceCreateOrConnectWithoutShopInput | AdditionalPriceCreateOrConnectWithoutShopInput[]
    upsert?: AdditionalPriceUpsertWithWhereUniqueWithoutShopInput | AdditionalPriceUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: AdditionalPriceCreateManyShopInputEnvelope
    set?: AdditionalPriceWhereUniqueInput | AdditionalPriceWhereUniqueInput[]
    disconnect?: AdditionalPriceWhereUniqueInput | AdditionalPriceWhereUniqueInput[]
    delete?: AdditionalPriceWhereUniqueInput | AdditionalPriceWhereUniqueInput[]
    connect?: AdditionalPriceWhereUniqueInput | AdditionalPriceWhereUniqueInput[]
    update?: AdditionalPriceUpdateWithWhereUniqueWithoutShopInput | AdditionalPriceUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: AdditionalPriceUpdateManyWithWhereWithoutShopInput | AdditionalPriceUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: AdditionalPriceScalarWhereInput | AdditionalPriceScalarWhereInput[]
  }

  export type SellItemUpdateManyWithoutShopNestedInput = {
    create?: XOR<SellItemCreateWithoutShopInput, SellItemUncheckedCreateWithoutShopInput> | SellItemCreateWithoutShopInput[] | SellItemUncheckedCreateWithoutShopInput[]
    connectOrCreate?: SellItemCreateOrConnectWithoutShopInput | SellItemCreateOrConnectWithoutShopInput[]
    upsert?: SellItemUpsertWithWhereUniqueWithoutShopInput | SellItemUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: SellItemCreateManyShopInputEnvelope
    set?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    disconnect?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    delete?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    connect?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    update?: SellItemUpdateWithWhereUniqueWithoutShopInput | SellItemUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: SellItemUpdateManyWithWhereWithoutShopInput | SellItemUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: SellItemScalarWhereInput | SellItemScalarWhereInput[]
  }

  export type SellStockCorrectionItemUpdateManyWithoutShopNestedInput = {
    create?: XOR<SellStockCorrectionItemCreateWithoutShopInput, SellStockCorrectionItemUncheckedCreateWithoutShopInput> | SellStockCorrectionItemCreateWithoutShopInput[] | SellStockCorrectionItemUncheckedCreateWithoutShopInput[]
    connectOrCreate?: SellStockCorrectionItemCreateOrConnectWithoutShopInput | SellStockCorrectionItemCreateOrConnectWithoutShopInput[]
    upsert?: SellStockCorrectionItemUpsertWithWhereUniqueWithoutShopInput | SellStockCorrectionItemUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: SellStockCorrectionItemCreateManyShopInputEnvelope
    set?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    disconnect?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    delete?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    connect?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    update?: SellStockCorrectionItemUpdateWithWhereUniqueWithoutShopInput | SellStockCorrectionItemUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: SellStockCorrectionItemUpdateManyWithWhereWithoutShopInput | SellStockCorrectionItemUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: SellStockCorrectionItemScalarWhereInput | SellStockCorrectionItemScalarWhereInput[]
  }

  export type UserUpdateManyWithoutShopsNestedInput = {
    create?: XOR<UserCreateWithoutShopsInput, UserUncheckedCreateWithoutShopsInput> | UserCreateWithoutShopsInput[] | UserUncheckedCreateWithoutShopsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutShopsInput | UserCreateOrConnectWithoutShopsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutShopsInput | UserUpsertWithWhereUniqueWithoutShopsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutShopsInput | UserUpdateWithWhereUniqueWithoutShopsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutShopsInput | UserUpdateManyWithWhereWithoutShopsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CartItemUpdateManyWithoutShopNestedInput = {
    create?: XOR<CartItemCreateWithoutShopInput, CartItemUncheckedCreateWithoutShopInput> | CartItemCreateWithoutShopInput[] | CartItemUncheckedCreateWithoutShopInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutShopInput | CartItemCreateOrConnectWithoutShopInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutShopInput | CartItemUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: CartItemCreateManyShopInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutShopInput | CartItemUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutShopInput | CartItemUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type WaitlistUpdateManyWithoutShopNestedInput = {
    create?: XOR<WaitlistCreateWithoutShopInput, WaitlistUncheckedCreateWithoutShopInput> | WaitlistCreateWithoutShopInput[] | WaitlistUncheckedCreateWithoutShopInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutShopInput | WaitlistCreateOrConnectWithoutShopInput[]
    upsert?: WaitlistUpsertWithWhereUniqueWithoutShopInput | WaitlistUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: WaitlistCreateManyShopInputEnvelope
    set?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    disconnect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    delete?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    update?: WaitlistUpdateWithWhereUniqueWithoutShopInput | WaitlistUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: WaitlistUpdateManyWithWhereWithoutShopInput | WaitlistUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: WaitlistScalarWhereInput | WaitlistScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutShopNestedInput = {
    create?: XOR<NotificationCreateWithoutShopInput, NotificationUncheckedCreateWithoutShopInput> | NotificationCreateWithoutShopInput[] | NotificationUncheckedCreateWithoutShopInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutShopInput | NotificationCreateOrConnectWithoutShopInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutShopInput | NotificationUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: NotificationCreateManyShopInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutShopInput | NotificationUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutShopInput | NotificationUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ShopStockUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<ShopStockCreateWithoutShopInput, ShopStockUncheckedCreateWithoutShopInput> | ShopStockCreateWithoutShopInput[] | ShopStockUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopStockCreateOrConnectWithoutShopInput | ShopStockCreateOrConnectWithoutShopInput[]
    upsert?: ShopStockUpsertWithWhereUniqueWithoutShopInput | ShopStockUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: ShopStockCreateManyShopInputEnvelope
    set?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
    disconnect?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
    delete?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
    connect?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
    update?: ShopStockUpdateWithWhereUniqueWithoutShopInput | ShopStockUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: ShopStockUpdateManyWithWhereWithoutShopInput | ShopStockUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: ShopStockScalarWhereInput | ShopStockScalarWhereInput[]
  }

  export type StockLedgerUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<StockLedgerCreateWithoutShopInput, StockLedgerUncheckedCreateWithoutShopInput> | StockLedgerCreateWithoutShopInput[] | StockLedgerUncheckedCreateWithoutShopInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutShopInput | StockLedgerCreateOrConnectWithoutShopInput[]
    upsert?: StockLedgerUpsertWithWhereUniqueWithoutShopInput | StockLedgerUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: StockLedgerCreateManyShopInputEnvelope
    set?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    disconnect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    delete?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    update?: StockLedgerUpdateWithWhereUniqueWithoutShopInput | StockLedgerUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: StockLedgerUpdateManyWithWhereWithoutShopInput | StockLedgerUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: StockLedgerScalarWhereInput | StockLedgerScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutSourceShopNestedInput = {
    create?: XOR<TransferCreateWithoutSourceShopInput, TransferUncheckedCreateWithoutSourceShopInput> | TransferCreateWithoutSourceShopInput[] | TransferUncheckedCreateWithoutSourceShopInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutSourceShopInput | TransferCreateOrConnectWithoutSourceShopInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutSourceShopInput | TransferUpsertWithWhereUniqueWithoutSourceShopInput[]
    createMany?: TransferCreateManySourceShopInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutSourceShopInput | TransferUpdateWithWhereUniqueWithoutSourceShopInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutSourceShopInput | TransferUpdateManyWithWhereWithoutSourceShopInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutDestShopNestedInput = {
    create?: XOR<TransferCreateWithoutDestShopInput, TransferUncheckedCreateWithoutDestShopInput> | TransferCreateWithoutDestShopInput[] | TransferUncheckedCreateWithoutDestShopInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutDestShopInput | TransferCreateOrConnectWithoutDestShopInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutDestShopInput | TransferUpsertWithWhereUniqueWithoutDestShopInput[]
    createMany?: TransferCreateManyDestShopInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutDestShopInput | TransferUpdateWithWhereUniqueWithoutDestShopInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutDestShopInput | TransferUpdateManyWithWhereWithoutDestShopInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type StockCorrectionUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<StockCorrectionCreateWithoutShopInput, StockCorrectionUncheckedCreateWithoutShopInput> | StockCorrectionCreateWithoutShopInput[] | StockCorrectionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: StockCorrectionCreateOrConnectWithoutShopInput | StockCorrectionCreateOrConnectWithoutShopInput[]
    upsert?: StockCorrectionUpsertWithWhereUniqueWithoutShopInput | StockCorrectionUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: StockCorrectionCreateManyShopInputEnvelope
    set?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    disconnect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    delete?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    connect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    update?: StockCorrectionUpdateWithWhereUniqueWithoutShopInput | StockCorrectionUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: StockCorrectionUpdateManyWithWhereWithoutShopInput | StockCorrectionUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: StockCorrectionScalarWhereInput | StockCorrectionScalarWhereInput[]
  }

  export type AdditionalPriceUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<AdditionalPriceCreateWithoutShopInput, AdditionalPriceUncheckedCreateWithoutShopInput> | AdditionalPriceCreateWithoutShopInput[] | AdditionalPriceUncheckedCreateWithoutShopInput[]
    connectOrCreate?: AdditionalPriceCreateOrConnectWithoutShopInput | AdditionalPriceCreateOrConnectWithoutShopInput[]
    upsert?: AdditionalPriceUpsertWithWhereUniqueWithoutShopInput | AdditionalPriceUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: AdditionalPriceCreateManyShopInputEnvelope
    set?: AdditionalPriceWhereUniqueInput | AdditionalPriceWhereUniqueInput[]
    disconnect?: AdditionalPriceWhereUniqueInput | AdditionalPriceWhereUniqueInput[]
    delete?: AdditionalPriceWhereUniqueInput | AdditionalPriceWhereUniqueInput[]
    connect?: AdditionalPriceWhereUniqueInput | AdditionalPriceWhereUniqueInput[]
    update?: AdditionalPriceUpdateWithWhereUniqueWithoutShopInput | AdditionalPriceUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: AdditionalPriceUpdateManyWithWhereWithoutShopInput | AdditionalPriceUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: AdditionalPriceScalarWhereInput | AdditionalPriceScalarWhereInput[]
  }

  export type SellItemUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<SellItemCreateWithoutShopInput, SellItemUncheckedCreateWithoutShopInput> | SellItemCreateWithoutShopInput[] | SellItemUncheckedCreateWithoutShopInput[]
    connectOrCreate?: SellItemCreateOrConnectWithoutShopInput | SellItemCreateOrConnectWithoutShopInput[]
    upsert?: SellItemUpsertWithWhereUniqueWithoutShopInput | SellItemUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: SellItemCreateManyShopInputEnvelope
    set?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    disconnect?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    delete?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    connect?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    update?: SellItemUpdateWithWhereUniqueWithoutShopInput | SellItemUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: SellItemUpdateManyWithWhereWithoutShopInput | SellItemUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: SellItemScalarWhereInput | SellItemScalarWhereInput[]
  }

  export type SellStockCorrectionItemUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<SellStockCorrectionItemCreateWithoutShopInput, SellStockCorrectionItemUncheckedCreateWithoutShopInput> | SellStockCorrectionItemCreateWithoutShopInput[] | SellStockCorrectionItemUncheckedCreateWithoutShopInput[]
    connectOrCreate?: SellStockCorrectionItemCreateOrConnectWithoutShopInput | SellStockCorrectionItemCreateOrConnectWithoutShopInput[]
    upsert?: SellStockCorrectionItemUpsertWithWhereUniqueWithoutShopInput | SellStockCorrectionItemUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: SellStockCorrectionItemCreateManyShopInputEnvelope
    set?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    disconnect?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    delete?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    connect?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    update?: SellStockCorrectionItemUpdateWithWhereUniqueWithoutShopInput | SellStockCorrectionItemUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: SellStockCorrectionItemUpdateManyWithWhereWithoutShopInput | SellStockCorrectionItemUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: SellStockCorrectionItemScalarWhereInput | SellStockCorrectionItemScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutShopsNestedInput = {
    create?: XOR<UserCreateWithoutShopsInput, UserUncheckedCreateWithoutShopsInput> | UserCreateWithoutShopsInput[] | UserUncheckedCreateWithoutShopsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutShopsInput | UserCreateOrConnectWithoutShopsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutShopsInput | UserUpsertWithWhereUniqueWithoutShopsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutShopsInput | UserUpdateWithWhereUniqueWithoutShopsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutShopsInput | UserUpdateManyWithWhereWithoutShopsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CartItemUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<CartItemCreateWithoutShopInput, CartItemUncheckedCreateWithoutShopInput> | CartItemCreateWithoutShopInput[] | CartItemUncheckedCreateWithoutShopInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutShopInput | CartItemCreateOrConnectWithoutShopInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutShopInput | CartItemUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: CartItemCreateManyShopInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutShopInput | CartItemUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutShopInput | CartItemUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type WaitlistUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<WaitlistCreateWithoutShopInput, WaitlistUncheckedCreateWithoutShopInput> | WaitlistCreateWithoutShopInput[] | WaitlistUncheckedCreateWithoutShopInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutShopInput | WaitlistCreateOrConnectWithoutShopInput[]
    upsert?: WaitlistUpsertWithWhereUniqueWithoutShopInput | WaitlistUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: WaitlistCreateManyShopInputEnvelope
    set?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    disconnect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    delete?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    update?: WaitlistUpdateWithWhereUniqueWithoutShopInput | WaitlistUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: WaitlistUpdateManyWithWhereWithoutShopInput | WaitlistUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: WaitlistScalarWhereInput | WaitlistScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<NotificationCreateWithoutShopInput, NotificationUncheckedCreateWithoutShopInput> | NotificationCreateWithoutShopInput[] | NotificationUncheckedCreateWithoutShopInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutShopInput | NotificationCreateOrConnectWithoutShopInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutShopInput | NotificationUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: NotificationCreateManyShopInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutShopInput | NotificationUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutShopInput | NotificationUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutStoreInput = {
    create?: XOR<BranchCreateWithoutStoreInput, BranchUncheckedCreateWithoutStoreInput>
    connectOrCreate?: BranchCreateOrConnectWithoutStoreInput
    connect?: BranchWhereUniqueInput
  }

  export type ProductBatchCreateNestedManyWithoutStoreInput = {
    create?: XOR<ProductBatchCreateWithoutStoreInput, ProductBatchUncheckedCreateWithoutStoreInput> | ProductBatchCreateWithoutStoreInput[] | ProductBatchUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductBatchCreateOrConnectWithoutStoreInput | ProductBatchCreateOrConnectWithoutStoreInput[]
    createMany?: ProductBatchCreateManyStoreInputEnvelope
    connect?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
  }

  export type StoreStockCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreStockCreateWithoutStoreInput, StoreStockUncheckedCreateWithoutStoreInput> | StoreStockCreateWithoutStoreInput[] | StoreStockUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreStockCreateOrConnectWithoutStoreInput | StoreStockCreateOrConnectWithoutStoreInput[]
    createMany?: StoreStockCreateManyStoreInputEnvelope
    connect?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
  }

  export type StockLedgerCreateNestedManyWithoutStoreInput = {
    create?: XOR<StockLedgerCreateWithoutStoreInput, StockLedgerUncheckedCreateWithoutStoreInput> | StockLedgerCreateWithoutStoreInput[] | StockLedgerUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutStoreInput | StockLedgerCreateOrConnectWithoutStoreInput[]
    createMany?: StockLedgerCreateManyStoreInputEnvelope
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
  }

  export type PurchaseCreateNestedManyWithoutStoreInput = {
    create?: XOR<PurchaseCreateWithoutStoreInput, PurchaseUncheckedCreateWithoutStoreInput> | PurchaseCreateWithoutStoreInput[] | PurchaseUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutStoreInput | PurchaseCreateOrConnectWithoutStoreInput[]
    createMany?: PurchaseCreateManyStoreInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutSourceStoreInput = {
    create?: XOR<TransferCreateWithoutSourceStoreInput, TransferUncheckedCreateWithoutSourceStoreInput> | TransferCreateWithoutSourceStoreInput[] | TransferUncheckedCreateWithoutSourceStoreInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutSourceStoreInput | TransferCreateOrConnectWithoutSourceStoreInput[]
    createMany?: TransferCreateManySourceStoreInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutDestStoreInput = {
    create?: XOR<TransferCreateWithoutDestStoreInput, TransferUncheckedCreateWithoutDestStoreInput> | TransferCreateWithoutDestStoreInput[] | TransferUncheckedCreateWithoutDestStoreInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutDestStoreInput | TransferCreateOrConnectWithoutDestStoreInput[]
    createMany?: TransferCreateManyDestStoreInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type StockCorrectionCreateNestedManyWithoutStoreInput = {
    create?: XOR<StockCorrectionCreateWithoutStoreInput, StockCorrectionUncheckedCreateWithoutStoreInput> | StockCorrectionCreateWithoutStoreInput[] | StockCorrectionUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StockCorrectionCreateOrConnectWithoutStoreInput | StockCorrectionCreateOrConnectWithoutStoreInput[]
    createMany?: StockCorrectionCreateManyStoreInputEnvelope
    connect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutStoresInput = {
    create?: XOR<UserCreateWithoutStoresInput, UserUncheckedCreateWithoutStoresInput> | UserCreateWithoutStoresInput[] | UserUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: UserCreateOrConnectWithoutStoresInput | UserCreateOrConnectWithoutStoresInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutStoreInput = {
    create?: XOR<NotificationCreateWithoutStoreInput, NotificationUncheckedCreateWithoutStoreInput> | NotificationCreateWithoutStoreInput[] | NotificationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutStoreInput | NotificationCreateOrConnectWithoutStoreInput[]
    createMany?: NotificationCreateManyStoreInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ProductBatchUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<ProductBatchCreateWithoutStoreInput, ProductBatchUncheckedCreateWithoutStoreInput> | ProductBatchCreateWithoutStoreInput[] | ProductBatchUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductBatchCreateOrConnectWithoutStoreInput | ProductBatchCreateOrConnectWithoutStoreInput[]
    createMany?: ProductBatchCreateManyStoreInputEnvelope
    connect?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
  }

  export type StoreStockUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreStockCreateWithoutStoreInput, StoreStockUncheckedCreateWithoutStoreInput> | StoreStockCreateWithoutStoreInput[] | StoreStockUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreStockCreateOrConnectWithoutStoreInput | StoreStockCreateOrConnectWithoutStoreInput[]
    createMany?: StoreStockCreateManyStoreInputEnvelope
    connect?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
  }

  export type StockLedgerUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<StockLedgerCreateWithoutStoreInput, StockLedgerUncheckedCreateWithoutStoreInput> | StockLedgerCreateWithoutStoreInput[] | StockLedgerUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutStoreInput | StockLedgerCreateOrConnectWithoutStoreInput[]
    createMany?: StockLedgerCreateManyStoreInputEnvelope
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<PurchaseCreateWithoutStoreInput, PurchaseUncheckedCreateWithoutStoreInput> | PurchaseCreateWithoutStoreInput[] | PurchaseUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutStoreInput | PurchaseCreateOrConnectWithoutStoreInput[]
    createMany?: PurchaseCreateManyStoreInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutSourceStoreInput = {
    create?: XOR<TransferCreateWithoutSourceStoreInput, TransferUncheckedCreateWithoutSourceStoreInput> | TransferCreateWithoutSourceStoreInput[] | TransferUncheckedCreateWithoutSourceStoreInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutSourceStoreInput | TransferCreateOrConnectWithoutSourceStoreInput[]
    createMany?: TransferCreateManySourceStoreInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutDestStoreInput = {
    create?: XOR<TransferCreateWithoutDestStoreInput, TransferUncheckedCreateWithoutDestStoreInput> | TransferCreateWithoutDestStoreInput[] | TransferUncheckedCreateWithoutDestStoreInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutDestStoreInput | TransferCreateOrConnectWithoutDestStoreInput[]
    createMany?: TransferCreateManyDestStoreInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type StockCorrectionUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<StockCorrectionCreateWithoutStoreInput, StockCorrectionUncheckedCreateWithoutStoreInput> | StockCorrectionCreateWithoutStoreInput[] | StockCorrectionUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StockCorrectionCreateOrConnectWithoutStoreInput | StockCorrectionCreateOrConnectWithoutStoreInput[]
    createMany?: StockCorrectionCreateManyStoreInputEnvelope
    connect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<UserCreateWithoutStoresInput, UserUncheckedCreateWithoutStoresInput> | UserCreateWithoutStoresInput[] | UserUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: UserCreateOrConnectWithoutStoresInput | UserCreateOrConnectWithoutStoresInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<NotificationCreateWithoutStoreInput, NotificationUncheckedCreateWithoutStoreInput> | NotificationCreateWithoutStoreInput[] | NotificationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutStoreInput | NotificationCreateOrConnectWithoutStoreInput[]
    createMany?: NotificationCreateManyStoreInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type BranchUpdateOneRequiredWithoutStoreNestedInput = {
    create?: XOR<BranchCreateWithoutStoreInput, BranchUncheckedCreateWithoutStoreInput>
    connectOrCreate?: BranchCreateOrConnectWithoutStoreInput
    upsert?: BranchUpsertWithoutStoreInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutStoreInput, BranchUpdateWithoutStoreInput>, BranchUncheckedUpdateWithoutStoreInput>
  }

  export type ProductBatchUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ProductBatchCreateWithoutStoreInput, ProductBatchUncheckedCreateWithoutStoreInput> | ProductBatchCreateWithoutStoreInput[] | ProductBatchUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductBatchCreateOrConnectWithoutStoreInput | ProductBatchCreateOrConnectWithoutStoreInput[]
    upsert?: ProductBatchUpsertWithWhereUniqueWithoutStoreInput | ProductBatchUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ProductBatchCreateManyStoreInputEnvelope
    set?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
    disconnect?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
    delete?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
    connect?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
    update?: ProductBatchUpdateWithWhereUniqueWithoutStoreInput | ProductBatchUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ProductBatchUpdateManyWithWhereWithoutStoreInput | ProductBatchUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ProductBatchScalarWhereInput | ProductBatchScalarWhereInput[]
  }

  export type StoreStockUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreStockCreateWithoutStoreInput, StoreStockUncheckedCreateWithoutStoreInput> | StoreStockCreateWithoutStoreInput[] | StoreStockUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreStockCreateOrConnectWithoutStoreInput | StoreStockCreateOrConnectWithoutStoreInput[]
    upsert?: StoreStockUpsertWithWhereUniqueWithoutStoreInput | StoreStockUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreStockCreateManyStoreInputEnvelope
    set?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
    disconnect?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
    delete?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
    connect?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
    update?: StoreStockUpdateWithWhereUniqueWithoutStoreInput | StoreStockUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreStockUpdateManyWithWhereWithoutStoreInput | StoreStockUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreStockScalarWhereInput | StoreStockScalarWhereInput[]
  }

  export type StockLedgerUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StockLedgerCreateWithoutStoreInput, StockLedgerUncheckedCreateWithoutStoreInput> | StockLedgerCreateWithoutStoreInput[] | StockLedgerUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutStoreInput | StockLedgerCreateOrConnectWithoutStoreInput[]
    upsert?: StockLedgerUpsertWithWhereUniqueWithoutStoreInput | StockLedgerUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StockLedgerCreateManyStoreInputEnvelope
    set?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    disconnect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    delete?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    update?: StockLedgerUpdateWithWhereUniqueWithoutStoreInput | StockLedgerUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StockLedgerUpdateManyWithWhereWithoutStoreInput | StockLedgerUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StockLedgerScalarWhereInput | StockLedgerScalarWhereInput[]
  }

  export type PurchaseUpdateManyWithoutStoreNestedInput = {
    create?: XOR<PurchaseCreateWithoutStoreInput, PurchaseUncheckedCreateWithoutStoreInput> | PurchaseCreateWithoutStoreInput[] | PurchaseUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutStoreInput | PurchaseCreateOrConnectWithoutStoreInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutStoreInput | PurchaseUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: PurchaseCreateManyStoreInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutStoreInput | PurchaseUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutStoreInput | PurchaseUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutSourceStoreNestedInput = {
    create?: XOR<TransferCreateWithoutSourceStoreInput, TransferUncheckedCreateWithoutSourceStoreInput> | TransferCreateWithoutSourceStoreInput[] | TransferUncheckedCreateWithoutSourceStoreInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutSourceStoreInput | TransferCreateOrConnectWithoutSourceStoreInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutSourceStoreInput | TransferUpsertWithWhereUniqueWithoutSourceStoreInput[]
    createMany?: TransferCreateManySourceStoreInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutSourceStoreInput | TransferUpdateWithWhereUniqueWithoutSourceStoreInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutSourceStoreInput | TransferUpdateManyWithWhereWithoutSourceStoreInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutDestStoreNestedInput = {
    create?: XOR<TransferCreateWithoutDestStoreInput, TransferUncheckedCreateWithoutDestStoreInput> | TransferCreateWithoutDestStoreInput[] | TransferUncheckedCreateWithoutDestStoreInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutDestStoreInput | TransferCreateOrConnectWithoutDestStoreInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutDestStoreInput | TransferUpsertWithWhereUniqueWithoutDestStoreInput[]
    createMany?: TransferCreateManyDestStoreInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutDestStoreInput | TransferUpdateWithWhereUniqueWithoutDestStoreInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutDestStoreInput | TransferUpdateManyWithWhereWithoutDestStoreInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type StockCorrectionUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StockCorrectionCreateWithoutStoreInput, StockCorrectionUncheckedCreateWithoutStoreInput> | StockCorrectionCreateWithoutStoreInput[] | StockCorrectionUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StockCorrectionCreateOrConnectWithoutStoreInput | StockCorrectionCreateOrConnectWithoutStoreInput[]
    upsert?: StockCorrectionUpsertWithWhereUniqueWithoutStoreInput | StockCorrectionUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StockCorrectionCreateManyStoreInputEnvelope
    set?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    disconnect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    delete?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    connect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    update?: StockCorrectionUpdateWithWhereUniqueWithoutStoreInput | StockCorrectionUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StockCorrectionUpdateManyWithWhereWithoutStoreInput | StockCorrectionUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StockCorrectionScalarWhereInput | StockCorrectionScalarWhereInput[]
  }

  export type UserUpdateManyWithoutStoresNestedInput = {
    create?: XOR<UserCreateWithoutStoresInput, UserUncheckedCreateWithoutStoresInput> | UserCreateWithoutStoresInput[] | UserUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: UserCreateOrConnectWithoutStoresInput | UserCreateOrConnectWithoutStoresInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutStoresInput | UserUpsertWithWhereUniqueWithoutStoresInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutStoresInput | UserUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: UserUpdateManyWithWhereWithoutStoresInput | UserUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutStoreNestedInput = {
    create?: XOR<NotificationCreateWithoutStoreInput, NotificationUncheckedCreateWithoutStoreInput> | NotificationCreateWithoutStoreInput[] | NotificationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutStoreInput | NotificationCreateOrConnectWithoutStoreInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutStoreInput | NotificationUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: NotificationCreateManyStoreInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutStoreInput | NotificationUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutStoreInput | NotificationUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ProductBatchUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ProductBatchCreateWithoutStoreInput, ProductBatchUncheckedCreateWithoutStoreInput> | ProductBatchCreateWithoutStoreInput[] | ProductBatchUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductBatchCreateOrConnectWithoutStoreInput | ProductBatchCreateOrConnectWithoutStoreInput[]
    upsert?: ProductBatchUpsertWithWhereUniqueWithoutStoreInput | ProductBatchUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ProductBatchCreateManyStoreInputEnvelope
    set?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
    disconnect?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
    delete?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
    connect?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
    update?: ProductBatchUpdateWithWhereUniqueWithoutStoreInput | ProductBatchUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ProductBatchUpdateManyWithWhereWithoutStoreInput | ProductBatchUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ProductBatchScalarWhereInput | ProductBatchScalarWhereInput[]
  }

  export type StoreStockUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreStockCreateWithoutStoreInput, StoreStockUncheckedCreateWithoutStoreInput> | StoreStockCreateWithoutStoreInput[] | StoreStockUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreStockCreateOrConnectWithoutStoreInput | StoreStockCreateOrConnectWithoutStoreInput[]
    upsert?: StoreStockUpsertWithWhereUniqueWithoutStoreInput | StoreStockUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreStockCreateManyStoreInputEnvelope
    set?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
    disconnect?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
    delete?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
    connect?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
    update?: StoreStockUpdateWithWhereUniqueWithoutStoreInput | StoreStockUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreStockUpdateManyWithWhereWithoutStoreInput | StoreStockUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreStockScalarWhereInput | StoreStockScalarWhereInput[]
  }

  export type StockLedgerUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StockLedgerCreateWithoutStoreInput, StockLedgerUncheckedCreateWithoutStoreInput> | StockLedgerCreateWithoutStoreInput[] | StockLedgerUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutStoreInput | StockLedgerCreateOrConnectWithoutStoreInput[]
    upsert?: StockLedgerUpsertWithWhereUniqueWithoutStoreInput | StockLedgerUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StockLedgerCreateManyStoreInputEnvelope
    set?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    disconnect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    delete?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    update?: StockLedgerUpdateWithWhereUniqueWithoutStoreInput | StockLedgerUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StockLedgerUpdateManyWithWhereWithoutStoreInput | StockLedgerUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StockLedgerScalarWhereInput | StockLedgerScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<PurchaseCreateWithoutStoreInput, PurchaseUncheckedCreateWithoutStoreInput> | PurchaseCreateWithoutStoreInput[] | PurchaseUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutStoreInput | PurchaseCreateOrConnectWithoutStoreInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutStoreInput | PurchaseUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: PurchaseCreateManyStoreInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutStoreInput | PurchaseUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutStoreInput | PurchaseUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutSourceStoreNestedInput = {
    create?: XOR<TransferCreateWithoutSourceStoreInput, TransferUncheckedCreateWithoutSourceStoreInput> | TransferCreateWithoutSourceStoreInput[] | TransferUncheckedCreateWithoutSourceStoreInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutSourceStoreInput | TransferCreateOrConnectWithoutSourceStoreInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutSourceStoreInput | TransferUpsertWithWhereUniqueWithoutSourceStoreInput[]
    createMany?: TransferCreateManySourceStoreInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutSourceStoreInput | TransferUpdateWithWhereUniqueWithoutSourceStoreInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutSourceStoreInput | TransferUpdateManyWithWhereWithoutSourceStoreInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutDestStoreNestedInput = {
    create?: XOR<TransferCreateWithoutDestStoreInput, TransferUncheckedCreateWithoutDestStoreInput> | TransferCreateWithoutDestStoreInput[] | TransferUncheckedCreateWithoutDestStoreInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutDestStoreInput | TransferCreateOrConnectWithoutDestStoreInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutDestStoreInput | TransferUpsertWithWhereUniqueWithoutDestStoreInput[]
    createMany?: TransferCreateManyDestStoreInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutDestStoreInput | TransferUpdateWithWhereUniqueWithoutDestStoreInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutDestStoreInput | TransferUpdateManyWithWhereWithoutDestStoreInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type StockCorrectionUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StockCorrectionCreateWithoutStoreInput, StockCorrectionUncheckedCreateWithoutStoreInput> | StockCorrectionCreateWithoutStoreInput[] | StockCorrectionUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StockCorrectionCreateOrConnectWithoutStoreInput | StockCorrectionCreateOrConnectWithoutStoreInput[]
    upsert?: StockCorrectionUpsertWithWhereUniqueWithoutStoreInput | StockCorrectionUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StockCorrectionCreateManyStoreInputEnvelope
    set?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    disconnect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    delete?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    connect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    update?: StockCorrectionUpdateWithWhereUniqueWithoutStoreInput | StockCorrectionUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StockCorrectionUpdateManyWithWhereWithoutStoreInput | StockCorrectionUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StockCorrectionScalarWhereInput | StockCorrectionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<UserCreateWithoutStoresInput, UserUncheckedCreateWithoutStoresInput> | UserCreateWithoutStoresInput[] | UserUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: UserCreateOrConnectWithoutStoresInput | UserCreateOrConnectWithoutStoresInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutStoresInput | UserUpsertWithWhereUniqueWithoutStoresInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutStoresInput | UserUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: UserUpdateManyWithWhereWithoutStoresInput | UserUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<NotificationCreateWithoutStoreInput, NotificationUncheckedCreateWithoutStoreInput> | NotificationCreateWithoutStoreInput[] | NotificationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutStoreInput | NotificationCreateOrConnectWithoutStoreInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutStoreInput | NotificationUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: NotificationCreateManyStoreInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutStoreInput | NotificationUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutStoreInput | NotificationUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type StoreCreateNestedOneWithoutStoreStockInput = {
    create?: XOR<StoreCreateWithoutStoreStockInput, StoreUncheckedCreateWithoutStoreStockInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStoreStockInput
    connect?: StoreWhereUniqueInput
  }

  export type ProductBatchCreateNestedOneWithoutStoreStockInput = {
    create?: XOR<ProductBatchCreateWithoutStoreStockInput, ProductBatchUncheckedCreateWithoutStoreStockInput>
    connectOrCreate?: ProductBatchCreateOrConnectWithoutStoreStockInput
    connect?: ProductBatchWhereUniqueInput
  }

  export type UnitOfMeasureCreateNestedOneWithoutStoreStockInput = {
    create?: XOR<UnitOfMeasureCreateWithoutStoreStockInput, UnitOfMeasureUncheckedCreateWithoutStoreStockInput>
    connectOrCreate?: UnitOfMeasureCreateOrConnectWithoutStoreStockInput
    connect?: UnitOfMeasureWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumStockStatusFieldUpdateOperationsInput = {
    set?: $Enums.StockStatus
  }

  export type StoreUpdateOneRequiredWithoutStoreStockNestedInput = {
    create?: XOR<StoreCreateWithoutStoreStockInput, StoreUncheckedCreateWithoutStoreStockInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStoreStockInput
    upsert?: StoreUpsertWithoutStoreStockInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutStoreStockInput, StoreUpdateWithoutStoreStockInput>, StoreUncheckedUpdateWithoutStoreStockInput>
  }

  export type ProductBatchUpdateOneRequiredWithoutStoreStockNestedInput = {
    create?: XOR<ProductBatchCreateWithoutStoreStockInput, ProductBatchUncheckedCreateWithoutStoreStockInput>
    connectOrCreate?: ProductBatchCreateOrConnectWithoutStoreStockInput
    upsert?: ProductBatchUpsertWithoutStoreStockInput
    connect?: ProductBatchWhereUniqueInput
    update?: XOR<XOR<ProductBatchUpdateToOneWithWhereWithoutStoreStockInput, ProductBatchUpdateWithoutStoreStockInput>, ProductBatchUncheckedUpdateWithoutStoreStockInput>
  }

  export type UnitOfMeasureUpdateOneRequiredWithoutStoreStockNestedInput = {
    create?: XOR<UnitOfMeasureCreateWithoutStoreStockInput, UnitOfMeasureUncheckedCreateWithoutStoreStockInput>
    connectOrCreate?: UnitOfMeasureCreateOrConnectWithoutStoreStockInput
    upsert?: UnitOfMeasureUpsertWithoutStoreStockInput
    connect?: UnitOfMeasureWhereUniqueInput
    update?: XOR<XOR<UnitOfMeasureUpdateToOneWithWhereWithoutStoreStockInput, UnitOfMeasureUpdateWithoutStoreStockInput>, UnitOfMeasureUncheckedUpdateWithoutStoreStockInput>
  }

  export type ShopCreateNestedOneWithoutShopStockInput = {
    create?: XOR<ShopCreateWithoutShopStockInput, ShopUncheckedCreateWithoutShopStockInput>
    connectOrCreate?: ShopCreateOrConnectWithoutShopStockInput
    connect?: ShopWhereUniqueInput
  }

  export type ProductBatchCreateNestedOneWithoutShopStockInput = {
    create?: XOR<ProductBatchCreateWithoutShopStockInput, ProductBatchUncheckedCreateWithoutShopStockInput>
    connectOrCreate?: ProductBatchCreateOrConnectWithoutShopStockInput
    connect?: ProductBatchWhereUniqueInput
  }

  export type UnitOfMeasureCreateNestedOneWithoutShopStockInput = {
    create?: XOR<UnitOfMeasureCreateWithoutShopStockInput, UnitOfMeasureUncheckedCreateWithoutShopStockInput>
    connectOrCreate?: UnitOfMeasureCreateOrConnectWithoutShopStockInput
    connect?: UnitOfMeasureWhereUniqueInput
  }

  export type ShopUpdateOneRequiredWithoutShopStockNestedInput = {
    create?: XOR<ShopCreateWithoutShopStockInput, ShopUncheckedCreateWithoutShopStockInput>
    connectOrCreate?: ShopCreateOrConnectWithoutShopStockInput
    upsert?: ShopUpsertWithoutShopStockInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutShopStockInput, ShopUpdateWithoutShopStockInput>, ShopUncheckedUpdateWithoutShopStockInput>
  }

  export type ProductBatchUpdateOneRequiredWithoutShopStockNestedInput = {
    create?: XOR<ProductBatchCreateWithoutShopStockInput, ProductBatchUncheckedCreateWithoutShopStockInput>
    connectOrCreate?: ProductBatchCreateOrConnectWithoutShopStockInput
    upsert?: ProductBatchUpsertWithoutShopStockInput
    connect?: ProductBatchWhereUniqueInput
    update?: XOR<XOR<ProductBatchUpdateToOneWithWhereWithoutShopStockInput, ProductBatchUpdateWithoutShopStockInput>, ProductBatchUncheckedUpdateWithoutShopStockInput>
  }

  export type UnitOfMeasureUpdateOneRequiredWithoutShopStockNestedInput = {
    create?: XOR<UnitOfMeasureCreateWithoutShopStockInput, UnitOfMeasureUncheckedCreateWithoutShopStockInput>
    connectOrCreate?: UnitOfMeasureCreateOrConnectWithoutShopStockInput
    upsert?: UnitOfMeasureUpsertWithoutShopStockInput
    connect?: UnitOfMeasureWhereUniqueInput
    update?: XOR<XOR<UnitOfMeasureUpdateToOneWithWhereWithoutShopStockInput, UnitOfMeasureUpdateWithoutShopStockInput>, UnitOfMeasureUncheckedUpdateWithoutShopStockInput>
  }

  export type ProductBatchCreateNestedOneWithoutStockLedgerInput = {
    create?: XOR<ProductBatchCreateWithoutStockLedgerInput, ProductBatchUncheckedCreateWithoutStockLedgerInput>
    connectOrCreate?: ProductBatchCreateOrConnectWithoutStockLedgerInput
    connect?: ProductBatchWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutStockLedgerInput = {
    create?: XOR<StoreCreateWithoutStockLedgerInput, StoreUncheckedCreateWithoutStockLedgerInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStockLedgerInput
    connect?: StoreWhereUniqueInput
  }

  export type ShopCreateNestedOneWithoutStockLedgerInput = {
    create?: XOR<ShopCreateWithoutStockLedgerInput, ShopUncheckedCreateWithoutStockLedgerInput>
    connectOrCreate?: ShopCreateOrConnectWithoutStockLedgerInput
    connect?: ShopWhereUniqueInput
  }

  export type UnitOfMeasureCreateNestedOneWithoutStockLedgerInput = {
    create?: XOR<UnitOfMeasureCreateWithoutStockLedgerInput, UnitOfMeasureUncheckedCreateWithoutStockLedgerInput>
    connectOrCreate?: UnitOfMeasureCreateOrConnectWithoutStockLedgerInput
    connect?: UnitOfMeasureWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStockLedgerInput = {
    create?: XOR<UserCreateWithoutStockLedgerInput, UserUncheckedCreateWithoutStockLedgerInput>
    connectOrCreate?: UserCreateOrConnectWithoutStockLedgerInput
    connect?: UserWhereUniqueInput
  }

  export type EnumStockMovementTypeFieldUpdateOperationsInput = {
    set?: $Enums.StockMovementType
  }

  export type ProductBatchUpdateOneRequiredWithoutStockLedgerNestedInput = {
    create?: XOR<ProductBatchCreateWithoutStockLedgerInput, ProductBatchUncheckedCreateWithoutStockLedgerInput>
    connectOrCreate?: ProductBatchCreateOrConnectWithoutStockLedgerInput
    upsert?: ProductBatchUpsertWithoutStockLedgerInput
    connect?: ProductBatchWhereUniqueInput
    update?: XOR<XOR<ProductBatchUpdateToOneWithWhereWithoutStockLedgerInput, ProductBatchUpdateWithoutStockLedgerInput>, ProductBatchUncheckedUpdateWithoutStockLedgerInput>
  }

  export type StoreUpdateOneWithoutStockLedgerNestedInput = {
    create?: XOR<StoreCreateWithoutStockLedgerInput, StoreUncheckedCreateWithoutStockLedgerInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStockLedgerInput
    upsert?: StoreUpsertWithoutStockLedgerInput
    disconnect?: StoreWhereInput | boolean
    delete?: StoreWhereInput | boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutStockLedgerInput, StoreUpdateWithoutStockLedgerInput>, StoreUncheckedUpdateWithoutStockLedgerInput>
  }

  export type ShopUpdateOneWithoutStockLedgerNestedInput = {
    create?: XOR<ShopCreateWithoutStockLedgerInput, ShopUncheckedCreateWithoutStockLedgerInput>
    connectOrCreate?: ShopCreateOrConnectWithoutStockLedgerInput
    upsert?: ShopUpsertWithoutStockLedgerInput
    disconnect?: ShopWhereInput | boolean
    delete?: ShopWhereInput | boolean
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutStockLedgerInput, ShopUpdateWithoutStockLedgerInput>, ShopUncheckedUpdateWithoutStockLedgerInput>
  }

  export type UnitOfMeasureUpdateOneRequiredWithoutStockLedgerNestedInput = {
    create?: XOR<UnitOfMeasureCreateWithoutStockLedgerInput, UnitOfMeasureUncheckedCreateWithoutStockLedgerInput>
    connectOrCreate?: UnitOfMeasureCreateOrConnectWithoutStockLedgerInput
    upsert?: UnitOfMeasureUpsertWithoutStockLedgerInput
    connect?: UnitOfMeasureWhereUniqueInput
    update?: XOR<XOR<UnitOfMeasureUpdateToOneWithWhereWithoutStockLedgerInput, UnitOfMeasureUpdateWithoutStockLedgerInput>, UnitOfMeasureUncheckedUpdateWithoutStockLedgerInput>
  }

  export type UserUpdateOneWithoutStockLedgerNestedInput = {
    create?: XOR<UserCreateWithoutStockLedgerInput, UserUncheckedCreateWithoutStockLedgerInput>
    connectOrCreate?: UserCreateOrConnectWithoutStockLedgerInput
    upsert?: UserUpsertWithoutStockLedgerInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStockLedgerInput, UserUpdateWithoutStockLedgerInput>, UserUncheckedUpdateWithoutStockLedgerInput>
  }

  export type UserCreateNestedOneWithoutLogInput = {
    create?: XOR<UserCreateWithoutLogInput, UserUncheckedCreateWithoutLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutLogNestedInput = {
    create?: XOR<UserCreateWithoutLogInput, UserUncheckedCreateWithoutLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogInput
    upsert?: UserUpsertWithoutLogInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLogInput, UserUpdateWithoutLogInput>, UserUncheckedUpdateWithoutLogInput>
  }

  export type SellCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SellCreateWithoutCustomerInput, SellUncheckedCreateWithoutCustomerInput> | SellCreateWithoutCustomerInput[] | SellUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SellCreateOrConnectWithoutCustomerInput | SellCreateOrConnectWithoutCustomerInput[]
    createMany?: SellCreateManyCustomerInputEnvelope
    connect?: SellWhereUniqueInput | SellWhereUniqueInput[]
  }

  export type AddToCartCreateNestedManyWithoutCustomerInput = {
    create?: XOR<AddToCartCreateWithoutCustomerInput, AddToCartUncheckedCreateWithoutCustomerInput> | AddToCartCreateWithoutCustomerInput[] | AddToCartUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AddToCartCreateOrConnectWithoutCustomerInput | AddToCartCreateOrConnectWithoutCustomerInput[]
    createMany?: AddToCartCreateManyCustomerInputEnvelope
    connect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
  }

  export type WaitlistCreateNestedManyWithoutCustomerInput = {
    create?: XOR<WaitlistCreateWithoutCustomerInput, WaitlistUncheckedCreateWithoutCustomerInput> | WaitlistCreateWithoutCustomerInput[] | WaitlistUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutCustomerInput | WaitlistCreateOrConnectWithoutCustomerInput[]
    createMany?: WaitlistCreateManyCustomerInputEnvelope
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
  }

  export type SellUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SellCreateWithoutCustomerInput, SellUncheckedCreateWithoutCustomerInput> | SellCreateWithoutCustomerInput[] | SellUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SellCreateOrConnectWithoutCustomerInput | SellCreateOrConnectWithoutCustomerInput[]
    createMany?: SellCreateManyCustomerInputEnvelope
    connect?: SellWhereUniqueInput | SellWhereUniqueInput[]
  }

  export type AddToCartUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<AddToCartCreateWithoutCustomerInput, AddToCartUncheckedCreateWithoutCustomerInput> | AddToCartCreateWithoutCustomerInput[] | AddToCartUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AddToCartCreateOrConnectWithoutCustomerInput | AddToCartCreateOrConnectWithoutCustomerInput[]
    createMany?: AddToCartCreateManyCustomerInputEnvelope
    connect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
  }

  export type WaitlistUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<WaitlistCreateWithoutCustomerInput, WaitlistUncheckedCreateWithoutCustomerInput> | WaitlistCreateWithoutCustomerInput[] | WaitlistUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutCustomerInput | WaitlistCreateOrConnectWithoutCustomerInput[]
    createMany?: WaitlistCreateManyCustomerInputEnvelope
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
  }

  export type SellUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SellCreateWithoutCustomerInput, SellUncheckedCreateWithoutCustomerInput> | SellCreateWithoutCustomerInput[] | SellUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SellCreateOrConnectWithoutCustomerInput | SellCreateOrConnectWithoutCustomerInput[]
    upsert?: SellUpsertWithWhereUniqueWithoutCustomerInput | SellUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SellCreateManyCustomerInputEnvelope
    set?: SellWhereUniqueInput | SellWhereUniqueInput[]
    disconnect?: SellWhereUniqueInput | SellWhereUniqueInput[]
    delete?: SellWhereUniqueInput | SellWhereUniqueInput[]
    connect?: SellWhereUniqueInput | SellWhereUniqueInput[]
    update?: SellUpdateWithWhereUniqueWithoutCustomerInput | SellUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SellUpdateManyWithWhereWithoutCustomerInput | SellUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SellScalarWhereInput | SellScalarWhereInput[]
  }

  export type AddToCartUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<AddToCartCreateWithoutCustomerInput, AddToCartUncheckedCreateWithoutCustomerInput> | AddToCartCreateWithoutCustomerInput[] | AddToCartUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AddToCartCreateOrConnectWithoutCustomerInput | AddToCartCreateOrConnectWithoutCustomerInput[]
    upsert?: AddToCartUpsertWithWhereUniqueWithoutCustomerInput | AddToCartUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: AddToCartCreateManyCustomerInputEnvelope
    set?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    disconnect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    delete?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    connect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    update?: AddToCartUpdateWithWhereUniqueWithoutCustomerInput | AddToCartUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: AddToCartUpdateManyWithWhereWithoutCustomerInput | AddToCartUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: AddToCartScalarWhereInput | AddToCartScalarWhereInput[]
  }

  export type WaitlistUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<WaitlistCreateWithoutCustomerInput, WaitlistUncheckedCreateWithoutCustomerInput> | WaitlistCreateWithoutCustomerInput[] | WaitlistUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutCustomerInput | WaitlistCreateOrConnectWithoutCustomerInput[]
    upsert?: WaitlistUpsertWithWhereUniqueWithoutCustomerInput | WaitlistUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: WaitlistCreateManyCustomerInputEnvelope
    set?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    disconnect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    delete?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    update?: WaitlistUpdateWithWhereUniqueWithoutCustomerInput | WaitlistUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: WaitlistUpdateManyWithWhereWithoutCustomerInput | WaitlistUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: WaitlistScalarWhereInput | WaitlistScalarWhereInput[]
  }

  export type SellUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SellCreateWithoutCustomerInput, SellUncheckedCreateWithoutCustomerInput> | SellCreateWithoutCustomerInput[] | SellUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SellCreateOrConnectWithoutCustomerInput | SellCreateOrConnectWithoutCustomerInput[]
    upsert?: SellUpsertWithWhereUniqueWithoutCustomerInput | SellUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SellCreateManyCustomerInputEnvelope
    set?: SellWhereUniqueInput | SellWhereUniqueInput[]
    disconnect?: SellWhereUniqueInput | SellWhereUniqueInput[]
    delete?: SellWhereUniqueInput | SellWhereUniqueInput[]
    connect?: SellWhereUniqueInput | SellWhereUniqueInput[]
    update?: SellUpdateWithWhereUniqueWithoutCustomerInput | SellUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SellUpdateManyWithWhereWithoutCustomerInput | SellUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SellScalarWhereInput | SellScalarWhereInput[]
  }

  export type AddToCartUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<AddToCartCreateWithoutCustomerInput, AddToCartUncheckedCreateWithoutCustomerInput> | AddToCartCreateWithoutCustomerInput[] | AddToCartUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AddToCartCreateOrConnectWithoutCustomerInput | AddToCartCreateOrConnectWithoutCustomerInput[]
    upsert?: AddToCartUpsertWithWhereUniqueWithoutCustomerInput | AddToCartUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: AddToCartCreateManyCustomerInputEnvelope
    set?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    disconnect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    delete?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    connect?: AddToCartWhereUniqueInput | AddToCartWhereUniqueInput[]
    update?: AddToCartUpdateWithWhereUniqueWithoutCustomerInput | AddToCartUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: AddToCartUpdateManyWithWhereWithoutCustomerInput | AddToCartUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: AddToCartScalarWhereInput | AddToCartScalarWhereInput[]
  }

  export type WaitlistUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<WaitlistCreateWithoutCustomerInput, WaitlistUncheckedCreateWithoutCustomerInput> | WaitlistCreateWithoutCustomerInput[] | WaitlistUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutCustomerInput | WaitlistCreateOrConnectWithoutCustomerInput[]
    upsert?: WaitlistUpsertWithWhereUniqueWithoutCustomerInput | WaitlistUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: WaitlistCreateManyCustomerInputEnvelope
    set?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    disconnect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    delete?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    update?: WaitlistUpdateWithWhereUniqueWithoutCustomerInput | WaitlistUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: WaitlistUpdateManyWithWhereWithoutCustomerInput | WaitlistUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: WaitlistScalarWhereInput | WaitlistScalarWhereInput[]
  }

  export type PurchaseCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseCreateWithoutSupplierInput, PurchaseUncheckedCreateWithoutSupplierInput> | PurchaseCreateWithoutSupplierInput[] | PurchaseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutSupplierInput | PurchaseCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseCreateManySupplierInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseCreateWithoutSupplierInput, PurchaseUncheckedCreateWithoutSupplierInput> | PurchaseCreateWithoutSupplierInput[] | PurchaseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutSupplierInput | PurchaseCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseCreateManySupplierInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type PurchaseUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseCreateWithoutSupplierInput, PurchaseUncheckedCreateWithoutSupplierInput> | PurchaseCreateWithoutSupplierInput[] | PurchaseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutSupplierInput | PurchaseCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutSupplierInput | PurchaseUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseCreateManySupplierInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutSupplierInput | PurchaseUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutSupplierInput | PurchaseUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseCreateWithoutSupplierInput, PurchaseUncheckedCreateWithoutSupplierInput> | PurchaseCreateWithoutSupplierInput[] | PurchaseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutSupplierInput | PurchaseCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutSupplierInput | PurchaseUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseCreateManySupplierInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutSupplierInput | PurchaseUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutSupplierInput | PurchaseUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type SubCategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SubCategoryCreateWithoutCategoryInput, SubCategoryUncheckedCreateWithoutCategoryInput> | SubCategoryCreateWithoutCategoryInput[] | SubCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubCategoryCreateOrConnectWithoutCategoryInput | SubCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: SubCategoryCreateManyCategoryInputEnvelope
    connect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type SubCategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SubCategoryCreateWithoutCategoryInput, SubCategoryUncheckedCreateWithoutCategoryInput> | SubCategoryCreateWithoutCategoryInput[] | SubCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubCategoryCreateOrConnectWithoutCategoryInput | SubCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: SubCategoryCreateManyCategoryInputEnvelope
    connect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SubCategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SubCategoryCreateWithoutCategoryInput, SubCategoryUncheckedCreateWithoutCategoryInput> | SubCategoryCreateWithoutCategoryInput[] | SubCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubCategoryCreateOrConnectWithoutCategoryInput | SubCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: SubCategoryUpsertWithWhereUniqueWithoutCategoryInput | SubCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SubCategoryCreateManyCategoryInputEnvelope
    set?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    disconnect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    delete?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    connect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    update?: SubCategoryUpdateWithWhereUniqueWithoutCategoryInput | SubCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SubCategoryUpdateManyWithWhereWithoutCategoryInput | SubCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SubCategoryScalarWhereInput | SubCategoryScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SubCategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SubCategoryCreateWithoutCategoryInput, SubCategoryUncheckedCreateWithoutCategoryInput> | SubCategoryCreateWithoutCategoryInput[] | SubCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubCategoryCreateOrConnectWithoutCategoryInput | SubCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: SubCategoryUpsertWithWhereUniqueWithoutCategoryInput | SubCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SubCategoryCreateManyCategoryInputEnvelope
    set?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    disconnect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    delete?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    connect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    update?: SubCategoryUpdateWithWhereUniqueWithoutCategoryInput | SubCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SubCategoryUpdateManyWithWhereWithoutCategoryInput | SubCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SubCategoryScalarWhereInput | SubCategoryScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutSubCategoriesInput = {
    create?: XOR<CategoryCreateWithoutSubCategoriesInput, CategoryUncheckedCreateWithoutSubCategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSubCategoriesInput
    connect?: CategoryWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutSubCategoryInput = {
    create?: XOR<ProductCreateWithoutSubCategoryInput, ProductUncheckedCreateWithoutSubCategoryInput> | ProductCreateWithoutSubCategoryInput[] | ProductUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSubCategoryInput | ProductCreateOrConnectWithoutSubCategoryInput[]
    createMany?: ProductCreateManySubCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutSubCategoryInput = {
    create?: XOR<ProductCreateWithoutSubCategoryInput, ProductUncheckedCreateWithoutSubCategoryInput> | ProductCreateWithoutSubCategoryInput[] | ProductUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSubCategoryInput | ProductCreateOrConnectWithoutSubCategoryInput[]
    createMany?: ProductCreateManySubCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CategoryUpdateOneRequiredWithoutSubCategoriesNestedInput = {
    create?: XOR<CategoryCreateWithoutSubCategoriesInput, CategoryUncheckedCreateWithoutSubCategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSubCategoriesInput
    upsert?: CategoryUpsertWithoutSubCategoriesInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutSubCategoriesInput, CategoryUpdateWithoutSubCategoriesInput>, CategoryUncheckedUpdateWithoutSubCategoriesInput>
  }

  export type ProductUpdateManyWithoutSubCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutSubCategoryInput, ProductUncheckedCreateWithoutSubCategoryInput> | ProductCreateWithoutSubCategoryInput[] | ProductUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSubCategoryInput | ProductCreateOrConnectWithoutSubCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSubCategoryInput | ProductUpsertWithWhereUniqueWithoutSubCategoryInput[]
    createMany?: ProductCreateManySubCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSubCategoryInput | ProductUpdateWithWhereUniqueWithoutSubCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSubCategoryInput | ProductUpdateManyWithWhereWithoutSubCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutSubCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutSubCategoryInput, ProductUncheckedCreateWithoutSubCategoryInput> | ProductCreateWithoutSubCategoryInput[] | ProductUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSubCategoryInput | ProductCreateOrConnectWithoutSubCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSubCategoryInput | ProductUpsertWithWhereUniqueWithoutSubCategoryInput[]
    createMany?: ProductCreateManySubCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSubCategoryInput | ProductUpdateWithWhereUniqueWithoutSubCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSubCategoryInput | ProductUpdateManyWithWhereWithoutSubCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    connect?: CategoryWhereUniqueInput
  }

  export type SubCategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<SubCategoryCreateWithoutProductsInput, SubCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SubCategoryCreateOrConnectWithoutProductsInput
    connect?: SubCategoryWhereUniqueInput
  }

  export type UnitOfMeasureCreateNestedOneWithoutProductsInput = {
    create?: XOR<UnitOfMeasureCreateWithoutProductsInput, UnitOfMeasureUncheckedCreateWithoutProductsInput>
    connectOrCreate?: UnitOfMeasureCreateOrConnectWithoutProductsInput
    connect?: UnitOfMeasureWhereUniqueInput
  }

  export type ProductBatchCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductBatchCreateWithoutProductInput, ProductBatchUncheckedCreateWithoutProductInput> | ProductBatchCreateWithoutProductInput[] | ProductBatchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductBatchCreateOrConnectWithoutProductInput | ProductBatchCreateOrConnectWithoutProductInput[]
    createMany?: ProductBatchCreateManyProductInputEnvelope
    connect?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
  }

  export type PurchaseItemCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput> | PurchaseItemCreateWithoutProductInput[] | PurchaseItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutProductInput | PurchaseItemCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseItemCreateManyProductInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type TransferItemCreateNestedManyWithoutProductInput = {
    create?: XOR<TransferItemCreateWithoutProductInput, TransferItemUncheckedCreateWithoutProductInput> | TransferItemCreateWithoutProductInput[] | TransferItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutProductInput | TransferItemCreateOrConnectWithoutProductInput[]
    createMany?: TransferItemCreateManyProductInputEnvelope
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
  }

  export type StockCorrectionItemCreateNestedManyWithoutProductInput = {
    create?: XOR<StockCorrectionItemCreateWithoutProductInput, StockCorrectionItemUncheckedCreateWithoutProductInput> | StockCorrectionItemCreateWithoutProductInput[] | StockCorrectionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockCorrectionItemCreateOrConnectWithoutProductInput | StockCorrectionItemCreateOrConnectWithoutProductInput[]
    createMany?: StockCorrectionItemCreateManyProductInputEnvelope
    connect?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
  }

  export type CartItemCreateNestedManyWithoutProductInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type AdditionalPriceCreateNestedManyWithoutProductInput = {
    create?: XOR<AdditionalPriceCreateWithoutProductInput, AdditionalPriceUncheckedCreateWithoutProductInput> | AdditionalPriceCreateWithoutProductInput[] | AdditionalPriceUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AdditionalPriceCreateOrConnectWithoutProductInput | AdditionalPriceCreateOrConnectWithoutProductInput[]
    createMany?: AdditionalPriceCreateManyProductInputEnvelope
    connect?: AdditionalPriceWhereUniqueInput | AdditionalPriceWhereUniqueInput[]
  }

  export type SellItemCreateNestedManyWithoutProductInput = {
    create?: XOR<SellItemCreateWithoutProductInput, SellItemUncheckedCreateWithoutProductInput> | SellItemCreateWithoutProductInput[] | SellItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SellItemCreateOrConnectWithoutProductInput | SellItemCreateOrConnectWithoutProductInput[]
    createMany?: SellItemCreateManyProductInputEnvelope
    connect?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
  }

  export type SellStockCorrectionItemCreateNestedManyWithoutProductInput = {
    create?: XOR<SellStockCorrectionItemCreateWithoutProductInput, SellStockCorrectionItemUncheckedCreateWithoutProductInput> | SellStockCorrectionItemCreateWithoutProductInput[] | SellStockCorrectionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SellStockCorrectionItemCreateOrConnectWithoutProductInput | SellStockCorrectionItemCreateOrConnectWithoutProductInput[]
    createMany?: SellStockCorrectionItemCreateManyProductInputEnvelope
    connect?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
  }

  export type WaitlistCreateNestedManyWithoutProductInput = {
    create?: XOR<WaitlistCreateWithoutProductInput, WaitlistUncheckedCreateWithoutProductInput> | WaitlistCreateWithoutProductInput[] | WaitlistUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutProductInput | WaitlistCreateOrConnectWithoutProductInput[]
    createMany?: WaitlistCreateManyProductInputEnvelope
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
  }

  export type ProductBatchUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductBatchCreateWithoutProductInput, ProductBatchUncheckedCreateWithoutProductInput> | ProductBatchCreateWithoutProductInput[] | ProductBatchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductBatchCreateOrConnectWithoutProductInput | ProductBatchCreateOrConnectWithoutProductInput[]
    createMany?: ProductBatchCreateManyProductInputEnvelope
    connect?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
  }

  export type PurchaseItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput> | PurchaseItemCreateWithoutProductInput[] | PurchaseItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutProductInput | PurchaseItemCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseItemCreateManyProductInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type TransferItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<TransferItemCreateWithoutProductInput, TransferItemUncheckedCreateWithoutProductInput> | TransferItemCreateWithoutProductInput[] | TransferItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutProductInput | TransferItemCreateOrConnectWithoutProductInput[]
    createMany?: TransferItemCreateManyProductInputEnvelope
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
  }

  export type StockCorrectionItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<StockCorrectionItemCreateWithoutProductInput, StockCorrectionItemUncheckedCreateWithoutProductInput> | StockCorrectionItemCreateWithoutProductInput[] | StockCorrectionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockCorrectionItemCreateOrConnectWithoutProductInput | StockCorrectionItemCreateOrConnectWithoutProductInput[]
    createMany?: StockCorrectionItemCreateManyProductInputEnvelope
    connect?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
  }

  export type CartItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type AdditionalPriceUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<AdditionalPriceCreateWithoutProductInput, AdditionalPriceUncheckedCreateWithoutProductInput> | AdditionalPriceCreateWithoutProductInput[] | AdditionalPriceUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AdditionalPriceCreateOrConnectWithoutProductInput | AdditionalPriceCreateOrConnectWithoutProductInput[]
    createMany?: AdditionalPriceCreateManyProductInputEnvelope
    connect?: AdditionalPriceWhereUniqueInput | AdditionalPriceWhereUniqueInput[]
  }

  export type SellItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SellItemCreateWithoutProductInput, SellItemUncheckedCreateWithoutProductInput> | SellItemCreateWithoutProductInput[] | SellItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SellItemCreateOrConnectWithoutProductInput | SellItemCreateOrConnectWithoutProductInput[]
    createMany?: SellItemCreateManyProductInputEnvelope
    connect?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
  }

  export type SellStockCorrectionItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SellStockCorrectionItemCreateWithoutProductInput, SellStockCorrectionItemUncheckedCreateWithoutProductInput> | SellStockCorrectionItemCreateWithoutProductInput[] | SellStockCorrectionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SellStockCorrectionItemCreateOrConnectWithoutProductInput | SellStockCorrectionItemCreateOrConnectWithoutProductInput[]
    createMany?: SellStockCorrectionItemCreateManyProductInputEnvelope
    connect?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
  }

  export type WaitlistUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<WaitlistCreateWithoutProductInput, WaitlistUncheckedCreateWithoutProductInput> | WaitlistCreateWithoutProductInput[] | WaitlistUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutProductInput | WaitlistCreateOrConnectWithoutProductInput[]
    createMany?: WaitlistCreateManyProductInputEnvelope
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type CategoryUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    upsert?: CategoryUpsertWithoutProductsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductsInput, CategoryUpdateWithoutProductsInput>, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type SubCategoryUpdateOneWithoutProductsNestedInput = {
    create?: XOR<SubCategoryCreateWithoutProductsInput, SubCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SubCategoryCreateOrConnectWithoutProductsInput
    upsert?: SubCategoryUpsertWithoutProductsInput
    disconnect?: SubCategoryWhereInput | boolean
    delete?: SubCategoryWhereInput | boolean
    connect?: SubCategoryWhereUniqueInput
    update?: XOR<XOR<SubCategoryUpdateToOneWithWhereWithoutProductsInput, SubCategoryUpdateWithoutProductsInput>, SubCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type UnitOfMeasureUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<UnitOfMeasureCreateWithoutProductsInput, UnitOfMeasureUncheckedCreateWithoutProductsInput>
    connectOrCreate?: UnitOfMeasureCreateOrConnectWithoutProductsInput
    upsert?: UnitOfMeasureUpsertWithoutProductsInput
    connect?: UnitOfMeasureWhereUniqueInput
    update?: XOR<XOR<UnitOfMeasureUpdateToOneWithWhereWithoutProductsInput, UnitOfMeasureUpdateWithoutProductsInput>, UnitOfMeasureUncheckedUpdateWithoutProductsInput>
  }

  export type ProductBatchUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductBatchCreateWithoutProductInput, ProductBatchUncheckedCreateWithoutProductInput> | ProductBatchCreateWithoutProductInput[] | ProductBatchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductBatchCreateOrConnectWithoutProductInput | ProductBatchCreateOrConnectWithoutProductInput[]
    upsert?: ProductBatchUpsertWithWhereUniqueWithoutProductInput | ProductBatchUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductBatchCreateManyProductInputEnvelope
    set?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
    disconnect?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
    delete?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
    connect?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
    update?: ProductBatchUpdateWithWhereUniqueWithoutProductInput | ProductBatchUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductBatchUpdateManyWithWhereWithoutProductInput | ProductBatchUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductBatchScalarWhereInput | ProductBatchScalarWhereInput[]
  }

  export type PurchaseItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput> | PurchaseItemCreateWithoutProductInput[] | PurchaseItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutProductInput | PurchaseItemCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutProductInput | PurchaseItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseItemCreateManyProductInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutProductInput | PurchaseItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutProductInput | PurchaseItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type TransferItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<TransferItemCreateWithoutProductInput, TransferItemUncheckedCreateWithoutProductInput> | TransferItemCreateWithoutProductInput[] | TransferItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutProductInput | TransferItemCreateOrConnectWithoutProductInput[]
    upsert?: TransferItemUpsertWithWhereUniqueWithoutProductInput | TransferItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TransferItemCreateManyProductInputEnvelope
    set?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    disconnect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    delete?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    update?: TransferItemUpdateWithWhereUniqueWithoutProductInput | TransferItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TransferItemUpdateManyWithWhereWithoutProductInput | TransferItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TransferItemScalarWhereInput | TransferItemScalarWhereInput[]
  }

  export type StockCorrectionItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockCorrectionItemCreateWithoutProductInput, StockCorrectionItemUncheckedCreateWithoutProductInput> | StockCorrectionItemCreateWithoutProductInput[] | StockCorrectionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockCorrectionItemCreateOrConnectWithoutProductInput | StockCorrectionItemCreateOrConnectWithoutProductInput[]
    upsert?: StockCorrectionItemUpsertWithWhereUniqueWithoutProductInput | StockCorrectionItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockCorrectionItemCreateManyProductInputEnvelope
    set?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    disconnect?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    delete?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    connect?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    update?: StockCorrectionItemUpdateWithWhereUniqueWithoutProductInput | StockCorrectionItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockCorrectionItemUpdateManyWithWhereWithoutProductInput | StockCorrectionItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockCorrectionItemScalarWhereInput | StockCorrectionItemScalarWhereInput[]
  }

  export type CartItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutProductInput | CartItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutProductInput | CartItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutProductInput | CartItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type AdditionalPriceUpdateManyWithoutProductNestedInput = {
    create?: XOR<AdditionalPriceCreateWithoutProductInput, AdditionalPriceUncheckedCreateWithoutProductInput> | AdditionalPriceCreateWithoutProductInput[] | AdditionalPriceUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AdditionalPriceCreateOrConnectWithoutProductInput | AdditionalPriceCreateOrConnectWithoutProductInput[]
    upsert?: AdditionalPriceUpsertWithWhereUniqueWithoutProductInput | AdditionalPriceUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: AdditionalPriceCreateManyProductInputEnvelope
    set?: AdditionalPriceWhereUniqueInput | AdditionalPriceWhereUniqueInput[]
    disconnect?: AdditionalPriceWhereUniqueInput | AdditionalPriceWhereUniqueInput[]
    delete?: AdditionalPriceWhereUniqueInput | AdditionalPriceWhereUniqueInput[]
    connect?: AdditionalPriceWhereUniqueInput | AdditionalPriceWhereUniqueInput[]
    update?: AdditionalPriceUpdateWithWhereUniqueWithoutProductInput | AdditionalPriceUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: AdditionalPriceUpdateManyWithWhereWithoutProductInput | AdditionalPriceUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: AdditionalPriceScalarWhereInput | AdditionalPriceScalarWhereInput[]
  }

  export type SellItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<SellItemCreateWithoutProductInput, SellItemUncheckedCreateWithoutProductInput> | SellItemCreateWithoutProductInput[] | SellItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SellItemCreateOrConnectWithoutProductInput | SellItemCreateOrConnectWithoutProductInput[]
    upsert?: SellItemUpsertWithWhereUniqueWithoutProductInput | SellItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SellItemCreateManyProductInputEnvelope
    set?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    disconnect?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    delete?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    connect?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    update?: SellItemUpdateWithWhereUniqueWithoutProductInput | SellItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SellItemUpdateManyWithWhereWithoutProductInput | SellItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SellItemScalarWhereInput | SellItemScalarWhereInput[]
  }

  export type SellStockCorrectionItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<SellStockCorrectionItemCreateWithoutProductInput, SellStockCorrectionItemUncheckedCreateWithoutProductInput> | SellStockCorrectionItemCreateWithoutProductInput[] | SellStockCorrectionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SellStockCorrectionItemCreateOrConnectWithoutProductInput | SellStockCorrectionItemCreateOrConnectWithoutProductInput[]
    upsert?: SellStockCorrectionItemUpsertWithWhereUniqueWithoutProductInput | SellStockCorrectionItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SellStockCorrectionItemCreateManyProductInputEnvelope
    set?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    disconnect?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    delete?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    connect?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    update?: SellStockCorrectionItemUpdateWithWhereUniqueWithoutProductInput | SellStockCorrectionItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SellStockCorrectionItemUpdateManyWithWhereWithoutProductInput | SellStockCorrectionItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SellStockCorrectionItemScalarWhereInput | SellStockCorrectionItemScalarWhereInput[]
  }

  export type WaitlistUpdateManyWithoutProductNestedInput = {
    create?: XOR<WaitlistCreateWithoutProductInput, WaitlistUncheckedCreateWithoutProductInput> | WaitlistCreateWithoutProductInput[] | WaitlistUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutProductInput | WaitlistCreateOrConnectWithoutProductInput[]
    upsert?: WaitlistUpsertWithWhereUniqueWithoutProductInput | WaitlistUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: WaitlistCreateManyProductInputEnvelope
    set?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    disconnect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    delete?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    update?: WaitlistUpdateWithWhereUniqueWithoutProductInput | WaitlistUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: WaitlistUpdateManyWithWhereWithoutProductInput | WaitlistUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: WaitlistScalarWhereInput | WaitlistScalarWhereInput[]
  }

  export type ProductBatchUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductBatchCreateWithoutProductInput, ProductBatchUncheckedCreateWithoutProductInput> | ProductBatchCreateWithoutProductInput[] | ProductBatchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductBatchCreateOrConnectWithoutProductInput | ProductBatchCreateOrConnectWithoutProductInput[]
    upsert?: ProductBatchUpsertWithWhereUniqueWithoutProductInput | ProductBatchUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductBatchCreateManyProductInputEnvelope
    set?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
    disconnect?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
    delete?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
    connect?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
    update?: ProductBatchUpdateWithWhereUniqueWithoutProductInput | ProductBatchUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductBatchUpdateManyWithWhereWithoutProductInput | ProductBatchUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductBatchScalarWhereInput | ProductBatchScalarWhereInput[]
  }

  export type PurchaseItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput> | PurchaseItemCreateWithoutProductInput[] | PurchaseItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutProductInput | PurchaseItemCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutProductInput | PurchaseItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseItemCreateManyProductInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutProductInput | PurchaseItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutProductInput | PurchaseItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type TransferItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<TransferItemCreateWithoutProductInput, TransferItemUncheckedCreateWithoutProductInput> | TransferItemCreateWithoutProductInput[] | TransferItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutProductInput | TransferItemCreateOrConnectWithoutProductInput[]
    upsert?: TransferItemUpsertWithWhereUniqueWithoutProductInput | TransferItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TransferItemCreateManyProductInputEnvelope
    set?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    disconnect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    delete?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    update?: TransferItemUpdateWithWhereUniqueWithoutProductInput | TransferItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TransferItemUpdateManyWithWhereWithoutProductInput | TransferItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TransferItemScalarWhereInput | TransferItemScalarWhereInput[]
  }

  export type StockCorrectionItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockCorrectionItemCreateWithoutProductInput, StockCorrectionItemUncheckedCreateWithoutProductInput> | StockCorrectionItemCreateWithoutProductInput[] | StockCorrectionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockCorrectionItemCreateOrConnectWithoutProductInput | StockCorrectionItemCreateOrConnectWithoutProductInput[]
    upsert?: StockCorrectionItemUpsertWithWhereUniqueWithoutProductInput | StockCorrectionItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockCorrectionItemCreateManyProductInputEnvelope
    set?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    disconnect?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    delete?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    connect?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    update?: StockCorrectionItemUpdateWithWhereUniqueWithoutProductInput | StockCorrectionItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockCorrectionItemUpdateManyWithWhereWithoutProductInput | StockCorrectionItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockCorrectionItemScalarWhereInput | StockCorrectionItemScalarWhereInput[]
  }

  export type CartItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutProductInput | CartItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutProductInput | CartItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutProductInput | CartItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type AdditionalPriceUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<AdditionalPriceCreateWithoutProductInput, AdditionalPriceUncheckedCreateWithoutProductInput> | AdditionalPriceCreateWithoutProductInput[] | AdditionalPriceUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AdditionalPriceCreateOrConnectWithoutProductInput | AdditionalPriceCreateOrConnectWithoutProductInput[]
    upsert?: AdditionalPriceUpsertWithWhereUniqueWithoutProductInput | AdditionalPriceUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: AdditionalPriceCreateManyProductInputEnvelope
    set?: AdditionalPriceWhereUniqueInput | AdditionalPriceWhereUniqueInput[]
    disconnect?: AdditionalPriceWhereUniqueInput | AdditionalPriceWhereUniqueInput[]
    delete?: AdditionalPriceWhereUniqueInput | AdditionalPriceWhereUniqueInput[]
    connect?: AdditionalPriceWhereUniqueInput | AdditionalPriceWhereUniqueInput[]
    update?: AdditionalPriceUpdateWithWhereUniqueWithoutProductInput | AdditionalPriceUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: AdditionalPriceUpdateManyWithWhereWithoutProductInput | AdditionalPriceUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: AdditionalPriceScalarWhereInput | AdditionalPriceScalarWhereInput[]
  }

  export type SellItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SellItemCreateWithoutProductInput, SellItemUncheckedCreateWithoutProductInput> | SellItemCreateWithoutProductInput[] | SellItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SellItemCreateOrConnectWithoutProductInput | SellItemCreateOrConnectWithoutProductInput[]
    upsert?: SellItemUpsertWithWhereUniqueWithoutProductInput | SellItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SellItemCreateManyProductInputEnvelope
    set?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    disconnect?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    delete?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    connect?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    update?: SellItemUpdateWithWhereUniqueWithoutProductInput | SellItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SellItemUpdateManyWithWhereWithoutProductInput | SellItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SellItemScalarWhereInput | SellItemScalarWhereInput[]
  }

  export type SellStockCorrectionItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SellStockCorrectionItemCreateWithoutProductInput, SellStockCorrectionItemUncheckedCreateWithoutProductInput> | SellStockCorrectionItemCreateWithoutProductInput[] | SellStockCorrectionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SellStockCorrectionItemCreateOrConnectWithoutProductInput | SellStockCorrectionItemCreateOrConnectWithoutProductInput[]
    upsert?: SellStockCorrectionItemUpsertWithWhereUniqueWithoutProductInput | SellStockCorrectionItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SellStockCorrectionItemCreateManyProductInputEnvelope
    set?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    disconnect?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    delete?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    connect?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    update?: SellStockCorrectionItemUpdateWithWhereUniqueWithoutProductInput | SellStockCorrectionItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SellStockCorrectionItemUpdateManyWithWhereWithoutProductInput | SellStockCorrectionItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SellStockCorrectionItemScalarWhereInput | SellStockCorrectionItemScalarWhereInput[]
  }

  export type WaitlistUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<WaitlistCreateWithoutProductInput, WaitlistUncheckedCreateWithoutProductInput> | WaitlistCreateWithoutProductInput[] | WaitlistUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutProductInput | WaitlistCreateOrConnectWithoutProductInput[]
    upsert?: WaitlistUpsertWithWhereUniqueWithoutProductInput | WaitlistUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: WaitlistCreateManyProductInputEnvelope
    set?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    disconnect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    delete?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    update?: WaitlistUpdateWithWhereUniqueWithoutProductInput | WaitlistUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: WaitlistUpdateManyWithWhereWithoutProductInput | WaitlistUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: WaitlistScalarWhereInput | WaitlistScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutAdditionalPriceInput = {
    create?: XOR<ProductCreateWithoutAdditionalPriceInput, ProductUncheckedCreateWithoutAdditionalPriceInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAdditionalPriceInput
    connect?: ProductWhereUniqueInput
  }

  export type ShopCreateNestedOneWithoutAdditionalPriceInput = {
    create?: XOR<ShopCreateWithoutAdditionalPriceInput, ShopUncheckedCreateWithoutAdditionalPriceInput>
    connectOrCreate?: ShopCreateOrConnectWithoutAdditionalPriceInput
    connect?: ShopWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductUpdateOneRequiredWithoutAdditionalPriceNestedInput = {
    create?: XOR<ProductCreateWithoutAdditionalPriceInput, ProductUncheckedCreateWithoutAdditionalPriceInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAdditionalPriceInput
    upsert?: ProductUpsertWithoutAdditionalPriceInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutAdditionalPriceInput, ProductUpdateWithoutAdditionalPriceInput>, ProductUncheckedUpdateWithoutAdditionalPriceInput>
  }

  export type ShopUpdateOneWithoutAdditionalPriceNestedInput = {
    create?: XOR<ShopCreateWithoutAdditionalPriceInput, ShopUncheckedCreateWithoutAdditionalPriceInput>
    connectOrCreate?: ShopCreateOrConnectWithoutAdditionalPriceInput
    upsert?: ShopUpsertWithoutAdditionalPriceInput
    disconnect?: ShopWhereInput | boolean
    delete?: ShopWhereInput | boolean
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutAdditionalPriceInput, ShopUpdateWithoutAdditionalPriceInput>, ShopUncheckedUpdateWithoutAdditionalPriceInput>
  }

  export type StoreCreateNestedOneWithoutProductBatchInput = {
    create?: XOR<StoreCreateWithoutProductBatchInput, StoreUncheckedCreateWithoutProductBatchInput>
    connectOrCreate?: StoreCreateOrConnectWithoutProductBatchInput
    connect?: StoreWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutBatchesInput = {
    create?: XOR<ProductCreateWithoutBatchesInput, ProductUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutBatchesInput
    connect?: ProductWhereUniqueInput
  }

  export type ShopStockCreateNestedManyWithoutBatchInput = {
    create?: XOR<ShopStockCreateWithoutBatchInput, ShopStockUncheckedCreateWithoutBatchInput> | ShopStockCreateWithoutBatchInput[] | ShopStockUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: ShopStockCreateOrConnectWithoutBatchInput | ShopStockCreateOrConnectWithoutBatchInput[]
    createMany?: ShopStockCreateManyBatchInputEnvelope
    connect?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
  }

  export type StoreStockCreateNestedManyWithoutBatchInput = {
    create?: XOR<StoreStockCreateWithoutBatchInput, StoreStockUncheckedCreateWithoutBatchInput> | StoreStockCreateWithoutBatchInput[] | StoreStockUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: StoreStockCreateOrConnectWithoutBatchInput | StoreStockCreateOrConnectWithoutBatchInput[]
    createMany?: StoreStockCreateManyBatchInputEnvelope
    connect?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
  }

  export type StockLedgerCreateNestedManyWithoutBatchInput = {
    create?: XOR<StockLedgerCreateWithoutBatchInput, StockLedgerUncheckedCreateWithoutBatchInput> | StockLedgerCreateWithoutBatchInput[] | StockLedgerUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutBatchInput | StockLedgerCreateOrConnectWithoutBatchInput[]
    createMany?: StockLedgerCreateManyBatchInputEnvelope
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
  }

  export type PurchaseItemCreateNestedManyWithoutBatchInput = {
    create?: XOR<PurchaseItemCreateWithoutBatchInput, PurchaseItemUncheckedCreateWithoutBatchInput> | PurchaseItemCreateWithoutBatchInput[] | PurchaseItemUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutBatchInput | PurchaseItemCreateOrConnectWithoutBatchInput[]
    createMany?: PurchaseItemCreateManyBatchInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type TransferItemCreateNestedManyWithoutBatchInput = {
    create?: XOR<TransferItemCreateWithoutBatchInput, TransferItemUncheckedCreateWithoutBatchInput> | TransferItemCreateWithoutBatchInput[] | TransferItemUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutBatchInput | TransferItemCreateOrConnectWithoutBatchInput[]
    createMany?: TransferItemCreateManyBatchInputEnvelope
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
  }

  export type StockCorrectionItemCreateNestedManyWithoutBatchInput = {
    create?: XOR<StockCorrectionItemCreateWithoutBatchInput, StockCorrectionItemUncheckedCreateWithoutBatchInput> | StockCorrectionItemCreateWithoutBatchInput[] | StockCorrectionItemUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: StockCorrectionItemCreateOrConnectWithoutBatchInput | StockCorrectionItemCreateOrConnectWithoutBatchInput[]
    createMany?: StockCorrectionItemCreateManyBatchInputEnvelope
    connect?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
  }

  export type SellItemBatchCreateNestedManyWithoutBatchInput = {
    create?: XOR<SellItemBatchCreateWithoutBatchInput, SellItemBatchUncheckedCreateWithoutBatchInput> | SellItemBatchCreateWithoutBatchInput[] | SellItemBatchUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: SellItemBatchCreateOrConnectWithoutBatchInput | SellItemBatchCreateOrConnectWithoutBatchInput[]
    createMany?: SellItemBatchCreateManyBatchInputEnvelope
    connect?: SellItemBatchWhereUniqueInput | SellItemBatchWhereUniqueInput[]
  }

  export type SellStockCorrectionBatchCreateNestedManyWithoutBatchInput = {
    create?: XOR<SellStockCorrectionBatchCreateWithoutBatchInput, SellStockCorrectionBatchUncheckedCreateWithoutBatchInput> | SellStockCorrectionBatchCreateWithoutBatchInput[] | SellStockCorrectionBatchUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: SellStockCorrectionBatchCreateOrConnectWithoutBatchInput | SellStockCorrectionBatchCreateOrConnectWithoutBatchInput[]
    createMany?: SellStockCorrectionBatchCreateManyBatchInputEnvelope
    connect?: SellStockCorrectionBatchWhereUniqueInput | SellStockCorrectionBatchWhereUniqueInput[]
  }

  export type ShopStockUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<ShopStockCreateWithoutBatchInput, ShopStockUncheckedCreateWithoutBatchInput> | ShopStockCreateWithoutBatchInput[] | ShopStockUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: ShopStockCreateOrConnectWithoutBatchInput | ShopStockCreateOrConnectWithoutBatchInput[]
    createMany?: ShopStockCreateManyBatchInputEnvelope
    connect?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
  }

  export type StoreStockUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<StoreStockCreateWithoutBatchInput, StoreStockUncheckedCreateWithoutBatchInput> | StoreStockCreateWithoutBatchInput[] | StoreStockUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: StoreStockCreateOrConnectWithoutBatchInput | StoreStockCreateOrConnectWithoutBatchInput[]
    createMany?: StoreStockCreateManyBatchInputEnvelope
    connect?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
  }

  export type StockLedgerUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<StockLedgerCreateWithoutBatchInput, StockLedgerUncheckedCreateWithoutBatchInput> | StockLedgerCreateWithoutBatchInput[] | StockLedgerUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutBatchInput | StockLedgerCreateOrConnectWithoutBatchInput[]
    createMany?: StockLedgerCreateManyBatchInputEnvelope
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
  }

  export type PurchaseItemUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<PurchaseItemCreateWithoutBatchInput, PurchaseItemUncheckedCreateWithoutBatchInput> | PurchaseItemCreateWithoutBatchInput[] | PurchaseItemUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutBatchInput | PurchaseItemCreateOrConnectWithoutBatchInput[]
    createMany?: PurchaseItemCreateManyBatchInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type TransferItemUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<TransferItemCreateWithoutBatchInput, TransferItemUncheckedCreateWithoutBatchInput> | TransferItemCreateWithoutBatchInput[] | TransferItemUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutBatchInput | TransferItemCreateOrConnectWithoutBatchInput[]
    createMany?: TransferItemCreateManyBatchInputEnvelope
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
  }

  export type StockCorrectionItemUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<StockCorrectionItemCreateWithoutBatchInput, StockCorrectionItemUncheckedCreateWithoutBatchInput> | StockCorrectionItemCreateWithoutBatchInput[] | StockCorrectionItemUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: StockCorrectionItemCreateOrConnectWithoutBatchInput | StockCorrectionItemCreateOrConnectWithoutBatchInput[]
    createMany?: StockCorrectionItemCreateManyBatchInputEnvelope
    connect?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
  }

  export type SellItemBatchUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<SellItemBatchCreateWithoutBatchInput, SellItemBatchUncheckedCreateWithoutBatchInput> | SellItemBatchCreateWithoutBatchInput[] | SellItemBatchUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: SellItemBatchCreateOrConnectWithoutBatchInput | SellItemBatchCreateOrConnectWithoutBatchInput[]
    createMany?: SellItemBatchCreateManyBatchInputEnvelope
    connect?: SellItemBatchWhereUniqueInput | SellItemBatchWhereUniqueInput[]
  }

  export type SellStockCorrectionBatchUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<SellStockCorrectionBatchCreateWithoutBatchInput, SellStockCorrectionBatchUncheckedCreateWithoutBatchInput> | SellStockCorrectionBatchCreateWithoutBatchInput[] | SellStockCorrectionBatchUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: SellStockCorrectionBatchCreateOrConnectWithoutBatchInput | SellStockCorrectionBatchCreateOrConnectWithoutBatchInput[]
    createMany?: SellStockCorrectionBatchCreateManyBatchInputEnvelope
    connect?: SellStockCorrectionBatchWhereUniqueInput | SellStockCorrectionBatchWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StoreUpdateOneWithoutProductBatchNestedInput = {
    create?: XOR<StoreCreateWithoutProductBatchInput, StoreUncheckedCreateWithoutProductBatchInput>
    connectOrCreate?: StoreCreateOrConnectWithoutProductBatchInput
    upsert?: StoreUpsertWithoutProductBatchInput
    disconnect?: StoreWhereInput | boolean
    delete?: StoreWhereInput | boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutProductBatchInput, StoreUpdateWithoutProductBatchInput>, StoreUncheckedUpdateWithoutProductBatchInput>
  }

  export type ProductUpdateOneRequiredWithoutBatchesNestedInput = {
    create?: XOR<ProductCreateWithoutBatchesInput, ProductUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutBatchesInput
    upsert?: ProductUpsertWithoutBatchesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutBatchesInput, ProductUpdateWithoutBatchesInput>, ProductUncheckedUpdateWithoutBatchesInput>
  }

  export type ShopStockUpdateManyWithoutBatchNestedInput = {
    create?: XOR<ShopStockCreateWithoutBatchInput, ShopStockUncheckedCreateWithoutBatchInput> | ShopStockCreateWithoutBatchInput[] | ShopStockUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: ShopStockCreateOrConnectWithoutBatchInput | ShopStockCreateOrConnectWithoutBatchInput[]
    upsert?: ShopStockUpsertWithWhereUniqueWithoutBatchInput | ShopStockUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: ShopStockCreateManyBatchInputEnvelope
    set?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
    disconnect?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
    delete?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
    connect?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
    update?: ShopStockUpdateWithWhereUniqueWithoutBatchInput | ShopStockUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: ShopStockUpdateManyWithWhereWithoutBatchInput | ShopStockUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: ShopStockScalarWhereInput | ShopStockScalarWhereInput[]
  }

  export type StoreStockUpdateManyWithoutBatchNestedInput = {
    create?: XOR<StoreStockCreateWithoutBatchInput, StoreStockUncheckedCreateWithoutBatchInput> | StoreStockCreateWithoutBatchInput[] | StoreStockUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: StoreStockCreateOrConnectWithoutBatchInput | StoreStockCreateOrConnectWithoutBatchInput[]
    upsert?: StoreStockUpsertWithWhereUniqueWithoutBatchInput | StoreStockUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: StoreStockCreateManyBatchInputEnvelope
    set?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
    disconnect?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
    delete?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
    connect?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
    update?: StoreStockUpdateWithWhereUniqueWithoutBatchInput | StoreStockUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: StoreStockUpdateManyWithWhereWithoutBatchInput | StoreStockUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: StoreStockScalarWhereInput | StoreStockScalarWhereInput[]
  }

  export type StockLedgerUpdateManyWithoutBatchNestedInput = {
    create?: XOR<StockLedgerCreateWithoutBatchInput, StockLedgerUncheckedCreateWithoutBatchInput> | StockLedgerCreateWithoutBatchInput[] | StockLedgerUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutBatchInput | StockLedgerCreateOrConnectWithoutBatchInput[]
    upsert?: StockLedgerUpsertWithWhereUniqueWithoutBatchInput | StockLedgerUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: StockLedgerCreateManyBatchInputEnvelope
    set?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    disconnect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    delete?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    update?: StockLedgerUpdateWithWhereUniqueWithoutBatchInput | StockLedgerUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: StockLedgerUpdateManyWithWhereWithoutBatchInput | StockLedgerUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: StockLedgerScalarWhereInput | StockLedgerScalarWhereInput[]
  }

  export type PurchaseItemUpdateManyWithoutBatchNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutBatchInput, PurchaseItemUncheckedCreateWithoutBatchInput> | PurchaseItemCreateWithoutBatchInput[] | PurchaseItemUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutBatchInput | PurchaseItemCreateOrConnectWithoutBatchInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutBatchInput | PurchaseItemUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: PurchaseItemCreateManyBatchInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutBatchInput | PurchaseItemUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutBatchInput | PurchaseItemUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type TransferItemUpdateManyWithoutBatchNestedInput = {
    create?: XOR<TransferItemCreateWithoutBatchInput, TransferItemUncheckedCreateWithoutBatchInput> | TransferItemCreateWithoutBatchInput[] | TransferItemUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutBatchInput | TransferItemCreateOrConnectWithoutBatchInput[]
    upsert?: TransferItemUpsertWithWhereUniqueWithoutBatchInput | TransferItemUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: TransferItemCreateManyBatchInputEnvelope
    set?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    disconnect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    delete?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    update?: TransferItemUpdateWithWhereUniqueWithoutBatchInput | TransferItemUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: TransferItemUpdateManyWithWhereWithoutBatchInput | TransferItemUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: TransferItemScalarWhereInput | TransferItemScalarWhereInput[]
  }

  export type StockCorrectionItemUpdateManyWithoutBatchNestedInput = {
    create?: XOR<StockCorrectionItemCreateWithoutBatchInput, StockCorrectionItemUncheckedCreateWithoutBatchInput> | StockCorrectionItemCreateWithoutBatchInput[] | StockCorrectionItemUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: StockCorrectionItemCreateOrConnectWithoutBatchInput | StockCorrectionItemCreateOrConnectWithoutBatchInput[]
    upsert?: StockCorrectionItemUpsertWithWhereUniqueWithoutBatchInput | StockCorrectionItemUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: StockCorrectionItemCreateManyBatchInputEnvelope
    set?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    disconnect?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    delete?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    connect?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    update?: StockCorrectionItemUpdateWithWhereUniqueWithoutBatchInput | StockCorrectionItemUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: StockCorrectionItemUpdateManyWithWhereWithoutBatchInput | StockCorrectionItemUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: StockCorrectionItemScalarWhereInput | StockCorrectionItemScalarWhereInput[]
  }

  export type SellItemBatchUpdateManyWithoutBatchNestedInput = {
    create?: XOR<SellItemBatchCreateWithoutBatchInput, SellItemBatchUncheckedCreateWithoutBatchInput> | SellItemBatchCreateWithoutBatchInput[] | SellItemBatchUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: SellItemBatchCreateOrConnectWithoutBatchInput | SellItemBatchCreateOrConnectWithoutBatchInput[]
    upsert?: SellItemBatchUpsertWithWhereUniqueWithoutBatchInput | SellItemBatchUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: SellItemBatchCreateManyBatchInputEnvelope
    set?: SellItemBatchWhereUniqueInput | SellItemBatchWhereUniqueInput[]
    disconnect?: SellItemBatchWhereUniqueInput | SellItemBatchWhereUniqueInput[]
    delete?: SellItemBatchWhereUniqueInput | SellItemBatchWhereUniqueInput[]
    connect?: SellItemBatchWhereUniqueInput | SellItemBatchWhereUniqueInput[]
    update?: SellItemBatchUpdateWithWhereUniqueWithoutBatchInput | SellItemBatchUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: SellItemBatchUpdateManyWithWhereWithoutBatchInput | SellItemBatchUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: SellItemBatchScalarWhereInput | SellItemBatchScalarWhereInput[]
  }

  export type SellStockCorrectionBatchUpdateManyWithoutBatchNestedInput = {
    create?: XOR<SellStockCorrectionBatchCreateWithoutBatchInput, SellStockCorrectionBatchUncheckedCreateWithoutBatchInput> | SellStockCorrectionBatchCreateWithoutBatchInput[] | SellStockCorrectionBatchUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: SellStockCorrectionBatchCreateOrConnectWithoutBatchInput | SellStockCorrectionBatchCreateOrConnectWithoutBatchInput[]
    upsert?: SellStockCorrectionBatchUpsertWithWhereUniqueWithoutBatchInput | SellStockCorrectionBatchUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: SellStockCorrectionBatchCreateManyBatchInputEnvelope
    set?: SellStockCorrectionBatchWhereUniqueInput | SellStockCorrectionBatchWhereUniqueInput[]
    disconnect?: SellStockCorrectionBatchWhereUniqueInput | SellStockCorrectionBatchWhereUniqueInput[]
    delete?: SellStockCorrectionBatchWhereUniqueInput | SellStockCorrectionBatchWhereUniqueInput[]
    connect?: SellStockCorrectionBatchWhereUniqueInput | SellStockCorrectionBatchWhereUniqueInput[]
    update?: SellStockCorrectionBatchUpdateWithWhereUniqueWithoutBatchInput | SellStockCorrectionBatchUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: SellStockCorrectionBatchUpdateManyWithWhereWithoutBatchInput | SellStockCorrectionBatchUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: SellStockCorrectionBatchScalarWhereInput | SellStockCorrectionBatchScalarWhereInput[]
  }

  export type ShopStockUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<ShopStockCreateWithoutBatchInput, ShopStockUncheckedCreateWithoutBatchInput> | ShopStockCreateWithoutBatchInput[] | ShopStockUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: ShopStockCreateOrConnectWithoutBatchInput | ShopStockCreateOrConnectWithoutBatchInput[]
    upsert?: ShopStockUpsertWithWhereUniqueWithoutBatchInput | ShopStockUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: ShopStockCreateManyBatchInputEnvelope
    set?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
    disconnect?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
    delete?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
    connect?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
    update?: ShopStockUpdateWithWhereUniqueWithoutBatchInput | ShopStockUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: ShopStockUpdateManyWithWhereWithoutBatchInput | ShopStockUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: ShopStockScalarWhereInput | ShopStockScalarWhereInput[]
  }

  export type StoreStockUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<StoreStockCreateWithoutBatchInput, StoreStockUncheckedCreateWithoutBatchInput> | StoreStockCreateWithoutBatchInput[] | StoreStockUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: StoreStockCreateOrConnectWithoutBatchInput | StoreStockCreateOrConnectWithoutBatchInput[]
    upsert?: StoreStockUpsertWithWhereUniqueWithoutBatchInput | StoreStockUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: StoreStockCreateManyBatchInputEnvelope
    set?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
    disconnect?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
    delete?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
    connect?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
    update?: StoreStockUpdateWithWhereUniqueWithoutBatchInput | StoreStockUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: StoreStockUpdateManyWithWhereWithoutBatchInput | StoreStockUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: StoreStockScalarWhereInput | StoreStockScalarWhereInput[]
  }

  export type StockLedgerUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<StockLedgerCreateWithoutBatchInput, StockLedgerUncheckedCreateWithoutBatchInput> | StockLedgerCreateWithoutBatchInput[] | StockLedgerUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutBatchInput | StockLedgerCreateOrConnectWithoutBatchInput[]
    upsert?: StockLedgerUpsertWithWhereUniqueWithoutBatchInput | StockLedgerUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: StockLedgerCreateManyBatchInputEnvelope
    set?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    disconnect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    delete?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    update?: StockLedgerUpdateWithWhereUniqueWithoutBatchInput | StockLedgerUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: StockLedgerUpdateManyWithWhereWithoutBatchInput | StockLedgerUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: StockLedgerScalarWhereInput | StockLedgerScalarWhereInput[]
  }

  export type PurchaseItemUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutBatchInput, PurchaseItemUncheckedCreateWithoutBatchInput> | PurchaseItemCreateWithoutBatchInput[] | PurchaseItemUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutBatchInput | PurchaseItemCreateOrConnectWithoutBatchInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutBatchInput | PurchaseItemUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: PurchaseItemCreateManyBatchInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutBatchInput | PurchaseItemUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutBatchInput | PurchaseItemUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type TransferItemUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<TransferItemCreateWithoutBatchInput, TransferItemUncheckedCreateWithoutBatchInput> | TransferItemCreateWithoutBatchInput[] | TransferItemUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutBatchInput | TransferItemCreateOrConnectWithoutBatchInput[]
    upsert?: TransferItemUpsertWithWhereUniqueWithoutBatchInput | TransferItemUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: TransferItemCreateManyBatchInputEnvelope
    set?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    disconnect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    delete?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    update?: TransferItemUpdateWithWhereUniqueWithoutBatchInput | TransferItemUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: TransferItemUpdateManyWithWhereWithoutBatchInput | TransferItemUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: TransferItemScalarWhereInput | TransferItemScalarWhereInput[]
  }

  export type StockCorrectionItemUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<StockCorrectionItemCreateWithoutBatchInput, StockCorrectionItemUncheckedCreateWithoutBatchInput> | StockCorrectionItemCreateWithoutBatchInput[] | StockCorrectionItemUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: StockCorrectionItemCreateOrConnectWithoutBatchInput | StockCorrectionItemCreateOrConnectWithoutBatchInput[]
    upsert?: StockCorrectionItemUpsertWithWhereUniqueWithoutBatchInput | StockCorrectionItemUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: StockCorrectionItemCreateManyBatchInputEnvelope
    set?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    disconnect?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    delete?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    connect?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    update?: StockCorrectionItemUpdateWithWhereUniqueWithoutBatchInput | StockCorrectionItemUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: StockCorrectionItemUpdateManyWithWhereWithoutBatchInput | StockCorrectionItemUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: StockCorrectionItemScalarWhereInput | StockCorrectionItemScalarWhereInput[]
  }

  export type SellItemBatchUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<SellItemBatchCreateWithoutBatchInput, SellItemBatchUncheckedCreateWithoutBatchInput> | SellItemBatchCreateWithoutBatchInput[] | SellItemBatchUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: SellItemBatchCreateOrConnectWithoutBatchInput | SellItemBatchCreateOrConnectWithoutBatchInput[]
    upsert?: SellItemBatchUpsertWithWhereUniqueWithoutBatchInput | SellItemBatchUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: SellItemBatchCreateManyBatchInputEnvelope
    set?: SellItemBatchWhereUniqueInput | SellItemBatchWhereUniqueInput[]
    disconnect?: SellItemBatchWhereUniqueInput | SellItemBatchWhereUniqueInput[]
    delete?: SellItemBatchWhereUniqueInput | SellItemBatchWhereUniqueInput[]
    connect?: SellItemBatchWhereUniqueInput | SellItemBatchWhereUniqueInput[]
    update?: SellItemBatchUpdateWithWhereUniqueWithoutBatchInput | SellItemBatchUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: SellItemBatchUpdateManyWithWhereWithoutBatchInput | SellItemBatchUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: SellItemBatchScalarWhereInput | SellItemBatchScalarWhereInput[]
  }

  export type SellStockCorrectionBatchUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<SellStockCorrectionBatchCreateWithoutBatchInput, SellStockCorrectionBatchUncheckedCreateWithoutBatchInput> | SellStockCorrectionBatchCreateWithoutBatchInput[] | SellStockCorrectionBatchUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: SellStockCorrectionBatchCreateOrConnectWithoutBatchInput | SellStockCorrectionBatchCreateOrConnectWithoutBatchInput[]
    upsert?: SellStockCorrectionBatchUpsertWithWhereUniqueWithoutBatchInput | SellStockCorrectionBatchUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: SellStockCorrectionBatchCreateManyBatchInputEnvelope
    set?: SellStockCorrectionBatchWhereUniqueInput | SellStockCorrectionBatchWhereUniqueInput[]
    disconnect?: SellStockCorrectionBatchWhereUniqueInput | SellStockCorrectionBatchWhereUniqueInput[]
    delete?: SellStockCorrectionBatchWhereUniqueInput | SellStockCorrectionBatchWhereUniqueInput[]
    connect?: SellStockCorrectionBatchWhereUniqueInput | SellStockCorrectionBatchWhereUniqueInput[]
    update?: SellStockCorrectionBatchUpdateWithWhereUniqueWithoutBatchInput | SellStockCorrectionBatchUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: SellStockCorrectionBatchUpdateManyWithWhereWithoutBatchInput | SellStockCorrectionBatchUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: SellStockCorrectionBatchScalarWhereInput | SellStockCorrectionBatchScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutUnitOfMeasureInput = {
    create?: XOR<ProductCreateWithoutUnitOfMeasureInput, ProductUncheckedCreateWithoutUnitOfMeasureInput> | ProductCreateWithoutUnitOfMeasureInput[] | ProductUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUnitOfMeasureInput | ProductCreateOrConnectWithoutUnitOfMeasureInput[]
    createMany?: ProductCreateManyUnitOfMeasureInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type PurchaseItemCreateNestedManyWithoutUnitOfMeasureInput = {
    create?: XOR<PurchaseItemCreateWithoutUnitOfMeasureInput, PurchaseItemUncheckedCreateWithoutUnitOfMeasureInput> | PurchaseItemCreateWithoutUnitOfMeasureInput[] | PurchaseItemUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutUnitOfMeasureInput | PurchaseItemCreateOrConnectWithoutUnitOfMeasureInput[]
    createMany?: PurchaseItemCreateManyUnitOfMeasureInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type TransferItemCreateNestedManyWithoutUnitOfMeasureInput = {
    create?: XOR<TransferItemCreateWithoutUnitOfMeasureInput, TransferItemUncheckedCreateWithoutUnitOfMeasureInput> | TransferItemCreateWithoutUnitOfMeasureInput[] | TransferItemUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutUnitOfMeasureInput | TransferItemCreateOrConnectWithoutUnitOfMeasureInput[]
    createMany?: TransferItemCreateManyUnitOfMeasureInputEnvelope
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
  }

  export type StockLedgerCreateNestedManyWithoutUnitOfMeasureInput = {
    create?: XOR<StockLedgerCreateWithoutUnitOfMeasureInput, StockLedgerUncheckedCreateWithoutUnitOfMeasureInput> | StockLedgerCreateWithoutUnitOfMeasureInput[] | StockLedgerUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutUnitOfMeasureInput | StockLedgerCreateOrConnectWithoutUnitOfMeasureInput[]
    createMany?: StockLedgerCreateManyUnitOfMeasureInputEnvelope
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
  }

  export type ShopStockCreateNestedManyWithoutUnitOfMeasureInput = {
    create?: XOR<ShopStockCreateWithoutUnitOfMeasureInput, ShopStockUncheckedCreateWithoutUnitOfMeasureInput> | ShopStockCreateWithoutUnitOfMeasureInput[] | ShopStockUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: ShopStockCreateOrConnectWithoutUnitOfMeasureInput | ShopStockCreateOrConnectWithoutUnitOfMeasureInput[]
    createMany?: ShopStockCreateManyUnitOfMeasureInputEnvelope
    connect?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
  }

  export type StoreStockCreateNestedManyWithoutUnitOfMeasureInput = {
    create?: XOR<StoreStockCreateWithoutUnitOfMeasureInput, StoreStockUncheckedCreateWithoutUnitOfMeasureInput> | StoreStockCreateWithoutUnitOfMeasureInput[] | StoreStockUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: StoreStockCreateOrConnectWithoutUnitOfMeasureInput | StoreStockCreateOrConnectWithoutUnitOfMeasureInput[]
    createMany?: StoreStockCreateManyUnitOfMeasureInputEnvelope
    connect?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
  }

  export type StockCorrectionItemCreateNestedManyWithoutUnitOfMeasureInput = {
    create?: XOR<StockCorrectionItemCreateWithoutUnitOfMeasureInput, StockCorrectionItemUncheckedCreateWithoutUnitOfMeasureInput> | StockCorrectionItemCreateWithoutUnitOfMeasureInput[] | StockCorrectionItemUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: StockCorrectionItemCreateOrConnectWithoutUnitOfMeasureInput | StockCorrectionItemCreateOrConnectWithoutUnitOfMeasureInput[]
    createMany?: StockCorrectionItemCreateManyUnitOfMeasureInputEnvelope
    connect?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
  }

  export type SellItemCreateNestedManyWithoutUnitOfMeasureInput = {
    create?: XOR<SellItemCreateWithoutUnitOfMeasureInput, SellItemUncheckedCreateWithoutUnitOfMeasureInput> | SellItemCreateWithoutUnitOfMeasureInput[] | SellItemUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: SellItemCreateOrConnectWithoutUnitOfMeasureInput | SellItemCreateOrConnectWithoutUnitOfMeasureInput[]
    createMany?: SellItemCreateManyUnitOfMeasureInputEnvelope
    connect?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
  }

  export type SellStockCorrectionItemCreateNestedManyWithoutUnitOfMeasureInput = {
    create?: XOR<SellStockCorrectionItemCreateWithoutUnitOfMeasureInput, SellStockCorrectionItemUncheckedCreateWithoutUnitOfMeasureInput> | SellStockCorrectionItemCreateWithoutUnitOfMeasureInput[] | SellStockCorrectionItemUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: SellStockCorrectionItemCreateOrConnectWithoutUnitOfMeasureInput | SellStockCorrectionItemCreateOrConnectWithoutUnitOfMeasureInput[]
    createMany?: SellStockCorrectionItemCreateManyUnitOfMeasureInputEnvelope
    connect?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
  }

  export type CartItemCreateNestedManyWithoutUnitOfMeasureInput = {
    create?: XOR<CartItemCreateWithoutUnitOfMeasureInput, CartItemUncheckedCreateWithoutUnitOfMeasureInput> | CartItemCreateWithoutUnitOfMeasureInput[] | CartItemUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutUnitOfMeasureInput | CartItemCreateOrConnectWithoutUnitOfMeasureInput[]
    createMany?: CartItemCreateManyUnitOfMeasureInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutUnitOfMeasureInput = {
    create?: XOR<ProductCreateWithoutUnitOfMeasureInput, ProductUncheckedCreateWithoutUnitOfMeasureInput> | ProductCreateWithoutUnitOfMeasureInput[] | ProductUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUnitOfMeasureInput | ProductCreateOrConnectWithoutUnitOfMeasureInput[]
    createMany?: ProductCreateManyUnitOfMeasureInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type PurchaseItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput = {
    create?: XOR<PurchaseItemCreateWithoutUnitOfMeasureInput, PurchaseItemUncheckedCreateWithoutUnitOfMeasureInput> | PurchaseItemCreateWithoutUnitOfMeasureInput[] | PurchaseItemUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutUnitOfMeasureInput | PurchaseItemCreateOrConnectWithoutUnitOfMeasureInput[]
    createMany?: PurchaseItemCreateManyUnitOfMeasureInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type TransferItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput = {
    create?: XOR<TransferItemCreateWithoutUnitOfMeasureInput, TransferItemUncheckedCreateWithoutUnitOfMeasureInput> | TransferItemCreateWithoutUnitOfMeasureInput[] | TransferItemUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutUnitOfMeasureInput | TransferItemCreateOrConnectWithoutUnitOfMeasureInput[]
    createMany?: TransferItemCreateManyUnitOfMeasureInputEnvelope
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
  }

  export type StockLedgerUncheckedCreateNestedManyWithoutUnitOfMeasureInput = {
    create?: XOR<StockLedgerCreateWithoutUnitOfMeasureInput, StockLedgerUncheckedCreateWithoutUnitOfMeasureInput> | StockLedgerCreateWithoutUnitOfMeasureInput[] | StockLedgerUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutUnitOfMeasureInput | StockLedgerCreateOrConnectWithoutUnitOfMeasureInput[]
    createMany?: StockLedgerCreateManyUnitOfMeasureInputEnvelope
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
  }

  export type ShopStockUncheckedCreateNestedManyWithoutUnitOfMeasureInput = {
    create?: XOR<ShopStockCreateWithoutUnitOfMeasureInput, ShopStockUncheckedCreateWithoutUnitOfMeasureInput> | ShopStockCreateWithoutUnitOfMeasureInput[] | ShopStockUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: ShopStockCreateOrConnectWithoutUnitOfMeasureInput | ShopStockCreateOrConnectWithoutUnitOfMeasureInput[]
    createMany?: ShopStockCreateManyUnitOfMeasureInputEnvelope
    connect?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
  }

  export type StoreStockUncheckedCreateNestedManyWithoutUnitOfMeasureInput = {
    create?: XOR<StoreStockCreateWithoutUnitOfMeasureInput, StoreStockUncheckedCreateWithoutUnitOfMeasureInput> | StoreStockCreateWithoutUnitOfMeasureInput[] | StoreStockUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: StoreStockCreateOrConnectWithoutUnitOfMeasureInput | StoreStockCreateOrConnectWithoutUnitOfMeasureInput[]
    createMany?: StoreStockCreateManyUnitOfMeasureInputEnvelope
    connect?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
  }

  export type StockCorrectionItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput = {
    create?: XOR<StockCorrectionItemCreateWithoutUnitOfMeasureInput, StockCorrectionItemUncheckedCreateWithoutUnitOfMeasureInput> | StockCorrectionItemCreateWithoutUnitOfMeasureInput[] | StockCorrectionItemUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: StockCorrectionItemCreateOrConnectWithoutUnitOfMeasureInput | StockCorrectionItemCreateOrConnectWithoutUnitOfMeasureInput[]
    createMany?: StockCorrectionItemCreateManyUnitOfMeasureInputEnvelope
    connect?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
  }

  export type SellItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput = {
    create?: XOR<SellItemCreateWithoutUnitOfMeasureInput, SellItemUncheckedCreateWithoutUnitOfMeasureInput> | SellItemCreateWithoutUnitOfMeasureInput[] | SellItemUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: SellItemCreateOrConnectWithoutUnitOfMeasureInput | SellItemCreateOrConnectWithoutUnitOfMeasureInput[]
    createMany?: SellItemCreateManyUnitOfMeasureInputEnvelope
    connect?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
  }

  export type SellStockCorrectionItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput = {
    create?: XOR<SellStockCorrectionItemCreateWithoutUnitOfMeasureInput, SellStockCorrectionItemUncheckedCreateWithoutUnitOfMeasureInput> | SellStockCorrectionItemCreateWithoutUnitOfMeasureInput[] | SellStockCorrectionItemUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: SellStockCorrectionItemCreateOrConnectWithoutUnitOfMeasureInput | SellStockCorrectionItemCreateOrConnectWithoutUnitOfMeasureInput[]
    createMany?: SellStockCorrectionItemCreateManyUnitOfMeasureInputEnvelope
    connect?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
  }

  export type CartItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput = {
    create?: XOR<CartItemCreateWithoutUnitOfMeasureInput, CartItemUncheckedCreateWithoutUnitOfMeasureInput> | CartItemCreateWithoutUnitOfMeasureInput[] | CartItemUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutUnitOfMeasureInput | CartItemCreateOrConnectWithoutUnitOfMeasureInput[]
    createMany?: CartItemCreateManyUnitOfMeasureInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutUnitOfMeasureNestedInput = {
    create?: XOR<ProductCreateWithoutUnitOfMeasureInput, ProductUncheckedCreateWithoutUnitOfMeasureInput> | ProductCreateWithoutUnitOfMeasureInput[] | ProductUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUnitOfMeasureInput | ProductCreateOrConnectWithoutUnitOfMeasureInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutUnitOfMeasureInput | ProductUpsertWithWhereUniqueWithoutUnitOfMeasureInput[]
    createMany?: ProductCreateManyUnitOfMeasureInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutUnitOfMeasureInput | ProductUpdateWithWhereUniqueWithoutUnitOfMeasureInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutUnitOfMeasureInput | ProductUpdateManyWithWhereWithoutUnitOfMeasureInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type PurchaseItemUpdateManyWithoutUnitOfMeasureNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutUnitOfMeasureInput, PurchaseItemUncheckedCreateWithoutUnitOfMeasureInput> | PurchaseItemCreateWithoutUnitOfMeasureInput[] | PurchaseItemUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutUnitOfMeasureInput | PurchaseItemCreateOrConnectWithoutUnitOfMeasureInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput | PurchaseItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput[]
    createMany?: PurchaseItemCreateManyUnitOfMeasureInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput | PurchaseItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutUnitOfMeasureInput | PurchaseItemUpdateManyWithWhereWithoutUnitOfMeasureInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type TransferItemUpdateManyWithoutUnitOfMeasureNestedInput = {
    create?: XOR<TransferItemCreateWithoutUnitOfMeasureInput, TransferItemUncheckedCreateWithoutUnitOfMeasureInput> | TransferItemCreateWithoutUnitOfMeasureInput[] | TransferItemUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutUnitOfMeasureInput | TransferItemCreateOrConnectWithoutUnitOfMeasureInput[]
    upsert?: TransferItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput | TransferItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput[]
    createMany?: TransferItemCreateManyUnitOfMeasureInputEnvelope
    set?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    disconnect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    delete?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    update?: TransferItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput | TransferItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput[]
    updateMany?: TransferItemUpdateManyWithWhereWithoutUnitOfMeasureInput | TransferItemUpdateManyWithWhereWithoutUnitOfMeasureInput[]
    deleteMany?: TransferItemScalarWhereInput | TransferItemScalarWhereInput[]
  }

  export type StockLedgerUpdateManyWithoutUnitOfMeasureNestedInput = {
    create?: XOR<StockLedgerCreateWithoutUnitOfMeasureInput, StockLedgerUncheckedCreateWithoutUnitOfMeasureInput> | StockLedgerCreateWithoutUnitOfMeasureInput[] | StockLedgerUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutUnitOfMeasureInput | StockLedgerCreateOrConnectWithoutUnitOfMeasureInput[]
    upsert?: StockLedgerUpsertWithWhereUniqueWithoutUnitOfMeasureInput | StockLedgerUpsertWithWhereUniqueWithoutUnitOfMeasureInput[]
    createMany?: StockLedgerCreateManyUnitOfMeasureInputEnvelope
    set?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    disconnect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    delete?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    update?: StockLedgerUpdateWithWhereUniqueWithoutUnitOfMeasureInput | StockLedgerUpdateWithWhereUniqueWithoutUnitOfMeasureInput[]
    updateMany?: StockLedgerUpdateManyWithWhereWithoutUnitOfMeasureInput | StockLedgerUpdateManyWithWhereWithoutUnitOfMeasureInput[]
    deleteMany?: StockLedgerScalarWhereInput | StockLedgerScalarWhereInput[]
  }

  export type ShopStockUpdateManyWithoutUnitOfMeasureNestedInput = {
    create?: XOR<ShopStockCreateWithoutUnitOfMeasureInput, ShopStockUncheckedCreateWithoutUnitOfMeasureInput> | ShopStockCreateWithoutUnitOfMeasureInput[] | ShopStockUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: ShopStockCreateOrConnectWithoutUnitOfMeasureInput | ShopStockCreateOrConnectWithoutUnitOfMeasureInput[]
    upsert?: ShopStockUpsertWithWhereUniqueWithoutUnitOfMeasureInput | ShopStockUpsertWithWhereUniqueWithoutUnitOfMeasureInput[]
    createMany?: ShopStockCreateManyUnitOfMeasureInputEnvelope
    set?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
    disconnect?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
    delete?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
    connect?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
    update?: ShopStockUpdateWithWhereUniqueWithoutUnitOfMeasureInput | ShopStockUpdateWithWhereUniqueWithoutUnitOfMeasureInput[]
    updateMany?: ShopStockUpdateManyWithWhereWithoutUnitOfMeasureInput | ShopStockUpdateManyWithWhereWithoutUnitOfMeasureInput[]
    deleteMany?: ShopStockScalarWhereInput | ShopStockScalarWhereInput[]
  }

  export type StoreStockUpdateManyWithoutUnitOfMeasureNestedInput = {
    create?: XOR<StoreStockCreateWithoutUnitOfMeasureInput, StoreStockUncheckedCreateWithoutUnitOfMeasureInput> | StoreStockCreateWithoutUnitOfMeasureInput[] | StoreStockUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: StoreStockCreateOrConnectWithoutUnitOfMeasureInput | StoreStockCreateOrConnectWithoutUnitOfMeasureInput[]
    upsert?: StoreStockUpsertWithWhereUniqueWithoutUnitOfMeasureInput | StoreStockUpsertWithWhereUniqueWithoutUnitOfMeasureInput[]
    createMany?: StoreStockCreateManyUnitOfMeasureInputEnvelope
    set?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
    disconnect?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
    delete?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
    connect?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
    update?: StoreStockUpdateWithWhereUniqueWithoutUnitOfMeasureInput | StoreStockUpdateWithWhereUniqueWithoutUnitOfMeasureInput[]
    updateMany?: StoreStockUpdateManyWithWhereWithoutUnitOfMeasureInput | StoreStockUpdateManyWithWhereWithoutUnitOfMeasureInput[]
    deleteMany?: StoreStockScalarWhereInput | StoreStockScalarWhereInput[]
  }

  export type StockCorrectionItemUpdateManyWithoutUnitOfMeasureNestedInput = {
    create?: XOR<StockCorrectionItemCreateWithoutUnitOfMeasureInput, StockCorrectionItemUncheckedCreateWithoutUnitOfMeasureInput> | StockCorrectionItemCreateWithoutUnitOfMeasureInput[] | StockCorrectionItemUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: StockCorrectionItemCreateOrConnectWithoutUnitOfMeasureInput | StockCorrectionItemCreateOrConnectWithoutUnitOfMeasureInput[]
    upsert?: StockCorrectionItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput | StockCorrectionItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput[]
    createMany?: StockCorrectionItemCreateManyUnitOfMeasureInputEnvelope
    set?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    disconnect?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    delete?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    connect?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    update?: StockCorrectionItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput | StockCorrectionItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput[]
    updateMany?: StockCorrectionItemUpdateManyWithWhereWithoutUnitOfMeasureInput | StockCorrectionItemUpdateManyWithWhereWithoutUnitOfMeasureInput[]
    deleteMany?: StockCorrectionItemScalarWhereInput | StockCorrectionItemScalarWhereInput[]
  }

  export type SellItemUpdateManyWithoutUnitOfMeasureNestedInput = {
    create?: XOR<SellItemCreateWithoutUnitOfMeasureInput, SellItemUncheckedCreateWithoutUnitOfMeasureInput> | SellItemCreateWithoutUnitOfMeasureInput[] | SellItemUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: SellItemCreateOrConnectWithoutUnitOfMeasureInput | SellItemCreateOrConnectWithoutUnitOfMeasureInput[]
    upsert?: SellItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput | SellItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput[]
    createMany?: SellItemCreateManyUnitOfMeasureInputEnvelope
    set?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    disconnect?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    delete?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    connect?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    update?: SellItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput | SellItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput[]
    updateMany?: SellItemUpdateManyWithWhereWithoutUnitOfMeasureInput | SellItemUpdateManyWithWhereWithoutUnitOfMeasureInput[]
    deleteMany?: SellItemScalarWhereInput | SellItemScalarWhereInput[]
  }

  export type SellStockCorrectionItemUpdateManyWithoutUnitOfMeasureNestedInput = {
    create?: XOR<SellStockCorrectionItemCreateWithoutUnitOfMeasureInput, SellStockCorrectionItemUncheckedCreateWithoutUnitOfMeasureInput> | SellStockCorrectionItemCreateWithoutUnitOfMeasureInput[] | SellStockCorrectionItemUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: SellStockCorrectionItemCreateOrConnectWithoutUnitOfMeasureInput | SellStockCorrectionItemCreateOrConnectWithoutUnitOfMeasureInput[]
    upsert?: SellStockCorrectionItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput | SellStockCorrectionItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput[]
    createMany?: SellStockCorrectionItemCreateManyUnitOfMeasureInputEnvelope
    set?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    disconnect?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    delete?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    connect?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    update?: SellStockCorrectionItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput | SellStockCorrectionItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput[]
    updateMany?: SellStockCorrectionItemUpdateManyWithWhereWithoutUnitOfMeasureInput | SellStockCorrectionItemUpdateManyWithWhereWithoutUnitOfMeasureInput[]
    deleteMany?: SellStockCorrectionItemScalarWhereInput | SellStockCorrectionItemScalarWhereInput[]
  }

  export type CartItemUpdateManyWithoutUnitOfMeasureNestedInput = {
    create?: XOR<CartItemCreateWithoutUnitOfMeasureInput, CartItemUncheckedCreateWithoutUnitOfMeasureInput> | CartItemCreateWithoutUnitOfMeasureInput[] | CartItemUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutUnitOfMeasureInput | CartItemCreateOrConnectWithoutUnitOfMeasureInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput | CartItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput[]
    createMany?: CartItemCreateManyUnitOfMeasureInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput | CartItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutUnitOfMeasureInput | CartItemUpdateManyWithWhereWithoutUnitOfMeasureInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutUnitOfMeasureNestedInput = {
    create?: XOR<ProductCreateWithoutUnitOfMeasureInput, ProductUncheckedCreateWithoutUnitOfMeasureInput> | ProductCreateWithoutUnitOfMeasureInput[] | ProductUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUnitOfMeasureInput | ProductCreateOrConnectWithoutUnitOfMeasureInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutUnitOfMeasureInput | ProductUpsertWithWhereUniqueWithoutUnitOfMeasureInput[]
    createMany?: ProductCreateManyUnitOfMeasureInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutUnitOfMeasureInput | ProductUpdateWithWhereUniqueWithoutUnitOfMeasureInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutUnitOfMeasureInput | ProductUpdateManyWithWhereWithoutUnitOfMeasureInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type PurchaseItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutUnitOfMeasureInput, PurchaseItemUncheckedCreateWithoutUnitOfMeasureInput> | PurchaseItemCreateWithoutUnitOfMeasureInput[] | PurchaseItemUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutUnitOfMeasureInput | PurchaseItemCreateOrConnectWithoutUnitOfMeasureInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput | PurchaseItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput[]
    createMany?: PurchaseItemCreateManyUnitOfMeasureInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput | PurchaseItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutUnitOfMeasureInput | PurchaseItemUpdateManyWithWhereWithoutUnitOfMeasureInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type TransferItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput = {
    create?: XOR<TransferItemCreateWithoutUnitOfMeasureInput, TransferItemUncheckedCreateWithoutUnitOfMeasureInput> | TransferItemCreateWithoutUnitOfMeasureInput[] | TransferItemUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutUnitOfMeasureInput | TransferItemCreateOrConnectWithoutUnitOfMeasureInput[]
    upsert?: TransferItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput | TransferItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput[]
    createMany?: TransferItemCreateManyUnitOfMeasureInputEnvelope
    set?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    disconnect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    delete?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    update?: TransferItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput | TransferItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput[]
    updateMany?: TransferItemUpdateManyWithWhereWithoutUnitOfMeasureInput | TransferItemUpdateManyWithWhereWithoutUnitOfMeasureInput[]
    deleteMany?: TransferItemScalarWhereInput | TransferItemScalarWhereInput[]
  }

  export type StockLedgerUncheckedUpdateManyWithoutUnitOfMeasureNestedInput = {
    create?: XOR<StockLedgerCreateWithoutUnitOfMeasureInput, StockLedgerUncheckedCreateWithoutUnitOfMeasureInput> | StockLedgerCreateWithoutUnitOfMeasureInput[] | StockLedgerUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutUnitOfMeasureInput | StockLedgerCreateOrConnectWithoutUnitOfMeasureInput[]
    upsert?: StockLedgerUpsertWithWhereUniqueWithoutUnitOfMeasureInput | StockLedgerUpsertWithWhereUniqueWithoutUnitOfMeasureInput[]
    createMany?: StockLedgerCreateManyUnitOfMeasureInputEnvelope
    set?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    disconnect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    delete?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    update?: StockLedgerUpdateWithWhereUniqueWithoutUnitOfMeasureInput | StockLedgerUpdateWithWhereUniqueWithoutUnitOfMeasureInput[]
    updateMany?: StockLedgerUpdateManyWithWhereWithoutUnitOfMeasureInput | StockLedgerUpdateManyWithWhereWithoutUnitOfMeasureInput[]
    deleteMany?: StockLedgerScalarWhereInput | StockLedgerScalarWhereInput[]
  }

  export type ShopStockUncheckedUpdateManyWithoutUnitOfMeasureNestedInput = {
    create?: XOR<ShopStockCreateWithoutUnitOfMeasureInput, ShopStockUncheckedCreateWithoutUnitOfMeasureInput> | ShopStockCreateWithoutUnitOfMeasureInput[] | ShopStockUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: ShopStockCreateOrConnectWithoutUnitOfMeasureInput | ShopStockCreateOrConnectWithoutUnitOfMeasureInput[]
    upsert?: ShopStockUpsertWithWhereUniqueWithoutUnitOfMeasureInput | ShopStockUpsertWithWhereUniqueWithoutUnitOfMeasureInput[]
    createMany?: ShopStockCreateManyUnitOfMeasureInputEnvelope
    set?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
    disconnect?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
    delete?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
    connect?: ShopStockWhereUniqueInput | ShopStockWhereUniqueInput[]
    update?: ShopStockUpdateWithWhereUniqueWithoutUnitOfMeasureInput | ShopStockUpdateWithWhereUniqueWithoutUnitOfMeasureInput[]
    updateMany?: ShopStockUpdateManyWithWhereWithoutUnitOfMeasureInput | ShopStockUpdateManyWithWhereWithoutUnitOfMeasureInput[]
    deleteMany?: ShopStockScalarWhereInput | ShopStockScalarWhereInput[]
  }

  export type StoreStockUncheckedUpdateManyWithoutUnitOfMeasureNestedInput = {
    create?: XOR<StoreStockCreateWithoutUnitOfMeasureInput, StoreStockUncheckedCreateWithoutUnitOfMeasureInput> | StoreStockCreateWithoutUnitOfMeasureInput[] | StoreStockUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: StoreStockCreateOrConnectWithoutUnitOfMeasureInput | StoreStockCreateOrConnectWithoutUnitOfMeasureInput[]
    upsert?: StoreStockUpsertWithWhereUniqueWithoutUnitOfMeasureInput | StoreStockUpsertWithWhereUniqueWithoutUnitOfMeasureInput[]
    createMany?: StoreStockCreateManyUnitOfMeasureInputEnvelope
    set?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
    disconnect?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
    delete?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
    connect?: StoreStockWhereUniqueInput | StoreStockWhereUniqueInput[]
    update?: StoreStockUpdateWithWhereUniqueWithoutUnitOfMeasureInput | StoreStockUpdateWithWhereUniqueWithoutUnitOfMeasureInput[]
    updateMany?: StoreStockUpdateManyWithWhereWithoutUnitOfMeasureInput | StoreStockUpdateManyWithWhereWithoutUnitOfMeasureInput[]
    deleteMany?: StoreStockScalarWhereInput | StoreStockScalarWhereInput[]
  }

  export type StockCorrectionItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput = {
    create?: XOR<StockCorrectionItemCreateWithoutUnitOfMeasureInput, StockCorrectionItemUncheckedCreateWithoutUnitOfMeasureInput> | StockCorrectionItemCreateWithoutUnitOfMeasureInput[] | StockCorrectionItemUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: StockCorrectionItemCreateOrConnectWithoutUnitOfMeasureInput | StockCorrectionItemCreateOrConnectWithoutUnitOfMeasureInput[]
    upsert?: StockCorrectionItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput | StockCorrectionItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput[]
    createMany?: StockCorrectionItemCreateManyUnitOfMeasureInputEnvelope
    set?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    disconnect?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    delete?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    connect?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    update?: StockCorrectionItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput | StockCorrectionItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput[]
    updateMany?: StockCorrectionItemUpdateManyWithWhereWithoutUnitOfMeasureInput | StockCorrectionItemUpdateManyWithWhereWithoutUnitOfMeasureInput[]
    deleteMany?: StockCorrectionItemScalarWhereInput | StockCorrectionItemScalarWhereInput[]
  }

  export type SellItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput = {
    create?: XOR<SellItemCreateWithoutUnitOfMeasureInput, SellItemUncheckedCreateWithoutUnitOfMeasureInput> | SellItemCreateWithoutUnitOfMeasureInput[] | SellItemUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: SellItemCreateOrConnectWithoutUnitOfMeasureInput | SellItemCreateOrConnectWithoutUnitOfMeasureInput[]
    upsert?: SellItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput | SellItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput[]
    createMany?: SellItemCreateManyUnitOfMeasureInputEnvelope
    set?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    disconnect?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    delete?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    connect?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    update?: SellItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput | SellItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput[]
    updateMany?: SellItemUpdateManyWithWhereWithoutUnitOfMeasureInput | SellItemUpdateManyWithWhereWithoutUnitOfMeasureInput[]
    deleteMany?: SellItemScalarWhereInput | SellItemScalarWhereInput[]
  }

  export type SellStockCorrectionItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput = {
    create?: XOR<SellStockCorrectionItemCreateWithoutUnitOfMeasureInput, SellStockCorrectionItemUncheckedCreateWithoutUnitOfMeasureInput> | SellStockCorrectionItemCreateWithoutUnitOfMeasureInput[] | SellStockCorrectionItemUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: SellStockCorrectionItemCreateOrConnectWithoutUnitOfMeasureInput | SellStockCorrectionItemCreateOrConnectWithoutUnitOfMeasureInput[]
    upsert?: SellStockCorrectionItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput | SellStockCorrectionItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput[]
    createMany?: SellStockCorrectionItemCreateManyUnitOfMeasureInputEnvelope
    set?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    disconnect?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    delete?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    connect?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    update?: SellStockCorrectionItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput | SellStockCorrectionItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput[]
    updateMany?: SellStockCorrectionItemUpdateManyWithWhereWithoutUnitOfMeasureInput | SellStockCorrectionItemUpdateManyWithWhereWithoutUnitOfMeasureInput[]
    deleteMany?: SellStockCorrectionItemScalarWhereInput | SellStockCorrectionItemScalarWhereInput[]
  }

  export type CartItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput = {
    create?: XOR<CartItemCreateWithoutUnitOfMeasureInput, CartItemUncheckedCreateWithoutUnitOfMeasureInput> | CartItemCreateWithoutUnitOfMeasureInput[] | CartItemUncheckedCreateWithoutUnitOfMeasureInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutUnitOfMeasureInput | CartItemCreateOrConnectWithoutUnitOfMeasureInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput | CartItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput[]
    createMany?: CartItemCreateManyUnitOfMeasureInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput | CartItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutUnitOfMeasureInput | CartItemUpdateManyWithWhereWithoutUnitOfMeasureInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type SupplierCreateNestedOneWithoutPurchaseInput = {
    create?: XOR<SupplierCreateWithoutPurchaseInput, SupplierUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchaseInput
    connect?: SupplierWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutPurchaseInput = {
    create?: XOR<StoreCreateWithoutPurchaseInput, StoreUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: StoreCreateOrConnectWithoutPurchaseInput
    connect?: StoreWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatorPurchaseInput = {
    create?: XOR<UserCreateWithoutCreatorPurchaseInput, UserUncheckedCreateWithoutCreatorPurchaseInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatorPurchaseInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdatedPurchaseInput = {
    create?: XOR<UserCreateWithoutUpdatedPurchaseInput, UserUncheckedCreateWithoutUpdatedPurchaseInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedPurchaseInput
    connect?: UserWhereUniqueInput
  }

  export type PurchaseItemCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput> | PurchaseItemCreateWithoutPurchaseInput[] | PurchaseItemUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPurchaseInput | PurchaseItemCreateOrConnectWithoutPurchaseInput[]
    createMany?: PurchaseItemCreateManyPurchaseInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type StockCorrectionCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<StockCorrectionCreateWithoutPurchaseInput, StockCorrectionUncheckedCreateWithoutPurchaseInput> | StockCorrectionCreateWithoutPurchaseInput[] | StockCorrectionUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: StockCorrectionCreateOrConnectWithoutPurchaseInput | StockCorrectionCreateOrConnectWithoutPurchaseInput[]
    createMany?: StockCorrectionCreateManyPurchaseInputEnvelope
    connect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
  }

  export type PurchaseItemUncheckedCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput> | PurchaseItemCreateWithoutPurchaseInput[] | PurchaseItemUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPurchaseInput | PurchaseItemCreateOrConnectWithoutPurchaseInput[]
    createMany?: PurchaseItemCreateManyPurchaseInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type StockCorrectionUncheckedCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<StockCorrectionCreateWithoutPurchaseInput, StockCorrectionUncheckedCreateWithoutPurchaseInput> | StockCorrectionCreateWithoutPurchaseInput[] | StockCorrectionUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: StockCorrectionCreateOrConnectWithoutPurchaseInput | StockCorrectionCreateOrConnectWithoutPurchaseInput[]
    createMany?: StockCorrectionCreateManyPurchaseInputEnvelope
    connect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type SupplierUpdateOneRequiredWithoutPurchaseNestedInput = {
    create?: XOR<SupplierCreateWithoutPurchaseInput, SupplierUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchaseInput
    upsert?: SupplierUpsertWithoutPurchaseInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutPurchaseInput, SupplierUpdateWithoutPurchaseInput>, SupplierUncheckedUpdateWithoutPurchaseInput>
  }

  export type StoreUpdateOneRequiredWithoutPurchaseNestedInput = {
    create?: XOR<StoreCreateWithoutPurchaseInput, StoreUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: StoreCreateOrConnectWithoutPurchaseInput
    upsert?: StoreUpsertWithoutPurchaseInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutPurchaseInput, StoreUpdateWithoutPurchaseInput>, StoreUncheckedUpdateWithoutPurchaseInput>
  }

  export type UserUpdateOneWithoutCreatorPurchaseNestedInput = {
    create?: XOR<UserCreateWithoutCreatorPurchaseInput, UserUncheckedCreateWithoutCreatorPurchaseInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatorPurchaseInput
    upsert?: UserUpsertWithoutCreatorPurchaseInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatorPurchaseInput, UserUpdateWithoutCreatorPurchaseInput>, UserUncheckedUpdateWithoutCreatorPurchaseInput>
  }

  export type UserUpdateOneWithoutUpdatedPurchaseNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedPurchaseInput, UserUncheckedCreateWithoutUpdatedPurchaseInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedPurchaseInput
    upsert?: UserUpsertWithoutUpdatedPurchaseInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedPurchaseInput, UserUpdateWithoutUpdatedPurchaseInput>, UserUncheckedUpdateWithoutUpdatedPurchaseInput>
  }

  export type PurchaseItemUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput> | PurchaseItemCreateWithoutPurchaseInput[] | PurchaseItemUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPurchaseInput | PurchaseItemCreateOrConnectWithoutPurchaseInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutPurchaseInput | PurchaseItemUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: PurchaseItemCreateManyPurchaseInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutPurchaseInput | PurchaseItemUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutPurchaseInput | PurchaseItemUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type StockCorrectionUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<StockCorrectionCreateWithoutPurchaseInput, StockCorrectionUncheckedCreateWithoutPurchaseInput> | StockCorrectionCreateWithoutPurchaseInput[] | StockCorrectionUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: StockCorrectionCreateOrConnectWithoutPurchaseInput | StockCorrectionCreateOrConnectWithoutPurchaseInput[]
    upsert?: StockCorrectionUpsertWithWhereUniqueWithoutPurchaseInput | StockCorrectionUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: StockCorrectionCreateManyPurchaseInputEnvelope
    set?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    disconnect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    delete?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    connect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    update?: StockCorrectionUpdateWithWhereUniqueWithoutPurchaseInput | StockCorrectionUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: StockCorrectionUpdateManyWithWhereWithoutPurchaseInput | StockCorrectionUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: StockCorrectionScalarWhereInput | StockCorrectionScalarWhereInput[]
  }

  export type PurchaseItemUncheckedUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput> | PurchaseItemCreateWithoutPurchaseInput[] | PurchaseItemUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPurchaseInput | PurchaseItemCreateOrConnectWithoutPurchaseInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutPurchaseInput | PurchaseItemUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: PurchaseItemCreateManyPurchaseInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutPurchaseInput | PurchaseItemUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutPurchaseInput | PurchaseItemUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type StockCorrectionUncheckedUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<StockCorrectionCreateWithoutPurchaseInput, StockCorrectionUncheckedCreateWithoutPurchaseInput> | StockCorrectionCreateWithoutPurchaseInput[] | StockCorrectionUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: StockCorrectionCreateOrConnectWithoutPurchaseInput | StockCorrectionCreateOrConnectWithoutPurchaseInput[]
    upsert?: StockCorrectionUpsertWithWhereUniqueWithoutPurchaseInput | StockCorrectionUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: StockCorrectionCreateManyPurchaseInputEnvelope
    set?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    disconnect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    delete?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    connect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    update?: StockCorrectionUpdateWithWhereUniqueWithoutPurchaseInput | StockCorrectionUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: StockCorrectionUpdateManyWithWhereWithoutPurchaseInput | StockCorrectionUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: StockCorrectionScalarWhereInput | StockCorrectionScalarWhereInput[]
  }

  export type PurchaseCreateNestedOneWithoutItemsInput = {
    create?: XOR<PurchaseCreateWithoutItemsInput, PurchaseUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutItemsInput
    connect?: PurchaseWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutPurchaseItemInput = {
    create?: XOR<ProductCreateWithoutPurchaseItemInput, ProductUncheckedCreateWithoutPurchaseItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseItemInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductBatchCreateNestedOneWithoutPurchaseItemInput = {
    create?: XOR<ProductBatchCreateWithoutPurchaseItemInput, ProductBatchUncheckedCreateWithoutPurchaseItemInput>
    connectOrCreate?: ProductBatchCreateOrConnectWithoutPurchaseItemInput
    connect?: ProductBatchWhereUniqueInput
  }

  export type UnitOfMeasureCreateNestedOneWithoutPurchaseItemInput = {
    create?: XOR<UnitOfMeasureCreateWithoutPurchaseItemInput, UnitOfMeasureUncheckedCreateWithoutPurchaseItemInput>
    connectOrCreate?: UnitOfMeasureCreateOrConnectWithoutPurchaseItemInput
    connect?: UnitOfMeasureWhereUniqueInput
  }

  export type PurchaseUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PurchaseCreateWithoutItemsInput, PurchaseUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutItemsInput
    upsert?: PurchaseUpsertWithoutItemsInput
    connect?: PurchaseWhereUniqueInput
    update?: XOR<XOR<PurchaseUpdateToOneWithWhereWithoutItemsInput, PurchaseUpdateWithoutItemsInput>, PurchaseUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutPurchaseItemNestedInput = {
    create?: XOR<ProductCreateWithoutPurchaseItemInput, ProductUncheckedCreateWithoutPurchaseItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseItemInput
    upsert?: ProductUpsertWithoutPurchaseItemInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPurchaseItemInput, ProductUpdateWithoutPurchaseItemInput>, ProductUncheckedUpdateWithoutPurchaseItemInput>
  }

  export type ProductBatchUpdateOneRequiredWithoutPurchaseItemNestedInput = {
    create?: XOR<ProductBatchCreateWithoutPurchaseItemInput, ProductBatchUncheckedCreateWithoutPurchaseItemInput>
    connectOrCreate?: ProductBatchCreateOrConnectWithoutPurchaseItemInput
    upsert?: ProductBatchUpsertWithoutPurchaseItemInput
    connect?: ProductBatchWhereUniqueInput
    update?: XOR<XOR<ProductBatchUpdateToOneWithWhereWithoutPurchaseItemInput, ProductBatchUpdateWithoutPurchaseItemInput>, ProductBatchUncheckedUpdateWithoutPurchaseItemInput>
  }

  export type UnitOfMeasureUpdateOneRequiredWithoutPurchaseItemNestedInput = {
    create?: XOR<UnitOfMeasureCreateWithoutPurchaseItemInput, UnitOfMeasureUncheckedCreateWithoutPurchaseItemInput>
    connectOrCreate?: UnitOfMeasureCreateOrConnectWithoutPurchaseItemInput
    upsert?: UnitOfMeasureUpsertWithoutPurchaseItemInput
    connect?: UnitOfMeasureWhereUniqueInput
    update?: XOR<XOR<UnitOfMeasureUpdateToOneWithWhereWithoutPurchaseItemInput, UnitOfMeasureUpdateWithoutPurchaseItemInput>, UnitOfMeasureUncheckedUpdateWithoutPurchaseItemInput>
  }

  export type StoreCreateNestedOneWithoutSourceTransferInput = {
    create?: XOR<StoreCreateWithoutSourceTransferInput, StoreUncheckedCreateWithoutSourceTransferInput>
    connectOrCreate?: StoreCreateOrConnectWithoutSourceTransferInput
    connect?: StoreWhereUniqueInput
  }

  export type ShopCreateNestedOneWithoutSourceTransferInput = {
    create?: XOR<ShopCreateWithoutSourceTransferInput, ShopUncheckedCreateWithoutSourceTransferInput>
    connectOrCreate?: ShopCreateOrConnectWithoutSourceTransferInput
    connect?: ShopWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutDestinatTransferInput = {
    create?: XOR<StoreCreateWithoutDestinatTransferInput, StoreUncheckedCreateWithoutDestinatTransferInput>
    connectOrCreate?: StoreCreateOrConnectWithoutDestinatTransferInput
    connect?: StoreWhereUniqueInput
  }

  export type ShopCreateNestedOneWithoutDestinatTransferInput = {
    create?: XOR<ShopCreateWithoutDestinatTransferInput, ShopUncheckedCreateWithoutDestinatTransferInput>
    connectOrCreate?: ShopCreateOrConnectWithoutDestinatTransferInput
    connect?: ShopWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedTransferInput = {
    create?: XOR<UserCreateWithoutCreatedTransferInput, UserUncheckedCreateWithoutCreatedTransferInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTransferInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdatedTransferInput = {
    create?: XOR<UserCreateWithoutUpdatedTransferInput, UserUncheckedCreateWithoutUpdatedTransferInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedTransferInput
    connect?: UserWhereUniqueInput
  }

  export type TransferItemCreateNestedManyWithoutTransferInput = {
    create?: XOR<TransferItemCreateWithoutTransferInput, TransferItemUncheckedCreateWithoutTransferInput> | TransferItemCreateWithoutTransferInput[] | TransferItemUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutTransferInput | TransferItemCreateOrConnectWithoutTransferInput[]
    createMany?: TransferItemCreateManyTransferInputEnvelope
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
  }

  export type StockCorrectionCreateNestedManyWithoutTransferInput = {
    create?: XOR<StockCorrectionCreateWithoutTransferInput, StockCorrectionUncheckedCreateWithoutTransferInput> | StockCorrectionCreateWithoutTransferInput[] | StockCorrectionUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: StockCorrectionCreateOrConnectWithoutTransferInput | StockCorrectionCreateOrConnectWithoutTransferInput[]
    createMany?: StockCorrectionCreateManyTransferInputEnvelope
    connect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
  }

  export type TransferItemUncheckedCreateNestedManyWithoutTransferInput = {
    create?: XOR<TransferItemCreateWithoutTransferInput, TransferItemUncheckedCreateWithoutTransferInput> | TransferItemCreateWithoutTransferInput[] | TransferItemUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutTransferInput | TransferItemCreateOrConnectWithoutTransferInput[]
    createMany?: TransferItemCreateManyTransferInputEnvelope
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
  }

  export type StockCorrectionUncheckedCreateNestedManyWithoutTransferInput = {
    create?: XOR<StockCorrectionCreateWithoutTransferInput, StockCorrectionUncheckedCreateWithoutTransferInput> | StockCorrectionCreateWithoutTransferInput[] | StockCorrectionUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: StockCorrectionCreateOrConnectWithoutTransferInput | StockCorrectionCreateOrConnectWithoutTransferInput[]
    createMany?: StockCorrectionCreateManyTransferInputEnvelope
    connect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
  }

  export type EnumTransferEntityTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransferEntityType
  }

  export type EnumTransferStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransferStatus
  }

  export type StoreUpdateOneWithoutSourceTransferNestedInput = {
    create?: XOR<StoreCreateWithoutSourceTransferInput, StoreUncheckedCreateWithoutSourceTransferInput>
    connectOrCreate?: StoreCreateOrConnectWithoutSourceTransferInput
    upsert?: StoreUpsertWithoutSourceTransferInput
    disconnect?: StoreWhereInput | boolean
    delete?: StoreWhereInput | boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutSourceTransferInput, StoreUpdateWithoutSourceTransferInput>, StoreUncheckedUpdateWithoutSourceTransferInput>
  }

  export type ShopUpdateOneWithoutSourceTransferNestedInput = {
    create?: XOR<ShopCreateWithoutSourceTransferInput, ShopUncheckedCreateWithoutSourceTransferInput>
    connectOrCreate?: ShopCreateOrConnectWithoutSourceTransferInput
    upsert?: ShopUpsertWithoutSourceTransferInput
    disconnect?: ShopWhereInput | boolean
    delete?: ShopWhereInput | boolean
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutSourceTransferInput, ShopUpdateWithoutSourceTransferInput>, ShopUncheckedUpdateWithoutSourceTransferInput>
  }

  export type StoreUpdateOneWithoutDestinatTransferNestedInput = {
    create?: XOR<StoreCreateWithoutDestinatTransferInput, StoreUncheckedCreateWithoutDestinatTransferInput>
    connectOrCreate?: StoreCreateOrConnectWithoutDestinatTransferInput
    upsert?: StoreUpsertWithoutDestinatTransferInput
    disconnect?: StoreWhereInput | boolean
    delete?: StoreWhereInput | boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutDestinatTransferInput, StoreUpdateWithoutDestinatTransferInput>, StoreUncheckedUpdateWithoutDestinatTransferInput>
  }

  export type ShopUpdateOneWithoutDestinatTransferNestedInput = {
    create?: XOR<ShopCreateWithoutDestinatTransferInput, ShopUncheckedCreateWithoutDestinatTransferInput>
    connectOrCreate?: ShopCreateOrConnectWithoutDestinatTransferInput
    upsert?: ShopUpsertWithoutDestinatTransferInput
    disconnect?: ShopWhereInput | boolean
    delete?: ShopWhereInput | boolean
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutDestinatTransferInput, ShopUpdateWithoutDestinatTransferInput>, ShopUncheckedUpdateWithoutDestinatTransferInput>
  }

  export type UserUpdateOneWithoutCreatedTransferNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTransferInput, UserUncheckedCreateWithoutCreatedTransferInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTransferInput
    upsert?: UserUpsertWithoutCreatedTransferInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedTransferInput, UserUpdateWithoutCreatedTransferInput>, UserUncheckedUpdateWithoutCreatedTransferInput>
  }

  export type UserUpdateOneWithoutUpdatedTransferNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedTransferInput, UserUncheckedCreateWithoutUpdatedTransferInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedTransferInput
    upsert?: UserUpsertWithoutUpdatedTransferInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedTransferInput, UserUpdateWithoutUpdatedTransferInput>, UserUncheckedUpdateWithoutUpdatedTransferInput>
  }

  export type TransferItemUpdateManyWithoutTransferNestedInput = {
    create?: XOR<TransferItemCreateWithoutTransferInput, TransferItemUncheckedCreateWithoutTransferInput> | TransferItemCreateWithoutTransferInput[] | TransferItemUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutTransferInput | TransferItemCreateOrConnectWithoutTransferInput[]
    upsert?: TransferItemUpsertWithWhereUniqueWithoutTransferInput | TransferItemUpsertWithWhereUniqueWithoutTransferInput[]
    createMany?: TransferItemCreateManyTransferInputEnvelope
    set?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    disconnect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    delete?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    update?: TransferItemUpdateWithWhereUniqueWithoutTransferInput | TransferItemUpdateWithWhereUniqueWithoutTransferInput[]
    updateMany?: TransferItemUpdateManyWithWhereWithoutTransferInput | TransferItemUpdateManyWithWhereWithoutTransferInput[]
    deleteMany?: TransferItemScalarWhereInput | TransferItemScalarWhereInput[]
  }

  export type StockCorrectionUpdateManyWithoutTransferNestedInput = {
    create?: XOR<StockCorrectionCreateWithoutTransferInput, StockCorrectionUncheckedCreateWithoutTransferInput> | StockCorrectionCreateWithoutTransferInput[] | StockCorrectionUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: StockCorrectionCreateOrConnectWithoutTransferInput | StockCorrectionCreateOrConnectWithoutTransferInput[]
    upsert?: StockCorrectionUpsertWithWhereUniqueWithoutTransferInput | StockCorrectionUpsertWithWhereUniqueWithoutTransferInput[]
    createMany?: StockCorrectionCreateManyTransferInputEnvelope
    set?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    disconnect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    delete?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    connect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    update?: StockCorrectionUpdateWithWhereUniqueWithoutTransferInput | StockCorrectionUpdateWithWhereUniqueWithoutTransferInput[]
    updateMany?: StockCorrectionUpdateManyWithWhereWithoutTransferInput | StockCorrectionUpdateManyWithWhereWithoutTransferInput[]
    deleteMany?: StockCorrectionScalarWhereInput | StockCorrectionScalarWhereInput[]
  }

  export type TransferItemUncheckedUpdateManyWithoutTransferNestedInput = {
    create?: XOR<TransferItemCreateWithoutTransferInput, TransferItemUncheckedCreateWithoutTransferInput> | TransferItemCreateWithoutTransferInput[] | TransferItemUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutTransferInput | TransferItemCreateOrConnectWithoutTransferInput[]
    upsert?: TransferItemUpsertWithWhereUniqueWithoutTransferInput | TransferItemUpsertWithWhereUniqueWithoutTransferInput[]
    createMany?: TransferItemCreateManyTransferInputEnvelope
    set?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    disconnect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    delete?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    update?: TransferItemUpdateWithWhereUniqueWithoutTransferInput | TransferItemUpdateWithWhereUniqueWithoutTransferInput[]
    updateMany?: TransferItemUpdateManyWithWhereWithoutTransferInput | TransferItemUpdateManyWithWhereWithoutTransferInput[]
    deleteMany?: TransferItemScalarWhereInput | TransferItemScalarWhereInput[]
  }

  export type StockCorrectionUncheckedUpdateManyWithoutTransferNestedInput = {
    create?: XOR<StockCorrectionCreateWithoutTransferInput, StockCorrectionUncheckedCreateWithoutTransferInput> | StockCorrectionCreateWithoutTransferInput[] | StockCorrectionUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: StockCorrectionCreateOrConnectWithoutTransferInput | StockCorrectionCreateOrConnectWithoutTransferInput[]
    upsert?: StockCorrectionUpsertWithWhereUniqueWithoutTransferInput | StockCorrectionUpsertWithWhereUniqueWithoutTransferInput[]
    createMany?: StockCorrectionCreateManyTransferInputEnvelope
    set?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    disconnect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    delete?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    connect?: StockCorrectionWhereUniqueInput | StockCorrectionWhereUniqueInput[]
    update?: StockCorrectionUpdateWithWhereUniqueWithoutTransferInput | StockCorrectionUpdateWithWhereUniqueWithoutTransferInput[]
    updateMany?: StockCorrectionUpdateManyWithWhereWithoutTransferInput | StockCorrectionUpdateManyWithWhereWithoutTransferInput[]
    deleteMany?: StockCorrectionScalarWhereInput | StockCorrectionScalarWhereInput[]
  }

  export type TransferCreateNestedOneWithoutItemsInput = {
    create?: XOR<TransferCreateWithoutItemsInput, TransferUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TransferCreateOrConnectWithoutItemsInput
    connect?: TransferWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutTransferItemInput = {
    create?: XOR<ProductCreateWithoutTransferItemInput, ProductUncheckedCreateWithoutTransferItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTransferItemInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductBatchCreateNestedOneWithoutTransferItemInput = {
    create?: XOR<ProductBatchCreateWithoutTransferItemInput, ProductBatchUncheckedCreateWithoutTransferItemInput>
    connectOrCreate?: ProductBatchCreateOrConnectWithoutTransferItemInput
    connect?: ProductBatchWhereUniqueInput
  }

  export type UnitOfMeasureCreateNestedOneWithoutTransferItemInput = {
    create?: XOR<UnitOfMeasureCreateWithoutTransferItemInput, UnitOfMeasureUncheckedCreateWithoutTransferItemInput>
    connectOrCreate?: UnitOfMeasureCreateOrConnectWithoutTransferItemInput
    connect?: UnitOfMeasureWhereUniqueInput
  }

  export type TransferUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<TransferCreateWithoutItemsInput, TransferUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TransferCreateOrConnectWithoutItemsInput
    upsert?: TransferUpsertWithoutItemsInput
    connect?: TransferWhereUniqueInput
    update?: XOR<XOR<TransferUpdateToOneWithWhereWithoutItemsInput, TransferUpdateWithoutItemsInput>, TransferUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutTransferItemNestedInput = {
    create?: XOR<ProductCreateWithoutTransferItemInput, ProductUncheckedCreateWithoutTransferItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTransferItemInput
    upsert?: ProductUpsertWithoutTransferItemInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutTransferItemInput, ProductUpdateWithoutTransferItemInput>, ProductUncheckedUpdateWithoutTransferItemInput>
  }

  export type ProductBatchUpdateOneRequiredWithoutTransferItemNestedInput = {
    create?: XOR<ProductBatchCreateWithoutTransferItemInput, ProductBatchUncheckedCreateWithoutTransferItemInput>
    connectOrCreate?: ProductBatchCreateOrConnectWithoutTransferItemInput
    upsert?: ProductBatchUpsertWithoutTransferItemInput
    connect?: ProductBatchWhereUniqueInput
    update?: XOR<XOR<ProductBatchUpdateToOneWithWhereWithoutTransferItemInput, ProductBatchUpdateWithoutTransferItemInput>, ProductBatchUncheckedUpdateWithoutTransferItemInput>
  }

  export type UnitOfMeasureUpdateOneRequiredWithoutTransferItemNestedInput = {
    create?: XOR<UnitOfMeasureCreateWithoutTransferItemInput, UnitOfMeasureUncheckedCreateWithoutTransferItemInput>
    connectOrCreate?: UnitOfMeasureCreateOrConnectWithoutTransferItemInput
    upsert?: UnitOfMeasureUpsertWithoutTransferItemInput
    connect?: UnitOfMeasureWhereUniqueInput
    update?: XOR<XOR<UnitOfMeasureUpdateToOneWithWhereWithoutTransferItemInput, UnitOfMeasureUpdateWithoutTransferItemInput>, UnitOfMeasureUncheckedUpdateWithoutTransferItemInput>
  }

  export type StoreCreateNestedOneWithoutStockCorrectionInput = {
    create?: XOR<StoreCreateWithoutStockCorrectionInput, StoreUncheckedCreateWithoutStockCorrectionInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStockCorrectionInput
    connect?: StoreWhereUniqueInput
  }

  export type ShopCreateNestedOneWithoutStockCorrectionInput = {
    create?: XOR<ShopCreateWithoutStockCorrectionInput, ShopUncheckedCreateWithoutStockCorrectionInput>
    connectOrCreate?: ShopCreateOrConnectWithoutStockCorrectionInput
    connect?: ShopWhereUniqueInput
  }

  export type PurchaseCreateNestedOneWithoutStockCorrectionInput = {
    create?: XOR<PurchaseCreateWithoutStockCorrectionInput, PurchaseUncheckedCreateWithoutStockCorrectionInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutStockCorrectionInput
    connect?: PurchaseWhereUniqueInput
  }

  export type TransferCreateNestedOneWithoutStockCorrectionInput = {
    create?: XOR<TransferCreateWithoutStockCorrectionInput, TransferUncheckedCreateWithoutStockCorrectionInput>
    connectOrCreate?: TransferCreateOrConnectWithoutStockCorrectionInput
    connect?: TransferWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStockCorrectionInput = {
    create?: XOR<UserCreateWithoutStockCorrectionInput, UserUncheckedCreateWithoutStockCorrectionInput>
    connectOrCreate?: UserCreateOrConnectWithoutStockCorrectionInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdateStockCorrectionInput = {
    create?: XOR<UserCreateWithoutUpdateStockCorrectionInput, UserUncheckedCreateWithoutUpdateStockCorrectionInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdateStockCorrectionInput
    connect?: UserWhereUniqueInput
  }

  export type StockCorrectionItemCreateNestedManyWithoutCorrectionInput = {
    create?: XOR<StockCorrectionItemCreateWithoutCorrectionInput, StockCorrectionItemUncheckedCreateWithoutCorrectionInput> | StockCorrectionItemCreateWithoutCorrectionInput[] | StockCorrectionItemUncheckedCreateWithoutCorrectionInput[]
    connectOrCreate?: StockCorrectionItemCreateOrConnectWithoutCorrectionInput | StockCorrectionItemCreateOrConnectWithoutCorrectionInput[]
    createMany?: StockCorrectionItemCreateManyCorrectionInputEnvelope
    connect?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
  }

  export type StockCorrectionItemUncheckedCreateNestedManyWithoutCorrectionInput = {
    create?: XOR<StockCorrectionItemCreateWithoutCorrectionInput, StockCorrectionItemUncheckedCreateWithoutCorrectionInput> | StockCorrectionItemCreateWithoutCorrectionInput[] | StockCorrectionItemUncheckedCreateWithoutCorrectionInput[]
    connectOrCreate?: StockCorrectionItemCreateOrConnectWithoutCorrectionInput | StockCorrectionItemCreateOrConnectWithoutCorrectionInput[]
    createMany?: StockCorrectionItemCreateManyCorrectionInputEnvelope
    connect?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
  }

  export type EnumStockCorrectionReasonFieldUpdateOperationsInput = {
    set?: $Enums.StockCorrectionReason
  }

  export type EnumStockCorrectionStatusFieldUpdateOperationsInput = {
    set?: $Enums.StockCorrectionStatus
  }

  export type StoreUpdateOneWithoutStockCorrectionNestedInput = {
    create?: XOR<StoreCreateWithoutStockCorrectionInput, StoreUncheckedCreateWithoutStockCorrectionInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStockCorrectionInput
    upsert?: StoreUpsertWithoutStockCorrectionInput
    disconnect?: StoreWhereInput | boolean
    delete?: StoreWhereInput | boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutStockCorrectionInput, StoreUpdateWithoutStockCorrectionInput>, StoreUncheckedUpdateWithoutStockCorrectionInput>
  }

  export type ShopUpdateOneWithoutStockCorrectionNestedInput = {
    create?: XOR<ShopCreateWithoutStockCorrectionInput, ShopUncheckedCreateWithoutStockCorrectionInput>
    connectOrCreate?: ShopCreateOrConnectWithoutStockCorrectionInput
    upsert?: ShopUpsertWithoutStockCorrectionInput
    disconnect?: ShopWhereInput | boolean
    delete?: ShopWhereInput | boolean
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutStockCorrectionInput, ShopUpdateWithoutStockCorrectionInput>, ShopUncheckedUpdateWithoutStockCorrectionInput>
  }

  export type PurchaseUpdateOneWithoutStockCorrectionNestedInput = {
    create?: XOR<PurchaseCreateWithoutStockCorrectionInput, PurchaseUncheckedCreateWithoutStockCorrectionInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutStockCorrectionInput
    upsert?: PurchaseUpsertWithoutStockCorrectionInput
    disconnect?: PurchaseWhereInput | boolean
    delete?: PurchaseWhereInput | boolean
    connect?: PurchaseWhereUniqueInput
    update?: XOR<XOR<PurchaseUpdateToOneWithWhereWithoutStockCorrectionInput, PurchaseUpdateWithoutStockCorrectionInput>, PurchaseUncheckedUpdateWithoutStockCorrectionInput>
  }

  export type TransferUpdateOneWithoutStockCorrectionNestedInput = {
    create?: XOR<TransferCreateWithoutStockCorrectionInput, TransferUncheckedCreateWithoutStockCorrectionInput>
    connectOrCreate?: TransferCreateOrConnectWithoutStockCorrectionInput
    upsert?: TransferUpsertWithoutStockCorrectionInput
    disconnect?: TransferWhereInput | boolean
    delete?: TransferWhereInput | boolean
    connect?: TransferWhereUniqueInput
    update?: XOR<XOR<TransferUpdateToOneWithWhereWithoutStockCorrectionInput, TransferUpdateWithoutStockCorrectionInput>, TransferUncheckedUpdateWithoutStockCorrectionInput>
  }

  export type UserUpdateOneWithoutStockCorrectionNestedInput = {
    create?: XOR<UserCreateWithoutStockCorrectionInput, UserUncheckedCreateWithoutStockCorrectionInput>
    connectOrCreate?: UserCreateOrConnectWithoutStockCorrectionInput
    upsert?: UserUpsertWithoutStockCorrectionInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStockCorrectionInput, UserUpdateWithoutStockCorrectionInput>, UserUncheckedUpdateWithoutStockCorrectionInput>
  }

  export type UserUpdateOneWithoutUpdateStockCorrectionNestedInput = {
    create?: XOR<UserCreateWithoutUpdateStockCorrectionInput, UserUncheckedCreateWithoutUpdateStockCorrectionInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdateStockCorrectionInput
    upsert?: UserUpsertWithoutUpdateStockCorrectionInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdateStockCorrectionInput, UserUpdateWithoutUpdateStockCorrectionInput>, UserUncheckedUpdateWithoutUpdateStockCorrectionInput>
  }

  export type StockCorrectionItemUpdateManyWithoutCorrectionNestedInput = {
    create?: XOR<StockCorrectionItemCreateWithoutCorrectionInput, StockCorrectionItemUncheckedCreateWithoutCorrectionInput> | StockCorrectionItemCreateWithoutCorrectionInput[] | StockCorrectionItemUncheckedCreateWithoutCorrectionInput[]
    connectOrCreate?: StockCorrectionItemCreateOrConnectWithoutCorrectionInput | StockCorrectionItemCreateOrConnectWithoutCorrectionInput[]
    upsert?: StockCorrectionItemUpsertWithWhereUniqueWithoutCorrectionInput | StockCorrectionItemUpsertWithWhereUniqueWithoutCorrectionInput[]
    createMany?: StockCorrectionItemCreateManyCorrectionInputEnvelope
    set?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    disconnect?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    delete?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    connect?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    update?: StockCorrectionItemUpdateWithWhereUniqueWithoutCorrectionInput | StockCorrectionItemUpdateWithWhereUniqueWithoutCorrectionInput[]
    updateMany?: StockCorrectionItemUpdateManyWithWhereWithoutCorrectionInput | StockCorrectionItemUpdateManyWithWhereWithoutCorrectionInput[]
    deleteMany?: StockCorrectionItemScalarWhereInput | StockCorrectionItemScalarWhereInput[]
  }

  export type StockCorrectionItemUncheckedUpdateManyWithoutCorrectionNestedInput = {
    create?: XOR<StockCorrectionItemCreateWithoutCorrectionInput, StockCorrectionItemUncheckedCreateWithoutCorrectionInput> | StockCorrectionItemCreateWithoutCorrectionInput[] | StockCorrectionItemUncheckedCreateWithoutCorrectionInput[]
    connectOrCreate?: StockCorrectionItemCreateOrConnectWithoutCorrectionInput | StockCorrectionItemCreateOrConnectWithoutCorrectionInput[]
    upsert?: StockCorrectionItemUpsertWithWhereUniqueWithoutCorrectionInput | StockCorrectionItemUpsertWithWhereUniqueWithoutCorrectionInput[]
    createMany?: StockCorrectionItemCreateManyCorrectionInputEnvelope
    set?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    disconnect?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    delete?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    connect?: StockCorrectionItemWhereUniqueInput | StockCorrectionItemWhereUniqueInput[]
    update?: StockCorrectionItemUpdateWithWhereUniqueWithoutCorrectionInput | StockCorrectionItemUpdateWithWhereUniqueWithoutCorrectionInput[]
    updateMany?: StockCorrectionItemUpdateManyWithWhereWithoutCorrectionInput | StockCorrectionItemUpdateManyWithWhereWithoutCorrectionInput[]
    deleteMany?: StockCorrectionItemScalarWhereInput | StockCorrectionItemScalarWhereInput[]
  }

  export type StockCorrectionCreateNestedOneWithoutItemsInput = {
    create?: XOR<StockCorrectionCreateWithoutItemsInput, StockCorrectionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: StockCorrectionCreateOrConnectWithoutItemsInput
    connect?: StockCorrectionWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutStockCorrectionItemInput = {
    create?: XOR<ProductCreateWithoutStockCorrectionItemInput, ProductUncheckedCreateWithoutStockCorrectionItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockCorrectionItemInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductBatchCreateNestedOneWithoutStockCorrectionItemInput = {
    create?: XOR<ProductBatchCreateWithoutStockCorrectionItemInput, ProductBatchUncheckedCreateWithoutStockCorrectionItemInput>
    connectOrCreate?: ProductBatchCreateOrConnectWithoutStockCorrectionItemInput
    connect?: ProductBatchWhereUniqueInput
  }

  export type UnitOfMeasureCreateNestedOneWithoutStockCorrectionItemInput = {
    create?: XOR<UnitOfMeasureCreateWithoutStockCorrectionItemInput, UnitOfMeasureUncheckedCreateWithoutStockCorrectionItemInput>
    connectOrCreate?: UnitOfMeasureCreateOrConnectWithoutStockCorrectionItemInput
    connect?: UnitOfMeasureWhereUniqueInput
  }

  export type StockCorrectionUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<StockCorrectionCreateWithoutItemsInput, StockCorrectionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: StockCorrectionCreateOrConnectWithoutItemsInput
    upsert?: StockCorrectionUpsertWithoutItemsInput
    connect?: StockCorrectionWhereUniqueInput
    update?: XOR<XOR<StockCorrectionUpdateToOneWithWhereWithoutItemsInput, StockCorrectionUpdateWithoutItemsInput>, StockCorrectionUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutStockCorrectionItemNestedInput = {
    create?: XOR<ProductCreateWithoutStockCorrectionItemInput, ProductUncheckedCreateWithoutStockCorrectionItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockCorrectionItemInput
    upsert?: ProductUpsertWithoutStockCorrectionItemInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutStockCorrectionItemInput, ProductUpdateWithoutStockCorrectionItemInput>, ProductUncheckedUpdateWithoutStockCorrectionItemInput>
  }

  export type ProductBatchUpdateOneWithoutStockCorrectionItemNestedInput = {
    create?: XOR<ProductBatchCreateWithoutStockCorrectionItemInput, ProductBatchUncheckedCreateWithoutStockCorrectionItemInput>
    connectOrCreate?: ProductBatchCreateOrConnectWithoutStockCorrectionItemInput
    upsert?: ProductBatchUpsertWithoutStockCorrectionItemInput
    disconnect?: ProductBatchWhereInput | boolean
    delete?: ProductBatchWhereInput | boolean
    connect?: ProductBatchWhereUniqueInput
    update?: XOR<XOR<ProductBatchUpdateToOneWithWhereWithoutStockCorrectionItemInput, ProductBatchUpdateWithoutStockCorrectionItemInput>, ProductBatchUncheckedUpdateWithoutStockCorrectionItemInput>
  }

  export type UnitOfMeasureUpdateOneRequiredWithoutStockCorrectionItemNestedInput = {
    create?: XOR<UnitOfMeasureCreateWithoutStockCorrectionItemInput, UnitOfMeasureUncheckedCreateWithoutStockCorrectionItemInput>
    connectOrCreate?: UnitOfMeasureCreateOrConnectWithoutStockCorrectionItemInput
    upsert?: UnitOfMeasureUpsertWithoutStockCorrectionItemInput
    connect?: UnitOfMeasureWhereUniqueInput
    update?: XOR<XOR<UnitOfMeasureUpdateToOneWithWhereWithoutStockCorrectionItemInput, UnitOfMeasureUpdateWithoutStockCorrectionItemInput>, UnitOfMeasureUncheckedUpdateWithoutStockCorrectionItemInput>
  }

  export type BranchCreateNestedOneWithoutSellInput = {
    create?: XOR<BranchCreateWithoutSellInput, BranchUncheckedCreateWithoutSellInput>
    connectOrCreate?: BranchCreateOrConnectWithoutSellInput
    connect?: BranchWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutSellInput = {
    create?: XOR<CustomerCreateWithoutSellInput, CustomerUncheckedCreateWithoutSellInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSellInput
    connect?: CustomerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSellInput = {
    create?: XOR<UserCreateWithoutSellInput, UserUncheckedCreateWithoutSellInput>
    connectOrCreate?: UserCreateOrConnectWithoutSellInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdateSellInput = {
    create?: XOR<UserCreateWithoutUpdateSellInput, UserUncheckedCreateWithoutUpdateSellInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdateSellInput
    connect?: UserWhereUniqueInput
  }

  export type SellItemCreateNestedManyWithoutSellInput = {
    create?: XOR<SellItemCreateWithoutSellInput, SellItemUncheckedCreateWithoutSellInput> | SellItemCreateWithoutSellInput[] | SellItemUncheckedCreateWithoutSellInput[]
    connectOrCreate?: SellItemCreateOrConnectWithoutSellInput | SellItemCreateOrConnectWithoutSellInput[]
    createMany?: SellItemCreateManySellInputEnvelope
    connect?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
  }

  export type SellStockCorrectionCreateNestedManyWithoutSellInput = {
    create?: XOR<SellStockCorrectionCreateWithoutSellInput, SellStockCorrectionUncheckedCreateWithoutSellInput> | SellStockCorrectionCreateWithoutSellInput[] | SellStockCorrectionUncheckedCreateWithoutSellInput[]
    connectOrCreate?: SellStockCorrectionCreateOrConnectWithoutSellInput | SellStockCorrectionCreateOrConnectWithoutSellInput[]
    createMany?: SellStockCorrectionCreateManySellInputEnvelope
    connect?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
  }

  export type SellItemUncheckedCreateNestedManyWithoutSellInput = {
    create?: XOR<SellItemCreateWithoutSellInput, SellItemUncheckedCreateWithoutSellInput> | SellItemCreateWithoutSellInput[] | SellItemUncheckedCreateWithoutSellInput[]
    connectOrCreate?: SellItemCreateOrConnectWithoutSellInput | SellItemCreateOrConnectWithoutSellInput[]
    createMany?: SellItemCreateManySellInputEnvelope
    connect?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
  }

  export type SellStockCorrectionUncheckedCreateNestedManyWithoutSellInput = {
    create?: XOR<SellStockCorrectionCreateWithoutSellInput, SellStockCorrectionUncheckedCreateWithoutSellInput> | SellStockCorrectionCreateWithoutSellInput[] | SellStockCorrectionUncheckedCreateWithoutSellInput[]
    connectOrCreate?: SellStockCorrectionCreateOrConnectWithoutSellInput | SellStockCorrectionCreateOrConnectWithoutSellInput[]
    createMany?: SellStockCorrectionCreateManySellInputEnvelope
    connect?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
  }

  export type EnumSaleStatusFieldUpdateOperationsInput = {
    set?: $Enums.SaleStatus
  }

  export type BranchUpdateOneWithoutSellNestedInput = {
    create?: XOR<BranchCreateWithoutSellInput, BranchUncheckedCreateWithoutSellInput>
    connectOrCreate?: BranchCreateOrConnectWithoutSellInput
    upsert?: BranchUpsertWithoutSellInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutSellInput, BranchUpdateWithoutSellInput>, BranchUncheckedUpdateWithoutSellInput>
  }

  export type CustomerUpdateOneWithoutSellNestedInput = {
    create?: XOR<CustomerCreateWithoutSellInput, CustomerUncheckedCreateWithoutSellInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSellInput
    upsert?: CustomerUpsertWithoutSellInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSellInput, CustomerUpdateWithoutSellInput>, CustomerUncheckedUpdateWithoutSellInput>
  }

  export type UserUpdateOneWithoutSellNestedInput = {
    create?: XOR<UserCreateWithoutSellInput, UserUncheckedCreateWithoutSellInput>
    connectOrCreate?: UserCreateOrConnectWithoutSellInput
    upsert?: UserUpsertWithoutSellInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSellInput, UserUpdateWithoutSellInput>, UserUncheckedUpdateWithoutSellInput>
  }

  export type UserUpdateOneWithoutUpdateSellNestedInput = {
    create?: XOR<UserCreateWithoutUpdateSellInput, UserUncheckedCreateWithoutUpdateSellInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdateSellInput
    upsert?: UserUpsertWithoutUpdateSellInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdateSellInput, UserUpdateWithoutUpdateSellInput>, UserUncheckedUpdateWithoutUpdateSellInput>
  }

  export type SellItemUpdateManyWithoutSellNestedInput = {
    create?: XOR<SellItemCreateWithoutSellInput, SellItemUncheckedCreateWithoutSellInput> | SellItemCreateWithoutSellInput[] | SellItemUncheckedCreateWithoutSellInput[]
    connectOrCreate?: SellItemCreateOrConnectWithoutSellInput | SellItemCreateOrConnectWithoutSellInput[]
    upsert?: SellItemUpsertWithWhereUniqueWithoutSellInput | SellItemUpsertWithWhereUniqueWithoutSellInput[]
    createMany?: SellItemCreateManySellInputEnvelope
    set?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    disconnect?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    delete?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    connect?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    update?: SellItemUpdateWithWhereUniqueWithoutSellInput | SellItemUpdateWithWhereUniqueWithoutSellInput[]
    updateMany?: SellItemUpdateManyWithWhereWithoutSellInput | SellItemUpdateManyWithWhereWithoutSellInput[]
    deleteMany?: SellItemScalarWhereInput | SellItemScalarWhereInput[]
  }

  export type SellStockCorrectionUpdateManyWithoutSellNestedInput = {
    create?: XOR<SellStockCorrectionCreateWithoutSellInput, SellStockCorrectionUncheckedCreateWithoutSellInput> | SellStockCorrectionCreateWithoutSellInput[] | SellStockCorrectionUncheckedCreateWithoutSellInput[]
    connectOrCreate?: SellStockCorrectionCreateOrConnectWithoutSellInput | SellStockCorrectionCreateOrConnectWithoutSellInput[]
    upsert?: SellStockCorrectionUpsertWithWhereUniqueWithoutSellInput | SellStockCorrectionUpsertWithWhereUniqueWithoutSellInput[]
    createMany?: SellStockCorrectionCreateManySellInputEnvelope
    set?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
    disconnect?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
    delete?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
    connect?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
    update?: SellStockCorrectionUpdateWithWhereUniqueWithoutSellInput | SellStockCorrectionUpdateWithWhereUniqueWithoutSellInput[]
    updateMany?: SellStockCorrectionUpdateManyWithWhereWithoutSellInput | SellStockCorrectionUpdateManyWithWhereWithoutSellInput[]
    deleteMany?: SellStockCorrectionScalarWhereInput | SellStockCorrectionScalarWhereInput[]
  }

  export type SellItemUncheckedUpdateManyWithoutSellNestedInput = {
    create?: XOR<SellItemCreateWithoutSellInput, SellItemUncheckedCreateWithoutSellInput> | SellItemCreateWithoutSellInput[] | SellItemUncheckedCreateWithoutSellInput[]
    connectOrCreate?: SellItemCreateOrConnectWithoutSellInput | SellItemCreateOrConnectWithoutSellInput[]
    upsert?: SellItemUpsertWithWhereUniqueWithoutSellInput | SellItemUpsertWithWhereUniqueWithoutSellInput[]
    createMany?: SellItemCreateManySellInputEnvelope
    set?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    disconnect?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    delete?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    connect?: SellItemWhereUniqueInput | SellItemWhereUniqueInput[]
    update?: SellItemUpdateWithWhereUniqueWithoutSellInput | SellItemUpdateWithWhereUniqueWithoutSellInput[]
    updateMany?: SellItemUpdateManyWithWhereWithoutSellInput | SellItemUpdateManyWithWhereWithoutSellInput[]
    deleteMany?: SellItemScalarWhereInput | SellItemScalarWhereInput[]
  }

  export type SellStockCorrectionUncheckedUpdateManyWithoutSellNestedInput = {
    create?: XOR<SellStockCorrectionCreateWithoutSellInput, SellStockCorrectionUncheckedCreateWithoutSellInput> | SellStockCorrectionCreateWithoutSellInput[] | SellStockCorrectionUncheckedCreateWithoutSellInput[]
    connectOrCreate?: SellStockCorrectionCreateOrConnectWithoutSellInput | SellStockCorrectionCreateOrConnectWithoutSellInput[]
    upsert?: SellStockCorrectionUpsertWithWhereUniqueWithoutSellInput | SellStockCorrectionUpsertWithWhereUniqueWithoutSellInput[]
    createMany?: SellStockCorrectionCreateManySellInputEnvelope
    set?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
    disconnect?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
    delete?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
    connect?: SellStockCorrectionWhereUniqueInput | SellStockCorrectionWhereUniqueInput[]
    update?: SellStockCorrectionUpdateWithWhereUniqueWithoutSellInput | SellStockCorrectionUpdateWithWhereUniqueWithoutSellInput[]
    updateMany?: SellStockCorrectionUpdateManyWithWhereWithoutSellInput | SellStockCorrectionUpdateManyWithWhereWithoutSellInput[]
    deleteMany?: SellStockCorrectionScalarWhereInput | SellStockCorrectionScalarWhereInput[]
  }

  export type SellCreateNestedOneWithoutItemsInput = {
    create?: XOR<SellCreateWithoutItemsInput, SellUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SellCreateOrConnectWithoutItemsInput
    connect?: SellWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutSellItemInput = {
    create?: XOR<ProductCreateWithoutSellItemInput, ProductUncheckedCreateWithoutSellItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSellItemInput
    connect?: ProductWhereUniqueInput
  }

  export type ShopCreateNestedOneWithoutSellItemInput = {
    create?: XOR<ShopCreateWithoutSellItemInput, ShopUncheckedCreateWithoutSellItemInput>
    connectOrCreate?: ShopCreateOrConnectWithoutSellItemInput
    connect?: ShopWhereUniqueInput
  }

  export type UnitOfMeasureCreateNestedOneWithoutSellItemInput = {
    create?: XOR<UnitOfMeasureCreateWithoutSellItemInput, UnitOfMeasureUncheckedCreateWithoutSellItemInput>
    connectOrCreate?: UnitOfMeasureCreateOrConnectWithoutSellItemInput
    connect?: UnitOfMeasureWhereUniqueInput
  }

  export type SellItemBatchCreateNestedManyWithoutSellItemInput = {
    create?: XOR<SellItemBatchCreateWithoutSellItemInput, SellItemBatchUncheckedCreateWithoutSellItemInput> | SellItemBatchCreateWithoutSellItemInput[] | SellItemBatchUncheckedCreateWithoutSellItemInput[]
    connectOrCreate?: SellItemBatchCreateOrConnectWithoutSellItemInput | SellItemBatchCreateOrConnectWithoutSellItemInput[]
    createMany?: SellItemBatchCreateManySellItemInputEnvelope
    connect?: SellItemBatchWhereUniqueInput | SellItemBatchWhereUniqueInput[]
  }

  export type SellItemBatchUncheckedCreateNestedManyWithoutSellItemInput = {
    create?: XOR<SellItemBatchCreateWithoutSellItemInput, SellItemBatchUncheckedCreateWithoutSellItemInput> | SellItemBatchCreateWithoutSellItemInput[] | SellItemBatchUncheckedCreateWithoutSellItemInput[]
    connectOrCreate?: SellItemBatchCreateOrConnectWithoutSellItemInput | SellItemBatchCreateOrConnectWithoutSellItemInput[]
    createMany?: SellItemBatchCreateManySellItemInputEnvelope
    connect?: SellItemBatchWhereUniqueInput | SellItemBatchWhereUniqueInput[]
  }

  export type EnumItemSaleStatusFieldUpdateOperationsInput = {
    set?: $Enums.ItemSaleStatus
  }

  export type SellUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<SellCreateWithoutItemsInput, SellUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SellCreateOrConnectWithoutItemsInput
    upsert?: SellUpsertWithoutItemsInput
    connect?: SellWhereUniqueInput
    update?: XOR<XOR<SellUpdateToOneWithWhereWithoutItemsInput, SellUpdateWithoutItemsInput>, SellUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutSellItemNestedInput = {
    create?: XOR<ProductCreateWithoutSellItemInput, ProductUncheckedCreateWithoutSellItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSellItemInput
    upsert?: ProductUpsertWithoutSellItemInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSellItemInput, ProductUpdateWithoutSellItemInput>, ProductUncheckedUpdateWithoutSellItemInput>
  }

  export type ShopUpdateOneRequiredWithoutSellItemNestedInput = {
    create?: XOR<ShopCreateWithoutSellItemInput, ShopUncheckedCreateWithoutSellItemInput>
    connectOrCreate?: ShopCreateOrConnectWithoutSellItemInput
    upsert?: ShopUpsertWithoutSellItemInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutSellItemInput, ShopUpdateWithoutSellItemInput>, ShopUncheckedUpdateWithoutSellItemInput>
  }

  export type UnitOfMeasureUpdateOneRequiredWithoutSellItemNestedInput = {
    create?: XOR<UnitOfMeasureCreateWithoutSellItemInput, UnitOfMeasureUncheckedCreateWithoutSellItemInput>
    connectOrCreate?: UnitOfMeasureCreateOrConnectWithoutSellItemInput
    upsert?: UnitOfMeasureUpsertWithoutSellItemInput
    connect?: UnitOfMeasureWhereUniqueInput
    update?: XOR<XOR<UnitOfMeasureUpdateToOneWithWhereWithoutSellItemInput, UnitOfMeasureUpdateWithoutSellItemInput>, UnitOfMeasureUncheckedUpdateWithoutSellItemInput>
  }

  export type SellItemBatchUpdateManyWithoutSellItemNestedInput = {
    create?: XOR<SellItemBatchCreateWithoutSellItemInput, SellItemBatchUncheckedCreateWithoutSellItemInput> | SellItemBatchCreateWithoutSellItemInput[] | SellItemBatchUncheckedCreateWithoutSellItemInput[]
    connectOrCreate?: SellItemBatchCreateOrConnectWithoutSellItemInput | SellItemBatchCreateOrConnectWithoutSellItemInput[]
    upsert?: SellItemBatchUpsertWithWhereUniqueWithoutSellItemInput | SellItemBatchUpsertWithWhereUniqueWithoutSellItemInput[]
    createMany?: SellItemBatchCreateManySellItemInputEnvelope
    set?: SellItemBatchWhereUniqueInput | SellItemBatchWhereUniqueInput[]
    disconnect?: SellItemBatchWhereUniqueInput | SellItemBatchWhereUniqueInput[]
    delete?: SellItemBatchWhereUniqueInput | SellItemBatchWhereUniqueInput[]
    connect?: SellItemBatchWhereUniqueInput | SellItemBatchWhereUniqueInput[]
    update?: SellItemBatchUpdateWithWhereUniqueWithoutSellItemInput | SellItemBatchUpdateWithWhereUniqueWithoutSellItemInput[]
    updateMany?: SellItemBatchUpdateManyWithWhereWithoutSellItemInput | SellItemBatchUpdateManyWithWhereWithoutSellItemInput[]
    deleteMany?: SellItemBatchScalarWhereInput | SellItemBatchScalarWhereInput[]
  }

  export type SellItemBatchUncheckedUpdateManyWithoutSellItemNestedInput = {
    create?: XOR<SellItemBatchCreateWithoutSellItemInput, SellItemBatchUncheckedCreateWithoutSellItemInput> | SellItemBatchCreateWithoutSellItemInput[] | SellItemBatchUncheckedCreateWithoutSellItemInput[]
    connectOrCreate?: SellItemBatchCreateOrConnectWithoutSellItemInput | SellItemBatchCreateOrConnectWithoutSellItemInput[]
    upsert?: SellItemBatchUpsertWithWhereUniqueWithoutSellItemInput | SellItemBatchUpsertWithWhereUniqueWithoutSellItemInput[]
    createMany?: SellItemBatchCreateManySellItemInputEnvelope
    set?: SellItemBatchWhereUniqueInput | SellItemBatchWhereUniqueInput[]
    disconnect?: SellItemBatchWhereUniqueInput | SellItemBatchWhereUniqueInput[]
    delete?: SellItemBatchWhereUniqueInput | SellItemBatchWhereUniqueInput[]
    connect?: SellItemBatchWhereUniqueInput | SellItemBatchWhereUniqueInput[]
    update?: SellItemBatchUpdateWithWhereUniqueWithoutSellItemInput | SellItemBatchUpdateWithWhereUniqueWithoutSellItemInput[]
    updateMany?: SellItemBatchUpdateManyWithWhereWithoutSellItemInput | SellItemBatchUpdateManyWithWhereWithoutSellItemInput[]
    deleteMany?: SellItemBatchScalarWhereInput | SellItemBatchScalarWhereInput[]
  }

  export type SellItemCreateNestedOneWithoutBatchesInput = {
    create?: XOR<SellItemCreateWithoutBatchesInput, SellItemUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: SellItemCreateOrConnectWithoutBatchesInput
    connect?: SellItemWhereUniqueInput
  }

  export type ProductBatchCreateNestedOneWithoutSellItemBatchInput = {
    create?: XOR<ProductBatchCreateWithoutSellItemBatchInput, ProductBatchUncheckedCreateWithoutSellItemBatchInput>
    connectOrCreate?: ProductBatchCreateOrConnectWithoutSellItemBatchInput
    connect?: ProductBatchWhereUniqueInput
  }

  export type SellItemUpdateOneRequiredWithoutBatchesNestedInput = {
    create?: XOR<SellItemCreateWithoutBatchesInput, SellItemUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: SellItemCreateOrConnectWithoutBatchesInput
    upsert?: SellItemUpsertWithoutBatchesInput
    connect?: SellItemWhereUniqueInput
    update?: XOR<XOR<SellItemUpdateToOneWithWhereWithoutBatchesInput, SellItemUpdateWithoutBatchesInput>, SellItemUncheckedUpdateWithoutBatchesInput>
  }

  export type ProductBatchUpdateOneRequiredWithoutSellItemBatchNestedInput = {
    create?: XOR<ProductBatchCreateWithoutSellItemBatchInput, ProductBatchUncheckedCreateWithoutSellItemBatchInput>
    connectOrCreate?: ProductBatchCreateOrConnectWithoutSellItemBatchInput
    upsert?: ProductBatchUpsertWithoutSellItemBatchInput
    connect?: ProductBatchWhereUniqueInput
    update?: XOR<XOR<ProductBatchUpdateToOneWithWhereWithoutSellItemBatchInput, ProductBatchUpdateWithoutSellItemBatchInput>, ProductBatchUncheckedUpdateWithoutSellItemBatchInput>
  }

  export type UserCreateNestedOneWithoutAllAddToCartInput = {
    create?: XOR<UserCreateWithoutAllAddToCartInput, UserUncheckedCreateWithoutAllAddToCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutAllAddToCartInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutAddToCartInput = {
    create?: XOR<BranchCreateWithoutAddToCartInput, BranchUncheckedCreateWithoutAddToCartInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAddToCartInput
    connect?: BranchWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutAddToCartInput = {
    create?: XOR<CustomerCreateWithoutAddToCartInput, CustomerUncheckedCreateWithoutAddToCartInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAddToCartInput
    connect?: CustomerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedAddToCartInput = {
    create?: XOR<UserCreateWithoutCreatedAddToCartInput, UserUncheckedCreateWithoutCreatedAddToCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedAddToCartInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAddToCartInput = {
    create?: XOR<UserCreateWithoutAddToCartInput, UserUncheckedCreateWithoutAddToCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddToCartInput
    connect?: UserWhereUniqueInput
  }

  export type CartItemCreateNestedManyWithoutCartInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type WaitlistCreateNestedManyWithoutCartInput = {
    create?: XOR<WaitlistCreateWithoutCartInput, WaitlistUncheckedCreateWithoutCartInput> | WaitlistCreateWithoutCartInput[] | WaitlistUncheckedCreateWithoutCartInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutCartInput | WaitlistCreateOrConnectWithoutCartInput[]
    createMany?: WaitlistCreateManyCartInputEnvelope
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
  }

  export type CartItemUncheckedCreateNestedManyWithoutCartInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type WaitlistUncheckedCreateNestedManyWithoutCartInput = {
    create?: XOR<WaitlistCreateWithoutCartInput, WaitlistUncheckedCreateWithoutCartInput> | WaitlistCreateWithoutCartInput[] | WaitlistUncheckedCreateWithoutCartInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutCartInput | WaitlistCreateOrConnectWithoutCartInput[]
    createMany?: WaitlistCreateManyCartInputEnvelope
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutAllAddToCartNestedInput = {
    create?: XOR<UserCreateWithoutAllAddToCartInput, UserUncheckedCreateWithoutAllAddToCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutAllAddToCartInput
    upsert?: UserUpsertWithoutAllAddToCartInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAllAddToCartInput, UserUpdateWithoutAllAddToCartInput>, UserUncheckedUpdateWithoutAllAddToCartInput>
  }

  export type BranchUpdateOneWithoutAddToCartNestedInput = {
    create?: XOR<BranchCreateWithoutAddToCartInput, BranchUncheckedCreateWithoutAddToCartInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAddToCartInput
    upsert?: BranchUpsertWithoutAddToCartInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutAddToCartInput, BranchUpdateWithoutAddToCartInput>, BranchUncheckedUpdateWithoutAddToCartInput>
  }

  export type CustomerUpdateOneWithoutAddToCartNestedInput = {
    create?: XOR<CustomerCreateWithoutAddToCartInput, CustomerUncheckedCreateWithoutAddToCartInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAddToCartInput
    upsert?: CustomerUpsertWithoutAddToCartInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutAddToCartInput, CustomerUpdateWithoutAddToCartInput>, CustomerUncheckedUpdateWithoutAddToCartInput>
  }

  export type UserUpdateOneWithoutCreatedAddToCartNestedInput = {
    create?: XOR<UserCreateWithoutCreatedAddToCartInput, UserUncheckedCreateWithoutCreatedAddToCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedAddToCartInput
    upsert?: UserUpsertWithoutCreatedAddToCartInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedAddToCartInput, UserUpdateWithoutCreatedAddToCartInput>, UserUncheckedUpdateWithoutCreatedAddToCartInput>
  }

  export type UserUpdateOneWithoutAddToCartNestedInput = {
    create?: XOR<UserCreateWithoutAddToCartInput, UserUncheckedCreateWithoutAddToCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddToCartInput
    upsert?: UserUpsertWithoutAddToCartInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAddToCartInput, UserUpdateWithoutAddToCartInput>, UserUncheckedUpdateWithoutAddToCartInput>
  }

  export type CartItemUpdateManyWithoutCartNestedInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutCartInput | CartItemUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutCartInput | CartItemUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutCartInput | CartItemUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type WaitlistUpdateManyWithoutCartNestedInput = {
    create?: XOR<WaitlistCreateWithoutCartInput, WaitlistUncheckedCreateWithoutCartInput> | WaitlistCreateWithoutCartInput[] | WaitlistUncheckedCreateWithoutCartInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutCartInput | WaitlistCreateOrConnectWithoutCartInput[]
    upsert?: WaitlistUpsertWithWhereUniqueWithoutCartInput | WaitlistUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: WaitlistCreateManyCartInputEnvelope
    set?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    disconnect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    delete?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    update?: WaitlistUpdateWithWhereUniqueWithoutCartInput | WaitlistUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: WaitlistUpdateManyWithWhereWithoutCartInput | WaitlistUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: WaitlistScalarWhereInput | WaitlistScalarWhereInput[]
  }

  export type CartItemUncheckedUpdateManyWithoutCartNestedInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutCartInput | CartItemUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutCartInput | CartItemUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutCartInput | CartItemUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type WaitlistUncheckedUpdateManyWithoutCartNestedInput = {
    create?: XOR<WaitlistCreateWithoutCartInput, WaitlistUncheckedCreateWithoutCartInput> | WaitlistCreateWithoutCartInput[] | WaitlistUncheckedCreateWithoutCartInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutCartInput | WaitlistCreateOrConnectWithoutCartInput[]
    upsert?: WaitlistUpsertWithWhereUniqueWithoutCartInput | WaitlistUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: WaitlistCreateManyCartInputEnvelope
    set?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    disconnect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    delete?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    update?: WaitlistUpdateWithWhereUniqueWithoutCartInput | WaitlistUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: WaitlistUpdateManyWithWhereWithoutCartInput | WaitlistUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: WaitlistScalarWhereInput | WaitlistScalarWhereInput[]
  }

  export type AddToCartCreateNestedOneWithoutItemsInput = {
    create?: XOR<AddToCartCreateWithoutItemsInput, AddToCartUncheckedCreateWithoutItemsInput>
    connectOrCreate?: AddToCartCreateOrConnectWithoutItemsInput
    connect?: AddToCartWhereUniqueInput
  }

  export type ShopCreateNestedOneWithoutCartItemInput = {
    create?: XOR<ShopCreateWithoutCartItemInput, ShopUncheckedCreateWithoutCartItemInput>
    connectOrCreate?: ShopCreateOrConnectWithoutCartItemInput
    connect?: ShopWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutCartItemInput = {
    create?: XOR<ProductCreateWithoutCartItemInput, ProductUncheckedCreateWithoutCartItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCartItemInput
    connect?: ProductWhereUniqueInput
  }

  export type UnitOfMeasureCreateNestedOneWithoutCartItemInput = {
    create?: XOR<UnitOfMeasureCreateWithoutCartItemInput, UnitOfMeasureUncheckedCreateWithoutCartItemInput>
    connectOrCreate?: UnitOfMeasureCreateOrConnectWithoutCartItemInput
    connect?: UnitOfMeasureWhereUniqueInput
  }

  export type WaitlistCreateNestedManyWithoutCartItemInput = {
    create?: XOR<WaitlistCreateWithoutCartItemInput, WaitlistUncheckedCreateWithoutCartItemInput> | WaitlistCreateWithoutCartItemInput[] | WaitlistUncheckedCreateWithoutCartItemInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutCartItemInput | WaitlistCreateOrConnectWithoutCartItemInput[]
    createMany?: WaitlistCreateManyCartItemInputEnvelope
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
  }

  export type WaitlistUncheckedCreateNestedManyWithoutCartItemInput = {
    create?: XOR<WaitlistCreateWithoutCartItemInput, WaitlistUncheckedCreateWithoutCartItemInput> | WaitlistCreateWithoutCartItemInput[] | WaitlistUncheckedCreateWithoutCartItemInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutCartItemInput | WaitlistCreateOrConnectWithoutCartItemInput[]
    createMany?: WaitlistCreateManyCartItemInputEnvelope
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
  }

  export type AddToCartUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<AddToCartCreateWithoutItemsInput, AddToCartUncheckedCreateWithoutItemsInput>
    connectOrCreate?: AddToCartCreateOrConnectWithoutItemsInput
    upsert?: AddToCartUpsertWithoutItemsInput
    connect?: AddToCartWhereUniqueInput
    update?: XOR<XOR<AddToCartUpdateToOneWithWhereWithoutItemsInput, AddToCartUpdateWithoutItemsInput>, AddToCartUncheckedUpdateWithoutItemsInput>
  }

  export type ShopUpdateOneRequiredWithoutCartItemNestedInput = {
    create?: XOR<ShopCreateWithoutCartItemInput, ShopUncheckedCreateWithoutCartItemInput>
    connectOrCreate?: ShopCreateOrConnectWithoutCartItemInput
    upsert?: ShopUpsertWithoutCartItemInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutCartItemInput, ShopUpdateWithoutCartItemInput>, ShopUncheckedUpdateWithoutCartItemInput>
  }

  export type ProductUpdateOneRequiredWithoutCartItemNestedInput = {
    create?: XOR<ProductCreateWithoutCartItemInput, ProductUncheckedCreateWithoutCartItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCartItemInput
    upsert?: ProductUpsertWithoutCartItemInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutCartItemInput, ProductUpdateWithoutCartItemInput>, ProductUncheckedUpdateWithoutCartItemInput>
  }

  export type UnitOfMeasureUpdateOneWithoutCartItemNestedInput = {
    create?: XOR<UnitOfMeasureCreateWithoutCartItemInput, UnitOfMeasureUncheckedCreateWithoutCartItemInput>
    connectOrCreate?: UnitOfMeasureCreateOrConnectWithoutCartItemInput
    upsert?: UnitOfMeasureUpsertWithoutCartItemInput
    disconnect?: UnitOfMeasureWhereInput | boolean
    delete?: UnitOfMeasureWhereInput | boolean
    connect?: UnitOfMeasureWhereUniqueInput
    update?: XOR<XOR<UnitOfMeasureUpdateToOneWithWhereWithoutCartItemInput, UnitOfMeasureUpdateWithoutCartItemInput>, UnitOfMeasureUncheckedUpdateWithoutCartItemInput>
  }

  export type WaitlistUpdateManyWithoutCartItemNestedInput = {
    create?: XOR<WaitlistCreateWithoutCartItemInput, WaitlistUncheckedCreateWithoutCartItemInput> | WaitlistCreateWithoutCartItemInput[] | WaitlistUncheckedCreateWithoutCartItemInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutCartItemInput | WaitlistCreateOrConnectWithoutCartItemInput[]
    upsert?: WaitlistUpsertWithWhereUniqueWithoutCartItemInput | WaitlistUpsertWithWhereUniqueWithoutCartItemInput[]
    createMany?: WaitlistCreateManyCartItemInputEnvelope
    set?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    disconnect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    delete?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    update?: WaitlistUpdateWithWhereUniqueWithoutCartItemInput | WaitlistUpdateWithWhereUniqueWithoutCartItemInput[]
    updateMany?: WaitlistUpdateManyWithWhereWithoutCartItemInput | WaitlistUpdateManyWithWhereWithoutCartItemInput[]
    deleteMany?: WaitlistScalarWhereInput | WaitlistScalarWhereInput[]
  }

  export type WaitlistUncheckedUpdateManyWithoutCartItemNestedInput = {
    create?: XOR<WaitlistCreateWithoutCartItemInput, WaitlistUncheckedCreateWithoutCartItemInput> | WaitlistCreateWithoutCartItemInput[] | WaitlistUncheckedCreateWithoutCartItemInput[]
    connectOrCreate?: WaitlistCreateOrConnectWithoutCartItemInput | WaitlistCreateOrConnectWithoutCartItemInput[]
    upsert?: WaitlistUpsertWithWhereUniqueWithoutCartItemInput | WaitlistUpsertWithWhereUniqueWithoutCartItemInput[]
    createMany?: WaitlistCreateManyCartItemInputEnvelope
    set?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    disconnect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    delete?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    connect?: WaitlistWhereUniqueInput | WaitlistWhereUniqueInput[]
    update?: WaitlistUpdateWithWhereUniqueWithoutCartItemInput | WaitlistUpdateWithWhereUniqueWithoutCartItemInput[]
    updateMany?: WaitlistUpdateManyWithWhereWithoutCartItemInput | WaitlistUpdateManyWithWhereWithoutCartItemInput[]
    deleteMany?: WaitlistScalarWhereInput | WaitlistScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutWaitlistsInput = {
    create?: XOR<UserCreateWithoutWaitlistsInput, UserUncheckedCreateWithoutWaitlistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWaitlistsInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutWaitlistsInput = {
    create?: XOR<CustomerCreateWithoutWaitlistsInput, CustomerUncheckedCreateWithoutWaitlistsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutWaitlistsInput
    connect?: CustomerWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutWaitlistsInput = {
    create?: XOR<BranchCreateWithoutWaitlistsInput, BranchUncheckedCreateWithoutWaitlistsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutWaitlistsInput
    connect?: BranchWhereUniqueInput
  }

  export type AddToCartCreateNestedOneWithoutWaitlistsInput = {
    create?: XOR<AddToCartCreateWithoutWaitlistsInput, AddToCartUncheckedCreateWithoutWaitlistsInput>
    connectOrCreate?: AddToCartCreateOrConnectWithoutWaitlistsInput
    connect?: AddToCartWhereUniqueInput
  }

  export type CartItemCreateNestedOneWithoutWaitlistsInput = {
    create?: XOR<CartItemCreateWithoutWaitlistsInput, CartItemUncheckedCreateWithoutWaitlistsInput>
    connectOrCreate?: CartItemCreateOrConnectWithoutWaitlistsInput
    connect?: CartItemWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutWaitlistsInput = {
    create?: XOR<ProductCreateWithoutWaitlistsInput, ProductUncheckedCreateWithoutWaitlistsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutWaitlistsInput
    connect?: ProductWhereUniqueInput
  }

  export type ShopCreateNestedOneWithoutWaitlistsInput = {
    create?: XOR<ShopCreateWithoutWaitlistsInput, ShopUncheckedCreateWithoutWaitlistsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutWaitlistsInput
    connect?: ShopWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWaitlistsCreatedInput = {
    create?: XOR<UserCreateWithoutWaitlistsCreatedInput, UserUncheckedCreateWithoutWaitlistsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutWaitlistsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWaitlistsUpdatedInput = {
    create?: XOR<UserCreateWithoutWaitlistsUpdatedInput, UserUncheckedCreateWithoutWaitlistsUpdatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutWaitlistsUpdatedInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutWaitlistsNestedInput = {
    create?: XOR<UserCreateWithoutWaitlistsInput, UserUncheckedCreateWithoutWaitlistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWaitlistsInput
    upsert?: UserUpsertWithoutWaitlistsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWaitlistsInput, UserUpdateWithoutWaitlistsInput>, UserUncheckedUpdateWithoutWaitlistsInput>
  }

  export type CustomerUpdateOneWithoutWaitlistsNestedInput = {
    create?: XOR<CustomerCreateWithoutWaitlistsInput, CustomerUncheckedCreateWithoutWaitlistsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutWaitlistsInput
    upsert?: CustomerUpsertWithoutWaitlistsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutWaitlistsInput, CustomerUpdateWithoutWaitlistsInput>, CustomerUncheckedUpdateWithoutWaitlistsInput>
  }

  export type BranchUpdateOneWithoutWaitlistsNestedInput = {
    create?: XOR<BranchCreateWithoutWaitlistsInput, BranchUncheckedCreateWithoutWaitlistsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutWaitlistsInput
    upsert?: BranchUpsertWithoutWaitlistsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutWaitlistsInput, BranchUpdateWithoutWaitlistsInput>, BranchUncheckedUpdateWithoutWaitlistsInput>
  }

  export type AddToCartUpdateOneWithoutWaitlistsNestedInput = {
    create?: XOR<AddToCartCreateWithoutWaitlistsInput, AddToCartUncheckedCreateWithoutWaitlistsInput>
    connectOrCreate?: AddToCartCreateOrConnectWithoutWaitlistsInput
    upsert?: AddToCartUpsertWithoutWaitlistsInput
    disconnect?: AddToCartWhereInput | boolean
    delete?: AddToCartWhereInput | boolean
    connect?: AddToCartWhereUniqueInput
    update?: XOR<XOR<AddToCartUpdateToOneWithWhereWithoutWaitlistsInput, AddToCartUpdateWithoutWaitlistsInput>, AddToCartUncheckedUpdateWithoutWaitlistsInput>
  }

  export type CartItemUpdateOneWithoutWaitlistsNestedInput = {
    create?: XOR<CartItemCreateWithoutWaitlistsInput, CartItemUncheckedCreateWithoutWaitlistsInput>
    connectOrCreate?: CartItemCreateOrConnectWithoutWaitlistsInput
    upsert?: CartItemUpsertWithoutWaitlistsInput
    disconnect?: CartItemWhereInput | boolean
    delete?: CartItemWhereInput | boolean
    connect?: CartItemWhereUniqueInput
    update?: XOR<XOR<CartItemUpdateToOneWithWhereWithoutWaitlistsInput, CartItemUpdateWithoutWaitlistsInput>, CartItemUncheckedUpdateWithoutWaitlistsInput>
  }

  export type ProductUpdateOneWithoutWaitlistsNestedInput = {
    create?: XOR<ProductCreateWithoutWaitlistsInput, ProductUncheckedCreateWithoutWaitlistsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutWaitlistsInput
    upsert?: ProductUpsertWithoutWaitlistsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutWaitlistsInput, ProductUpdateWithoutWaitlistsInput>, ProductUncheckedUpdateWithoutWaitlistsInput>
  }

  export type ShopUpdateOneWithoutWaitlistsNestedInput = {
    create?: XOR<ShopCreateWithoutWaitlistsInput, ShopUncheckedCreateWithoutWaitlistsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutWaitlistsInput
    upsert?: ShopUpsertWithoutWaitlistsInput
    disconnect?: ShopWhereInput | boolean
    delete?: ShopWhereInput | boolean
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutWaitlistsInput, ShopUpdateWithoutWaitlistsInput>, ShopUncheckedUpdateWithoutWaitlistsInput>
  }

  export type UserUpdateOneWithoutWaitlistsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutWaitlistsCreatedInput, UserUncheckedCreateWithoutWaitlistsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutWaitlistsCreatedInput
    upsert?: UserUpsertWithoutWaitlistsCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWaitlistsCreatedInput, UserUpdateWithoutWaitlistsCreatedInput>, UserUncheckedUpdateWithoutWaitlistsCreatedInput>
  }

  export type UserUpdateOneWithoutWaitlistsUpdatedNestedInput = {
    create?: XOR<UserCreateWithoutWaitlistsUpdatedInput, UserUncheckedCreateWithoutWaitlistsUpdatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutWaitlistsUpdatedInput
    upsert?: UserUpsertWithoutWaitlistsUpdatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWaitlistsUpdatedInput, UserUpdateWithoutWaitlistsUpdatedInput>, UserUncheckedUpdateWithoutWaitlistsUpdatedInput>
  }

  export type SellCreateNestedOneWithoutSellStockCorrectionInput = {
    create?: XOR<SellCreateWithoutSellStockCorrectionInput, SellUncheckedCreateWithoutSellStockCorrectionInput>
    connectOrCreate?: SellCreateOrConnectWithoutSellStockCorrectionInput
    connect?: SellWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSellStockCorrectionInput = {
    create?: XOR<UserCreateWithoutSellStockCorrectionInput, UserUncheckedCreateWithoutSellStockCorrectionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSellStockCorrectionInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdateSellStockCorrectionInput = {
    create?: XOR<UserCreateWithoutUpdateSellStockCorrectionInput, UserUncheckedCreateWithoutUpdateSellStockCorrectionInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdateSellStockCorrectionInput
    connect?: UserWhereUniqueInput
  }

  export type SellStockCorrectionItemCreateNestedManyWithoutCorrectionInput = {
    create?: XOR<SellStockCorrectionItemCreateWithoutCorrectionInput, SellStockCorrectionItemUncheckedCreateWithoutCorrectionInput> | SellStockCorrectionItemCreateWithoutCorrectionInput[] | SellStockCorrectionItemUncheckedCreateWithoutCorrectionInput[]
    connectOrCreate?: SellStockCorrectionItemCreateOrConnectWithoutCorrectionInput | SellStockCorrectionItemCreateOrConnectWithoutCorrectionInput[]
    createMany?: SellStockCorrectionItemCreateManyCorrectionInputEnvelope
    connect?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
  }

  export type SellStockCorrectionItemUncheckedCreateNestedManyWithoutCorrectionInput = {
    create?: XOR<SellStockCorrectionItemCreateWithoutCorrectionInput, SellStockCorrectionItemUncheckedCreateWithoutCorrectionInput> | SellStockCorrectionItemCreateWithoutCorrectionInput[] | SellStockCorrectionItemUncheckedCreateWithoutCorrectionInput[]
    connectOrCreate?: SellStockCorrectionItemCreateOrConnectWithoutCorrectionInput | SellStockCorrectionItemCreateOrConnectWithoutCorrectionInput[]
    createMany?: SellStockCorrectionItemCreateManyCorrectionInputEnvelope
    connect?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
  }

  export type EnumSellStockCorrectionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SellStockCorrectionStatus
  }

  export type SellUpdateOneWithoutSellStockCorrectionNestedInput = {
    create?: XOR<SellCreateWithoutSellStockCorrectionInput, SellUncheckedCreateWithoutSellStockCorrectionInput>
    connectOrCreate?: SellCreateOrConnectWithoutSellStockCorrectionInput
    upsert?: SellUpsertWithoutSellStockCorrectionInput
    disconnect?: SellWhereInput | boolean
    delete?: SellWhereInput | boolean
    connect?: SellWhereUniqueInput
    update?: XOR<XOR<SellUpdateToOneWithWhereWithoutSellStockCorrectionInput, SellUpdateWithoutSellStockCorrectionInput>, SellUncheckedUpdateWithoutSellStockCorrectionInput>
  }

  export type UserUpdateOneWithoutSellStockCorrectionNestedInput = {
    create?: XOR<UserCreateWithoutSellStockCorrectionInput, UserUncheckedCreateWithoutSellStockCorrectionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSellStockCorrectionInput
    upsert?: UserUpsertWithoutSellStockCorrectionInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSellStockCorrectionInput, UserUpdateWithoutSellStockCorrectionInput>, UserUncheckedUpdateWithoutSellStockCorrectionInput>
  }

  export type UserUpdateOneWithoutUpdateSellStockCorrectionNestedInput = {
    create?: XOR<UserCreateWithoutUpdateSellStockCorrectionInput, UserUncheckedCreateWithoutUpdateSellStockCorrectionInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdateSellStockCorrectionInput
    upsert?: UserUpsertWithoutUpdateSellStockCorrectionInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdateSellStockCorrectionInput, UserUpdateWithoutUpdateSellStockCorrectionInput>, UserUncheckedUpdateWithoutUpdateSellStockCorrectionInput>
  }

  export type SellStockCorrectionItemUpdateManyWithoutCorrectionNestedInput = {
    create?: XOR<SellStockCorrectionItemCreateWithoutCorrectionInput, SellStockCorrectionItemUncheckedCreateWithoutCorrectionInput> | SellStockCorrectionItemCreateWithoutCorrectionInput[] | SellStockCorrectionItemUncheckedCreateWithoutCorrectionInput[]
    connectOrCreate?: SellStockCorrectionItemCreateOrConnectWithoutCorrectionInput | SellStockCorrectionItemCreateOrConnectWithoutCorrectionInput[]
    upsert?: SellStockCorrectionItemUpsertWithWhereUniqueWithoutCorrectionInput | SellStockCorrectionItemUpsertWithWhereUniqueWithoutCorrectionInput[]
    createMany?: SellStockCorrectionItemCreateManyCorrectionInputEnvelope
    set?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    disconnect?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    delete?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    connect?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    update?: SellStockCorrectionItemUpdateWithWhereUniqueWithoutCorrectionInput | SellStockCorrectionItemUpdateWithWhereUniqueWithoutCorrectionInput[]
    updateMany?: SellStockCorrectionItemUpdateManyWithWhereWithoutCorrectionInput | SellStockCorrectionItemUpdateManyWithWhereWithoutCorrectionInput[]
    deleteMany?: SellStockCorrectionItemScalarWhereInput | SellStockCorrectionItemScalarWhereInput[]
  }

  export type SellStockCorrectionItemUncheckedUpdateManyWithoutCorrectionNestedInput = {
    create?: XOR<SellStockCorrectionItemCreateWithoutCorrectionInput, SellStockCorrectionItemUncheckedCreateWithoutCorrectionInput> | SellStockCorrectionItemCreateWithoutCorrectionInput[] | SellStockCorrectionItemUncheckedCreateWithoutCorrectionInput[]
    connectOrCreate?: SellStockCorrectionItemCreateOrConnectWithoutCorrectionInput | SellStockCorrectionItemCreateOrConnectWithoutCorrectionInput[]
    upsert?: SellStockCorrectionItemUpsertWithWhereUniqueWithoutCorrectionInput | SellStockCorrectionItemUpsertWithWhereUniqueWithoutCorrectionInput[]
    createMany?: SellStockCorrectionItemCreateManyCorrectionInputEnvelope
    set?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    disconnect?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    delete?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    connect?: SellStockCorrectionItemWhereUniqueInput | SellStockCorrectionItemWhereUniqueInput[]
    update?: SellStockCorrectionItemUpdateWithWhereUniqueWithoutCorrectionInput | SellStockCorrectionItemUpdateWithWhereUniqueWithoutCorrectionInput[]
    updateMany?: SellStockCorrectionItemUpdateManyWithWhereWithoutCorrectionInput | SellStockCorrectionItemUpdateManyWithWhereWithoutCorrectionInput[]
    deleteMany?: SellStockCorrectionItemScalarWhereInput | SellStockCorrectionItemScalarWhereInput[]
  }

  export type SellStockCorrectionCreateNestedOneWithoutItemsInput = {
    create?: XOR<SellStockCorrectionCreateWithoutItemsInput, SellStockCorrectionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SellStockCorrectionCreateOrConnectWithoutItemsInput
    connect?: SellStockCorrectionWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutSellStockCorrectionItemInput = {
    create?: XOR<ProductCreateWithoutSellStockCorrectionItemInput, ProductUncheckedCreateWithoutSellStockCorrectionItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSellStockCorrectionItemInput
    connect?: ProductWhereUniqueInput
  }

  export type ShopCreateNestedOneWithoutSellStockCorrectionItemInput = {
    create?: XOR<ShopCreateWithoutSellStockCorrectionItemInput, ShopUncheckedCreateWithoutSellStockCorrectionItemInput>
    connectOrCreate?: ShopCreateOrConnectWithoutSellStockCorrectionItemInput
    connect?: ShopWhereUniqueInput
  }

  export type UnitOfMeasureCreateNestedOneWithoutSellStockCorrectionItemInput = {
    create?: XOR<UnitOfMeasureCreateWithoutSellStockCorrectionItemInput, UnitOfMeasureUncheckedCreateWithoutSellStockCorrectionItemInput>
    connectOrCreate?: UnitOfMeasureCreateOrConnectWithoutSellStockCorrectionItemInput
    connect?: UnitOfMeasureWhereUniqueInput
  }

  export type SellStockCorrectionBatchCreateNestedManyWithoutCorrectionItemInput = {
    create?: XOR<SellStockCorrectionBatchCreateWithoutCorrectionItemInput, SellStockCorrectionBatchUncheckedCreateWithoutCorrectionItemInput> | SellStockCorrectionBatchCreateWithoutCorrectionItemInput[] | SellStockCorrectionBatchUncheckedCreateWithoutCorrectionItemInput[]
    connectOrCreate?: SellStockCorrectionBatchCreateOrConnectWithoutCorrectionItemInput | SellStockCorrectionBatchCreateOrConnectWithoutCorrectionItemInput[]
    createMany?: SellStockCorrectionBatchCreateManyCorrectionItemInputEnvelope
    connect?: SellStockCorrectionBatchWhereUniqueInput | SellStockCorrectionBatchWhereUniqueInput[]
  }

  export type SellStockCorrectionBatchUncheckedCreateNestedManyWithoutCorrectionItemInput = {
    create?: XOR<SellStockCorrectionBatchCreateWithoutCorrectionItemInput, SellStockCorrectionBatchUncheckedCreateWithoutCorrectionItemInput> | SellStockCorrectionBatchCreateWithoutCorrectionItemInput[] | SellStockCorrectionBatchUncheckedCreateWithoutCorrectionItemInput[]
    connectOrCreate?: SellStockCorrectionBatchCreateOrConnectWithoutCorrectionItemInput | SellStockCorrectionBatchCreateOrConnectWithoutCorrectionItemInput[]
    createMany?: SellStockCorrectionBatchCreateManyCorrectionItemInputEnvelope
    connect?: SellStockCorrectionBatchWhereUniqueInput | SellStockCorrectionBatchWhereUniqueInput[]
  }

  export type SellStockCorrectionUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<SellStockCorrectionCreateWithoutItemsInput, SellStockCorrectionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SellStockCorrectionCreateOrConnectWithoutItemsInput
    upsert?: SellStockCorrectionUpsertWithoutItemsInput
    connect?: SellStockCorrectionWhereUniqueInput
    update?: XOR<XOR<SellStockCorrectionUpdateToOneWithWhereWithoutItemsInput, SellStockCorrectionUpdateWithoutItemsInput>, SellStockCorrectionUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutSellStockCorrectionItemNestedInput = {
    create?: XOR<ProductCreateWithoutSellStockCorrectionItemInput, ProductUncheckedCreateWithoutSellStockCorrectionItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSellStockCorrectionItemInput
    upsert?: ProductUpsertWithoutSellStockCorrectionItemInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSellStockCorrectionItemInput, ProductUpdateWithoutSellStockCorrectionItemInput>, ProductUncheckedUpdateWithoutSellStockCorrectionItemInput>
  }

  export type ShopUpdateOneWithoutSellStockCorrectionItemNestedInput = {
    create?: XOR<ShopCreateWithoutSellStockCorrectionItemInput, ShopUncheckedCreateWithoutSellStockCorrectionItemInput>
    connectOrCreate?: ShopCreateOrConnectWithoutSellStockCorrectionItemInput
    upsert?: ShopUpsertWithoutSellStockCorrectionItemInput
    disconnect?: ShopWhereInput | boolean
    delete?: ShopWhereInput | boolean
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutSellStockCorrectionItemInput, ShopUpdateWithoutSellStockCorrectionItemInput>, ShopUncheckedUpdateWithoutSellStockCorrectionItemInput>
  }

  export type UnitOfMeasureUpdateOneRequiredWithoutSellStockCorrectionItemNestedInput = {
    create?: XOR<UnitOfMeasureCreateWithoutSellStockCorrectionItemInput, UnitOfMeasureUncheckedCreateWithoutSellStockCorrectionItemInput>
    connectOrCreate?: UnitOfMeasureCreateOrConnectWithoutSellStockCorrectionItemInput
    upsert?: UnitOfMeasureUpsertWithoutSellStockCorrectionItemInput
    connect?: UnitOfMeasureWhereUniqueInput
    update?: XOR<XOR<UnitOfMeasureUpdateToOneWithWhereWithoutSellStockCorrectionItemInput, UnitOfMeasureUpdateWithoutSellStockCorrectionItemInput>, UnitOfMeasureUncheckedUpdateWithoutSellStockCorrectionItemInput>
  }

  export type SellStockCorrectionBatchUpdateManyWithoutCorrectionItemNestedInput = {
    create?: XOR<SellStockCorrectionBatchCreateWithoutCorrectionItemInput, SellStockCorrectionBatchUncheckedCreateWithoutCorrectionItemInput> | SellStockCorrectionBatchCreateWithoutCorrectionItemInput[] | SellStockCorrectionBatchUncheckedCreateWithoutCorrectionItemInput[]
    connectOrCreate?: SellStockCorrectionBatchCreateOrConnectWithoutCorrectionItemInput | SellStockCorrectionBatchCreateOrConnectWithoutCorrectionItemInput[]
    upsert?: SellStockCorrectionBatchUpsertWithWhereUniqueWithoutCorrectionItemInput | SellStockCorrectionBatchUpsertWithWhereUniqueWithoutCorrectionItemInput[]
    createMany?: SellStockCorrectionBatchCreateManyCorrectionItemInputEnvelope
    set?: SellStockCorrectionBatchWhereUniqueInput | SellStockCorrectionBatchWhereUniqueInput[]
    disconnect?: SellStockCorrectionBatchWhereUniqueInput | SellStockCorrectionBatchWhereUniqueInput[]
    delete?: SellStockCorrectionBatchWhereUniqueInput | SellStockCorrectionBatchWhereUniqueInput[]
    connect?: SellStockCorrectionBatchWhereUniqueInput | SellStockCorrectionBatchWhereUniqueInput[]
    update?: SellStockCorrectionBatchUpdateWithWhereUniqueWithoutCorrectionItemInput | SellStockCorrectionBatchUpdateWithWhereUniqueWithoutCorrectionItemInput[]
    updateMany?: SellStockCorrectionBatchUpdateManyWithWhereWithoutCorrectionItemInput | SellStockCorrectionBatchUpdateManyWithWhereWithoutCorrectionItemInput[]
    deleteMany?: SellStockCorrectionBatchScalarWhereInput | SellStockCorrectionBatchScalarWhereInput[]
  }

  export type SellStockCorrectionBatchUncheckedUpdateManyWithoutCorrectionItemNestedInput = {
    create?: XOR<SellStockCorrectionBatchCreateWithoutCorrectionItemInput, SellStockCorrectionBatchUncheckedCreateWithoutCorrectionItemInput> | SellStockCorrectionBatchCreateWithoutCorrectionItemInput[] | SellStockCorrectionBatchUncheckedCreateWithoutCorrectionItemInput[]
    connectOrCreate?: SellStockCorrectionBatchCreateOrConnectWithoutCorrectionItemInput | SellStockCorrectionBatchCreateOrConnectWithoutCorrectionItemInput[]
    upsert?: SellStockCorrectionBatchUpsertWithWhereUniqueWithoutCorrectionItemInput | SellStockCorrectionBatchUpsertWithWhereUniqueWithoutCorrectionItemInput[]
    createMany?: SellStockCorrectionBatchCreateManyCorrectionItemInputEnvelope
    set?: SellStockCorrectionBatchWhereUniqueInput | SellStockCorrectionBatchWhereUniqueInput[]
    disconnect?: SellStockCorrectionBatchWhereUniqueInput | SellStockCorrectionBatchWhereUniqueInput[]
    delete?: SellStockCorrectionBatchWhereUniqueInput | SellStockCorrectionBatchWhereUniqueInput[]
    connect?: SellStockCorrectionBatchWhereUniqueInput | SellStockCorrectionBatchWhereUniqueInput[]
    update?: SellStockCorrectionBatchUpdateWithWhereUniqueWithoutCorrectionItemInput | SellStockCorrectionBatchUpdateWithWhereUniqueWithoutCorrectionItemInput[]
    updateMany?: SellStockCorrectionBatchUpdateManyWithWhereWithoutCorrectionItemInput | SellStockCorrectionBatchUpdateManyWithWhereWithoutCorrectionItemInput[]
    deleteMany?: SellStockCorrectionBatchScalarWhereInput | SellStockCorrectionBatchScalarWhereInput[]
  }

  export type SellStockCorrectionItemCreateNestedOneWithoutBatchesInput = {
    create?: XOR<SellStockCorrectionItemCreateWithoutBatchesInput, SellStockCorrectionItemUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: SellStockCorrectionItemCreateOrConnectWithoutBatchesInput
    connect?: SellStockCorrectionItemWhereUniqueInput
  }

  export type ProductBatchCreateNestedOneWithoutSellStockCorrectionBatchInput = {
    create?: XOR<ProductBatchCreateWithoutSellStockCorrectionBatchInput, ProductBatchUncheckedCreateWithoutSellStockCorrectionBatchInput>
    connectOrCreate?: ProductBatchCreateOrConnectWithoutSellStockCorrectionBatchInput
    connect?: ProductBatchWhereUniqueInput
  }

  export type SellStockCorrectionItemUpdateOneRequiredWithoutBatchesNestedInput = {
    create?: XOR<SellStockCorrectionItemCreateWithoutBatchesInput, SellStockCorrectionItemUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: SellStockCorrectionItemCreateOrConnectWithoutBatchesInput
    upsert?: SellStockCorrectionItemUpsertWithoutBatchesInput
    connect?: SellStockCorrectionItemWhereUniqueInput
    update?: XOR<XOR<SellStockCorrectionItemUpdateToOneWithWhereWithoutBatchesInput, SellStockCorrectionItemUpdateWithoutBatchesInput>, SellStockCorrectionItemUncheckedUpdateWithoutBatchesInput>
  }

  export type ProductBatchUpdateOneRequiredWithoutSellStockCorrectionBatchNestedInput = {
    create?: XOR<ProductBatchCreateWithoutSellStockCorrectionBatchInput, ProductBatchUncheckedCreateWithoutSellStockCorrectionBatchInput>
    connectOrCreate?: ProductBatchCreateOrConnectWithoutSellStockCorrectionBatchInput
    upsert?: ProductBatchUpsertWithoutSellStockCorrectionBatchInput
    connect?: ProductBatchWhereUniqueInput
    update?: XOR<XOR<ProductBatchUpdateToOneWithWhereWithoutSellStockCorrectionBatchInput, ProductBatchUpdateWithoutSellStockCorrectionBatchInput>, ProductBatchUncheckedUpdateWithoutSellStockCorrectionBatchInput>
  }

  export type StoreCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<StoreCreateWithoutNotificationsInput, StoreUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutNotificationsInput
    connect?: StoreWhereUniqueInput
  }

  export type ShopCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<ShopCreateWithoutNotificationsInput, ShopUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutNotificationsInput
    connect?: ShopWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type NullableEnumRelatedEntityTypeFieldUpdateOperationsInput = {
    set?: $Enums.RelatedEntityType | null
  }

  export type StoreUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<StoreCreateWithoutNotificationsInput, StoreUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutNotificationsInput
    upsert?: StoreUpsertWithoutNotificationsInput
    disconnect?: StoreWhereInput | boolean
    delete?: StoreWhereInput | boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutNotificationsInput, StoreUpdateWithoutNotificationsInput>, StoreUncheckedUpdateWithoutNotificationsInput>
  }

  export type ShopUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<ShopCreateWithoutNotificationsInput, ShopUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutNotificationsInput
    upsert?: ShopUpsertWithoutNotificationsInput
    disconnect?: ShopWhereInput | boolean
    delete?: ShopWhereInput | boolean
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutNotificationsInput, ShopUpdateWithoutNotificationsInput>, ShopUncheckedUpdateWithoutNotificationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumStockStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StockStatus | EnumStockStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StockStatus[]
    notIn?: $Enums.StockStatus[]
    not?: NestedEnumStockStatusFilter<$PrismaModel> | $Enums.StockStatus
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumStockStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StockStatus | EnumStockStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StockStatus[]
    notIn?: $Enums.StockStatus[]
    not?: NestedEnumStockStatusWithAggregatesFilter<$PrismaModel> | $Enums.StockStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStockStatusFilter<$PrismaModel>
    _max?: NestedEnumStockStatusFilter<$PrismaModel>
  }

  export type NestedEnumStockMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StockMovementType | EnumStockMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StockMovementType[]
    notIn?: $Enums.StockMovementType[]
    not?: NestedEnumStockMovementTypeFilter<$PrismaModel> | $Enums.StockMovementType
  }

  export type NestedEnumStockMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StockMovementType | EnumStockMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StockMovementType[]
    notIn?: $Enums.StockMovementType[]
    not?: NestedEnumStockMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.StockMovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStockMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumStockMovementTypeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumTransferEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferEntityType | EnumTransferEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransferEntityType[]
    notIn?: $Enums.TransferEntityType[]
    not?: NestedEnumTransferEntityTypeFilter<$PrismaModel> | $Enums.TransferEntityType
  }

  export type NestedEnumTransferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[]
    notIn?: $Enums.TransferStatus[]
    not?: NestedEnumTransferStatusFilter<$PrismaModel> | $Enums.TransferStatus
  }

  export type NestedEnumTransferEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferEntityType | EnumTransferEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransferEntityType[]
    notIn?: $Enums.TransferEntityType[]
    not?: NestedEnumTransferEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransferEntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumTransferEntityTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[]
    notIn?: $Enums.TransferStatus[]
    not?: NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferStatusFilter<$PrismaModel>
    _max?: NestedEnumTransferStatusFilter<$PrismaModel>
  }

  export type NestedEnumStockCorrectionReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.StockCorrectionReason | EnumStockCorrectionReasonFieldRefInput<$PrismaModel>
    in?: $Enums.StockCorrectionReason[]
    notIn?: $Enums.StockCorrectionReason[]
    not?: NestedEnumStockCorrectionReasonFilter<$PrismaModel> | $Enums.StockCorrectionReason
  }

  export type NestedEnumStockCorrectionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StockCorrectionStatus | EnumStockCorrectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StockCorrectionStatus[]
    notIn?: $Enums.StockCorrectionStatus[]
    not?: NestedEnumStockCorrectionStatusFilter<$PrismaModel> | $Enums.StockCorrectionStatus
  }

  export type NestedEnumStockCorrectionReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StockCorrectionReason | EnumStockCorrectionReasonFieldRefInput<$PrismaModel>
    in?: $Enums.StockCorrectionReason[]
    notIn?: $Enums.StockCorrectionReason[]
    not?: NestedEnumStockCorrectionReasonWithAggregatesFilter<$PrismaModel> | $Enums.StockCorrectionReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStockCorrectionReasonFilter<$PrismaModel>
    _max?: NestedEnumStockCorrectionReasonFilter<$PrismaModel>
  }

  export type NestedEnumStockCorrectionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StockCorrectionStatus | EnumStockCorrectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StockCorrectionStatus[]
    notIn?: $Enums.StockCorrectionStatus[]
    not?: NestedEnumStockCorrectionStatusWithAggregatesFilter<$PrismaModel> | $Enums.StockCorrectionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStockCorrectionStatusFilter<$PrismaModel>
    _max?: NestedEnumStockCorrectionStatusFilter<$PrismaModel>
  }

  export type NestedEnumSaleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SaleStatus | EnumSaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SaleStatus[]
    notIn?: $Enums.SaleStatus[]
    not?: NestedEnumSaleStatusFilter<$PrismaModel> | $Enums.SaleStatus
  }

  export type NestedEnumSaleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SaleStatus | EnumSaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SaleStatus[]
    notIn?: $Enums.SaleStatus[]
    not?: NestedEnumSaleStatusWithAggregatesFilter<$PrismaModel> | $Enums.SaleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSaleStatusFilter<$PrismaModel>
    _max?: NestedEnumSaleStatusFilter<$PrismaModel>
  }

  export type NestedEnumItemSaleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemSaleStatus | EnumItemSaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ItemSaleStatus[]
    notIn?: $Enums.ItemSaleStatus[]
    not?: NestedEnumItemSaleStatusFilter<$PrismaModel> | $Enums.ItemSaleStatus
  }

  export type NestedEnumItemSaleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemSaleStatus | EnumItemSaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ItemSaleStatus[]
    notIn?: $Enums.ItemSaleStatus[]
    not?: NestedEnumItemSaleStatusWithAggregatesFilter<$PrismaModel> | $Enums.ItemSaleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemSaleStatusFilter<$PrismaModel>
    _max?: NestedEnumItemSaleStatusFilter<$PrismaModel>
  }

  export type NestedEnumSellStockCorrectionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SellStockCorrectionStatus | EnumSellStockCorrectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SellStockCorrectionStatus[]
    notIn?: $Enums.SellStockCorrectionStatus[]
    not?: NestedEnumSellStockCorrectionStatusFilter<$PrismaModel> | $Enums.SellStockCorrectionStatus
  }

  export type NestedEnumSellStockCorrectionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SellStockCorrectionStatus | EnumSellStockCorrectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SellStockCorrectionStatus[]
    notIn?: $Enums.SellStockCorrectionStatus[]
    not?: NestedEnumSellStockCorrectionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SellStockCorrectionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSellStockCorrectionStatusFilter<$PrismaModel>
    _max?: NestedEnumSellStockCorrectionStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumRelatedEntityTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RelatedEntityType | EnumRelatedEntityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RelatedEntityType[] | null
    notIn?: $Enums.RelatedEntityType[] | null
    not?: NestedEnumRelatedEntityTypeNullableFilter<$PrismaModel> | $Enums.RelatedEntityType | null
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumRelatedEntityTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RelatedEntityType | EnumRelatedEntityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RelatedEntityType[] | null
    notIn?: $Enums.RelatedEntityType[] | null
    not?: NestedEnumRelatedEntityTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.RelatedEntityType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRelatedEntityTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumRelatedEntityTypeNullableFilter<$PrismaModel>
  }

  export type BranchCreateWithoutUserInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Shop?: ShopCreateNestedManyWithoutBranchInput
    Store?: StoreCreateNestedManyWithoutBranchInput
    Sell?: SellCreateNestedManyWithoutBranchInput
    AddToCart?: AddToCartCreateNestedManyWithoutBranchInput
    waitlists?: WaitlistCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Shop?: ShopUncheckedCreateNestedManyWithoutBranchInput
    Store?: StoreUncheckedCreateNestedManyWithoutBranchInput
    Sell?: SellUncheckedCreateNestedManyWithoutBranchInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutBranchInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutUserInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutUserInput, BranchUncheckedCreateWithoutUserInput>
  }

  export type RoleCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type ShopCreateWithoutUserInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutShopInput
    ShopStock?: ShopStockCreateNestedManyWithoutShopInput
    StockLedger?: StockLedgerCreateNestedManyWithoutShopInput
    SourceTransfer?: TransferCreateNestedManyWithoutSourceShopInput
    DestinatTransfer?: TransferCreateNestedManyWithoutDestShopInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutShopInput
    AdditionalPrice?: AdditionalPriceCreateNestedManyWithoutShopInput
    SellItem?: SellItemCreateNestedManyWithoutShopInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutShopInput
    CartItem?: CartItemCreateNestedManyWithoutShopInput
    waitlists?: WaitlistCreateNestedManyWithoutShopInput
    notifications?: NotificationCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutShopInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutShopInput
    SourceTransfer?: TransferUncheckedCreateNestedManyWithoutSourceShopInput
    DestinatTransfer?: TransferUncheckedCreateNestedManyWithoutDestShopInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutShopInput
    AdditionalPrice?: AdditionalPriceUncheckedCreateNestedManyWithoutShopInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutShopInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutShopInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutShopInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutShopInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutUserInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutUserInput, ShopUncheckedCreateWithoutUserInput>
  }

  export type StoreCreateWithoutUserInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutStoreInput
    ProductBatch?: ProductBatchCreateNestedManyWithoutStoreInput
    StoreStock?: StoreStockCreateNestedManyWithoutStoreInput
    StockLedger?: StockLedgerCreateNestedManyWithoutStoreInput
    Purchase?: PurchaseCreateNestedManyWithoutStoreInput
    SourceTransfer?: TransferCreateNestedManyWithoutSourceStoreInput
    DestinatTransfer?: TransferCreateNestedManyWithoutDestStoreInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutStoreInput
    notifications?: NotificationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ProductBatch?: ProductBatchUncheckedCreateNestedManyWithoutStoreInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutStoreInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutStoreInput
    Purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    SourceTransfer?: TransferUncheckedCreateNestedManyWithoutSourceStoreInput
    DestinatTransfer?: TransferUncheckedCreateNestedManyWithoutDestStoreInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutStoreInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutUserInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutUserInput, StoreUncheckedCreateWithoutUserInput>
  }

  export type LogCreateWithoutUserInput = {
    id?: string
    action: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LogCreateOrConnectWithoutUserInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput>
  }

  export type LogCreateManyUserInputEnvelope = {
    data: LogCreateManyUserInput | LogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StockLedgerCreateWithoutUserInput = {
    id?: string
    invoiceNo?: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    reference?: string | null
    notes?: string | null
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    batch: ProductBatchCreateNestedOneWithoutStockLedgerInput
    store?: StoreCreateNestedOneWithoutStockLedgerInput
    shop?: ShopCreateNestedOneWithoutStockLedgerInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutStockLedgerInput
  }

  export type StockLedgerUncheckedCreateWithoutUserInput = {
    id?: string
    invoiceNo?: string | null
    batchId: string
    storeId?: string | null
    shopId?: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    unitOfMeasureId: string
    reference?: string | null
    notes?: string | null
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockLedgerCreateOrConnectWithoutUserInput = {
    where: StockLedgerWhereUniqueInput
    create: XOR<StockLedgerCreateWithoutUserInput, StockLedgerUncheckedCreateWithoutUserInput>
  }

  export type StockLedgerCreateManyUserInputEnvelope = {
    data: StockLedgerCreateManyUserInput | StockLedgerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseCreateWithoutCreatedByInput = {
    id?: string
    invoiceNo: string
    paymentStatus?: $Enums.PaymentStatus
    totalProducts?: number
    subTotal?: number
    grandTotal?: number
    notes?: string | null
    purchaseDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutPurchaseInput
    store: StoreCreateNestedOneWithoutPurchaseInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedPurchaseInput
    items?: PurchaseItemCreateNestedManyWithoutPurchaseInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutCreatedByInput = {
    id?: string
    invoiceNo: string
    supplierId: string
    storeId: string
    paymentStatus?: $Enums.PaymentStatus
    totalProducts?: number
    subTotal?: number
    grandTotal?: number
    notes?: string | null
    purchaseDate?: Date | string
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseItemUncheckedCreateNestedManyWithoutPurchaseInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutCreatedByInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutCreatedByInput, PurchaseUncheckedCreateWithoutCreatedByInput>
  }

  export type PurchaseCreateManyCreatedByInputEnvelope = {
    data: PurchaseCreateManyCreatedByInput | PurchaseCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseCreateWithoutUpdatedByInput = {
    id?: string
    invoiceNo: string
    paymentStatus?: $Enums.PaymentStatus
    totalProducts?: number
    subTotal?: number
    grandTotal?: number
    notes?: string | null
    purchaseDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutPurchaseInput
    store: StoreCreateNestedOneWithoutPurchaseInput
    createdBy?: UserCreateNestedOneWithoutCreatorPurchaseInput
    items?: PurchaseItemCreateNestedManyWithoutPurchaseInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    invoiceNo: string
    supplierId: string
    storeId: string
    paymentStatus?: $Enums.PaymentStatus
    totalProducts?: number
    subTotal?: number
    grandTotal?: number
    notes?: string | null
    purchaseDate?: Date | string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseItemUncheckedCreateNestedManyWithoutPurchaseInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutUpdatedByInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutUpdatedByInput, PurchaseUncheckedCreateWithoutUpdatedByInput>
  }

  export type PurchaseCreateManyUpdatedByInputEnvelope = {
    data: PurchaseCreateManyUpdatedByInput | PurchaseCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutCreatedByInput = {
    id?: string
    shortCode: string
    sourceType: $Enums.TransferEntityType
    destinationType: $Enums.TransferEntityType
    reference?: string | null
    notes?: string | null
    status?: $Enums.TransferStatus
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceStore?: StoreCreateNestedOneWithoutSourceTransferInput
    sourceShop?: ShopCreateNestedOneWithoutSourceTransferInput
    destStore?: StoreCreateNestedOneWithoutDestinatTransferInput
    destShop?: ShopCreateNestedOneWithoutDestinatTransferInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedTransferInput
    items?: TransferItemCreateNestedManyWithoutTransferInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutCreatedByInput = {
    id?: string
    shortCode: string
    sourceType: $Enums.TransferEntityType
    sourceStoreId?: string | null
    sourceShopId?: string | null
    destinationType: $Enums.TransferEntityType
    destStoreId?: string | null
    destShopId?: string | null
    reference?: string | null
    notes?: string | null
    status?: $Enums.TransferStatus
    movementDate?: Date | string
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferItemUncheckedCreateNestedManyWithoutTransferInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutCreatedByInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutCreatedByInput, TransferUncheckedCreateWithoutCreatedByInput>
  }

  export type TransferCreateManyCreatedByInputEnvelope = {
    data: TransferCreateManyCreatedByInput | TransferCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutUpdatedByInput = {
    id?: string
    shortCode: string
    sourceType: $Enums.TransferEntityType
    destinationType: $Enums.TransferEntityType
    reference?: string | null
    notes?: string | null
    status?: $Enums.TransferStatus
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceStore?: StoreCreateNestedOneWithoutSourceTransferInput
    sourceShop?: ShopCreateNestedOneWithoutSourceTransferInput
    destStore?: StoreCreateNestedOneWithoutDestinatTransferInput
    destShop?: ShopCreateNestedOneWithoutDestinatTransferInput
    createdBy?: UserCreateNestedOneWithoutCreatedTransferInput
    items?: TransferItemCreateNestedManyWithoutTransferInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    shortCode: string
    sourceType: $Enums.TransferEntityType
    sourceStoreId?: string | null
    sourceShopId?: string | null
    destinationType: $Enums.TransferEntityType
    destStoreId?: string | null
    destShopId?: string | null
    reference?: string | null
    notes?: string | null
    status?: $Enums.TransferStatus
    movementDate?: Date | string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferItemUncheckedCreateNestedManyWithoutTransferInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutUpdatedByInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutUpdatedByInput, TransferUncheckedCreateWithoutUpdatedByInput>
  }

  export type TransferCreateManyUpdatedByInputEnvelope = {
    data: TransferCreateManyUpdatedByInput | TransferCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type StockCorrectionCreateWithoutCreatedByInput = {
    id?: string
    shortCode: string
    reason: $Enums.StockCorrectionReason
    status?: $Enums.StockCorrectionStatus
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store?: StoreCreateNestedOneWithoutStockCorrectionInput
    shop?: ShopCreateNestedOneWithoutStockCorrectionInput
    purchase?: PurchaseCreateNestedOneWithoutStockCorrectionInput
    transfer?: TransferCreateNestedOneWithoutStockCorrectionInput
    updatedBy?: UserCreateNestedOneWithoutUpdateStockCorrectionInput
    items?: StockCorrectionItemCreateNestedManyWithoutCorrectionInput
  }

  export type StockCorrectionUncheckedCreateWithoutCreatedByInput = {
    id?: string
    shortCode: string
    storeId?: string | null
    shopId?: string | null
    reason: $Enums.StockCorrectionReason
    status?: $Enums.StockCorrectionStatus
    purchaseId?: string | null
    transferId?: string | null
    reference?: string | null
    notes?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: StockCorrectionItemUncheckedCreateNestedManyWithoutCorrectionInput
  }

  export type StockCorrectionCreateOrConnectWithoutCreatedByInput = {
    where: StockCorrectionWhereUniqueInput
    create: XOR<StockCorrectionCreateWithoutCreatedByInput, StockCorrectionUncheckedCreateWithoutCreatedByInput>
  }

  export type StockCorrectionCreateManyCreatedByInputEnvelope = {
    data: StockCorrectionCreateManyCreatedByInput | StockCorrectionCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type StockCorrectionCreateWithoutUpdatedByInput = {
    id?: string
    shortCode: string
    reason: $Enums.StockCorrectionReason
    status?: $Enums.StockCorrectionStatus
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store?: StoreCreateNestedOneWithoutStockCorrectionInput
    shop?: ShopCreateNestedOneWithoutStockCorrectionInput
    purchase?: PurchaseCreateNestedOneWithoutStockCorrectionInput
    transfer?: TransferCreateNestedOneWithoutStockCorrectionInput
    createdBy?: UserCreateNestedOneWithoutStockCorrectionInput
    items?: StockCorrectionItemCreateNestedManyWithoutCorrectionInput
  }

  export type StockCorrectionUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    shortCode: string
    storeId?: string | null
    shopId?: string | null
    reason: $Enums.StockCorrectionReason
    status?: $Enums.StockCorrectionStatus
    purchaseId?: string | null
    transferId?: string | null
    reference?: string | null
    notes?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: StockCorrectionItemUncheckedCreateNestedManyWithoutCorrectionInput
  }

  export type StockCorrectionCreateOrConnectWithoutUpdatedByInput = {
    where: StockCorrectionWhereUniqueInput
    create: XOR<StockCorrectionCreateWithoutUpdatedByInput, StockCorrectionUncheckedCreateWithoutUpdatedByInput>
  }

  export type StockCorrectionCreateManyUpdatedByInputEnvelope = {
    data: StockCorrectionCreateManyUpdatedByInput | StockCorrectionCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type SellCreateWithoutCreatedByInput = {
    id?: string
    invoiceNo: string
    saleStatus?: $Enums.SaleStatus
    locked?: boolean
    lockedAt?: Date | string | null
    totalProducts?: number
    subTotal?: number
    discount?: number
    vat?: number
    grandTotal?: number
    NetTotal?: number
    notes?: string | null
    saleDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutSellInput
    customer?: CustomerCreateNestedOneWithoutSellInput
    updatedBy?: UserCreateNestedOneWithoutUpdateSellInput
    items?: SellItemCreateNestedManyWithoutSellInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutSellInput
  }

  export type SellUncheckedCreateWithoutCreatedByInput = {
    id?: string
    invoiceNo: string
    saleStatus?: $Enums.SaleStatus
    locked?: boolean
    lockedAt?: Date | string | null
    branchId?: string | null
    customerId?: string | null
    totalProducts?: number
    subTotal?: number
    discount?: number
    vat?: number
    grandTotal?: number
    NetTotal?: number
    notes?: string | null
    saleDate?: Date | string
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SellItemUncheckedCreateNestedManyWithoutSellInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutSellInput
  }

  export type SellCreateOrConnectWithoutCreatedByInput = {
    where: SellWhereUniqueInput
    create: XOR<SellCreateWithoutCreatedByInput, SellUncheckedCreateWithoutCreatedByInput>
  }

  export type SellCreateManyCreatedByInputEnvelope = {
    data: SellCreateManyCreatedByInput | SellCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type SellCreateWithoutUpdatedByInput = {
    id?: string
    invoiceNo: string
    saleStatus?: $Enums.SaleStatus
    locked?: boolean
    lockedAt?: Date | string | null
    totalProducts?: number
    subTotal?: number
    discount?: number
    vat?: number
    grandTotal?: number
    NetTotal?: number
    notes?: string | null
    saleDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutSellInput
    customer?: CustomerCreateNestedOneWithoutSellInput
    createdBy?: UserCreateNestedOneWithoutSellInput
    items?: SellItemCreateNestedManyWithoutSellInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutSellInput
  }

  export type SellUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    invoiceNo: string
    saleStatus?: $Enums.SaleStatus
    locked?: boolean
    lockedAt?: Date | string | null
    branchId?: string | null
    customerId?: string | null
    totalProducts?: number
    subTotal?: number
    discount?: number
    vat?: number
    grandTotal?: number
    NetTotal?: number
    notes?: string | null
    saleDate?: Date | string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SellItemUncheckedCreateNestedManyWithoutSellInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutSellInput
  }

  export type SellCreateOrConnectWithoutUpdatedByInput = {
    where: SellWhereUniqueInput
    create: XOR<SellCreateWithoutUpdatedByInput, SellUncheckedCreateWithoutUpdatedByInput>
  }

  export type SellCreateManyUpdatedByInputEnvelope = {
    data: SellCreateManyUpdatedByInput | SellCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type SellStockCorrectionCreateWithoutCreatedByInput = {
    id?: string
    status?: $Enums.SellStockCorrectionStatus
    reference?: string | null
    notes?: string | null
    total?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sell?: SellCreateNestedOneWithoutSellStockCorrectionInput
    updatedBy?: UserCreateNestedOneWithoutUpdateSellStockCorrectionInput
    items?: SellStockCorrectionItemCreateNestedManyWithoutCorrectionInput
  }

  export type SellStockCorrectionUncheckedCreateWithoutCreatedByInput = {
    id?: string
    sellId?: string | null
    status?: $Enums.SellStockCorrectionStatus
    reference?: string | null
    notes?: string | null
    updatedById?: string | null
    total?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutCorrectionInput
  }

  export type SellStockCorrectionCreateOrConnectWithoutCreatedByInput = {
    where: SellStockCorrectionWhereUniqueInput
    create: XOR<SellStockCorrectionCreateWithoutCreatedByInput, SellStockCorrectionUncheckedCreateWithoutCreatedByInput>
  }

  export type SellStockCorrectionCreateManyCreatedByInputEnvelope = {
    data: SellStockCorrectionCreateManyCreatedByInput | SellStockCorrectionCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type SellStockCorrectionCreateWithoutUpdatedByInput = {
    id?: string
    status?: $Enums.SellStockCorrectionStatus
    reference?: string | null
    notes?: string | null
    total?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sell?: SellCreateNestedOneWithoutSellStockCorrectionInput
    createdBy?: UserCreateNestedOneWithoutSellStockCorrectionInput
    items?: SellStockCorrectionItemCreateNestedManyWithoutCorrectionInput
  }

  export type SellStockCorrectionUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    sellId?: string | null
    status?: $Enums.SellStockCorrectionStatus
    reference?: string | null
    notes?: string | null
    createdById?: string | null
    total?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutCorrectionInput
  }

  export type SellStockCorrectionCreateOrConnectWithoutUpdatedByInput = {
    where: SellStockCorrectionWhereUniqueInput
    create: XOR<SellStockCorrectionCreateWithoutUpdatedByInput, SellStockCorrectionUncheckedCreateWithoutUpdatedByInput>
  }

  export type SellStockCorrectionCreateManyUpdatedByInputEnvelope = {
    data: SellStockCorrectionCreateManyUpdatedByInput | SellStockCorrectionCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type AddToCartCreateWithoutUserInput = {
    id?: string
    isCheckedOut?: boolean
    isWaitlist?: boolean
    totalItems?: number
    totalAmount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutAddToCartInput
    customer?: CustomerCreateNestedOneWithoutAddToCartInput
    createdBy?: UserCreateNestedOneWithoutCreatedAddToCartInput
    updatedBy?: UserCreateNestedOneWithoutAddToCartInput
    items?: CartItemCreateNestedManyWithoutCartInput
    waitlists?: WaitlistCreateNestedManyWithoutCartInput
  }

  export type AddToCartUncheckedCreateWithoutUserInput = {
    id?: string
    branchId?: string | null
    isCheckedOut?: boolean
    isWaitlist?: boolean
    customerId?: string | null
    totalItems?: number
    totalAmount?: number
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemUncheckedCreateNestedManyWithoutCartInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutCartInput
  }

  export type AddToCartCreateOrConnectWithoutUserInput = {
    where: AddToCartWhereUniqueInput
    create: XOR<AddToCartCreateWithoutUserInput, AddToCartUncheckedCreateWithoutUserInput>
  }

  export type AddToCartCreateManyUserInputEnvelope = {
    data: AddToCartCreateManyUserInput | AddToCartCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AddToCartCreateWithoutCreatedByInput = {
    id?: string
    isCheckedOut?: boolean
    isWaitlist?: boolean
    totalItems?: number
    totalAmount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAllAddToCartInput
    branch?: BranchCreateNestedOneWithoutAddToCartInput
    customer?: CustomerCreateNestedOneWithoutAddToCartInput
    updatedBy?: UserCreateNestedOneWithoutAddToCartInput
    items?: CartItemCreateNestedManyWithoutCartInput
    waitlists?: WaitlistCreateNestedManyWithoutCartInput
  }

  export type AddToCartUncheckedCreateWithoutCreatedByInput = {
    id?: string
    userId: string
    branchId?: string | null
    isCheckedOut?: boolean
    isWaitlist?: boolean
    customerId?: string | null
    totalItems?: number
    totalAmount?: number
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemUncheckedCreateNestedManyWithoutCartInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutCartInput
  }

  export type AddToCartCreateOrConnectWithoutCreatedByInput = {
    where: AddToCartWhereUniqueInput
    create: XOR<AddToCartCreateWithoutCreatedByInput, AddToCartUncheckedCreateWithoutCreatedByInput>
  }

  export type AddToCartCreateManyCreatedByInputEnvelope = {
    data: AddToCartCreateManyCreatedByInput | AddToCartCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AddToCartCreateWithoutUpdatedByInput = {
    id?: string
    isCheckedOut?: boolean
    isWaitlist?: boolean
    totalItems?: number
    totalAmount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAllAddToCartInput
    branch?: BranchCreateNestedOneWithoutAddToCartInput
    customer?: CustomerCreateNestedOneWithoutAddToCartInput
    createdBy?: UserCreateNestedOneWithoutCreatedAddToCartInput
    items?: CartItemCreateNestedManyWithoutCartInput
    waitlists?: WaitlistCreateNestedManyWithoutCartInput
  }

  export type AddToCartUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    userId: string
    branchId?: string | null
    isCheckedOut?: boolean
    isWaitlist?: boolean
    customerId?: string | null
    totalItems?: number
    totalAmount?: number
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemUncheckedCreateNestedManyWithoutCartInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutCartInput
  }

  export type AddToCartCreateOrConnectWithoutUpdatedByInput = {
    where: AddToCartWhereUniqueInput
    create: XOR<AddToCartCreateWithoutUpdatedByInput, AddToCartUncheckedCreateWithoutUpdatedByInput>
  }

  export type AddToCartCreateManyUpdatedByInputEnvelope = {
    data: AddToCartCreateManyUpdatedByInput | AddToCartCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type WaitlistCreateWithoutUserInput = {
    id?: string
    quantity?: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutWaitlistsInput
    branch?: BranchCreateNestedOneWithoutWaitlistsInput
    cart?: AddToCartCreateNestedOneWithoutWaitlistsInput
    cartItem?: CartItemCreateNestedOneWithoutWaitlistsInput
    product?: ProductCreateNestedOneWithoutWaitlistsInput
    shop?: ShopCreateNestedOneWithoutWaitlistsInput
    createdBy?: UserCreateNestedOneWithoutWaitlistsCreatedInput
    updatedBy?: UserCreateNestedOneWithoutWaitlistsUpdatedInput
  }

  export type WaitlistUncheckedCreateWithoutUserInput = {
    id?: string
    customerId?: string | null
    branchId?: string | null
    cartId?: string | null
    cartItemId?: string | null
    productId?: string | null
    quantity?: number
    note?: string | null
    shopId?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaitlistCreateOrConnectWithoutUserInput = {
    where: WaitlistWhereUniqueInput
    create: XOR<WaitlistCreateWithoutUserInput, WaitlistUncheckedCreateWithoutUserInput>
  }

  export type WaitlistCreateManyUserInputEnvelope = {
    data: WaitlistCreateManyUserInput | WaitlistCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WaitlistCreateWithoutCreatedByInput = {
    id?: string
    quantity?: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutWaitlistsInput
    customer?: CustomerCreateNestedOneWithoutWaitlistsInput
    branch?: BranchCreateNestedOneWithoutWaitlistsInput
    cart?: AddToCartCreateNestedOneWithoutWaitlistsInput
    cartItem?: CartItemCreateNestedOneWithoutWaitlistsInput
    product?: ProductCreateNestedOneWithoutWaitlistsInput
    shop?: ShopCreateNestedOneWithoutWaitlistsInput
    updatedBy?: UserCreateNestedOneWithoutWaitlistsUpdatedInput
  }

  export type WaitlistUncheckedCreateWithoutCreatedByInput = {
    id?: string
    userId?: string | null
    customerId?: string | null
    branchId?: string | null
    cartId?: string | null
    cartItemId?: string | null
    productId?: string | null
    quantity?: number
    note?: string | null
    shopId?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaitlistCreateOrConnectWithoutCreatedByInput = {
    where: WaitlistWhereUniqueInput
    create: XOR<WaitlistCreateWithoutCreatedByInput, WaitlistUncheckedCreateWithoutCreatedByInput>
  }

  export type WaitlistCreateManyCreatedByInputEnvelope = {
    data: WaitlistCreateManyCreatedByInput | WaitlistCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type WaitlistCreateWithoutUpdatedByInput = {
    id?: string
    quantity?: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutWaitlistsInput
    customer?: CustomerCreateNestedOneWithoutWaitlistsInput
    branch?: BranchCreateNestedOneWithoutWaitlistsInput
    cart?: AddToCartCreateNestedOneWithoutWaitlistsInput
    cartItem?: CartItemCreateNestedOneWithoutWaitlistsInput
    product?: ProductCreateNestedOneWithoutWaitlistsInput
    shop?: ShopCreateNestedOneWithoutWaitlistsInput
    createdBy?: UserCreateNestedOneWithoutWaitlistsCreatedInput
  }

  export type WaitlistUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    userId?: string | null
    customerId?: string | null
    branchId?: string | null
    cartId?: string | null
    cartItemId?: string | null
    productId?: string | null
    quantity?: number
    note?: string | null
    shopId?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaitlistCreateOrConnectWithoutUpdatedByInput = {
    where: WaitlistWhereUniqueInput
    create: XOR<WaitlistCreateWithoutUpdatedByInput, WaitlistUncheckedCreateWithoutUpdatedByInput>
  }

  export type WaitlistCreateManyUpdatedByInputEnvelope = {
    data: WaitlistCreateManyUpdatedByInput | WaitlistCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutUserInput = {
    update: XOR<BranchUpdateWithoutUserInput, BranchUncheckedUpdateWithoutUserInput>
    create: XOR<BranchCreateWithoutUserInput, BranchUncheckedCreateWithoutUserInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutUserInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutUserInput, BranchUncheckedUpdateWithoutUserInput>
  }

  export type BranchUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Shop?: ShopUpdateManyWithoutBranchNestedInput
    Store?: StoreUpdateManyWithoutBranchNestedInput
    Sell?: SellUpdateManyWithoutBranchNestedInput
    AddToCart?: AddToCartUpdateManyWithoutBranchNestedInput
    waitlists?: WaitlistUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Shop?: ShopUncheckedUpdateManyWithoutBranchNestedInput
    Store?: StoreUncheckedUpdateManyWithoutBranchNestedInput
    Sell?: SellUncheckedUpdateManyWithoutBranchNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutBranchNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type ShopUpsertWithWhereUniqueWithoutUserInput = {
    where: ShopWhereUniqueInput
    update: XOR<ShopUpdateWithoutUserInput, ShopUncheckedUpdateWithoutUserInput>
    create: XOR<ShopCreateWithoutUserInput, ShopUncheckedCreateWithoutUserInput>
  }

  export type ShopUpdateWithWhereUniqueWithoutUserInput = {
    where: ShopWhereUniqueInput
    data: XOR<ShopUpdateWithoutUserInput, ShopUncheckedUpdateWithoutUserInput>
  }

  export type ShopUpdateManyWithWhereWithoutUserInput = {
    where: ShopScalarWhereInput
    data: XOR<ShopUpdateManyMutationInput, ShopUncheckedUpdateManyWithoutUserInput>
  }

  export type ShopScalarWhereInput = {
    AND?: ShopScalarWhereInput | ShopScalarWhereInput[]
    OR?: ShopScalarWhereInput[]
    NOT?: ShopScalarWhereInput | ShopScalarWhereInput[]
    id?: StringFilter<"Shop"> | string
    name?: StringFilter<"Shop"> | string
    branchId?: StringFilter<"Shop"> | string
    createdAt?: DateTimeFilter<"Shop"> | Date | string
    updatedAt?: DateTimeFilter<"Shop"> | Date | string
  }

  export type StoreUpsertWithWhereUniqueWithoutUserInput = {
    where: StoreWhereUniqueInput
    update: XOR<StoreUpdateWithoutUserInput, StoreUncheckedUpdateWithoutUserInput>
    create: XOR<StoreCreateWithoutUserInput, StoreUncheckedCreateWithoutUserInput>
  }

  export type StoreUpdateWithWhereUniqueWithoutUserInput = {
    where: StoreWhereUniqueInput
    data: XOR<StoreUpdateWithoutUserInput, StoreUncheckedUpdateWithoutUserInput>
  }

  export type StoreUpdateManyWithWhereWithoutUserInput = {
    where: StoreScalarWhereInput
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyWithoutUserInput>
  }

  export type StoreScalarWhereInput = {
    AND?: StoreScalarWhereInput | StoreScalarWhereInput[]
    OR?: StoreScalarWhereInput[]
    NOT?: StoreScalarWhereInput | StoreScalarWhereInput[]
    id?: StringFilter<"Store"> | string
    name?: StringFilter<"Store"> | string
    branchId?: StringFilter<"Store"> | string
    createdAt?: DateTimeFilter<"Store"> | Date | string
    updatedAt?: DateTimeFilter<"Store"> | Date | string
  }

  export type LogUpsertWithWhereUniqueWithoutUserInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutUserInput, LogUncheckedUpdateWithoutUserInput>
    create: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput>
  }

  export type LogUpdateWithWhereUniqueWithoutUserInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutUserInput, LogUncheckedUpdateWithoutUserInput>
  }

  export type LogUpdateManyWithWhereWithoutUserInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutUserInput>
  }

  export type LogScalarWhereInput = {
    AND?: LogScalarWhereInput | LogScalarWhereInput[]
    OR?: LogScalarWhereInput[]
    NOT?: LogScalarWhereInput | LogScalarWhereInput[]
    id?: StringFilter<"Log"> | string
    action?: StringFilter<"Log"> | string
    userId?: StringNullableFilter<"Log"> | string | null
    createdAt?: DateTimeFilter<"Log"> | Date | string
    updatedAt?: DateTimeFilter<"Log"> | Date | string
  }

  export type StockLedgerUpsertWithWhereUniqueWithoutUserInput = {
    where: StockLedgerWhereUniqueInput
    update: XOR<StockLedgerUpdateWithoutUserInput, StockLedgerUncheckedUpdateWithoutUserInput>
    create: XOR<StockLedgerCreateWithoutUserInput, StockLedgerUncheckedCreateWithoutUserInput>
  }

  export type StockLedgerUpdateWithWhereUniqueWithoutUserInput = {
    where: StockLedgerWhereUniqueInput
    data: XOR<StockLedgerUpdateWithoutUserInput, StockLedgerUncheckedUpdateWithoutUserInput>
  }

  export type StockLedgerUpdateManyWithWhereWithoutUserInput = {
    where: StockLedgerScalarWhereInput
    data: XOR<StockLedgerUpdateManyMutationInput, StockLedgerUncheckedUpdateManyWithoutUserInput>
  }

  export type StockLedgerScalarWhereInput = {
    AND?: StockLedgerScalarWhereInput | StockLedgerScalarWhereInput[]
    OR?: StockLedgerScalarWhereInput[]
    NOT?: StockLedgerScalarWhereInput | StockLedgerScalarWhereInput[]
    id?: StringFilter<"StockLedger"> | string
    invoiceNo?: StringNullableFilter<"StockLedger"> | string | null
    batchId?: StringFilter<"StockLedger"> | string
    storeId?: StringNullableFilter<"StockLedger"> | string | null
    shopId?: StringNullableFilter<"StockLedger"> | string | null
    movementType?: EnumStockMovementTypeFilter<"StockLedger"> | $Enums.StockMovementType
    quantity?: IntFilter<"StockLedger"> | number
    unitOfMeasureId?: StringFilter<"StockLedger"> | string
    reference?: StringNullableFilter<"StockLedger"> | string | null
    userId?: StringNullableFilter<"StockLedger"> | string | null
    notes?: StringNullableFilter<"StockLedger"> | string | null
    movementDate?: DateTimeFilter<"StockLedger"> | Date | string
    createdAt?: DateTimeFilter<"StockLedger"> | Date | string
    updatedAt?: DateTimeFilter<"StockLedger"> | Date | string
  }

  export type PurchaseUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutCreatedByInput, PurchaseUncheckedUpdateWithoutCreatedByInput>
    create: XOR<PurchaseCreateWithoutCreatedByInput, PurchaseUncheckedCreateWithoutCreatedByInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutCreatedByInput, PurchaseUncheckedUpdateWithoutCreatedByInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutCreatedByInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type PurchaseScalarWhereInput = {
    AND?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    OR?: PurchaseScalarWhereInput[]
    NOT?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    id?: StringFilter<"Purchase"> | string
    invoiceNo?: StringFilter<"Purchase"> | string
    supplierId?: StringFilter<"Purchase"> | string
    storeId?: StringFilter<"Purchase"> | string
    paymentStatus?: EnumPaymentStatusFilter<"Purchase"> | $Enums.PaymentStatus
    totalProducts?: IntFilter<"Purchase"> | number
    subTotal?: FloatFilter<"Purchase"> | number
    grandTotal?: FloatFilter<"Purchase"> | number
    notes?: StringNullableFilter<"Purchase"> | string | null
    purchaseDate?: DateTimeFilter<"Purchase"> | Date | string
    createdById?: StringNullableFilter<"Purchase"> | string | null
    updatedById?: StringNullableFilter<"Purchase"> | string | null
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
  }

  export type PurchaseUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutUpdatedByInput, PurchaseUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<PurchaseCreateWithoutUpdatedByInput, PurchaseUncheckedCreateWithoutUpdatedByInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutUpdatedByInput, PurchaseUncheckedUpdateWithoutUpdatedByInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutUpdatedByInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutCreatedByInput, TransferUncheckedUpdateWithoutCreatedByInput>
    create: XOR<TransferCreateWithoutCreatedByInput, TransferUncheckedCreateWithoutCreatedByInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutCreatedByInput, TransferUncheckedUpdateWithoutCreatedByInput>
  }

  export type TransferUpdateManyWithWhereWithoutCreatedByInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type TransferScalarWhereInput = {
    AND?: TransferScalarWhereInput | TransferScalarWhereInput[]
    OR?: TransferScalarWhereInput[]
    NOT?: TransferScalarWhereInput | TransferScalarWhereInput[]
    id?: StringFilter<"Transfer"> | string
    shortCode?: StringFilter<"Transfer"> | string
    sourceType?: EnumTransferEntityTypeFilter<"Transfer"> | $Enums.TransferEntityType
    sourceStoreId?: StringNullableFilter<"Transfer"> | string | null
    sourceShopId?: StringNullableFilter<"Transfer"> | string | null
    destinationType?: EnumTransferEntityTypeFilter<"Transfer"> | $Enums.TransferEntityType
    destStoreId?: StringNullableFilter<"Transfer"> | string | null
    destShopId?: StringNullableFilter<"Transfer"> | string | null
    reference?: StringNullableFilter<"Transfer"> | string | null
    notes?: StringNullableFilter<"Transfer"> | string | null
    status?: EnumTransferStatusFilter<"Transfer"> | $Enums.TransferStatus
    movementDate?: DateTimeFilter<"Transfer"> | Date | string
    createdById?: StringNullableFilter<"Transfer"> | string | null
    updatedById?: StringNullableFilter<"Transfer"> | string | null
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeFilter<"Transfer"> | Date | string
  }

  export type TransferUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutUpdatedByInput, TransferUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<TransferCreateWithoutUpdatedByInput, TransferUncheckedCreateWithoutUpdatedByInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutUpdatedByInput, TransferUncheckedUpdateWithoutUpdatedByInput>
  }

  export type TransferUpdateManyWithWhereWithoutUpdatedByInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type StockCorrectionUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: StockCorrectionWhereUniqueInput
    update: XOR<StockCorrectionUpdateWithoutCreatedByInput, StockCorrectionUncheckedUpdateWithoutCreatedByInput>
    create: XOR<StockCorrectionCreateWithoutCreatedByInput, StockCorrectionUncheckedCreateWithoutCreatedByInput>
  }

  export type StockCorrectionUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: StockCorrectionWhereUniqueInput
    data: XOR<StockCorrectionUpdateWithoutCreatedByInput, StockCorrectionUncheckedUpdateWithoutCreatedByInput>
  }

  export type StockCorrectionUpdateManyWithWhereWithoutCreatedByInput = {
    where: StockCorrectionScalarWhereInput
    data: XOR<StockCorrectionUpdateManyMutationInput, StockCorrectionUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type StockCorrectionScalarWhereInput = {
    AND?: StockCorrectionScalarWhereInput | StockCorrectionScalarWhereInput[]
    OR?: StockCorrectionScalarWhereInput[]
    NOT?: StockCorrectionScalarWhereInput | StockCorrectionScalarWhereInput[]
    id?: StringFilter<"StockCorrection"> | string
    shortCode?: StringFilter<"StockCorrection"> | string
    storeId?: StringNullableFilter<"StockCorrection"> | string | null
    shopId?: StringNullableFilter<"StockCorrection"> | string | null
    reason?: EnumStockCorrectionReasonFilter<"StockCorrection"> | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFilter<"StockCorrection"> | $Enums.StockCorrectionStatus
    purchaseId?: StringNullableFilter<"StockCorrection"> | string | null
    transferId?: StringNullableFilter<"StockCorrection"> | string | null
    reference?: StringNullableFilter<"StockCorrection"> | string | null
    notes?: StringNullableFilter<"StockCorrection"> | string | null
    createdById?: StringNullableFilter<"StockCorrection"> | string | null
    updatedById?: StringNullableFilter<"StockCorrection"> | string | null
    createdAt?: DateTimeFilter<"StockCorrection"> | Date | string
    updatedAt?: DateTimeFilter<"StockCorrection"> | Date | string
  }

  export type StockCorrectionUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: StockCorrectionWhereUniqueInput
    update: XOR<StockCorrectionUpdateWithoutUpdatedByInput, StockCorrectionUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<StockCorrectionCreateWithoutUpdatedByInput, StockCorrectionUncheckedCreateWithoutUpdatedByInput>
  }

  export type StockCorrectionUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: StockCorrectionWhereUniqueInput
    data: XOR<StockCorrectionUpdateWithoutUpdatedByInput, StockCorrectionUncheckedUpdateWithoutUpdatedByInput>
  }

  export type StockCorrectionUpdateManyWithWhereWithoutUpdatedByInput = {
    where: StockCorrectionScalarWhereInput
    data: XOR<StockCorrectionUpdateManyMutationInput, StockCorrectionUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type SellUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: SellWhereUniqueInput
    update: XOR<SellUpdateWithoutCreatedByInput, SellUncheckedUpdateWithoutCreatedByInput>
    create: XOR<SellCreateWithoutCreatedByInput, SellUncheckedCreateWithoutCreatedByInput>
  }

  export type SellUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: SellWhereUniqueInput
    data: XOR<SellUpdateWithoutCreatedByInput, SellUncheckedUpdateWithoutCreatedByInput>
  }

  export type SellUpdateManyWithWhereWithoutCreatedByInput = {
    where: SellScalarWhereInput
    data: XOR<SellUpdateManyMutationInput, SellUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type SellScalarWhereInput = {
    AND?: SellScalarWhereInput | SellScalarWhereInput[]
    OR?: SellScalarWhereInput[]
    NOT?: SellScalarWhereInput | SellScalarWhereInput[]
    id?: StringFilter<"Sell"> | string
    invoiceNo?: StringFilter<"Sell"> | string
    saleStatus?: EnumSaleStatusFilter<"Sell"> | $Enums.SaleStatus
    locked?: BoolFilter<"Sell"> | boolean
    lockedAt?: DateTimeNullableFilter<"Sell"> | Date | string | null
    branchId?: StringNullableFilter<"Sell"> | string | null
    customerId?: StringNullableFilter<"Sell"> | string | null
    totalProducts?: IntFilter<"Sell"> | number
    subTotal?: FloatFilter<"Sell"> | number
    discount?: FloatFilter<"Sell"> | number
    vat?: FloatFilter<"Sell"> | number
    grandTotal?: FloatFilter<"Sell"> | number
    NetTotal?: FloatFilter<"Sell"> | number
    notes?: StringNullableFilter<"Sell"> | string | null
    saleDate?: DateTimeFilter<"Sell"> | Date | string
    createdById?: StringNullableFilter<"Sell"> | string | null
    updatedById?: StringNullableFilter<"Sell"> | string | null
    createdAt?: DateTimeFilter<"Sell"> | Date | string
    updatedAt?: DateTimeFilter<"Sell"> | Date | string
  }

  export type SellUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: SellWhereUniqueInput
    update: XOR<SellUpdateWithoutUpdatedByInput, SellUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<SellCreateWithoutUpdatedByInput, SellUncheckedCreateWithoutUpdatedByInput>
  }

  export type SellUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: SellWhereUniqueInput
    data: XOR<SellUpdateWithoutUpdatedByInput, SellUncheckedUpdateWithoutUpdatedByInput>
  }

  export type SellUpdateManyWithWhereWithoutUpdatedByInput = {
    where: SellScalarWhereInput
    data: XOR<SellUpdateManyMutationInput, SellUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type SellStockCorrectionUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: SellStockCorrectionWhereUniqueInput
    update: XOR<SellStockCorrectionUpdateWithoutCreatedByInput, SellStockCorrectionUncheckedUpdateWithoutCreatedByInput>
    create: XOR<SellStockCorrectionCreateWithoutCreatedByInput, SellStockCorrectionUncheckedCreateWithoutCreatedByInput>
  }

  export type SellStockCorrectionUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: SellStockCorrectionWhereUniqueInput
    data: XOR<SellStockCorrectionUpdateWithoutCreatedByInput, SellStockCorrectionUncheckedUpdateWithoutCreatedByInput>
  }

  export type SellStockCorrectionUpdateManyWithWhereWithoutCreatedByInput = {
    where: SellStockCorrectionScalarWhereInput
    data: XOR<SellStockCorrectionUpdateManyMutationInput, SellStockCorrectionUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type SellStockCorrectionScalarWhereInput = {
    AND?: SellStockCorrectionScalarWhereInput | SellStockCorrectionScalarWhereInput[]
    OR?: SellStockCorrectionScalarWhereInput[]
    NOT?: SellStockCorrectionScalarWhereInput | SellStockCorrectionScalarWhereInput[]
    id?: StringFilter<"SellStockCorrection"> | string
    sellId?: StringNullableFilter<"SellStockCorrection"> | string | null
    status?: EnumSellStockCorrectionStatusFilter<"SellStockCorrection"> | $Enums.SellStockCorrectionStatus
    reference?: StringNullableFilter<"SellStockCorrection"> | string | null
    notes?: StringNullableFilter<"SellStockCorrection"> | string | null
    createdById?: StringNullableFilter<"SellStockCorrection"> | string | null
    updatedById?: StringNullableFilter<"SellStockCorrection"> | string | null
    total?: FloatFilter<"SellStockCorrection"> | number
    createdAt?: DateTimeFilter<"SellStockCorrection"> | Date | string
    updatedAt?: DateTimeFilter<"SellStockCorrection"> | Date | string
  }

  export type SellStockCorrectionUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: SellStockCorrectionWhereUniqueInput
    update: XOR<SellStockCorrectionUpdateWithoutUpdatedByInput, SellStockCorrectionUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<SellStockCorrectionCreateWithoutUpdatedByInput, SellStockCorrectionUncheckedCreateWithoutUpdatedByInput>
  }

  export type SellStockCorrectionUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: SellStockCorrectionWhereUniqueInput
    data: XOR<SellStockCorrectionUpdateWithoutUpdatedByInput, SellStockCorrectionUncheckedUpdateWithoutUpdatedByInput>
  }

  export type SellStockCorrectionUpdateManyWithWhereWithoutUpdatedByInput = {
    where: SellStockCorrectionScalarWhereInput
    data: XOR<SellStockCorrectionUpdateManyMutationInput, SellStockCorrectionUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type AddToCartUpsertWithWhereUniqueWithoutUserInput = {
    where: AddToCartWhereUniqueInput
    update: XOR<AddToCartUpdateWithoutUserInput, AddToCartUncheckedUpdateWithoutUserInput>
    create: XOR<AddToCartCreateWithoutUserInput, AddToCartUncheckedCreateWithoutUserInput>
  }

  export type AddToCartUpdateWithWhereUniqueWithoutUserInput = {
    where: AddToCartWhereUniqueInput
    data: XOR<AddToCartUpdateWithoutUserInput, AddToCartUncheckedUpdateWithoutUserInput>
  }

  export type AddToCartUpdateManyWithWhereWithoutUserInput = {
    where: AddToCartScalarWhereInput
    data: XOR<AddToCartUpdateManyMutationInput, AddToCartUncheckedUpdateManyWithoutUserInput>
  }

  export type AddToCartScalarWhereInput = {
    AND?: AddToCartScalarWhereInput | AddToCartScalarWhereInput[]
    OR?: AddToCartScalarWhereInput[]
    NOT?: AddToCartScalarWhereInput | AddToCartScalarWhereInput[]
    id?: StringFilter<"AddToCart"> | string
    userId?: StringFilter<"AddToCart"> | string
    branchId?: StringNullableFilter<"AddToCart"> | string | null
    isCheckedOut?: BoolFilter<"AddToCart"> | boolean
    isWaitlist?: BoolFilter<"AddToCart"> | boolean
    customerId?: StringNullableFilter<"AddToCart"> | string | null
    totalItems?: IntFilter<"AddToCart"> | number
    totalAmount?: FloatFilter<"AddToCart"> | number
    createdById?: StringNullableFilter<"AddToCart"> | string | null
    updatedById?: StringNullableFilter<"AddToCart"> | string | null
    createdAt?: DateTimeFilter<"AddToCart"> | Date | string
    updatedAt?: DateTimeFilter<"AddToCart"> | Date | string
  }

  export type AddToCartUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: AddToCartWhereUniqueInput
    update: XOR<AddToCartUpdateWithoutCreatedByInput, AddToCartUncheckedUpdateWithoutCreatedByInput>
    create: XOR<AddToCartCreateWithoutCreatedByInput, AddToCartUncheckedCreateWithoutCreatedByInput>
  }

  export type AddToCartUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: AddToCartWhereUniqueInput
    data: XOR<AddToCartUpdateWithoutCreatedByInput, AddToCartUncheckedUpdateWithoutCreatedByInput>
  }

  export type AddToCartUpdateManyWithWhereWithoutCreatedByInput = {
    where: AddToCartScalarWhereInput
    data: XOR<AddToCartUpdateManyMutationInput, AddToCartUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AddToCartUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: AddToCartWhereUniqueInput
    update: XOR<AddToCartUpdateWithoutUpdatedByInput, AddToCartUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<AddToCartCreateWithoutUpdatedByInput, AddToCartUncheckedCreateWithoutUpdatedByInput>
  }

  export type AddToCartUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: AddToCartWhereUniqueInput
    data: XOR<AddToCartUpdateWithoutUpdatedByInput, AddToCartUncheckedUpdateWithoutUpdatedByInput>
  }

  export type AddToCartUpdateManyWithWhereWithoutUpdatedByInput = {
    where: AddToCartScalarWhereInput
    data: XOR<AddToCartUpdateManyMutationInput, AddToCartUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type WaitlistUpsertWithWhereUniqueWithoutUserInput = {
    where: WaitlistWhereUniqueInput
    update: XOR<WaitlistUpdateWithoutUserInput, WaitlistUncheckedUpdateWithoutUserInput>
    create: XOR<WaitlistCreateWithoutUserInput, WaitlistUncheckedCreateWithoutUserInput>
  }

  export type WaitlistUpdateWithWhereUniqueWithoutUserInput = {
    where: WaitlistWhereUniqueInput
    data: XOR<WaitlistUpdateWithoutUserInput, WaitlistUncheckedUpdateWithoutUserInput>
  }

  export type WaitlistUpdateManyWithWhereWithoutUserInput = {
    where: WaitlistScalarWhereInput
    data: XOR<WaitlistUpdateManyMutationInput, WaitlistUncheckedUpdateManyWithoutUserInput>
  }

  export type WaitlistScalarWhereInput = {
    AND?: WaitlistScalarWhereInput | WaitlistScalarWhereInput[]
    OR?: WaitlistScalarWhereInput[]
    NOT?: WaitlistScalarWhereInput | WaitlistScalarWhereInput[]
    id?: StringFilter<"Waitlist"> | string
    userId?: StringNullableFilter<"Waitlist"> | string | null
    customerId?: StringNullableFilter<"Waitlist"> | string | null
    branchId?: StringNullableFilter<"Waitlist"> | string | null
    cartId?: StringNullableFilter<"Waitlist"> | string | null
    cartItemId?: StringNullableFilter<"Waitlist"> | string | null
    productId?: StringNullableFilter<"Waitlist"> | string | null
    quantity?: IntFilter<"Waitlist"> | number
    note?: StringNullableFilter<"Waitlist"> | string | null
    shopId?: StringNullableFilter<"Waitlist"> | string | null
    createdById?: StringNullableFilter<"Waitlist"> | string | null
    updatedById?: StringNullableFilter<"Waitlist"> | string | null
    createdAt?: DateTimeFilter<"Waitlist"> | Date | string
    updatedAt?: DateTimeFilter<"Waitlist"> | Date | string
  }

  export type WaitlistUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: WaitlistWhereUniqueInput
    update: XOR<WaitlistUpdateWithoutCreatedByInput, WaitlistUncheckedUpdateWithoutCreatedByInput>
    create: XOR<WaitlistCreateWithoutCreatedByInput, WaitlistUncheckedCreateWithoutCreatedByInput>
  }

  export type WaitlistUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: WaitlistWhereUniqueInput
    data: XOR<WaitlistUpdateWithoutCreatedByInput, WaitlistUncheckedUpdateWithoutCreatedByInput>
  }

  export type WaitlistUpdateManyWithWhereWithoutCreatedByInput = {
    where: WaitlistScalarWhereInput
    data: XOR<WaitlistUpdateManyMutationInput, WaitlistUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type WaitlistUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: WaitlistWhereUniqueInput
    update: XOR<WaitlistUpdateWithoutUpdatedByInput, WaitlistUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<WaitlistCreateWithoutUpdatedByInput, WaitlistUncheckedCreateWithoutUpdatedByInput>
  }

  export type WaitlistUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: WaitlistWhereUniqueInput
    data: XOR<WaitlistUpdateWithoutUpdatedByInput, WaitlistUncheckedUpdateWithoutUpdatedByInput>
  }

  export type WaitlistUpdateManyWithWhereWithoutUpdatedByInput = {
    where: WaitlistScalarWhereInput
    data: XOR<WaitlistUpdateManyMutationInput, WaitlistUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type RolePermissionCreateWithoutRoleInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    permission: PermissionCreateNestedOneWithoutRolesInput
  }

  export type RolePermissionUncheckedCreateWithoutRoleInput = {
    id?: string
    permissionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionCreateManyRoleInputEnvelope = {
    data: RolePermissionCreateManyRoleInput | RolePermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutRoleInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    branch?: BranchCreateNestedOneWithoutUserInput
    shops?: ShopCreateNestedManyWithoutUserInput
    stores?: StoreCreateNestedManyWithoutUserInput
    Log?: LogCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionCreateNestedManyWithoutUpdatedByInput
    Sell?: SellCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    branchId?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    shops?: ShopUncheckedCreateNestedManyWithoutUserInput
    stores?: StoreUncheckedCreateNestedManyWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseUncheckedCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferUncheckedCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    Sell?: SellUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellUncheckedCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartUncheckedCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartUncheckedCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistUncheckedCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    id?: StringFilter<"RolePermission"> | string
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    updatedAt?: DateTimeFilter<"RolePermission"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    userCode?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    admin?: BoolFilter<"User"> | boolean
    password?: StringFilter<"User"> | string
    branchId?: StringNullableFilter<"User"> | string | null
    roleId?: StringFilter<"User"> | string
    status?: EnumStatusFilter<"User"> | $Enums.Status
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutPermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: RolePermissionCreateManyPermissionInput | RolePermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type PermissionCreateWithoutRolesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUncheckedCreateWithoutRolesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionCreateOrConnectWithoutRolesInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
  }

  export type RoleCreateWithoutPermissionsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutPermissionsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutPermissionsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
  }

  export type PermissionUpsertWithoutRolesInput = {
    update: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRolesInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type PermissionUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUpsertWithoutPermissionsInput = {
    update: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type RoleUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type ShopCreateWithoutBranchInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopStock?: ShopStockCreateNestedManyWithoutShopInput
    StockLedger?: StockLedgerCreateNestedManyWithoutShopInput
    SourceTransfer?: TransferCreateNestedManyWithoutSourceShopInput
    DestinatTransfer?: TransferCreateNestedManyWithoutDestShopInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutShopInput
    AdditionalPrice?: AdditionalPriceCreateNestedManyWithoutShopInput
    SellItem?: SellItemCreateNestedManyWithoutShopInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutShopInput
    User?: UserCreateNestedManyWithoutShopsInput
    CartItem?: CartItemCreateNestedManyWithoutShopInput
    waitlists?: WaitlistCreateNestedManyWithoutShopInput
    notifications?: NotificationCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutBranchInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutShopInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutShopInput
    SourceTransfer?: TransferUncheckedCreateNestedManyWithoutSourceShopInput
    DestinatTransfer?: TransferUncheckedCreateNestedManyWithoutDestShopInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutShopInput
    AdditionalPrice?: AdditionalPriceUncheckedCreateNestedManyWithoutShopInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutShopInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutShopInput
    User?: UserUncheckedCreateNestedManyWithoutShopsInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutShopInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutShopInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutBranchInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutBranchInput, ShopUncheckedCreateWithoutBranchInput>
  }

  export type ShopCreateManyBranchInputEnvelope = {
    data: ShopCreateManyBranchInput | ShopCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type StoreCreateWithoutBranchInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ProductBatch?: ProductBatchCreateNestedManyWithoutStoreInput
    StoreStock?: StoreStockCreateNestedManyWithoutStoreInput
    StockLedger?: StockLedgerCreateNestedManyWithoutStoreInput
    Purchase?: PurchaseCreateNestedManyWithoutStoreInput
    SourceTransfer?: TransferCreateNestedManyWithoutSourceStoreInput
    DestinatTransfer?: TransferCreateNestedManyWithoutDestStoreInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutStoreInput
    User?: UserCreateNestedManyWithoutStoresInput
    notifications?: NotificationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutBranchInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ProductBatch?: ProductBatchUncheckedCreateNestedManyWithoutStoreInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutStoreInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutStoreInput
    Purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    SourceTransfer?: TransferUncheckedCreateNestedManyWithoutSourceStoreInput
    DestinatTransfer?: TransferUncheckedCreateNestedManyWithoutDestStoreInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutStoreInput
    User?: UserUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutBranchInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutBranchInput, StoreUncheckedCreateWithoutBranchInput>
  }

  export type StoreCreateManyBranchInputEnvelope = {
    data: StoreCreateManyBranchInput | StoreCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutBranchInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    role: RoleCreateNestedOneWithoutUsersInput
    shops?: ShopCreateNestedManyWithoutUserInput
    stores?: StoreCreateNestedManyWithoutUserInput
    Log?: LogCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionCreateNestedManyWithoutUpdatedByInput
    Sell?: SellCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutBranchInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    roleId: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    shops?: ShopUncheckedCreateNestedManyWithoutUserInput
    stores?: StoreUncheckedCreateNestedManyWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseUncheckedCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferUncheckedCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    Sell?: SellUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellUncheckedCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartUncheckedCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartUncheckedCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistUncheckedCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutBranchInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput>
  }

  export type UserCreateManyBranchInputEnvelope = {
    data: UserCreateManyBranchInput | UserCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type SellCreateWithoutBranchInput = {
    id?: string
    invoiceNo: string
    saleStatus?: $Enums.SaleStatus
    locked?: boolean
    lockedAt?: Date | string | null
    totalProducts?: number
    subTotal?: number
    discount?: number
    vat?: number
    grandTotal?: number
    NetTotal?: number
    notes?: string | null
    saleDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutSellInput
    createdBy?: UserCreateNestedOneWithoutSellInput
    updatedBy?: UserCreateNestedOneWithoutUpdateSellInput
    items?: SellItemCreateNestedManyWithoutSellInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutSellInput
  }

  export type SellUncheckedCreateWithoutBranchInput = {
    id?: string
    invoiceNo: string
    saleStatus?: $Enums.SaleStatus
    locked?: boolean
    lockedAt?: Date | string | null
    customerId?: string | null
    totalProducts?: number
    subTotal?: number
    discount?: number
    vat?: number
    grandTotal?: number
    NetTotal?: number
    notes?: string | null
    saleDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SellItemUncheckedCreateNestedManyWithoutSellInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutSellInput
  }

  export type SellCreateOrConnectWithoutBranchInput = {
    where: SellWhereUniqueInput
    create: XOR<SellCreateWithoutBranchInput, SellUncheckedCreateWithoutBranchInput>
  }

  export type SellCreateManyBranchInputEnvelope = {
    data: SellCreateManyBranchInput | SellCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type AddToCartCreateWithoutBranchInput = {
    id?: string
    isCheckedOut?: boolean
    isWaitlist?: boolean
    totalItems?: number
    totalAmount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAllAddToCartInput
    customer?: CustomerCreateNestedOneWithoutAddToCartInput
    createdBy?: UserCreateNestedOneWithoutCreatedAddToCartInput
    updatedBy?: UserCreateNestedOneWithoutAddToCartInput
    items?: CartItemCreateNestedManyWithoutCartInput
    waitlists?: WaitlistCreateNestedManyWithoutCartInput
  }

  export type AddToCartUncheckedCreateWithoutBranchInput = {
    id?: string
    userId: string
    isCheckedOut?: boolean
    isWaitlist?: boolean
    customerId?: string | null
    totalItems?: number
    totalAmount?: number
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemUncheckedCreateNestedManyWithoutCartInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutCartInput
  }

  export type AddToCartCreateOrConnectWithoutBranchInput = {
    where: AddToCartWhereUniqueInput
    create: XOR<AddToCartCreateWithoutBranchInput, AddToCartUncheckedCreateWithoutBranchInput>
  }

  export type AddToCartCreateManyBranchInputEnvelope = {
    data: AddToCartCreateManyBranchInput | AddToCartCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type WaitlistCreateWithoutBranchInput = {
    id?: string
    quantity?: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutWaitlistsInput
    customer?: CustomerCreateNestedOneWithoutWaitlistsInput
    cart?: AddToCartCreateNestedOneWithoutWaitlistsInput
    cartItem?: CartItemCreateNestedOneWithoutWaitlistsInput
    product?: ProductCreateNestedOneWithoutWaitlistsInput
    shop?: ShopCreateNestedOneWithoutWaitlistsInput
    createdBy?: UserCreateNestedOneWithoutWaitlistsCreatedInput
    updatedBy?: UserCreateNestedOneWithoutWaitlistsUpdatedInput
  }

  export type WaitlistUncheckedCreateWithoutBranchInput = {
    id?: string
    userId?: string | null
    customerId?: string | null
    cartId?: string | null
    cartItemId?: string | null
    productId?: string | null
    quantity?: number
    note?: string | null
    shopId?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaitlistCreateOrConnectWithoutBranchInput = {
    where: WaitlistWhereUniqueInput
    create: XOR<WaitlistCreateWithoutBranchInput, WaitlistUncheckedCreateWithoutBranchInput>
  }

  export type WaitlistCreateManyBranchInputEnvelope = {
    data: WaitlistCreateManyBranchInput | WaitlistCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type ShopUpsertWithWhereUniqueWithoutBranchInput = {
    where: ShopWhereUniqueInput
    update: XOR<ShopUpdateWithoutBranchInput, ShopUncheckedUpdateWithoutBranchInput>
    create: XOR<ShopCreateWithoutBranchInput, ShopUncheckedCreateWithoutBranchInput>
  }

  export type ShopUpdateWithWhereUniqueWithoutBranchInput = {
    where: ShopWhereUniqueInput
    data: XOR<ShopUpdateWithoutBranchInput, ShopUncheckedUpdateWithoutBranchInput>
  }

  export type ShopUpdateManyWithWhereWithoutBranchInput = {
    where: ShopScalarWhereInput
    data: XOR<ShopUpdateManyMutationInput, ShopUncheckedUpdateManyWithoutBranchInput>
  }

  export type StoreUpsertWithWhereUniqueWithoutBranchInput = {
    where: StoreWhereUniqueInput
    update: XOR<StoreUpdateWithoutBranchInput, StoreUncheckedUpdateWithoutBranchInput>
    create: XOR<StoreCreateWithoutBranchInput, StoreUncheckedCreateWithoutBranchInput>
  }

  export type StoreUpdateWithWhereUniqueWithoutBranchInput = {
    where: StoreWhereUniqueInput
    data: XOR<StoreUpdateWithoutBranchInput, StoreUncheckedUpdateWithoutBranchInput>
  }

  export type StoreUpdateManyWithWhereWithoutBranchInput = {
    where: StoreScalarWhereInput
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyWithoutBranchInput>
  }

  export type UserUpsertWithWhereUniqueWithoutBranchInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutBranchInput, UserUncheckedUpdateWithoutBranchInput>
    create: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput>
  }

  export type UserUpdateWithWhereUniqueWithoutBranchInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutBranchInput, UserUncheckedUpdateWithoutBranchInput>
  }

  export type UserUpdateManyWithWhereWithoutBranchInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutBranchInput>
  }

  export type SellUpsertWithWhereUniqueWithoutBranchInput = {
    where: SellWhereUniqueInput
    update: XOR<SellUpdateWithoutBranchInput, SellUncheckedUpdateWithoutBranchInput>
    create: XOR<SellCreateWithoutBranchInput, SellUncheckedCreateWithoutBranchInput>
  }

  export type SellUpdateWithWhereUniqueWithoutBranchInput = {
    where: SellWhereUniqueInput
    data: XOR<SellUpdateWithoutBranchInput, SellUncheckedUpdateWithoutBranchInput>
  }

  export type SellUpdateManyWithWhereWithoutBranchInput = {
    where: SellScalarWhereInput
    data: XOR<SellUpdateManyMutationInput, SellUncheckedUpdateManyWithoutBranchInput>
  }

  export type AddToCartUpsertWithWhereUniqueWithoutBranchInput = {
    where: AddToCartWhereUniqueInput
    update: XOR<AddToCartUpdateWithoutBranchInput, AddToCartUncheckedUpdateWithoutBranchInput>
    create: XOR<AddToCartCreateWithoutBranchInput, AddToCartUncheckedCreateWithoutBranchInput>
  }

  export type AddToCartUpdateWithWhereUniqueWithoutBranchInput = {
    where: AddToCartWhereUniqueInput
    data: XOR<AddToCartUpdateWithoutBranchInput, AddToCartUncheckedUpdateWithoutBranchInput>
  }

  export type AddToCartUpdateManyWithWhereWithoutBranchInput = {
    where: AddToCartScalarWhereInput
    data: XOR<AddToCartUpdateManyMutationInput, AddToCartUncheckedUpdateManyWithoutBranchInput>
  }

  export type WaitlistUpsertWithWhereUniqueWithoutBranchInput = {
    where: WaitlistWhereUniqueInput
    update: XOR<WaitlistUpdateWithoutBranchInput, WaitlistUncheckedUpdateWithoutBranchInput>
    create: XOR<WaitlistCreateWithoutBranchInput, WaitlistUncheckedCreateWithoutBranchInput>
  }

  export type WaitlistUpdateWithWhereUniqueWithoutBranchInput = {
    where: WaitlistWhereUniqueInput
    data: XOR<WaitlistUpdateWithoutBranchInput, WaitlistUncheckedUpdateWithoutBranchInput>
  }

  export type WaitlistUpdateManyWithWhereWithoutBranchInput = {
    where: WaitlistScalarWhereInput
    data: XOR<WaitlistUpdateManyMutationInput, WaitlistUncheckedUpdateManyWithoutBranchInput>
  }

  export type BranchCreateWithoutShopInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Store?: StoreCreateNestedManyWithoutBranchInput
    User?: UserCreateNestedManyWithoutBranchInput
    Sell?: SellCreateNestedManyWithoutBranchInput
    AddToCart?: AddToCartCreateNestedManyWithoutBranchInput
    waitlists?: WaitlistCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutShopInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Store?: StoreUncheckedCreateNestedManyWithoutBranchInput
    User?: UserUncheckedCreateNestedManyWithoutBranchInput
    Sell?: SellUncheckedCreateNestedManyWithoutBranchInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutBranchInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutShopInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutShopInput, BranchUncheckedCreateWithoutShopInput>
  }

  export type ShopStockCreateWithoutShopInput = {
    id?: string
    quantity: number
    status?: $Enums.StockStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    batch: ProductBatchCreateNestedOneWithoutShopStockInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutShopStockInput
  }

  export type ShopStockUncheckedCreateWithoutShopInput = {
    id?: string
    batchId: string
    unitOfMeasureId: string
    quantity: number
    status?: $Enums.StockStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopStockCreateOrConnectWithoutShopInput = {
    where: ShopStockWhereUniqueInput
    create: XOR<ShopStockCreateWithoutShopInput, ShopStockUncheckedCreateWithoutShopInput>
  }

  export type ShopStockCreateManyShopInputEnvelope = {
    data: ShopStockCreateManyShopInput | ShopStockCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type StockLedgerCreateWithoutShopInput = {
    id?: string
    invoiceNo?: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    reference?: string | null
    notes?: string | null
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    batch: ProductBatchCreateNestedOneWithoutStockLedgerInput
    store?: StoreCreateNestedOneWithoutStockLedgerInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutStockLedgerInput
    user?: UserCreateNestedOneWithoutStockLedgerInput
  }

  export type StockLedgerUncheckedCreateWithoutShopInput = {
    id?: string
    invoiceNo?: string | null
    batchId: string
    storeId?: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    unitOfMeasureId: string
    reference?: string | null
    userId?: string | null
    notes?: string | null
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockLedgerCreateOrConnectWithoutShopInput = {
    where: StockLedgerWhereUniqueInput
    create: XOR<StockLedgerCreateWithoutShopInput, StockLedgerUncheckedCreateWithoutShopInput>
  }

  export type StockLedgerCreateManyShopInputEnvelope = {
    data: StockLedgerCreateManyShopInput | StockLedgerCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutSourceShopInput = {
    id?: string
    shortCode: string
    sourceType: $Enums.TransferEntityType
    destinationType: $Enums.TransferEntityType
    reference?: string | null
    notes?: string | null
    status?: $Enums.TransferStatus
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceStore?: StoreCreateNestedOneWithoutSourceTransferInput
    destStore?: StoreCreateNestedOneWithoutDestinatTransferInput
    destShop?: ShopCreateNestedOneWithoutDestinatTransferInput
    createdBy?: UserCreateNestedOneWithoutCreatedTransferInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedTransferInput
    items?: TransferItemCreateNestedManyWithoutTransferInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutSourceShopInput = {
    id?: string
    shortCode: string
    sourceType: $Enums.TransferEntityType
    sourceStoreId?: string | null
    destinationType: $Enums.TransferEntityType
    destStoreId?: string | null
    destShopId?: string | null
    reference?: string | null
    notes?: string | null
    status?: $Enums.TransferStatus
    movementDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferItemUncheckedCreateNestedManyWithoutTransferInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutSourceShopInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutSourceShopInput, TransferUncheckedCreateWithoutSourceShopInput>
  }

  export type TransferCreateManySourceShopInputEnvelope = {
    data: TransferCreateManySourceShopInput | TransferCreateManySourceShopInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutDestShopInput = {
    id?: string
    shortCode: string
    sourceType: $Enums.TransferEntityType
    destinationType: $Enums.TransferEntityType
    reference?: string | null
    notes?: string | null
    status?: $Enums.TransferStatus
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceStore?: StoreCreateNestedOneWithoutSourceTransferInput
    sourceShop?: ShopCreateNestedOneWithoutSourceTransferInput
    destStore?: StoreCreateNestedOneWithoutDestinatTransferInput
    createdBy?: UserCreateNestedOneWithoutCreatedTransferInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedTransferInput
    items?: TransferItemCreateNestedManyWithoutTransferInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutDestShopInput = {
    id?: string
    shortCode: string
    sourceType: $Enums.TransferEntityType
    sourceStoreId?: string | null
    sourceShopId?: string | null
    destinationType: $Enums.TransferEntityType
    destStoreId?: string | null
    reference?: string | null
    notes?: string | null
    status?: $Enums.TransferStatus
    movementDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferItemUncheckedCreateNestedManyWithoutTransferInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutDestShopInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutDestShopInput, TransferUncheckedCreateWithoutDestShopInput>
  }

  export type TransferCreateManyDestShopInputEnvelope = {
    data: TransferCreateManyDestShopInput | TransferCreateManyDestShopInput[]
    skipDuplicates?: boolean
  }

  export type StockCorrectionCreateWithoutShopInput = {
    id?: string
    shortCode: string
    reason: $Enums.StockCorrectionReason
    status?: $Enums.StockCorrectionStatus
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store?: StoreCreateNestedOneWithoutStockCorrectionInput
    purchase?: PurchaseCreateNestedOneWithoutStockCorrectionInput
    transfer?: TransferCreateNestedOneWithoutStockCorrectionInput
    createdBy?: UserCreateNestedOneWithoutStockCorrectionInput
    updatedBy?: UserCreateNestedOneWithoutUpdateStockCorrectionInput
    items?: StockCorrectionItemCreateNestedManyWithoutCorrectionInput
  }

  export type StockCorrectionUncheckedCreateWithoutShopInput = {
    id?: string
    shortCode: string
    storeId?: string | null
    reason: $Enums.StockCorrectionReason
    status?: $Enums.StockCorrectionStatus
    purchaseId?: string | null
    transferId?: string | null
    reference?: string | null
    notes?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: StockCorrectionItemUncheckedCreateNestedManyWithoutCorrectionInput
  }

  export type StockCorrectionCreateOrConnectWithoutShopInput = {
    where: StockCorrectionWhereUniqueInput
    create: XOR<StockCorrectionCreateWithoutShopInput, StockCorrectionUncheckedCreateWithoutShopInput>
  }

  export type StockCorrectionCreateManyShopInputEnvelope = {
    data: StockCorrectionCreateManyShopInput | StockCorrectionCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type AdditionalPriceCreateWithoutShopInput = {
    id?: string
    label?: string | null
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutAdditionalPriceInput
  }

  export type AdditionalPriceUncheckedCreateWithoutShopInput = {
    id?: string
    label?: string | null
    price: number
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdditionalPriceCreateOrConnectWithoutShopInput = {
    where: AdditionalPriceWhereUniqueInput
    create: XOR<AdditionalPriceCreateWithoutShopInput, AdditionalPriceUncheckedCreateWithoutShopInput>
  }

  export type AdditionalPriceCreateManyShopInputEnvelope = {
    data: AdditionalPriceCreateManyShopInput | AdditionalPriceCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type SellItemCreateWithoutShopInput = {
    id?: string
    itemSaleStatus?: $Enums.ItemSaleStatus
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sell: SellCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutSellItemInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutSellItemInput
    batches?: SellItemBatchCreateNestedManyWithoutSellItemInput
  }

  export type SellItemUncheckedCreateWithoutShopInput = {
    id?: string
    sellId: string
    productId: string
    unitOfMeasureId: string
    itemSaleStatus?: $Enums.ItemSaleStatus
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: SellItemBatchUncheckedCreateNestedManyWithoutSellItemInput
  }

  export type SellItemCreateOrConnectWithoutShopInput = {
    where: SellItemWhereUniqueInput
    create: XOR<SellItemCreateWithoutShopInput, SellItemUncheckedCreateWithoutShopInput>
  }

  export type SellItemCreateManyShopInputEnvelope = {
    data: SellItemCreateManyShopInput | SellItemCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type SellStockCorrectionItemCreateWithoutShopInput = {
    id?: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    correction: SellStockCorrectionCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutSellStockCorrectionItemInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutSellStockCorrectionItemInput
    batches?: SellStockCorrectionBatchCreateNestedManyWithoutCorrectionItemInput
  }

  export type SellStockCorrectionItemUncheckedCreateWithoutShopInput = {
    id?: string
    correctionId: string
    productId: string
    unitOfMeasureId: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: SellStockCorrectionBatchUncheckedCreateNestedManyWithoutCorrectionItemInput
  }

  export type SellStockCorrectionItemCreateOrConnectWithoutShopInput = {
    where: SellStockCorrectionItemWhereUniqueInput
    create: XOR<SellStockCorrectionItemCreateWithoutShopInput, SellStockCorrectionItemUncheckedCreateWithoutShopInput>
  }

  export type SellStockCorrectionItemCreateManyShopInputEnvelope = {
    data: SellStockCorrectionItemCreateManyShopInput | SellStockCorrectionItemCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutShopsInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    branch?: BranchCreateNestedOneWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    stores?: StoreCreateNestedManyWithoutUserInput
    Log?: LogCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionCreateNestedManyWithoutUpdatedByInput
    Sell?: SellCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutShopsInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    branchId?: string | null
    roleId: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    stores?: StoreUncheckedCreateNestedManyWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseUncheckedCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferUncheckedCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    Sell?: SellUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellUncheckedCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartUncheckedCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartUncheckedCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistUncheckedCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutShopsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShopsInput, UserUncheckedCreateWithoutShopsInput>
  }

  export type CartItemCreateWithoutShopInput = {
    id?: string
    isWaitlist?: boolean
    quantity: number
    unitPrice?: number
    totalPrice?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cart: AddToCartCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutCartItemInput
    unitOfMeasure?: UnitOfMeasureCreateNestedOneWithoutCartItemInput
    waitlists?: WaitlistCreateNestedManyWithoutCartItemInput
  }

  export type CartItemUncheckedCreateWithoutShopInput = {
    id?: string
    cartId: string
    isWaitlist?: boolean
    productId: string
    unitOfMeasureId?: string | null
    quantity: number
    unitPrice?: number
    totalPrice?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutCartItemInput
  }

  export type CartItemCreateOrConnectWithoutShopInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutShopInput, CartItemUncheckedCreateWithoutShopInput>
  }

  export type CartItemCreateManyShopInputEnvelope = {
    data: CartItemCreateManyShopInput | CartItemCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type WaitlistCreateWithoutShopInput = {
    id?: string
    quantity?: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutWaitlistsInput
    customer?: CustomerCreateNestedOneWithoutWaitlistsInput
    branch?: BranchCreateNestedOneWithoutWaitlistsInput
    cart?: AddToCartCreateNestedOneWithoutWaitlistsInput
    cartItem?: CartItemCreateNestedOneWithoutWaitlistsInput
    product?: ProductCreateNestedOneWithoutWaitlistsInput
    createdBy?: UserCreateNestedOneWithoutWaitlistsCreatedInput
    updatedBy?: UserCreateNestedOneWithoutWaitlistsUpdatedInput
  }

  export type WaitlistUncheckedCreateWithoutShopInput = {
    id?: string
    userId?: string | null
    customerId?: string | null
    branchId?: string | null
    cartId?: string | null
    cartItemId?: string | null
    productId?: string | null
    quantity?: number
    note?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaitlistCreateOrConnectWithoutShopInput = {
    where: WaitlistWhereUniqueInput
    create: XOR<WaitlistCreateWithoutShopInput, WaitlistUncheckedCreateWithoutShopInput>
  }

  export type WaitlistCreateManyShopInputEnvelope = {
    data: WaitlistCreateManyShopInput | WaitlistCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutShopInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    read?: boolean
    relatedEntityType?: $Enums.RelatedEntityType | null
    relatedEntityId?: string | null
    createdAt?: Date | string
    readAt?: Date | string | null
    store?: StoreCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutShopInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    read?: boolean
    relatedEntityType?: $Enums.RelatedEntityType | null
    relatedEntityId?: string | null
    createdAt?: Date | string
    readAt?: Date | string | null
    storeId?: string | null
  }

  export type NotificationCreateOrConnectWithoutShopInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutShopInput, NotificationUncheckedCreateWithoutShopInput>
  }

  export type NotificationCreateManyShopInputEnvelope = {
    data: NotificationCreateManyShopInput | NotificationCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutShopInput = {
    update: XOR<BranchUpdateWithoutShopInput, BranchUncheckedUpdateWithoutShopInput>
    create: XOR<BranchCreateWithoutShopInput, BranchUncheckedCreateWithoutShopInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutShopInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutShopInput, BranchUncheckedUpdateWithoutShopInput>
  }

  export type BranchUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Store?: StoreUpdateManyWithoutBranchNestedInput
    User?: UserUpdateManyWithoutBranchNestedInput
    Sell?: SellUpdateManyWithoutBranchNestedInput
    AddToCart?: AddToCartUpdateManyWithoutBranchNestedInput
    waitlists?: WaitlistUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Store?: StoreUncheckedUpdateManyWithoutBranchNestedInput
    User?: UserUncheckedUpdateManyWithoutBranchNestedInput
    Sell?: SellUncheckedUpdateManyWithoutBranchNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutBranchNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type ShopStockUpsertWithWhereUniqueWithoutShopInput = {
    where: ShopStockWhereUniqueInput
    update: XOR<ShopStockUpdateWithoutShopInput, ShopStockUncheckedUpdateWithoutShopInput>
    create: XOR<ShopStockCreateWithoutShopInput, ShopStockUncheckedCreateWithoutShopInput>
  }

  export type ShopStockUpdateWithWhereUniqueWithoutShopInput = {
    where: ShopStockWhereUniqueInput
    data: XOR<ShopStockUpdateWithoutShopInput, ShopStockUncheckedUpdateWithoutShopInput>
  }

  export type ShopStockUpdateManyWithWhereWithoutShopInput = {
    where: ShopStockScalarWhereInput
    data: XOR<ShopStockUpdateManyMutationInput, ShopStockUncheckedUpdateManyWithoutShopInput>
  }

  export type ShopStockScalarWhereInput = {
    AND?: ShopStockScalarWhereInput | ShopStockScalarWhereInput[]
    OR?: ShopStockScalarWhereInput[]
    NOT?: ShopStockScalarWhereInput | ShopStockScalarWhereInput[]
    id?: StringFilter<"ShopStock"> | string
    shopId?: StringFilter<"ShopStock"> | string
    batchId?: StringFilter<"ShopStock"> | string
    unitOfMeasureId?: StringFilter<"ShopStock"> | string
    quantity?: IntFilter<"ShopStock"> | number
    status?: EnumStockStatusFilter<"ShopStock"> | $Enums.StockStatus
    createdAt?: DateTimeFilter<"ShopStock"> | Date | string
    updatedAt?: DateTimeFilter<"ShopStock"> | Date | string
  }

  export type StockLedgerUpsertWithWhereUniqueWithoutShopInput = {
    where: StockLedgerWhereUniqueInput
    update: XOR<StockLedgerUpdateWithoutShopInput, StockLedgerUncheckedUpdateWithoutShopInput>
    create: XOR<StockLedgerCreateWithoutShopInput, StockLedgerUncheckedCreateWithoutShopInput>
  }

  export type StockLedgerUpdateWithWhereUniqueWithoutShopInput = {
    where: StockLedgerWhereUniqueInput
    data: XOR<StockLedgerUpdateWithoutShopInput, StockLedgerUncheckedUpdateWithoutShopInput>
  }

  export type StockLedgerUpdateManyWithWhereWithoutShopInput = {
    where: StockLedgerScalarWhereInput
    data: XOR<StockLedgerUpdateManyMutationInput, StockLedgerUncheckedUpdateManyWithoutShopInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutSourceShopInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutSourceShopInput, TransferUncheckedUpdateWithoutSourceShopInput>
    create: XOR<TransferCreateWithoutSourceShopInput, TransferUncheckedCreateWithoutSourceShopInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutSourceShopInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutSourceShopInput, TransferUncheckedUpdateWithoutSourceShopInput>
  }

  export type TransferUpdateManyWithWhereWithoutSourceShopInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutSourceShopInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutDestShopInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutDestShopInput, TransferUncheckedUpdateWithoutDestShopInput>
    create: XOR<TransferCreateWithoutDestShopInput, TransferUncheckedCreateWithoutDestShopInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutDestShopInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutDestShopInput, TransferUncheckedUpdateWithoutDestShopInput>
  }

  export type TransferUpdateManyWithWhereWithoutDestShopInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutDestShopInput>
  }

  export type StockCorrectionUpsertWithWhereUniqueWithoutShopInput = {
    where: StockCorrectionWhereUniqueInput
    update: XOR<StockCorrectionUpdateWithoutShopInput, StockCorrectionUncheckedUpdateWithoutShopInput>
    create: XOR<StockCorrectionCreateWithoutShopInput, StockCorrectionUncheckedCreateWithoutShopInput>
  }

  export type StockCorrectionUpdateWithWhereUniqueWithoutShopInput = {
    where: StockCorrectionWhereUniqueInput
    data: XOR<StockCorrectionUpdateWithoutShopInput, StockCorrectionUncheckedUpdateWithoutShopInput>
  }

  export type StockCorrectionUpdateManyWithWhereWithoutShopInput = {
    where: StockCorrectionScalarWhereInput
    data: XOR<StockCorrectionUpdateManyMutationInput, StockCorrectionUncheckedUpdateManyWithoutShopInput>
  }

  export type AdditionalPriceUpsertWithWhereUniqueWithoutShopInput = {
    where: AdditionalPriceWhereUniqueInput
    update: XOR<AdditionalPriceUpdateWithoutShopInput, AdditionalPriceUncheckedUpdateWithoutShopInput>
    create: XOR<AdditionalPriceCreateWithoutShopInput, AdditionalPriceUncheckedCreateWithoutShopInput>
  }

  export type AdditionalPriceUpdateWithWhereUniqueWithoutShopInput = {
    where: AdditionalPriceWhereUniqueInput
    data: XOR<AdditionalPriceUpdateWithoutShopInput, AdditionalPriceUncheckedUpdateWithoutShopInput>
  }

  export type AdditionalPriceUpdateManyWithWhereWithoutShopInput = {
    where: AdditionalPriceScalarWhereInput
    data: XOR<AdditionalPriceUpdateManyMutationInput, AdditionalPriceUncheckedUpdateManyWithoutShopInput>
  }

  export type AdditionalPriceScalarWhereInput = {
    AND?: AdditionalPriceScalarWhereInput | AdditionalPriceScalarWhereInput[]
    OR?: AdditionalPriceScalarWhereInput[]
    NOT?: AdditionalPriceScalarWhereInput | AdditionalPriceScalarWhereInput[]
    id?: StringFilter<"AdditionalPrice"> | string
    label?: StringNullableFilter<"AdditionalPrice"> | string | null
    price?: FloatFilter<"AdditionalPrice"> | number
    productId?: StringFilter<"AdditionalPrice"> | string
    shopId?: StringNullableFilter<"AdditionalPrice"> | string | null
    createdAt?: DateTimeFilter<"AdditionalPrice"> | Date | string
    updatedAt?: DateTimeFilter<"AdditionalPrice"> | Date | string
  }

  export type SellItemUpsertWithWhereUniqueWithoutShopInput = {
    where: SellItemWhereUniqueInput
    update: XOR<SellItemUpdateWithoutShopInput, SellItemUncheckedUpdateWithoutShopInput>
    create: XOR<SellItemCreateWithoutShopInput, SellItemUncheckedCreateWithoutShopInput>
  }

  export type SellItemUpdateWithWhereUniqueWithoutShopInput = {
    where: SellItemWhereUniqueInput
    data: XOR<SellItemUpdateWithoutShopInput, SellItemUncheckedUpdateWithoutShopInput>
  }

  export type SellItemUpdateManyWithWhereWithoutShopInput = {
    where: SellItemScalarWhereInput
    data: XOR<SellItemUpdateManyMutationInput, SellItemUncheckedUpdateManyWithoutShopInput>
  }

  export type SellItemScalarWhereInput = {
    AND?: SellItemScalarWhereInput | SellItemScalarWhereInput[]
    OR?: SellItemScalarWhereInput[]
    NOT?: SellItemScalarWhereInput | SellItemScalarWhereInput[]
    id?: StringFilter<"SellItem"> | string
    sellId?: StringFilter<"SellItem"> | string
    productId?: StringFilter<"SellItem"> | string
    shopId?: StringFilter<"SellItem"> | string
    unitOfMeasureId?: StringFilter<"SellItem"> | string
    itemSaleStatus?: EnumItemSaleStatusFilter<"SellItem"> | $Enums.ItemSaleStatus
    quantity?: IntFilter<"SellItem"> | number
    unitPrice?: FloatFilter<"SellItem"> | number
    totalPrice?: FloatFilter<"SellItem"> | number
    createdAt?: DateTimeFilter<"SellItem"> | Date | string
    updatedAt?: DateTimeFilter<"SellItem"> | Date | string
  }

  export type SellStockCorrectionItemUpsertWithWhereUniqueWithoutShopInput = {
    where: SellStockCorrectionItemWhereUniqueInput
    update: XOR<SellStockCorrectionItemUpdateWithoutShopInput, SellStockCorrectionItemUncheckedUpdateWithoutShopInput>
    create: XOR<SellStockCorrectionItemCreateWithoutShopInput, SellStockCorrectionItemUncheckedCreateWithoutShopInput>
  }

  export type SellStockCorrectionItemUpdateWithWhereUniqueWithoutShopInput = {
    where: SellStockCorrectionItemWhereUniqueInput
    data: XOR<SellStockCorrectionItemUpdateWithoutShopInput, SellStockCorrectionItemUncheckedUpdateWithoutShopInput>
  }

  export type SellStockCorrectionItemUpdateManyWithWhereWithoutShopInput = {
    where: SellStockCorrectionItemScalarWhereInput
    data: XOR<SellStockCorrectionItemUpdateManyMutationInput, SellStockCorrectionItemUncheckedUpdateManyWithoutShopInput>
  }

  export type SellStockCorrectionItemScalarWhereInput = {
    AND?: SellStockCorrectionItemScalarWhereInput | SellStockCorrectionItemScalarWhereInput[]
    OR?: SellStockCorrectionItemScalarWhereInput[]
    NOT?: SellStockCorrectionItemScalarWhereInput | SellStockCorrectionItemScalarWhereInput[]
    id?: StringFilter<"SellStockCorrectionItem"> | string
    correctionId?: StringFilter<"SellStockCorrectionItem"> | string
    productId?: StringFilter<"SellStockCorrectionItem"> | string
    shopId?: StringNullableFilter<"SellStockCorrectionItem"> | string | null
    unitOfMeasureId?: StringFilter<"SellStockCorrectionItem"> | string
    quantity?: IntFilter<"SellStockCorrectionItem"> | number
    unitPrice?: FloatFilter<"SellStockCorrectionItem"> | number
    totalPrice?: FloatFilter<"SellStockCorrectionItem"> | number
    createdAt?: DateTimeFilter<"SellStockCorrectionItem"> | Date | string
    updatedAt?: DateTimeFilter<"SellStockCorrectionItem"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutShopsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutShopsInput, UserUncheckedUpdateWithoutShopsInput>
    create: XOR<UserCreateWithoutShopsInput, UserUncheckedCreateWithoutShopsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutShopsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutShopsInput, UserUncheckedUpdateWithoutShopsInput>
  }

  export type UserUpdateManyWithWhereWithoutShopsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutShopsInput>
  }

  export type CartItemUpsertWithWhereUniqueWithoutShopInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutShopInput, CartItemUncheckedUpdateWithoutShopInput>
    create: XOR<CartItemCreateWithoutShopInput, CartItemUncheckedCreateWithoutShopInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutShopInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutShopInput, CartItemUncheckedUpdateWithoutShopInput>
  }

  export type CartItemUpdateManyWithWhereWithoutShopInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutShopInput>
  }

  export type CartItemScalarWhereInput = {
    AND?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
    OR?: CartItemScalarWhereInput[]
    NOT?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
    id?: StringFilter<"CartItem"> | string
    cartId?: StringFilter<"CartItem"> | string
    isWaitlist?: BoolFilter<"CartItem"> | boolean
    shopId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    unitOfMeasureId?: StringNullableFilter<"CartItem"> | string | null
    quantity?: IntFilter<"CartItem"> | number
    unitPrice?: FloatFilter<"CartItem"> | number
    totalPrice?: FloatFilter<"CartItem"> | number
    notes?: StringNullableFilter<"CartItem"> | string | null
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
  }

  export type WaitlistUpsertWithWhereUniqueWithoutShopInput = {
    where: WaitlistWhereUniqueInput
    update: XOR<WaitlistUpdateWithoutShopInput, WaitlistUncheckedUpdateWithoutShopInput>
    create: XOR<WaitlistCreateWithoutShopInput, WaitlistUncheckedCreateWithoutShopInput>
  }

  export type WaitlistUpdateWithWhereUniqueWithoutShopInput = {
    where: WaitlistWhereUniqueInput
    data: XOR<WaitlistUpdateWithoutShopInput, WaitlistUncheckedUpdateWithoutShopInput>
  }

  export type WaitlistUpdateManyWithWhereWithoutShopInput = {
    where: WaitlistScalarWhereInput
    data: XOR<WaitlistUpdateManyMutationInput, WaitlistUncheckedUpdateManyWithoutShopInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutShopInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutShopInput, NotificationUncheckedUpdateWithoutShopInput>
    create: XOR<NotificationCreateWithoutShopInput, NotificationUncheckedCreateWithoutShopInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutShopInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutShopInput, NotificationUncheckedUpdateWithoutShopInput>
  }

  export type NotificationUpdateManyWithWhereWithoutShopInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutShopInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    read?: BoolFilter<"Notification"> | boolean
    relatedEntityType?: EnumRelatedEntityTypeNullableFilter<"Notification"> | $Enums.RelatedEntityType | null
    relatedEntityId?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    storeId?: StringNullableFilter<"Notification"> | string | null
    shopId?: StringNullableFilter<"Notification"> | string | null
  }

  export type BranchCreateWithoutStoreInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Shop?: ShopCreateNestedManyWithoutBranchInput
    User?: UserCreateNestedManyWithoutBranchInput
    Sell?: SellCreateNestedManyWithoutBranchInput
    AddToCart?: AddToCartCreateNestedManyWithoutBranchInput
    waitlists?: WaitlistCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutStoreInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Shop?: ShopUncheckedCreateNestedManyWithoutBranchInput
    User?: UserUncheckedCreateNestedManyWithoutBranchInput
    Sell?: SellUncheckedCreateNestedManyWithoutBranchInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutBranchInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutStoreInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutStoreInput, BranchUncheckedCreateWithoutStoreInput>
  }

  export type ProductBatchCreateWithoutStoreInput = {
    id?: string
    batchNumber: string
    expiryDate?: Date | string | null
    price?: number | null
    stock?: number | null
    warningQuantity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutBatchesInput
    ShopStock?: ShopStockCreateNestedManyWithoutBatchInput
    StoreStock?: StoreStockCreateNestedManyWithoutBatchInput
    StockLedger?: StockLedgerCreateNestedManyWithoutBatchInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutBatchInput
    TransferItem?: TransferItemCreateNestedManyWithoutBatchInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutBatchInput
    SellItemBatch?: SellItemBatchCreateNestedManyWithoutBatchInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchCreateNestedManyWithoutBatchInput
  }

  export type ProductBatchUncheckedCreateWithoutStoreInput = {
    id?: string
    batchNumber: string
    expiryDate?: Date | string | null
    productId: string
    price?: number | null
    stock?: number | null
    warningQuantity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutBatchInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutBatchInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutBatchInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutBatchInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutBatchInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutBatchInput
    SellItemBatch?: SellItemBatchUncheckedCreateNestedManyWithoutBatchInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUncheckedCreateNestedManyWithoutBatchInput
  }

  export type ProductBatchCreateOrConnectWithoutStoreInput = {
    where: ProductBatchWhereUniqueInput
    create: XOR<ProductBatchCreateWithoutStoreInput, ProductBatchUncheckedCreateWithoutStoreInput>
  }

  export type ProductBatchCreateManyStoreInputEnvelope = {
    data: ProductBatchCreateManyStoreInput | ProductBatchCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type StoreStockCreateWithoutStoreInput = {
    id?: string
    quantity: number
    status?: $Enums.StockStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    batch: ProductBatchCreateNestedOneWithoutStoreStockInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutStoreStockInput
  }

  export type StoreStockUncheckedCreateWithoutStoreInput = {
    id?: string
    batchId: string
    quantity: number
    status?: $Enums.StockStatus
    unitOfMeasureId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreStockCreateOrConnectWithoutStoreInput = {
    where: StoreStockWhereUniqueInput
    create: XOR<StoreStockCreateWithoutStoreInput, StoreStockUncheckedCreateWithoutStoreInput>
  }

  export type StoreStockCreateManyStoreInputEnvelope = {
    data: StoreStockCreateManyStoreInput | StoreStockCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type StockLedgerCreateWithoutStoreInput = {
    id?: string
    invoiceNo?: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    reference?: string | null
    notes?: string | null
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    batch: ProductBatchCreateNestedOneWithoutStockLedgerInput
    shop?: ShopCreateNestedOneWithoutStockLedgerInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutStockLedgerInput
    user?: UserCreateNestedOneWithoutStockLedgerInput
  }

  export type StockLedgerUncheckedCreateWithoutStoreInput = {
    id?: string
    invoiceNo?: string | null
    batchId: string
    shopId?: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    unitOfMeasureId: string
    reference?: string | null
    userId?: string | null
    notes?: string | null
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockLedgerCreateOrConnectWithoutStoreInput = {
    where: StockLedgerWhereUniqueInput
    create: XOR<StockLedgerCreateWithoutStoreInput, StockLedgerUncheckedCreateWithoutStoreInput>
  }

  export type StockLedgerCreateManyStoreInputEnvelope = {
    data: StockLedgerCreateManyStoreInput | StockLedgerCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseCreateWithoutStoreInput = {
    id?: string
    invoiceNo: string
    paymentStatus?: $Enums.PaymentStatus
    totalProducts?: number
    subTotal?: number
    grandTotal?: number
    notes?: string | null
    purchaseDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutPurchaseInput
    createdBy?: UserCreateNestedOneWithoutCreatorPurchaseInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedPurchaseInput
    items?: PurchaseItemCreateNestedManyWithoutPurchaseInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutStoreInput = {
    id?: string
    invoiceNo: string
    supplierId: string
    paymentStatus?: $Enums.PaymentStatus
    totalProducts?: number
    subTotal?: number
    grandTotal?: number
    notes?: string | null
    purchaseDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseItemUncheckedCreateNestedManyWithoutPurchaseInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutStoreInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutStoreInput, PurchaseUncheckedCreateWithoutStoreInput>
  }

  export type PurchaseCreateManyStoreInputEnvelope = {
    data: PurchaseCreateManyStoreInput | PurchaseCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutSourceStoreInput = {
    id?: string
    shortCode: string
    sourceType: $Enums.TransferEntityType
    destinationType: $Enums.TransferEntityType
    reference?: string | null
    notes?: string | null
    status?: $Enums.TransferStatus
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceShop?: ShopCreateNestedOneWithoutSourceTransferInput
    destStore?: StoreCreateNestedOneWithoutDestinatTransferInput
    destShop?: ShopCreateNestedOneWithoutDestinatTransferInput
    createdBy?: UserCreateNestedOneWithoutCreatedTransferInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedTransferInput
    items?: TransferItemCreateNestedManyWithoutTransferInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutSourceStoreInput = {
    id?: string
    shortCode: string
    sourceType: $Enums.TransferEntityType
    sourceShopId?: string | null
    destinationType: $Enums.TransferEntityType
    destStoreId?: string | null
    destShopId?: string | null
    reference?: string | null
    notes?: string | null
    status?: $Enums.TransferStatus
    movementDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferItemUncheckedCreateNestedManyWithoutTransferInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutSourceStoreInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutSourceStoreInput, TransferUncheckedCreateWithoutSourceStoreInput>
  }

  export type TransferCreateManySourceStoreInputEnvelope = {
    data: TransferCreateManySourceStoreInput | TransferCreateManySourceStoreInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutDestStoreInput = {
    id?: string
    shortCode: string
    sourceType: $Enums.TransferEntityType
    destinationType: $Enums.TransferEntityType
    reference?: string | null
    notes?: string | null
    status?: $Enums.TransferStatus
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceStore?: StoreCreateNestedOneWithoutSourceTransferInput
    sourceShop?: ShopCreateNestedOneWithoutSourceTransferInput
    destShop?: ShopCreateNestedOneWithoutDestinatTransferInput
    createdBy?: UserCreateNestedOneWithoutCreatedTransferInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedTransferInput
    items?: TransferItemCreateNestedManyWithoutTransferInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutDestStoreInput = {
    id?: string
    shortCode: string
    sourceType: $Enums.TransferEntityType
    sourceStoreId?: string | null
    sourceShopId?: string | null
    destinationType: $Enums.TransferEntityType
    destShopId?: string | null
    reference?: string | null
    notes?: string | null
    status?: $Enums.TransferStatus
    movementDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferItemUncheckedCreateNestedManyWithoutTransferInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutDestStoreInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutDestStoreInput, TransferUncheckedCreateWithoutDestStoreInput>
  }

  export type TransferCreateManyDestStoreInputEnvelope = {
    data: TransferCreateManyDestStoreInput | TransferCreateManyDestStoreInput[]
    skipDuplicates?: boolean
  }

  export type StockCorrectionCreateWithoutStoreInput = {
    id?: string
    shortCode: string
    reason: $Enums.StockCorrectionReason
    status?: $Enums.StockCorrectionStatus
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shop?: ShopCreateNestedOneWithoutStockCorrectionInput
    purchase?: PurchaseCreateNestedOneWithoutStockCorrectionInput
    transfer?: TransferCreateNestedOneWithoutStockCorrectionInput
    createdBy?: UserCreateNestedOneWithoutStockCorrectionInput
    updatedBy?: UserCreateNestedOneWithoutUpdateStockCorrectionInput
    items?: StockCorrectionItemCreateNestedManyWithoutCorrectionInput
  }

  export type StockCorrectionUncheckedCreateWithoutStoreInput = {
    id?: string
    shortCode: string
    shopId?: string | null
    reason: $Enums.StockCorrectionReason
    status?: $Enums.StockCorrectionStatus
    purchaseId?: string | null
    transferId?: string | null
    reference?: string | null
    notes?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: StockCorrectionItemUncheckedCreateNestedManyWithoutCorrectionInput
  }

  export type StockCorrectionCreateOrConnectWithoutStoreInput = {
    where: StockCorrectionWhereUniqueInput
    create: XOR<StockCorrectionCreateWithoutStoreInput, StockCorrectionUncheckedCreateWithoutStoreInput>
  }

  export type StockCorrectionCreateManyStoreInputEnvelope = {
    data: StockCorrectionCreateManyStoreInput | StockCorrectionCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutStoresInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    branch?: BranchCreateNestedOneWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    shops?: ShopCreateNestedManyWithoutUserInput
    Log?: LogCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionCreateNestedManyWithoutUpdatedByInput
    Sell?: SellCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutStoresInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    branchId?: string | null
    roleId: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    shops?: ShopUncheckedCreateNestedManyWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseUncheckedCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferUncheckedCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    Sell?: SellUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellUncheckedCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartUncheckedCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartUncheckedCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistUncheckedCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutStoresInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStoresInput, UserUncheckedCreateWithoutStoresInput>
  }

  export type NotificationCreateWithoutStoreInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    read?: boolean
    relatedEntityType?: $Enums.RelatedEntityType | null
    relatedEntityId?: string | null
    createdAt?: Date | string
    readAt?: Date | string | null
    shop?: ShopCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutStoreInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    read?: boolean
    relatedEntityType?: $Enums.RelatedEntityType | null
    relatedEntityId?: string | null
    createdAt?: Date | string
    readAt?: Date | string | null
    shopId?: string | null
  }

  export type NotificationCreateOrConnectWithoutStoreInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutStoreInput, NotificationUncheckedCreateWithoutStoreInput>
  }

  export type NotificationCreateManyStoreInputEnvelope = {
    data: NotificationCreateManyStoreInput | NotificationCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutStoreInput = {
    update: XOR<BranchUpdateWithoutStoreInput, BranchUncheckedUpdateWithoutStoreInput>
    create: XOR<BranchCreateWithoutStoreInput, BranchUncheckedCreateWithoutStoreInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutStoreInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutStoreInput, BranchUncheckedUpdateWithoutStoreInput>
  }

  export type BranchUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Shop?: ShopUpdateManyWithoutBranchNestedInput
    User?: UserUpdateManyWithoutBranchNestedInput
    Sell?: SellUpdateManyWithoutBranchNestedInput
    AddToCart?: AddToCartUpdateManyWithoutBranchNestedInput
    waitlists?: WaitlistUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Shop?: ShopUncheckedUpdateManyWithoutBranchNestedInput
    User?: UserUncheckedUpdateManyWithoutBranchNestedInput
    Sell?: SellUncheckedUpdateManyWithoutBranchNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutBranchNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type ProductBatchUpsertWithWhereUniqueWithoutStoreInput = {
    where: ProductBatchWhereUniqueInput
    update: XOR<ProductBatchUpdateWithoutStoreInput, ProductBatchUncheckedUpdateWithoutStoreInput>
    create: XOR<ProductBatchCreateWithoutStoreInput, ProductBatchUncheckedCreateWithoutStoreInput>
  }

  export type ProductBatchUpdateWithWhereUniqueWithoutStoreInput = {
    where: ProductBatchWhereUniqueInput
    data: XOR<ProductBatchUpdateWithoutStoreInput, ProductBatchUncheckedUpdateWithoutStoreInput>
  }

  export type ProductBatchUpdateManyWithWhereWithoutStoreInput = {
    where: ProductBatchScalarWhereInput
    data: XOR<ProductBatchUpdateManyMutationInput, ProductBatchUncheckedUpdateManyWithoutStoreInput>
  }

  export type ProductBatchScalarWhereInput = {
    AND?: ProductBatchScalarWhereInput | ProductBatchScalarWhereInput[]
    OR?: ProductBatchScalarWhereInput[]
    NOT?: ProductBatchScalarWhereInput | ProductBatchScalarWhereInput[]
    id?: StringFilter<"ProductBatch"> | string
    batchNumber?: StringFilter<"ProductBatch"> | string
    expiryDate?: DateTimeNullableFilter<"ProductBatch"> | Date | string | null
    productId?: StringFilter<"ProductBatch"> | string
    price?: FloatNullableFilter<"ProductBatch"> | number | null
    stock?: IntNullableFilter<"ProductBatch"> | number | null
    warningQuantity?: IntNullableFilter<"ProductBatch"> | number | null
    storeId?: StringNullableFilter<"ProductBatch"> | string | null
    createdAt?: DateTimeFilter<"ProductBatch"> | Date | string
    updatedAt?: DateTimeFilter<"ProductBatch"> | Date | string
  }

  export type StoreStockUpsertWithWhereUniqueWithoutStoreInput = {
    where: StoreStockWhereUniqueInput
    update: XOR<StoreStockUpdateWithoutStoreInput, StoreStockUncheckedUpdateWithoutStoreInput>
    create: XOR<StoreStockCreateWithoutStoreInput, StoreStockUncheckedCreateWithoutStoreInput>
  }

  export type StoreStockUpdateWithWhereUniqueWithoutStoreInput = {
    where: StoreStockWhereUniqueInput
    data: XOR<StoreStockUpdateWithoutStoreInput, StoreStockUncheckedUpdateWithoutStoreInput>
  }

  export type StoreStockUpdateManyWithWhereWithoutStoreInput = {
    where: StoreStockScalarWhereInput
    data: XOR<StoreStockUpdateManyMutationInput, StoreStockUncheckedUpdateManyWithoutStoreInput>
  }

  export type StoreStockScalarWhereInput = {
    AND?: StoreStockScalarWhereInput | StoreStockScalarWhereInput[]
    OR?: StoreStockScalarWhereInput[]
    NOT?: StoreStockScalarWhereInput | StoreStockScalarWhereInput[]
    id?: StringFilter<"StoreStock"> | string
    storeId?: StringFilter<"StoreStock"> | string
    batchId?: StringFilter<"StoreStock"> | string
    quantity?: IntFilter<"StoreStock"> | number
    status?: EnumStockStatusFilter<"StoreStock"> | $Enums.StockStatus
    unitOfMeasureId?: StringFilter<"StoreStock"> | string
    createdAt?: DateTimeFilter<"StoreStock"> | Date | string
    updatedAt?: DateTimeFilter<"StoreStock"> | Date | string
  }

  export type StockLedgerUpsertWithWhereUniqueWithoutStoreInput = {
    where: StockLedgerWhereUniqueInput
    update: XOR<StockLedgerUpdateWithoutStoreInput, StockLedgerUncheckedUpdateWithoutStoreInput>
    create: XOR<StockLedgerCreateWithoutStoreInput, StockLedgerUncheckedCreateWithoutStoreInput>
  }

  export type StockLedgerUpdateWithWhereUniqueWithoutStoreInput = {
    where: StockLedgerWhereUniqueInput
    data: XOR<StockLedgerUpdateWithoutStoreInput, StockLedgerUncheckedUpdateWithoutStoreInput>
  }

  export type StockLedgerUpdateManyWithWhereWithoutStoreInput = {
    where: StockLedgerScalarWhereInput
    data: XOR<StockLedgerUpdateManyMutationInput, StockLedgerUncheckedUpdateManyWithoutStoreInput>
  }

  export type PurchaseUpsertWithWhereUniqueWithoutStoreInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutStoreInput, PurchaseUncheckedUpdateWithoutStoreInput>
    create: XOR<PurchaseCreateWithoutStoreInput, PurchaseUncheckedCreateWithoutStoreInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutStoreInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutStoreInput, PurchaseUncheckedUpdateWithoutStoreInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutStoreInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutStoreInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutSourceStoreInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutSourceStoreInput, TransferUncheckedUpdateWithoutSourceStoreInput>
    create: XOR<TransferCreateWithoutSourceStoreInput, TransferUncheckedCreateWithoutSourceStoreInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutSourceStoreInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutSourceStoreInput, TransferUncheckedUpdateWithoutSourceStoreInput>
  }

  export type TransferUpdateManyWithWhereWithoutSourceStoreInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutSourceStoreInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutDestStoreInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutDestStoreInput, TransferUncheckedUpdateWithoutDestStoreInput>
    create: XOR<TransferCreateWithoutDestStoreInput, TransferUncheckedCreateWithoutDestStoreInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutDestStoreInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutDestStoreInput, TransferUncheckedUpdateWithoutDestStoreInput>
  }

  export type TransferUpdateManyWithWhereWithoutDestStoreInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutDestStoreInput>
  }

  export type StockCorrectionUpsertWithWhereUniqueWithoutStoreInput = {
    where: StockCorrectionWhereUniqueInput
    update: XOR<StockCorrectionUpdateWithoutStoreInput, StockCorrectionUncheckedUpdateWithoutStoreInput>
    create: XOR<StockCorrectionCreateWithoutStoreInput, StockCorrectionUncheckedCreateWithoutStoreInput>
  }

  export type StockCorrectionUpdateWithWhereUniqueWithoutStoreInput = {
    where: StockCorrectionWhereUniqueInput
    data: XOR<StockCorrectionUpdateWithoutStoreInput, StockCorrectionUncheckedUpdateWithoutStoreInput>
  }

  export type StockCorrectionUpdateManyWithWhereWithoutStoreInput = {
    where: StockCorrectionScalarWhereInput
    data: XOR<StockCorrectionUpdateManyMutationInput, StockCorrectionUncheckedUpdateManyWithoutStoreInput>
  }

  export type UserUpsertWithWhereUniqueWithoutStoresInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutStoresInput, UserUncheckedUpdateWithoutStoresInput>
    create: XOR<UserCreateWithoutStoresInput, UserUncheckedCreateWithoutStoresInput>
  }

  export type UserUpdateWithWhereUniqueWithoutStoresInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutStoresInput, UserUncheckedUpdateWithoutStoresInput>
  }

  export type UserUpdateManyWithWhereWithoutStoresInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutStoresInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutStoreInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutStoreInput, NotificationUncheckedUpdateWithoutStoreInput>
    create: XOR<NotificationCreateWithoutStoreInput, NotificationUncheckedCreateWithoutStoreInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutStoreInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutStoreInput, NotificationUncheckedUpdateWithoutStoreInput>
  }

  export type NotificationUpdateManyWithWhereWithoutStoreInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutStoreInput>
  }

  export type StoreCreateWithoutStoreStockInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutStoreInput
    ProductBatch?: ProductBatchCreateNestedManyWithoutStoreInput
    StockLedger?: StockLedgerCreateNestedManyWithoutStoreInput
    Purchase?: PurchaseCreateNestedManyWithoutStoreInput
    SourceTransfer?: TransferCreateNestedManyWithoutSourceStoreInput
    DestinatTransfer?: TransferCreateNestedManyWithoutDestStoreInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutStoreInput
    User?: UserCreateNestedManyWithoutStoresInput
    notifications?: NotificationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutStoreStockInput = {
    id?: string
    name: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ProductBatch?: ProductBatchUncheckedCreateNestedManyWithoutStoreInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutStoreInput
    Purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    SourceTransfer?: TransferUncheckedCreateNestedManyWithoutSourceStoreInput
    DestinatTransfer?: TransferUncheckedCreateNestedManyWithoutDestStoreInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutStoreInput
    User?: UserUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutStoreStockInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutStoreStockInput, StoreUncheckedCreateWithoutStoreStockInput>
  }

  export type ProductBatchCreateWithoutStoreStockInput = {
    id?: string
    batchNumber: string
    expiryDate?: Date | string | null
    price?: number | null
    stock?: number | null
    warningQuantity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store?: StoreCreateNestedOneWithoutProductBatchInput
    product: ProductCreateNestedOneWithoutBatchesInput
    ShopStock?: ShopStockCreateNestedManyWithoutBatchInput
    StockLedger?: StockLedgerCreateNestedManyWithoutBatchInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutBatchInput
    TransferItem?: TransferItemCreateNestedManyWithoutBatchInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutBatchInput
    SellItemBatch?: SellItemBatchCreateNestedManyWithoutBatchInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchCreateNestedManyWithoutBatchInput
  }

  export type ProductBatchUncheckedCreateWithoutStoreStockInput = {
    id?: string
    batchNumber: string
    expiryDate?: Date | string | null
    productId: string
    price?: number | null
    stock?: number | null
    warningQuantity?: number | null
    storeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutBatchInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutBatchInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutBatchInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutBatchInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutBatchInput
    SellItemBatch?: SellItemBatchUncheckedCreateNestedManyWithoutBatchInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUncheckedCreateNestedManyWithoutBatchInput
  }

  export type ProductBatchCreateOrConnectWithoutStoreStockInput = {
    where: ProductBatchWhereUniqueInput
    create: XOR<ProductBatchCreateWithoutStoreStockInput, ProductBatchUncheckedCreateWithoutStoreStockInput>
  }

  export type UnitOfMeasureCreateWithoutStoreStockInput = {
    id?: string
    name: string
    symbol?: string | null
    base?: boolean
    products?: ProductCreateNestedManyWithoutUnitOfMeasureInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutUnitOfMeasureInput
    TransferItem?: TransferItemCreateNestedManyWithoutUnitOfMeasureInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUnitOfMeasureInput
    ShopStock?: ShopStockCreateNestedManyWithoutUnitOfMeasureInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutUnitOfMeasureInput
    SellItem?: SellItemCreateNestedManyWithoutUnitOfMeasureInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutUnitOfMeasureInput
    CartItem?: CartItemCreateNestedManyWithoutUnitOfMeasureInput
  }

  export type UnitOfMeasureUncheckedCreateWithoutStoreStockInput = {
    id?: string
    name: string
    symbol?: string | null
    base?: boolean
    products?: ProductUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
  }

  export type UnitOfMeasureCreateOrConnectWithoutStoreStockInput = {
    where: UnitOfMeasureWhereUniqueInput
    create: XOR<UnitOfMeasureCreateWithoutStoreStockInput, UnitOfMeasureUncheckedCreateWithoutStoreStockInput>
  }

  export type StoreUpsertWithoutStoreStockInput = {
    update: XOR<StoreUpdateWithoutStoreStockInput, StoreUncheckedUpdateWithoutStoreStockInput>
    create: XOR<StoreCreateWithoutStoreStockInput, StoreUncheckedCreateWithoutStoreStockInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutStoreStockInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutStoreStockInput, StoreUncheckedUpdateWithoutStoreStockInput>
  }

  export type StoreUpdateWithoutStoreStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStoreNestedInput
    ProductBatch?: ProductBatchUpdateManyWithoutStoreNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutStoreNestedInput
    Purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    SourceTransfer?: TransferUpdateManyWithoutSourceStoreNestedInput
    DestinatTransfer?: TransferUpdateManyWithoutDestStoreNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutStoreNestedInput
    User?: UserUpdateManyWithoutStoresNestedInput
    notifications?: NotificationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutStoreStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductBatch?: ProductBatchUncheckedUpdateManyWithoutStoreNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutStoreNestedInput
    Purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    SourceTransfer?: TransferUncheckedUpdateManyWithoutSourceStoreNestedInput
    DestinatTransfer?: TransferUncheckedUpdateManyWithoutDestStoreNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutStoreNestedInput
    User?: UserUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type ProductBatchUpsertWithoutStoreStockInput = {
    update: XOR<ProductBatchUpdateWithoutStoreStockInput, ProductBatchUncheckedUpdateWithoutStoreStockInput>
    create: XOR<ProductBatchCreateWithoutStoreStockInput, ProductBatchUncheckedCreateWithoutStoreStockInput>
    where?: ProductBatchWhereInput
  }

  export type ProductBatchUpdateToOneWithWhereWithoutStoreStockInput = {
    where?: ProductBatchWhereInput
    data: XOR<ProductBatchUpdateWithoutStoreStockInput, ProductBatchUncheckedUpdateWithoutStoreStockInput>
  }

  export type ProductBatchUpdateWithoutStoreStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    warningQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneWithoutProductBatchNestedInput
    product?: ProductUpdateOneRequiredWithoutBatchesNestedInput
    ShopStock?: ShopStockUpdateManyWithoutBatchNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutBatchNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutBatchNestedInput
    TransferItem?: TransferItemUpdateManyWithoutBatchNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutBatchNestedInput
    SellItemBatch?: SellItemBatchUpdateManyWithoutBatchNestedInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUpdateManyWithoutBatchNestedInput
  }

  export type ProductBatchUncheckedUpdateWithoutStoreStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productId?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    warningQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopStock?: ShopStockUncheckedUpdateManyWithoutBatchNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutBatchNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutBatchNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutBatchNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutBatchNestedInput
    SellItemBatch?: SellItemBatchUncheckedUpdateManyWithoutBatchNestedInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type UnitOfMeasureUpsertWithoutStoreStockInput = {
    update: XOR<UnitOfMeasureUpdateWithoutStoreStockInput, UnitOfMeasureUncheckedUpdateWithoutStoreStockInput>
    create: XOR<UnitOfMeasureCreateWithoutStoreStockInput, UnitOfMeasureUncheckedCreateWithoutStoreStockInput>
    where?: UnitOfMeasureWhereInput
  }

  export type UnitOfMeasureUpdateToOneWithWhereWithoutStoreStockInput = {
    where?: UnitOfMeasureWhereInput
    data: XOR<UnitOfMeasureUpdateWithoutStoreStockInput, UnitOfMeasureUncheckedUpdateWithoutStoreStockInput>
  }

  export type UnitOfMeasureUpdateWithoutStoreStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    base?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductUpdateManyWithoutUnitOfMeasureNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutUnitOfMeasureNestedInput
    TransferItem?: TransferItemUpdateManyWithoutUnitOfMeasureNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUnitOfMeasureNestedInput
    ShopStock?: ShopStockUpdateManyWithoutUnitOfMeasureNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutUnitOfMeasureNestedInput
    SellItem?: SellItemUpdateManyWithoutUnitOfMeasureNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutUnitOfMeasureNestedInput
    CartItem?: CartItemUpdateManyWithoutUnitOfMeasureNestedInput
  }

  export type UnitOfMeasureUncheckedUpdateWithoutStoreStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    base?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    ShopStock?: ShopStockUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
  }

  export type ShopCreateWithoutShopStockInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutShopInput
    StockLedger?: StockLedgerCreateNestedManyWithoutShopInput
    SourceTransfer?: TransferCreateNestedManyWithoutSourceShopInput
    DestinatTransfer?: TransferCreateNestedManyWithoutDestShopInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutShopInput
    AdditionalPrice?: AdditionalPriceCreateNestedManyWithoutShopInput
    SellItem?: SellItemCreateNestedManyWithoutShopInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutShopInput
    User?: UserCreateNestedManyWithoutShopsInput
    CartItem?: CartItemCreateNestedManyWithoutShopInput
    waitlists?: WaitlistCreateNestedManyWithoutShopInput
    notifications?: NotificationCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutShopStockInput = {
    id?: string
    name: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutShopInput
    SourceTransfer?: TransferUncheckedCreateNestedManyWithoutSourceShopInput
    DestinatTransfer?: TransferUncheckedCreateNestedManyWithoutDestShopInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutShopInput
    AdditionalPrice?: AdditionalPriceUncheckedCreateNestedManyWithoutShopInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutShopInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutShopInput
    User?: UserUncheckedCreateNestedManyWithoutShopsInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutShopInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutShopInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutShopStockInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutShopStockInput, ShopUncheckedCreateWithoutShopStockInput>
  }

  export type ProductBatchCreateWithoutShopStockInput = {
    id?: string
    batchNumber: string
    expiryDate?: Date | string | null
    price?: number | null
    stock?: number | null
    warningQuantity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store?: StoreCreateNestedOneWithoutProductBatchInput
    product: ProductCreateNestedOneWithoutBatchesInput
    StoreStock?: StoreStockCreateNestedManyWithoutBatchInput
    StockLedger?: StockLedgerCreateNestedManyWithoutBatchInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutBatchInput
    TransferItem?: TransferItemCreateNestedManyWithoutBatchInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutBatchInput
    SellItemBatch?: SellItemBatchCreateNestedManyWithoutBatchInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchCreateNestedManyWithoutBatchInput
  }

  export type ProductBatchUncheckedCreateWithoutShopStockInput = {
    id?: string
    batchNumber: string
    expiryDate?: Date | string | null
    productId: string
    price?: number | null
    stock?: number | null
    warningQuantity?: number | null
    storeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutBatchInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutBatchInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutBatchInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutBatchInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutBatchInput
    SellItemBatch?: SellItemBatchUncheckedCreateNestedManyWithoutBatchInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUncheckedCreateNestedManyWithoutBatchInput
  }

  export type ProductBatchCreateOrConnectWithoutShopStockInput = {
    where: ProductBatchWhereUniqueInput
    create: XOR<ProductBatchCreateWithoutShopStockInput, ProductBatchUncheckedCreateWithoutShopStockInput>
  }

  export type UnitOfMeasureCreateWithoutShopStockInput = {
    id?: string
    name: string
    symbol?: string | null
    base?: boolean
    products?: ProductCreateNestedManyWithoutUnitOfMeasureInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutUnitOfMeasureInput
    TransferItem?: TransferItemCreateNestedManyWithoutUnitOfMeasureInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUnitOfMeasureInput
    StoreStock?: StoreStockCreateNestedManyWithoutUnitOfMeasureInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutUnitOfMeasureInput
    SellItem?: SellItemCreateNestedManyWithoutUnitOfMeasureInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutUnitOfMeasureInput
    CartItem?: CartItemCreateNestedManyWithoutUnitOfMeasureInput
  }

  export type UnitOfMeasureUncheckedCreateWithoutShopStockInput = {
    id?: string
    name: string
    symbol?: string | null
    base?: boolean
    products?: ProductUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
  }

  export type UnitOfMeasureCreateOrConnectWithoutShopStockInput = {
    where: UnitOfMeasureWhereUniqueInput
    create: XOR<UnitOfMeasureCreateWithoutShopStockInput, UnitOfMeasureUncheckedCreateWithoutShopStockInput>
  }

  export type ShopUpsertWithoutShopStockInput = {
    update: XOR<ShopUpdateWithoutShopStockInput, ShopUncheckedUpdateWithoutShopStockInput>
    create: XOR<ShopCreateWithoutShopStockInput, ShopUncheckedCreateWithoutShopStockInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutShopStockInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutShopStockInput, ShopUncheckedUpdateWithoutShopStockInput>
  }

  export type ShopUpdateWithoutShopStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutShopNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutShopNestedInput
    SourceTransfer?: TransferUpdateManyWithoutSourceShopNestedInput
    DestinatTransfer?: TransferUpdateManyWithoutDestShopNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutShopNestedInput
    AdditionalPrice?: AdditionalPriceUpdateManyWithoutShopNestedInput
    SellItem?: SellItemUpdateManyWithoutShopNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutShopNestedInput
    User?: UserUpdateManyWithoutShopsNestedInput
    CartItem?: CartItemUpdateManyWithoutShopNestedInput
    waitlists?: WaitlistUpdateManyWithoutShopNestedInput
    notifications?: NotificationUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutShopStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutShopNestedInput
    SourceTransfer?: TransferUncheckedUpdateManyWithoutSourceShopNestedInput
    DestinatTransfer?: TransferUncheckedUpdateManyWithoutDestShopNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutShopNestedInput
    AdditionalPrice?: AdditionalPriceUncheckedUpdateManyWithoutShopNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutShopNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutShopNestedInput
    User?: UserUncheckedUpdateManyWithoutShopsNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutShopNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutShopNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ProductBatchUpsertWithoutShopStockInput = {
    update: XOR<ProductBatchUpdateWithoutShopStockInput, ProductBatchUncheckedUpdateWithoutShopStockInput>
    create: XOR<ProductBatchCreateWithoutShopStockInput, ProductBatchUncheckedCreateWithoutShopStockInput>
    where?: ProductBatchWhereInput
  }

  export type ProductBatchUpdateToOneWithWhereWithoutShopStockInput = {
    where?: ProductBatchWhereInput
    data: XOR<ProductBatchUpdateWithoutShopStockInput, ProductBatchUncheckedUpdateWithoutShopStockInput>
  }

  export type ProductBatchUpdateWithoutShopStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    warningQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneWithoutProductBatchNestedInput
    product?: ProductUpdateOneRequiredWithoutBatchesNestedInput
    StoreStock?: StoreStockUpdateManyWithoutBatchNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutBatchNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutBatchNestedInput
    TransferItem?: TransferItemUpdateManyWithoutBatchNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutBatchNestedInput
    SellItemBatch?: SellItemBatchUpdateManyWithoutBatchNestedInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUpdateManyWithoutBatchNestedInput
  }

  export type ProductBatchUncheckedUpdateWithoutShopStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productId?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    warningQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StoreStock?: StoreStockUncheckedUpdateManyWithoutBatchNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutBatchNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutBatchNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutBatchNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutBatchNestedInput
    SellItemBatch?: SellItemBatchUncheckedUpdateManyWithoutBatchNestedInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type UnitOfMeasureUpsertWithoutShopStockInput = {
    update: XOR<UnitOfMeasureUpdateWithoutShopStockInput, UnitOfMeasureUncheckedUpdateWithoutShopStockInput>
    create: XOR<UnitOfMeasureCreateWithoutShopStockInput, UnitOfMeasureUncheckedCreateWithoutShopStockInput>
    where?: UnitOfMeasureWhereInput
  }

  export type UnitOfMeasureUpdateToOneWithWhereWithoutShopStockInput = {
    where?: UnitOfMeasureWhereInput
    data: XOR<UnitOfMeasureUpdateWithoutShopStockInput, UnitOfMeasureUncheckedUpdateWithoutShopStockInput>
  }

  export type UnitOfMeasureUpdateWithoutShopStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    base?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductUpdateManyWithoutUnitOfMeasureNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutUnitOfMeasureNestedInput
    TransferItem?: TransferItemUpdateManyWithoutUnitOfMeasureNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUnitOfMeasureNestedInput
    StoreStock?: StoreStockUpdateManyWithoutUnitOfMeasureNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutUnitOfMeasureNestedInput
    SellItem?: SellItemUpdateManyWithoutUnitOfMeasureNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutUnitOfMeasureNestedInput
    CartItem?: CartItemUpdateManyWithoutUnitOfMeasureNestedInput
  }

  export type UnitOfMeasureUncheckedUpdateWithoutShopStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    base?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
  }

  export type ProductBatchCreateWithoutStockLedgerInput = {
    id?: string
    batchNumber: string
    expiryDate?: Date | string | null
    price?: number | null
    stock?: number | null
    warningQuantity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store?: StoreCreateNestedOneWithoutProductBatchInput
    product: ProductCreateNestedOneWithoutBatchesInput
    ShopStock?: ShopStockCreateNestedManyWithoutBatchInput
    StoreStock?: StoreStockCreateNestedManyWithoutBatchInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutBatchInput
    TransferItem?: TransferItemCreateNestedManyWithoutBatchInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutBatchInput
    SellItemBatch?: SellItemBatchCreateNestedManyWithoutBatchInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchCreateNestedManyWithoutBatchInput
  }

  export type ProductBatchUncheckedCreateWithoutStockLedgerInput = {
    id?: string
    batchNumber: string
    expiryDate?: Date | string | null
    productId: string
    price?: number | null
    stock?: number | null
    warningQuantity?: number | null
    storeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutBatchInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutBatchInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutBatchInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutBatchInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutBatchInput
    SellItemBatch?: SellItemBatchUncheckedCreateNestedManyWithoutBatchInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUncheckedCreateNestedManyWithoutBatchInput
  }

  export type ProductBatchCreateOrConnectWithoutStockLedgerInput = {
    where: ProductBatchWhereUniqueInput
    create: XOR<ProductBatchCreateWithoutStockLedgerInput, ProductBatchUncheckedCreateWithoutStockLedgerInput>
  }

  export type StoreCreateWithoutStockLedgerInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutStoreInput
    ProductBatch?: ProductBatchCreateNestedManyWithoutStoreInput
    StoreStock?: StoreStockCreateNestedManyWithoutStoreInput
    Purchase?: PurchaseCreateNestedManyWithoutStoreInput
    SourceTransfer?: TransferCreateNestedManyWithoutSourceStoreInput
    DestinatTransfer?: TransferCreateNestedManyWithoutDestStoreInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutStoreInput
    User?: UserCreateNestedManyWithoutStoresInput
    notifications?: NotificationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutStockLedgerInput = {
    id?: string
    name: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ProductBatch?: ProductBatchUncheckedCreateNestedManyWithoutStoreInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutStoreInput
    Purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    SourceTransfer?: TransferUncheckedCreateNestedManyWithoutSourceStoreInput
    DestinatTransfer?: TransferUncheckedCreateNestedManyWithoutDestStoreInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutStoreInput
    User?: UserUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutStockLedgerInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutStockLedgerInput, StoreUncheckedCreateWithoutStockLedgerInput>
  }

  export type ShopCreateWithoutStockLedgerInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutShopInput
    ShopStock?: ShopStockCreateNestedManyWithoutShopInput
    SourceTransfer?: TransferCreateNestedManyWithoutSourceShopInput
    DestinatTransfer?: TransferCreateNestedManyWithoutDestShopInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutShopInput
    AdditionalPrice?: AdditionalPriceCreateNestedManyWithoutShopInput
    SellItem?: SellItemCreateNestedManyWithoutShopInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutShopInput
    User?: UserCreateNestedManyWithoutShopsInput
    CartItem?: CartItemCreateNestedManyWithoutShopInput
    waitlists?: WaitlistCreateNestedManyWithoutShopInput
    notifications?: NotificationCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutStockLedgerInput = {
    id?: string
    name: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutShopInput
    SourceTransfer?: TransferUncheckedCreateNestedManyWithoutSourceShopInput
    DestinatTransfer?: TransferUncheckedCreateNestedManyWithoutDestShopInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutShopInput
    AdditionalPrice?: AdditionalPriceUncheckedCreateNestedManyWithoutShopInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutShopInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutShopInput
    User?: UserUncheckedCreateNestedManyWithoutShopsInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutShopInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutShopInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutStockLedgerInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutStockLedgerInput, ShopUncheckedCreateWithoutStockLedgerInput>
  }

  export type UnitOfMeasureCreateWithoutStockLedgerInput = {
    id?: string
    name: string
    symbol?: string | null
    base?: boolean
    products?: ProductCreateNestedManyWithoutUnitOfMeasureInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutUnitOfMeasureInput
    TransferItem?: TransferItemCreateNestedManyWithoutUnitOfMeasureInput
    ShopStock?: ShopStockCreateNestedManyWithoutUnitOfMeasureInput
    StoreStock?: StoreStockCreateNestedManyWithoutUnitOfMeasureInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutUnitOfMeasureInput
    SellItem?: SellItemCreateNestedManyWithoutUnitOfMeasureInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutUnitOfMeasureInput
    CartItem?: CartItemCreateNestedManyWithoutUnitOfMeasureInput
  }

  export type UnitOfMeasureUncheckedCreateWithoutStockLedgerInput = {
    id?: string
    name: string
    symbol?: string | null
    base?: boolean
    products?: ProductUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
  }

  export type UnitOfMeasureCreateOrConnectWithoutStockLedgerInput = {
    where: UnitOfMeasureWhereUniqueInput
    create: XOR<UnitOfMeasureCreateWithoutStockLedgerInput, UnitOfMeasureUncheckedCreateWithoutStockLedgerInput>
  }

  export type UserCreateWithoutStockLedgerInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    branch?: BranchCreateNestedOneWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    shops?: ShopCreateNestedManyWithoutUserInput
    stores?: StoreCreateNestedManyWithoutUserInput
    Log?: LogCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionCreateNestedManyWithoutUpdatedByInput
    Sell?: SellCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutStockLedgerInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    branchId?: string | null
    roleId: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    shops?: ShopUncheckedCreateNestedManyWithoutUserInput
    stores?: StoreUncheckedCreateNestedManyWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseUncheckedCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferUncheckedCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    Sell?: SellUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellUncheckedCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartUncheckedCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartUncheckedCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistUncheckedCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutStockLedgerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStockLedgerInput, UserUncheckedCreateWithoutStockLedgerInput>
  }

  export type ProductBatchUpsertWithoutStockLedgerInput = {
    update: XOR<ProductBatchUpdateWithoutStockLedgerInput, ProductBatchUncheckedUpdateWithoutStockLedgerInput>
    create: XOR<ProductBatchCreateWithoutStockLedgerInput, ProductBatchUncheckedCreateWithoutStockLedgerInput>
    where?: ProductBatchWhereInput
  }

  export type ProductBatchUpdateToOneWithWhereWithoutStockLedgerInput = {
    where?: ProductBatchWhereInput
    data: XOR<ProductBatchUpdateWithoutStockLedgerInput, ProductBatchUncheckedUpdateWithoutStockLedgerInput>
  }

  export type ProductBatchUpdateWithoutStockLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    warningQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneWithoutProductBatchNestedInput
    product?: ProductUpdateOneRequiredWithoutBatchesNestedInput
    ShopStock?: ShopStockUpdateManyWithoutBatchNestedInput
    StoreStock?: StoreStockUpdateManyWithoutBatchNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutBatchNestedInput
    TransferItem?: TransferItemUpdateManyWithoutBatchNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutBatchNestedInput
    SellItemBatch?: SellItemBatchUpdateManyWithoutBatchNestedInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUpdateManyWithoutBatchNestedInput
  }

  export type ProductBatchUncheckedUpdateWithoutStockLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productId?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    warningQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopStock?: ShopStockUncheckedUpdateManyWithoutBatchNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutBatchNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutBatchNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutBatchNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutBatchNestedInput
    SellItemBatch?: SellItemBatchUncheckedUpdateManyWithoutBatchNestedInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type StoreUpsertWithoutStockLedgerInput = {
    update: XOR<StoreUpdateWithoutStockLedgerInput, StoreUncheckedUpdateWithoutStockLedgerInput>
    create: XOR<StoreCreateWithoutStockLedgerInput, StoreUncheckedCreateWithoutStockLedgerInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutStockLedgerInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutStockLedgerInput, StoreUncheckedUpdateWithoutStockLedgerInput>
  }

  export type StoreUpdateWithoutStockLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStoreNestedInput
    ProductBatch?: ProductBatchUpdateManyWithoutStoreNestedInput
    StoreStock?: StoreStockUpdateManyWithoutStoreNestedInput
    Purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    SourceTransfer?: TransferUpdateManyWithoutSourceStoreNestedInput
    DestinatTransfer?: TransferUpdateManyWithoutDestStoreNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutStoreNestedInput
    User?: UserUpdateManyWithoutStoresNestedInput
    notifications?: NotificationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutStockLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductBatch?: ProductBatchUncheckedUpdateManyWithoutStoreNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutStoreNestedInput
    Purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    SourceTransfer?: TransferUncheckedUpdateManyWithoutSourceStoreNestedInput
    DestinatTransfer?: TransferUncheckedUpdateManyWithoutDestStoreNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutStoreNestedInput
    User?: UserUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type ShopUpsertWithoutStockLedgerInput = {
    update: XOR<ShopUpdateWithoutStockLedgerInput, ShopUncheckedUpdateWithoutStockLedgerInput>
    create: XOR<ShopCreateWithoutStockLedgerInput, ShopUncheckedCreateWithoutStockLedgerInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutStockLedgerInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutStockLedgerInput, ShopUncheckedUpdateWithoutStockLedgerInput>
  }

  export type ShopUpdateWithoutStockLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutShopNestedInput
    ShopStock?: ShopStockUpdateManyWithoutShopNestedInput
    SourceTransfer?: TransferUpdateManyWithoutSourceShopNestedInput
    DestinatTransfer?: TransferUpdateManyWithoutDestShopNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutShopNestedInput
    AdditionalPrice?: AdditionalPriceUpdateManyWithoutShopNestedInput
    SellItem?: SellItemUpdateManyWithoutShopNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutShopNestedInput
    User?: UserUpdateManyWithoutShopsNestedInput
    CartItem?: CartItemUpdateManyWithoutShopNestedInput
    waitlists?: WaitlistUpdateManyWithoutShopNestedInput
    notifications?: NotificationUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutStockLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopStock?: ShopStockUncheckedUpdateManyWithoutShopNestedInput
    SourceTransfer?: TransferUncheckedUpdateManyWithoutSourceShopNestedInput
    DestinatTransfer?: TransferUncheckedUpdateManyWithoutDestShopNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutShopNestedInput
    AdditionalPrice?: AdditionalPriceUncheckedUpdateManyWithoutShopNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutShopNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutShopNestedInput
    User?: UserUncheckedUpdateManyWithoutShopsNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutShopNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutShopNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutShopNestedInput
  }

  export type UnitOfMeasureUpsertWithoutStockLedgerInput = {
    update: XOR<UnitOfMeasureUpdateWithoutStockLedgerInput, UnitOfMeasureUncheckedUpdateWithoutStockLedgerInput>
    create: XOR<UnitOfMeasureCreateWithoutStockLedgerInput, UnitOfMeasureUncheckedCreateWithoutStockLedgerInput>
    where?: UnitOfMeasureWhereInput
  }

  export type UnitOfMeasureUpdateToOneWithWhereWithoutStockLedgerInput = {
    where?: UnitOfMeasureWhereInput
    data: XOR<UnitOfMeasureUpdateWithoutStockLedgerInput, UnitOfMeasureUncheckedUpdateWithoutStockLedgerInput>
  }

  export type UnitOfMeasureUpdateWithoutStockLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    base?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductUpdateManyWithoutUnitOfMeasureNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutUnitOfMeasureNestedInput
    TransferItem?: TransferItemUpdateManyWithoutUnitOfMeasureNestedInput
    ShopStock?: ShopStockUpdateManyWithoutUnitOfMeasureNestedInput
    StoreStock?: StoreStockUpdateManyWithoutUnitOfMeasureNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutUnitOfMeasureNestedInput
    SellItem?: SellItemUpdateManyWithoutUnitOfMeasureNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutUnitOfMeasureNestedInput
    CartItem?: CartItemUpdateManyWithoutUnitOfMeasureNestedInput
  }

  export type UnitOfMeasureUncheckedUpdateWithoutStockLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    base?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    ShopStock?: ShopStockUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
  }

  export type UserUpsertWithoutStockLedgerInput = {
    update: XOR<UserUpdateWithoutStockLedgerInput, UserUncheckedUpdateWithoutStockLedgerInput>
    create: XOR<UserCreateWithoutStockLedgerInput, UserUncheckedCreateWithoutStockLedgerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStockLedgerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStockLedgerInput, UserUncheckedUpdateWithoutStockLedgerInput>
  }

  export type UserUpdateWithoutStockLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: BranchUpdateOneWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    shops?: ShopUpdateManyWithoutUserNestedInput
    stores?: StoreUpdateManyWithoutUserNestedInput
    Log?: LogUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutStockLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shops?: ShopUncheckedUpdateManyWithoutUserNestedInput
    stores?: StoreUncheckedUpdateManyWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUncheckedUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUncheckedUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUncheckedUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUncheckedUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUncheckedUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUncheckedUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserCreateWithoutLogInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    branch?: BranchCreateNestedOneWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    shops?: ShopCreateNestedManyWithoutUserInput
    stores?: StoreCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionCreateNestedManyWithoutUpdatedByInput
    Sell?: SellCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutLogInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    branchId?: string | null
    roleId: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    shops?: ShopUncheckedCreateNestedManyWithoutUserInput
    stores?: StoreUncheckedCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseUncheckedCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferUncheckedCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    Sell?: SellUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellUncheckedCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartUncheckedCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartUncheckedCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistUncheckedCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutLogInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogInput, UserUncheckedCreateWithoutLogInput>
  }

  export type UserUpsertWithoutLogInput = {
    update: XOR<UserUpdateWithoutLogInput, UserUncheckedUpdateWithoutLogInput>
    create: XOR<UserCreateWithoutLogInput, UserUncheckedCreateWithoutLogInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLogInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLogInput, UserUncheckedUpdateWithoutLogInput>
  }

  export type UserUpdateWithoutLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: BranchUpdateOneWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    shops?: ShopUpdateManyWithoutUserNestedInput
    stores?: StoreUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shops?: ShopUncheckedUpdateManyWithoutUserNestedInput
    stores?: StoreUncheckedUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUncheckedUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUncheckedUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUncheckedUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUncheckedUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUncheckedUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUncheckedUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type SellCreateWithoutCustomerInput = {
    id?: string
    invoiceNo: string
    saleStatus?: $Enums.SaleStatus
    locked?: boolean
    lockedAt?: Date | string | null
    totalProducts?: number
    subTotal?: number
    discount?: number
    vat?: number
    grandTotal?: number
    NetTotal?: number
    notes?: string | null
    saleDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutSellInput
    createdBy?: UserCreateNestedOneWithoutSellInput
    updatedBy?: UserCreateNestedOneWithoutUpdateSellInput
    items?: SellItemCreateNestedManyWithoutSellInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutSellInput
  }

  export type SellUncheckedCreateWithoutCustomerInput = {
    id?: string
    invoiceNo: string
    saleStatus?: $Enums.SaleStatus
    locked?: boolean
    lockedAt?: Date | string | null
    branchId?: string | null
    totalProducts?: number
    subTotal?: number
    discount?: number
    vat?: number
    grandTotal?: number
    NetTotal?: number
    notes?: string | null
    saleDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SellItemUncheckedCreateNestedManyWithoutSellInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutSellInput
  }

  export type SellCreateOrConnectWithoutCustomerInput = {
    where: SellWhereUniqueInput
    create: XOR<SellCreateWithoutCustomerInput, SellUncheckedCreateWithoutCustomerInput>
  }

  export type SellCreateManyCustomerInputEnvelope = {
    data: SellCreateManyCustomerInput | SellCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type AddToCartCreateWithoutCustomerInput = {
    id?: string
    isCheckedOut?: boolean
    isWaitlist?: boolean
    totalItems?: number
    totalAmount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAllAddToCartInput
    branch?: BranchCreateNestedOneWithoutAddToCartInput
    createdBy?: UserCreateNestedOneWithoutCreatedAddToCartInput
    updatedBy?: UserCreateNestedOneWithoutAddToCartInput
    items?: CartItemCreateNestedManyWithoutCartInput
    waitlists?: WaitlistCreateNestedManyWithoutCartInput
  }

  export type AddToCartUncheckedCreateWithoutCustomerInput = {
    id?: string
    userId: string
    branchId?: string | null
    isCheckedOut?: boolean
    isWaitlist?: boolean
    totalItems?: number
    totalAmount?: number
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemUncheckedCreateNestedManyWithoutCartInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutCartInput
  }

  export type AddToCartCreateOrConnectWithoutCustomerInput = {
    where: AddToCartWhereUniqueInput
    create: XOR<AddToCartCreateWithoutCustomerInput, AddToCartUncheckedCreateWithoutCustomerInput>
  }

  export type AddToCartCreateManyCustomerInputEnvelope = {
    data: AddToCartCreateManyCustomerInput | AddToCartCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type WaitlistCreateWithoutCustomerInput = {
    id?: string
    quantity?: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutWaitlistsInput
    branch?: BranchCreateNestedOneWithoutWaitlistsInput
    cart?: AddToCartCreateNestedOneWithoutWaitlistsInput
    cartItem?: CartItemCreateNestedOneWithoutWaitlistsInput
    product?: ProductCreateNestedOneWithoutWaitlistsInput
    shop?: ShopCreateNestedOneWithoutWaitlistsInput
    createdBy?: UserCreateNestedOneWithoutWaitlistsCreatedInput
    updatedBy?: UserCreateNestedOneWithoutWaitlistsUpdatedInput
  }

  export type WaitlistUncheckedCreateWithoutCustomerInput = {
    id?: string
    userId?: string | null
    branchId?: string | null
    cartId?: string | null
    cartItemId?: string | null
    productId?: string | null
    quantity?: number
    note?: string | null
    shopId?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaitlistCreateOrConnectWithoutCustomerInput = {
    where: WaitlistWhereUniqueInput
    create: XOR<WaitlistCreateWithoutCustomerInput, WaitlistUncheckedCreateWithoutCustomerInput>
  }

  export type WaitlistCreateManyCustomerInputEnvelope = {
    data: WaitlistCreateManyCustomerInput | WaitlistCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type SellUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SellWhereUniqueInput
    update: XOR<SellUpdateWithoutCustomerInput, SellUncheckedUpdateWithoutCustomerInput>
    create: XOR<SellCreateWithoutCustomerInput, SellUncheckedCreateWithoutCustomerInput>
  }

  export type SellUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SellWhereUniqueInput
    data: XOR<SellUpdateWithoutCustomerInput, SellUncheckedUpdateWithoutCustomerInput>
  }

  export type SellUpdateManyWithWhereWithoutCustomerInput = {
    where: SellScalarWhereInput
    data: XOR<SellUpdateManyMutationInput, SellUncheckedUpdateManyWithoutCustomerInput>
  }

  export type AddToCartUpsertWithWhereUniqueWithoutCustomerInput = {
    where: AddToCartWhereUniqueInput
    update: XOR<AddToCartUpdateWithoutCustomerInput, AddToCartUncheckedUpdateWithoutCustomerInput>
    create: XOR<AddToCartCreateWithoutCustomerInput, AddToCartUncheckedCreateWithoutCustomerInput>
  }

  export type AddToCartUpdateWithWhereUniqueWithoutCustomerInput = {
    where: AddToCartWhereUniqueInput
    data: XOR<AddToCartUpdateWithoutCustomerInput, AddToCartUncheckedUpdateWithoutCustomerInput>
  }

  export type AddToCartUpdateManyWithWhereWithoutCustomerInput = {
    where: AddToCartScalarWhereInput
    data: XOR<AddToCartUpdateManyMutationInput, AddToCartUncheckedUpdateManyWithoutCustomerInput>
  }

  export type WaitlistUpsertWithWhereUniqueWithoutCustomerInput = {
    where: WaitlistWhereUniqueInput
    update: XOR<WaitlistUpdateWithoutCustomerInput, WaitlistUncheckedUpdateWithoutCustomerInput>
    create: XOR<WaitlistCreateWithoutCustomerInput, WaitlistUncheckedCreateWithoutCustomerInput>
  }

  export type WaitlistUpdateWithWhereUniqueWithoutCustomerInput = {
    where: WaitlistWhereUniqueInput
    data: XOR<WaitlistUpdateWithoutCustomerInput, WaitlistUncheckedUpdateWithoutCustomerInput>
  }

  export type WaitlistUpdateManyWithWhereWithoutCustomerInput = {
    where: WaitlistScalarWhereInput
    data: XOR<WaitlistUpdateManyMutationInput, WaitlistUncheckedUpdateManyWithoutCustomerInput>
  }

  export type PurchaseCreateWithoutSupplierInput = {
    id?: string
    invoiceNo: string
    paymentStatus?: $Enums.PaymentStatus
    totalProducts?: number
    subTotal?: number
    grandTotal?: number
    notes?: string | null
    purchaseDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutPurchaseInput
    createdBy?: UserCreateNestedOneWithoutCreatorPurchaseInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedPurchaseInput
    items?: PurchaseItemCreateNestedManyWithoutPurchaseInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutSupplierInput = {
    id?: string
    invoiceNo: string
    storeId: string
    paymentStatus?: $Enums.PaymentStatus
    totalProducts?: number
    subTotal?: number
    grandTotal?: number
    notes?: string | null
    purchaseDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseItemUncheckedCreateNestedManyWithoutPurchaseInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutSupplierInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutSupplierInput, PurchaseUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseCreateManySupplierInputEnvelope = {
    data: PurchaseCreateManySupplierInput | PurchaseCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseUpsertWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutSupplierInput, PurchaseUncheckedUpdateWithoutSupplierInput>
    create: XOR<PurchaseCreateWithoutSupplierInput, PurchaseUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutSupplierInput, PurchaseUncheckedUpdateWithoutSupplierInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutSupplierInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutSupplierInput>
  }

  export type ProductCreateWithoutCategoryInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subCategory?: SubCategoryCreateNestedOneWithoutProductsInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutProductsInput
    batches?: ProductBatchCreateNestedManyWithoutProductInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutProductInput
    TransferItem?: TransferItemCreateNestedManyWithoutProductInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutProductInput
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    AdditionalPrice?: AdditionalPriceCreateNestedManyWithoutProductInput
    SellItem?: SellItemCreateNestedManyWithoutProductInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutProductInput
    waitlists?: WaitlistCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    subCategoryId?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    unitOfMeasureId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: ProductBatchUncheckedCreateNestedManyWithoutProductInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutProductInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutProductInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    AdditionalPrice?: AdditionalPriceUncheckedCreateNestedManyWithoutProductInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutProductInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutProductInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type SubCategoryCreateWithoutCategoryInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutSubCategoryInput
  }

  export type SubCategoryUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutSubCategoryInput
  }

  export type SubCategoryCreateOrConnectWithoutCategoryInput = {
    where: SubCategoryWhereUniqueInput
    create: XOR<SubCategoryCreateWithoutCategoryInput, SubCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type SubCategoryCreateManyCategoryInputEnvelope = {
    data: SubCategoryCreateManyCategoryInput | SubCategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    productCode?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    generic?: StringNullableFilter<"Product"> | string | null
    description?: StringNullableFilter<"Product"> | string | null
    categoryId?: StringFilter<"Product"> | string
    subCategoryId?: StringNullableFilter<"Product"> | string | null
    sellPrice?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFilter<"Product"> | string
    unitOfMeasureId?: StringFilter<"Product"> | string
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type SubCategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: SubCategoryWhereUniqueInput
    update: XOR<SubCategoryUpdateWithoutCategoryInput, SubCategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<SubCategoryCreateWithoutCategoryInput, SubCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type SubCategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: SubCategoryWhereUniqueInput
    data: XOR<SubCategoryUpdateWithoutCategoryInput, SubCategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type SubCategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: SubCategoryScalarWhereInput
    data: XOR<SubCategoryUpdateManyMutationInput, SubCategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type SubCategoryScalarWhereInput = {
    AND?: SubCategoryScalarWhereInput | SubCategoryScalarWhereInput[]
    OR?: SubCategoryScalarWhereInput[]
    NOT?: SubCategoryScalarWhereInput | SubCategoryScalarWhereInput[]
    id?: StringFilter<"SubCategory"> | string
    name?: StringFilter<"SubCategory"> | string
    categoryId?: StringFilter<"SubCategory"> | string
    createdAt?: DateTimeFilter<"SubCategory"> | Date | string
    updatedAt?: DateTimeFilter<"SubCategory"> | Date | string
  }

  export type CategoryCreateWithoutSubCategoriesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutSubCategoriesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutSubCategoriesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutSubCategoriesInput, CategoryUncheckedCreateWithoutSubCategoriesInput>
  }

  export type ProductCreateWithoutSubCategoryInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutProductsInput
    batches?: ProductBatchCreateNestedManyWithoutProductInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutProductInput
    TransferItem?: TransferItemCreateNestedManyWithoutProductInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutProductInput
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    AdditionalPrice?: AdditionalPriceCreateNestedManyWithoutProductInput
    SellItem?: SellItemCreateNestedManyWithoutProductInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutProductInput
    waitlists?: WaitlistCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSubCategoryInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    categoryId: string
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    unitOfMeasureId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: ProductBatchUncheckedCreateNestedManyWithoutProductInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutProductInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutProductInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    AdditionalPrice?: AdditionalPriceUncheckedCreateNestedManyWithoutProductInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutProductInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutProductInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSubCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSubCategoryInput, ProductUncheckedCreateWithoutSubCategoryInput>
  }

  export type ProductCreateManySubCategoryInputEnvelope = {
    data: ProductCreateManySubCategoryInput | ProductCreateManySubCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutSubCategoriesInput = {
    update: XOR<CategoryUpdateWithoutSubCategoriesInput, CategoryUncheckedUpdateWithoutSubCategoriesInput>
    create: XOR<CategoryCreateWithoutSubCategoriesInput, CategoryUncheckedCreateWithoutSubCategoriesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutSubCategoriesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutSubCategoriesInput, CategoryUncheckedUpdateWithoutSubCategoriesInput>
  }

  export type CategoryUpdateWithoutSubCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutSubCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductUpsertWithWhereUniqueWithoutSubCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutSubCategoryInput, ProductUncheckedUpdateWithoutSubCategoryInput>
    create: XOR<ProductCreateWithoutSubCategoryInput, ProductUncheckedCreateWithoutSubCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutSubCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutSubCategoryInput, ProductUncheckedUpdateWithoutSubCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutSubCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutSubCategoryInput>
  }

  export type CategoryCreateWithoutProductsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subCategories?: SubCategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subCategories?: SubCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type SubCategoryCreateWithoutProductsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutSubCategoriesInput
  }

  export type SubCategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubCategoryCreateOrConnectWithoutProductsInput = {
    where: SubCategoryWhereUniqueInput
    create: XOR<SubCategoryCreateWithoutProductsInput, SubCategoryUncheckedCreateWithoutProductsInput>
  }

  export type UnitOfMeasureCreateWithoutProductsInput = {
    id?: string
    name: string
    symbol?: string | null
    base?: boolean
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutUnitOfMeasureInput
    TransferItem?: TransferItemCreateNestedManyWithoutUnitOfMeasureInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUnitOfMeasureInput
    ShopStock?: ShopStockCreateNestedManyWithoutUnitOfMeasureInput
    StoreStock?: StoreStockCreateNestedManyWithoutUnitOfMeasureInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutUnitOfMeasureInput
    SellItem?: SellItemCreateNestedManyWithoutUnitOfMeasureInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutUnitOfMeasureInput
    CartItem?: CartItemCreateNestedManyWithoutUnitOfMeasureInput
  }

  export type UnitOfMeasureUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    symbol?: string | null
    base?: boolean
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
  }

  export type UnitOfMeasureCreateOrConnectWithoutProductsInput = {
    where: UnitOfMeasureWhereUniqueInput
    create: XOR<UnitOfMeasureCreateWithoutProductsInput, UnitOfMeasureUncheckedCreateWithoutProductsInput>
  }

  export type ProductBatchCreateWithoutProductInput = {
    id?: string
    batchNumber: string
    expiryDate?: Date | string | null
    price?: number | null
    stock?: number | null
    warningQuantity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store?: StoreCreateNestedOneWithoutProductBatchInput
    ShopStock?: ShopStockCreateNestedManyWithoutBatchInput
    StoreStock?: StoreStockCreateNestedManyWithoutBatchInput
    StockLedger?: StockLedgerCreateNestedManyWithoutBatchInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutBatchInput
    TransferItem?: TransferItemCreateNestedManyWithoutBatchInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutBatchInput
    SellItemBatch?: SellItemBatchCreateNestedManyWithoutBatchInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchCreateNestedManyWithoutBatchInput
  }

  export type ProductBatchUncheckedCreateWithoutProductInput = {
    id?: string
    batchNumber: string
    expiryDate?: Date | string | null
    price?: number | null
    stock?: number | null
    warningQuantity?: number | null
    storeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutBatchInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutBatchInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutBatchInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutBatchInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutBatchInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutBatchInput
    SellItemBatch?: SellItemBatchUncheckedCreateNestedManyWithoutBatchInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUncheckedCreateNestedManyWithoutBatchInput
  }

  export type ProductBatchCreateOrConnectWithoutProductInput = {
    where: ProductBatchWhereUniqueInput
    create: XOR<ProductBatchCreateWithoutProductInput, ProductBatchUncheckedCreateWithoutProductInput>
  }

  export type ProductBatchCreateManyProductInputEnvelope = {
    data: ProductBatchCreateManyProductInput | ProductBatchCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchase: PurchaseCreateNestedOneWithoutItemsInput
    batch: ProductBatchCreateNestedOneWithoutPurchaseItemInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutPurchaseItemInput
  }

  export type PurchaseItemUncheckedCreateWithoutProductInput = {
    id?: string
    purchaseId: string
    batchId: string
    unitOfMeasureId: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseItemCreateOrConnectWithoutProductInput = {
    where: PurchaseItemWhereUniqueInput
    create: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput>
  }

  export type PurchaseItemCreateManyProductInputEnvelope = {
    data: PurchaseItemCreateManyProductInput | PurchaseItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type TransferItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transfer: TransferCreateNestedOneWithoutItemsInput
    batch: ProductBatchCreateNestedOneWithoutTransferItemInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutTransferItemInput
  }

  export type TransferItemUncheckedCreateWithoutProductInput = {
    id?: string
    transferId: string
    batchId: string
    unitOfMeasureId: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferItemCreateOrConnectWithoutProductInput = {
    where: TransferItemWhereUniqueInput
    create: XOR<TransferItemCreateWithoutProductInput, TransferItemUncheckedCreateWithoutProductInput>
  }

  export type TransferItemCreateManyProductInputEnvelope = {
    data: TransferItemCreateManyProductInput | TransferItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type StockCorrectionItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    correction: StockCorrectionCreateNestedOneWithoutItemsInput
    batch?: ProductBatchCreateNestedOneWithoutStockCorrectionItemInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutStockCorrectionItemInput
  }

  export type StockCorrectionItemUncheckedCreateWithoutProductInput = {
    id?: string
    correctionId: string
    batchId?: string | null
    unitOfMeasureId: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockCorrectionItemCreateOrConnectWithoutProductInput = {
    where: StockCorrectionItemWhereUniqueInput
    create: XOR<StockCorrectionItemCreateWithoutProductInput, StockCorrectionItemUncheckedCreateWithoutProductInput>
  }

  export type StockCorrectionItemCreateManyProductInputEnvelope = {
    data: StockCorrectionItemCreateManyProductInput | StockCorrectionItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CartItemCreateWithoutProductInput = {
    id?: string
    isWaitlist?: boolean
    quantity: number
    unitPrice?: number
    totalPrice?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cart: AddToCartCreateNestedOneWithoutItemsInput
    shop: ShopCreateNestedOneWithoutCartItemInput
    unitOfMeasure?: UnitOfMeasureCreateNestedOneWithoutCartItemInput
    waitlists?: WaitlistCreateNestedManyWithoutCartItemInput
  }

  export type CartItemUncheckedCreateWithoutProductInput = {
    id?: string
    cartId: string
    isWaitlist?: boolean
    shopId: string
    unitOfMeasureId?: string | null
    quantity: number
    unitPrice?: number
    totalPrice?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutCartItemInput
  }

  export type CartItemCreateOrConnectWithoutProductInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput>
  }

  export type CartItemCreateManyProductInputEnvelope = {
    data: CartItemCreateManyProductInput | CartItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type AdditionalPriceCreateWithoutProductInput = {
    id?: string
    label?: string | null
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    shop?: ShopCreateNestedOneWithoutAdditionalPriceInput
  }

  export type AdditionalPriceUncheckedCreateWithoutProductInput = {
    id?: string
    label?: string | null
    price: number
    shopId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdditionalPriceCreateOrConnectWithoutProductInput = {
    where: AdditionalPriceWhereUniqueInput
    create: XOR<AdditionalPriceCreateWithoutProductInput, AdditionalPriceUncheckedCreateWithoutProductInput>
  }

  export type AdditionalPriceCreateManyProductInputEnvelope = {
    data: AdditionalPriceCreateManyProductInput | AdditionalPriceCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SellItemCreateWithoutProductInput = {
    id?: string
    itemSaleStatus?: $Enums.ItemSaleStatus
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sell: SellCreateNestedOneWithoutItemsInput
    shop: ShopCreateNestedOneWithoutSellItemInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutSellItemInput
    batches?: SellItemBatchCreateNestedManyWithoutSellItemInput
  }

  export type SellItemUncheckedCreateWithoutProductInput = {
    id?: string
    sellId: string
    shopId: string
    unitOfMeasureId: string
    itemSaleStatus?: $Enums.ItemSaleStatus
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: SellItemBatchUncheckedCreateNestedManyWithoutSellItemInput
  }

  export type SellItemCreateOrConnectWithoutProductInput = {
    where: SellItemWhereUniqueInput
    create: XOR<SellItemCreateWithoutProductInput, SellItemUncheckedCreateWithoutProductInput>
  }

  export type SellItemCreateManyProductInputEnvelope = {
    data: SellItemCreateManyProductInput | SellItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SellStockCorrectionItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    correction: SellStockCorrectionCreateNestedOneWithoutItemsInput
    shop?: ShopCreateNestedOneWithoutSellStockCorrectionItemInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutSellStockCorrectionItemInput
    batches?: SellStockCorrectionBatchCreateNestedManyWithoutCorrectionItemInput
  }

  export type SellStockCorrectionItemUncheckedCreateWithoutProductInput = {
    id?: string
    correctionId: string
    shopId?: string | null
    unitOfMeasureId: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: SellStockCorrectionBatchUncheckedCreateNestedManyWithoutCorrectionItemInput
  }

  export type SellStockCorrectionItemCreateOrConnectWithoutProductInput = {
    where: SellStockCorrectionItemWhereUniqueInput
    create: XOR<SellStockCorrectionItemCreateWithoutProductInput, SellStockCorrectionItemUncheckedCreateWithoutProductInput>
  }

  export type SellStockCorrectionItemCreateManyProductInputEnvelope = {
    data: SellStockCorrectionItemCreateManyProductInput | SellStockCorrectionItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type WaitlistCreateWithoutProductInput = {
    id?: string
    quantity?: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutWaitlistsInput
    customer?: CustomerCreateNestedOneWithoutWaitlistsInput
    branch?: BranchCreateNestedOneWithoutWaitlistsInput
    cart?: AddToCartCreateNestedOneWithoutWaitlistsInput
    cartItem?: CartItemCreateNestedOneWithoutWaitlistsInput
    shop?: ShopCreateNestedOneWithoutWaitlistsInput
    createdBy?: UserCreateNestedOneWithoutWaitlistsCreatedInput
    updatedBy?: UserCreateNestedOneWithoutWaitlistsUpdatedInput
  }

  export type WaitlistUncheckedCreateWithoutProductInput = {
    id?: string
    userId?: string | null
    customerId?: string | null
    branchId?: string | null
    cartId?: string | null
    cartItemId?: string | null
    quantity?: number
    note?: string | null
    shopId?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaitlistCreateOrConnectWithoutProductInput = {
    where: WaitlistWhereUniqueInput
    create: XOR<WaitlistCreateWithoutProductInput, WaitlistUncheckedCreateWithoutProductInput>
  }

  export type WaitlistCreateManyProductInputEnvelope = {
    data: WaitlistCreateManyProductInput | WaitlistCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutProductsInput = {
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCategories?: SubCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCategories?: SubCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type SubCategoryUpsertWithoutProductsInput = {
    update: XOR<SubCategoryUpdateWithoutProductsInput, SubCategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<SubCategoryCreateWithoutProductsInput, SubCategoryUncheckedCreateWithoutProductsInput>
    where?: SubCategoryWhereInput
  }

  export type SubCategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: SubCategoryWhereInput
    data: XOR<SubCategoryUpdateWithoutProductsInput, SubCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type SubCategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutSubCategoriesNestedInput
  }

  export type SubCategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitOfMeasureUpsertWithoutProductsInput = {
    update: XOR<UnitOfMeasureUpdateWithoutProductsInput, UnitOfMeasureUncheckedUpdateWithoutProductsInput>
    create: XOR<UnitOfMeasureCreateWithoutProductsInput, UnitOfMeasureUncheckedCreateWithoutProductsInput>
    where?: UnitOfMeasureWhereInput
  }

  export type UnitOfMeasureUpdateToOneWithWhereWithoutProductsInput = {
    where?: UnitOfMeasureWhereInput
    data: XOR<UnitOfMeasureUpdateWithoutProductsInput, UnitOfMeasureUncheckedUpdateWithoutProductsInput>
  }

  export type UnitOfMeasureUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    base?: BoolFieldUpdateOperationsInput | boolean
    PurchaseItem?: PurchaseItemUpdateManyWithoutUnitOfMeasureNestedInput
    TransferItem?: TransferItemUpdateManyWithoutUnitOfMeasureNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUnitOfMeasureNestedInput
    ShopStock?: ShopStockUpdateManyWithoutUnitOfMeasureNestedInput
    StoreStock?: StoreStockUpdateManyWithoutUnitOfMeasureNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutUnitOfMeasureNestedInput
    SellItem?: SellItemUpdateManyWithoutUnitOfMeasureNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutUnitOfMeasureNestedInput
    CartItem?: CartItemUpdateManyWithoutUnitOfMeasureNestedInput
  }

  export type UnitOfMeasureUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    base?: BoolFieldUpdateOperationsInput | boolean
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    ShopStock?: ShopStockUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
  }

  export type ProductBatchUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductBatchWhereUniqueInput
    update: XOR<ProductBatchUpdateWithoutProductInput, ProductBatchUncheckedUpdateWithoutProductInput>
    create: XOR<ProductBatchCreateWithoutProductInput, ProductBatchUncheckedCreateWithoutProductInput>
  }

  export type ProductBatchUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductBatchWhereUniqueInput
    data: XOR<ProductBatchUpdateWithoutProductInput, ProductBatchUncheckedUpdateWithoutProductInput>
  }

  export type ProductBatchUpdateManyWithWhereWithoutProductInput = {
    where: ProductBatchScalarWhereInput
    data: XOR<ProductBatchUpdateManyMutationInput, ProductBatchUncheckedUpdateManyWithoutProductInput>
  }

  export type PurchaseItemUpsertWithWhereUniqueWithoutProductInput = {
    where: PurchaseItemWhereUniqueInput
    update: XOR<PurchaseItemUpdateWithoutProductInput, PurchaseItemUncheckedUpdateWithoutProductInput>
    create: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput>
  }

  export type PurchaseItemUpdateWithWhereUniqueWithoutProductInput = {
    where: PurchaseItemWhereUniqueInput
    data: XOR<PurchaseItemUpdateWithoutProductInput, PurchaseItemUncheckedUpdateWithoutProductInput>
  }

  export type PurchaseItemUpdateManyWithWhereWithoutProductInput = {
    where: PurchaseItemScalarWhereInput
    data: XOR<PurchaseItemUpdateManyMutationInput, PurchaseItemUncheckedUpdateManyWithoutProductInput>
  }

  export type PurchaseItemScalarWhereInput = {
    AND?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
    OR?: PurchaseItemScalarWhereInput[]
    NOT?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
    id?: StringFilter<"PurchaseItem"> | string
    purchaseId?: StringFilter<"PurchaseItem"> | string
    productId?: StringFilter<"PurchaseItem"> | string
    batchId?: StringFilter<"PurchaseItem"> | string
    unitOfMeasureId?: StringFilter<"PurchaseItem"> | string
    quantity?: IntFilter<"PurchaseItem"> | number
    unitPrice?: FloatFilter<"PurchaseItem"> | number
    totalPrice?: FloatFilter<"PurchaseItem"> | number
    createdAt?: DateTimeFilter<"PurchaseItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseItem"> | Date | string
  }

  export type TransferItemUpsertWithWhereUniqueWithoutProductInput = {
    where: TransferItemWhereUniqueInput
    update: XOR<TransferItemUpdateWithoutProductInput, TransferItemUncheckedUpdateWithoutProductInput>
    create: XOR<TransferItemCreateWithoutProductInput, TransferItemUncheckedCreateWithoutProductInput>
  }

  export type TransferItemUpdateWithWhereUniqueWithoutProductInput = {
    where: TransferItemWhereUniqueInput
    data: XOR<TransferItemUpdateWithoutProductInput, TransferItemUncheckedUpdateWithoutProductInput>
  }

  export type TransferItemUpdateManyWithWhereWithoutProductInput = {
    where: TransferItemScalarWhereInput
    data: XOR<TransferItemUpdateManyMutationInput, TransferItemUncheckedUpdateManyWithoutProductInput>
  }

  export type TransferItemScalarWhereInput = {
    AND?: TransferItemScalarWhereInput | TransferItemScalarWhereInput[]
    OR?: TransferItemScalarWhereInput[]
    NOT?: TransferItemScalarWhereInput | TransferItemScalarWhereInput[]
    id?: StringFilter<"TransferItem"> | string
    transferId?: StringFilter<"TransferItem"> | string
    productId?: StringFilter<"TransferItem"> | string
    batchId?: StringFilter<"TransferItem"> | string
    unitOfMeasureId?: StringFilter<"TransferItem"> | string
    quantity?: IntFilter<"TransferItem"> | number
    createdAt?: DateTimeFilter<"TransferItem"> | Date | string
    updatedAt?: DateTimeFilter<"TransferItem"> | Date | string
  }

  export type StockCorrectionItemUpsertWithWhereUniqueWithoutProductInput = {
    where: StockCorrectionItemWhereUniqueInput
    update: XOR<StockCorrectionItemUpdateWithoutProductInput, StockCorrectionItemUncheckedUpdateWithoutProductInput>
    create: XOR<StockCorrectionItemCreateWithoutProductInput, StockCorrectionItemUncheckedCreateWithoutProductInput>
  }

  export type StockCorrectionItemUpdateWithWhereUniqueWithoutProductInput = {
    where: StockCorrectionItemWhereUniqueInput
    data: XOR<StockCorrectionItemUpdateWithoutProductInput, StockCorrectionItemUncheckedUpdateWithoutProductInput>
  }

  export type StockCorrectionItemUpdateManyWithWhereWithoutProductInput = {
    where: StockCorrectionItemScalarWhereInput
    data: XOR<StockCorrectionItemUpdateManyMutationInput, StockCorrectionItemUncheckedUpdateManyWithoutProductInput>
  }

  export type StockCorrectionItemScalarWhereInput = {
    AND?: StockCorrectionItemScalarWhereInput | StockCorrectionItemScalarWhereInput[]
    OR?: StockCorrectionItemScalarWhereInput[]
    NOT?: StockCorrectionItemScalarWhereInput | StockCorrectionItemScalarWhereInput[]
    id?: StringFilter<"StockCorrectionItem"> | string
    correctionId?: StringFilter<"StockCorrectionItem"> | string
    productId?: StringFilter<"StockCorrectionItem"> | string
    batchId?: StringNullableFilter<"StockCorrectionItem"> | string | null
    unitOfMeasureId?: StringFilter<"StockCorrectionItem"> | string
    quantity?: IntFilter<"StockCorrectionItem"> | number
    createdAt?: DateTimeFilter<"StockCorrectionItem"> | Date | string
    updatedAt?: DateTimeFilter<"StockCorrectionItem"> | Date | string
  }

  export type CartItemUpsertWithWhereUniqueWithoutProductInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutProductInput, CartItemUncheckedUpdateWithoutProductInput>
    create: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutProductInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutProductInput, CartItemUncheckedUpdateWithoutProductInput>
  }

  export type CartItemUpdateManyWithWhereWithoutProductInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutProductInput>
  }

  export type AdditionalPriceUpsertWithWhereUniqueWithoutProductInput = {
    where: AdditionalPriceWhereUniqueInput
    update: XOR<AdditionalPriceUpdateWithoutProductInput, AdditionalPriceUncheckedUpdateWithoutProductInput>
    create: XOR<AdditionalPriceCreateWithoutProductInput, AdditionalPriceUncheckedCreateWithoutProductInput>
  }

  export type AdditionalPriceUpdateWithWhereUniqueWithoutProductInput = {
    where: AdditionalPriceWhereUniqueInput
    data: XOR<AdditionalPriceUpdateWithoutProductInput, AdditionalPriceUncheckedUpdateWithoutProductInput>
  }

  export type AdditionalPriceUpdateManyWithWhereWithoutProductInput = {
    where: AdditionalPriceScalarWhereInput
    data: XOR<AdditionalPriceUpdateManyMutationInput, AdditionalPriceUncheckedUpdateManyWithoutProductInput>
  }

  export type SellItemUpsertWithWhereUniqueWithoutProductInput = {
    where: SellItemWhereUniqueInput
    update: XOR<SellItemUpdateWithoutProductInput, SellItemUncheckedUpdateWithoutProductInput>
    create: XOR<SellItemCreateWithoutProductInput, SellItemUncheckedCreateWithoutProductInput>
  }

  export type SellItemUpdateWithWhereUniqueWithoutProductInput = {
    where: SellItemWhereUniqueInput
    data: XOR<SellItemUpdateWithoutProductInput, SellItemUncheckedUpdateWithoutProductInput>
  }

  export type SellItemUpdateManyWithWhereWithoutProductInput = {
    where: SellItemScalarWhereInput
    data: XOR<SellItemUpdateManyMutationInput, SellItemUncheckedUpdateManyWithoutProductInput>
  }

  export type SellStockCorrectionItemUpsertWithWhereUniqueWithoutProductInput = {
    where: SellStockCorrectionItemWhereUniqueInput
    update: XOR<SellStockCorrectionItemUpdateWithoutProductInput, SellStockCorrectionItemUncheckedUpdateWithoutProductInput>
    create: XOR<SellStockCorrectionItemCreateWithoutProductInput, SellStockCorrectionItemUncheckedCreateWithoutProductInput>
  }

  export type SellStockCorrectionItemUpdateWithWhereUniqueWithoutProductInput = {
    where: SellStockCorrectionItemWhereUniqueInput
    data: XOR<SellStockCorrectionItemUpdateWithoutProductInput, SellStockCorrectionItemUncheckedUpdateWithoutProductInput>
  }

  export type SellStockCorrectionItemUpdateManyWithWhereWithoutProductInput = {
    where: SellStockCorrectionItemScalarWhereInput
    data: XOR<SellStockCorrectionItemUpdateManyMutationInput, SellStockCorrectionItemUncheckedUpdateManyWithoutProductInput>
  }

  export type WaitlistUpsertWithWhereUniqueWithoutProductInput = {
    where: WaitlistWhereUniqueInput
    update: XOR<WaitlistUpdateWithoutProductInput, WaitlistUncheckedUpdateWithoutProductInput>
    create: XOR<WaitlistCreateWithoutProductInput, WaitlistUncheckedCreateWithoutProductInput>
  }

  export type WaitlistUpdateWithWhereUniqueWithoutProductInput = {
    where: WaitlistWhereUniqueInput
    data: XOR<WaitlistUpdateWithoutProductInput, WaitlistUncheckedUpdateWithoutProductInput>
  }

  export type WaitlistUpdateManyWithWhereWithoutProductInput = {
    where: WaitlistScalarWhereInput
    data: XOR<WaitlistUpdateManyMutationInput, WaitlistUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductCreateWithoutAdditionalPriceInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    subCategory?: SubCategoryCreateNestedOneWithoutProductsInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutProductsInput
    batches?: ProductBatchCreateNestedManyWithoutProductInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutProductInput
    TransferItem?: TransferItemCreateNestedManyWithoutProductInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutProductInput
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    SellItem?: SellItemCreateNestedManyWithoutProductInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutProductInput
    waitlists?: WaitlistCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutAdditionalPriceInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    categoryId: string
    subCategoryId?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    unitOfMeasureId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: ProductBatchUncheckedCreateNestedManyWithoutProductInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutProductInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutProductInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutProductInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutProductInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutAdditionalPriceInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutAdditionalPriceInput, ProductUncheckedCreateWithoutAdditionalPriceInput>
  }

  export type ShopCreateWithoutAdditionalPriceInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutShopInput
    ShopStock?: ShopStockCreateNestedManyWithoutShopInput
    StockLedger?: StockLedgerCreateNestedManyWithoutShopInput
    SourceTransfer?: TransferCreateNestedManyWithoutSourceShopInput
    DestinatTransfer?: TransferCreateNestedManyWithoutDestShopInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutShopInput
    SellItem?: SellItemCreateNestedManyWithoutShopInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutShopInput
    User?: UserCreateNestedManyWithoutShopsInput
    CartItem?: CartItemCreateNestedManyWithoutShopInput
    waitlists?: WaitlistCreateNestedManyWithoutShopInput
    notifications?: NotificationCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutAdditionalPriceInput = {
    id?: string
    name: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutShopInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutShopInput
    SourceTransfer?: TransferUncheckedCreateNestedManyWithoutSourceShopInput
    DestinatTransfer?: TransferUncheckedCreateNestedManyWithoutDestShopInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutShopInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutShopInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutShopInput
    User?: UserUncheckedCreateNestedManyWithoutShopsInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutShopInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutShopInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutAdditionalPriceInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutAdditionalPriceInput, ShopUncheckedCreateWithoutAdditionalPriceInput>
  }

  export type ProductUpsertWithoutAdditionalPriceInput = {
    update: XOR<ProductUpdateWithoutAdditionalPriceInput, ProductUncheckedUpdateWithoutAdditionalPriceInput>
    create: XOR<ProductCreateWithoutAdditionalPriceInput, ProductUncheckedCreateWithoutAdditionalPriceInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutAdditionalPriceInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutAdditionalPriceInput, ProductUncheckedUpdateWithoutAdditionalPriceInput>
  }

  export type ProductUpdateWithoutAdditionalPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    subCategory?: SubCategoryUpdateOneWithoutProductsNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutProductsNestedInput
    batches?: ProductBatchUpdateManyWithoutProductNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutProductNestedInput
    TransferItem?: TransferItemUpdateManyWithoutProductNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    SellItem?: SellItemUpdateManyWithoutProductNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutProductNestedInput
    waitlists?: WaitlistUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutAdditionalPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    subCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: ProductBatchUncheckedUpdateManyWithoutProductNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutProductNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutProductNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ShopUpsertWithoutAdditionalPriceInput = {
    update: XOR<ShopUpdateWithoutAdditionalPriceInput, ShopUncheckedUpdateWithoutAdditionalPriceInput>
    create: XOR<ShopCreateWithoutAdditionalPriceInput, ShopUncheckedCreateWithoutAdditionalPriceInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutAdditionalPriceInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutAdditionalPriceInput, ShopUncheckedUpdateWithoutAdditionalPriceInput>
  }

  export type ShopUpdateWithoutAdditionalPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutShopNestedInput
    ShopStock?: ShopStockUpdateManyWithoutShopNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutShopNestedInput
    SourceTransfer?: TransferUpdateManyWithoutSourceShopNestedInput
    DestinatTransfer?: TransferUpdateManyWithoutDestShopNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutShopNestedInput
    SellItem?: SellItemUpdateManyWithoutShopNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutShopNestedInput
    User?: UserUpdateManyWithoutShopsNestedInput
    CartItem?: CartItemUpdateManyWithoutShopNestedInput
    waitlists?: WaitlistUpdateManyWithoutShopNestedInput
    notifications?: NotificationUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutAdditionalPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopStock?: ShopStockUncheckedUpdateManyWithoutShopNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutShopNestedInput
    SourceTransfer?: TransferUncheckedUpdateManyWithoutSourceShopNestedInput
    DestinatTransfer?: TransferUncheckedUpdateManyWithoutDestShopNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutShopNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutShopNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutShopNestedInput
    User?: UserUncheckedUpdateManyWithoutShopsNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutShopNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutShopNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutShopNestedInput
  }

  export type StoreCreateWithoutProductBatchInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutStoreInput
    StoreStock?: StoreStockCreateNestedManyWithoutStoreInput
    StockLedger?: StockLedgerCreateNestedManyWithoutStoreInput
    Purchase?: PurchaseCreateNestedManyWithoutStoreInput
    SourceTransfer?: TransferCreateNestedManyWithoutSourceStoreInput
    DestinatTransfer?: TransferCreateNestedManyWithoutDestStoreInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutStoreInput
    User?: UserCreateNestedManyWithoutStoresInput
    notifications?: NotificationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutProductBatchInput = {
    id?: string
    name: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutStoreInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutStoreInput
    Purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    SourceTransfer?: TransferUncheckedCreateNestedManyWithoutSourceStoreInput
    DestinatTransfer?: TransferUncheckedCreateNestedManyWithoutDestStoreInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutStoreInput
    User?: UserUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutProductBatchInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutProductBatchInput, StoreUncheckedCreateWithoutProductBatchInput>
  }

  export type ProductCreateWithoutBatchesInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    subCategory?: SubCategoryCreateNestedOneWithoutProductsInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutProductsInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutProductInput
    TransferItem?: TransferItemCreateNestedManyWithoutProductInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutProductInput
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    AdditionalPrice?: AdditionalPriceCreateNestedManyWithoutProductInput
    SellItem?: SellItemCreateNestedManyWithoutProductInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutProductInput
    waitlists?: WaitlistCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutBatchesInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    categoryId: string
    subCategoryId?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    unitOfMeasureId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutProductInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutProductInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    AdditionalPrice?: AdditionalPriceUncheckedCreateNestedManyWithoutProductInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutProductInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutProductInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutBatchesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBatchesInput, ProductUncheckedCreateWithoutBatchesInput>
  }

  export type ShopStockCreateWithoutBatchInput = {
    id?: string
    quantity: number
    status?: $Enums.StockStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    shop: ShopCreateNestedOneWithoutShopStockInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutShopStockInput
  }

  export type ShopStockUncheckedCreateWithoutBatchInput = {
    id?: string
    shopId: string
    unitOfMeasureId: string
    quantity: number
    status?: $Enums.StockStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopStockCreateOrConnectWithoutBatchInput = {
    where: ShopStockWhereUniqueInput
    create: XOR<ShopStockCreateWithoutBatchInput, ShopStockUncheckedCreateWithoutBatchInput>
  }

  export type ShopStockCreateManyBatchInputEnvelope = {
    data: ShopStockCreateManyBatchInput | ShopStockCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type StoreStockCreateWithoutBatchInput = {
    id?: string
    quantity: number
    status?: $Enums.StockStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutStoreStockInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutStoreStockInput
  }

  export type StoreStockUncheckedCreateWithoutBatchInput = {
    id?: string
    storeId: string
    quantity: number
    status?: $Enums.StockStatus
    unitOfMeasureId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreStockCreateOrConnectWithoutBatchInput = {
    where: StoreStockWhereUniqueInput
    create: XOR<StoreStockCreateWithoutBatchInput, StoreStockUncheckedCreateWithoutBatchInput>
  }

  export type StoreStockCreateManyBatchInputEnvelope = {
    data: StoreStockCreateManyBatchInput | StoreStockCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type StockLedgerCreateWithoutBatchInput = {
    id?: string
    invoiceNo?: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    reference?: string | null
    notes?: string | null
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    store?: StoreCreateNestedOneWithoutStockLedgerInput
    shop?: ShopCreateNestedOneWithoutStockLedgerInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutStockLedgerInput
    user?: UserCreateNestedOneWithoutStockLedgerInput
  }

  export type StockLedgerUncheckedCreateWithoutBatchInput = {
    id?: string
    invoiceNo?: string | null
    storeId?: string | null
    shopId?: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    unitOfMeasureId: string
    reference?: string | null
    userId?: string | null
    notes?: string | null
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockLedgerCreateOrConnectWithoutBatchInput = {
    where: StockLedgerWhereUniqueInput
    create: XOR<StockLedgerCreateWithoutBatchInput, StockLedgerUncheckedCreateWithoutBatchInput>
  }

  export type StockLedgerCreateManyBatchInputEnvelope = {
    data: StockLedgerCreateManyBatchInput | StockLedgerCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseItemCreateWithoutBatchInput = {
    id?: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchase: PurchaseCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutPurchaseItemInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutPurchaseItemInput
  }

  export type PurchaseItemUncheckedCreateWithoutBatchInput = {
    id?: string
    purchaseId: string
    productId: string
    unitOfMeasureId: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseItemCreateOrConnectWithoutBatchInput = {
    where: PurchaseItemWhereUniqueInput
    create: XOR<PurchaseItemCreateWithoutBatchInput, PurchaseItemUncheckedCreateWithoutBatchInput>
  }

  export type PurchaseItemCreateManyBatchInputEnvelope = {
    data: PurchaseItemCreateManyBatchInput | PurchaseItemCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type TransferItemCreateWithoutBatchInput = {
    id?: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transfer: TransferCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutTransferItemInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutTransferItemInput
  }

  export type TransferItemUncheckedCreateWithoutBatchInput = {
    id?: string
    transferId: string
    productId: string
    unitOfMeasureId: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferItemCreateOrConnectWithoutBatchInput = {
    where: TransferItemWhereUniqueInput
    create: XOR<TransferItemCreateWithoutBatchInput, TransferItemUncheckedCreateWithoutBatchInput>
  }

  export type TransferItemCreateManyBatchInputEnvelope = {
    data: TransferItemCreateManyBatchInput | TransferItemCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type StockCorrectionItemCreateWithoutBatchInput = {
    id?: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    correction: StockCorrectionCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutStockCorrectionItemInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutStockCorrectionItemInput
  }

  export type StockCorrectionItemUncheckedCreateWithoutBatchInput = {
    id?: string
    correctionId: string
    productId: string
    unitOfMeasureId: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockCorrectionItemCreateOrConnectWithoutBatchInput = {
    where: StockCorrectionItemWhereUniqueInput
    create: XOR<StockCorrectionItemCreateWithoutBatchInput, StockCorrectionItemUncheckedCreateWithoutBatchInput>
  }

  export type StockCorrectionItemCreateManyBatchInputEnvelope = {
    data: StockCorrectionItemCreateManyBatchInput | StockCorrectionItemCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type SellItemBatchCreateWithoutBatchInput = {
    id?: string
    quantity?: number
    sellItem: SellItemCreateNestedOneWithoutBatchesInput
  }

  export type SellItemBatchUncheckedCreateWithoutBatchInput = {
    id?: string
    sellItemId: string
    quantity?: number
  }

  export type SellItemBatchCreateOrConnectWithoutBatchInput = {
    where: SellItemBatchWhereUniqueInput
    create: XOR<SellItemBatchCreateWithoutBatchInput, SellItemBatchUncheckedCreateWithoutBatchInput>
  }

  export type SellItemBatchCreateManyBatchInputEnvelope = {
    data: SellItemBatchCreateManyBatchInput | SellItemBatchCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type SellStockCorrectionBatchCreateWithoutBatchInput = {
    id?: string
    quantity?: number
    correctionItem: SellStockCorrectionItemCreateNestedOneWithoutBatchesInput
  }

  export type SellStockCorrectionBatchUncheckedCreateWithoutBatchInput = {
    id?: string
    correctionItemId: string
    quantity?: number
  }

  export type SellStockCorrectionBatchCreateOrConnectWithoutBatchInput = {
    where: SellStockCorrectionBatchWhereUniqueInput
    create: XOR<SellStockCorrectionBatchCreateWithoutBatchInput, SellStockCorrectionBatchUncheckedCreateWithoutBatchInput>
  }

  export type SellStockCorrectionBatchCreateManyBatchInputEnvelope = {
    data: SellStockCorrectionBatchCreateManyBatchInput | SellStockCorrectionBatchCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type StoreUpsertWithoutProductBatchInput = {
    update: XOR<StoreUpdateWithoutProductBatchInput, StoreUncheckedUpdateWithoutProductBatchInput>
    create: XOR<StoreCreateWithoutProductBatchInput, StoreUncheckedCreateWithoutProductBatchInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutProductBatchInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutProductBatchInput, StoreUncheckedUpdateWithoutProductBatchInput>
  }

  export type StoreUpdateWithoutProductBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStoreNestedInput
    StoreStock?: StoreStockUpdateManyWithoutStoreNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutStoreNestedInput
    Purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    SourceTransfer?: TransferUpdateManyWithoutSourceStoreNestedInput
    DestinatTransfer?: TransferUpdateManyWithoutDestStoreNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutStoreNestedInput
    User?: UserUpdateManyWithoutStoresNestedInput
    notifications?: NotificationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutProductBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StoreStock?: StoreStockUncheckedUpdateManyWithoutStoreNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutStoreNestedInput
    Purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    SourceTransfer?: TransferUncheckedUpdateManyWithoutSourceStoreNestedInput
    DestinatTransfer?: TransferUncheckedUpdateManyWithoutDestStoreNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutStoreNestedInput
    User?: UserUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type ProductUpsertWithoutBatchesInput = {
    update: XOR<ProductUpdateWithoutBatchesInput, ProductUncheckedUpdateWithoutBatchesInput>
    create: XOR<ProductCreateWithoutBatchesInput, ProductUncheckedCreateWithoutBatchesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutBatchesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutBatchesInput, ProductUncheckedUpdateWithoutBatchesInput>
  }

  export type ProductUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    subCategory?: SubCategoryUpdateOneWithoutProductsNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutProductsNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutProductNestedInput
    TransferItem?: TransferItemUpdateManyWithoutProductNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    AdditionalPrice?: AdditionalPriceUpdateManyWithoutProductNestedInput
    SellItem?: SellItemUpdateManyWithoutProductNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutProductNestedInput
    waitlists?: WaitlistUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    subCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    AdditionalPrice?: AdditionalPriceUncheckedUpdateManyWithoutProductNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutProductNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutProductNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ShopStockUpsertWithWhereUniqueWithoutBatchInput = {
    where: ShopStockWhereUniqueInput
    update: XOR<ShopStockUpdateWithoutBatchInput, ShopStockUncheckedUpdateWithoutBatchInput>
    create: XOR<ShopStockCreateWithoutBatchInput, ShopStockUncheckedCreateWithoutBatchInput>
  }

  export type ShopStockUpdateWithWhereUniqueWithoutBatchInput = {
    where: ShopStockWhereUniqueInput
    data: XOR<ShopStockUpdateWithoutBatchInput, ShopStockUncheckedUpdateWithoutBatchInput>
  }

  export type ShopStockUpdateManyWithWhereWithoutBatchInput = {
    where: ShopStockScalarWhereInput
    data: XOR<ShopStockUpdateManyMutationInput, ShopStockUncheckedUpdateManyWithoutBatchInput>
  }

  export type StoreStockUpsertWithWhereUniqueWithoutBatchInput = {
    where: StoreStockWhereUniqueInput
    update: XOR<StoreStockUpdateWithoutBatchInput, StoreStockUncheckedUpdateWithoutBatchInput>
    create: XOR<StoreStockCreateWithoutBatchInput, StoreStockUncheckedCreateWithoutBatchInput>
  }

  export type StoreStockUpdateWithWhereUniqueWithoutBatchInput = {
    where: StoreStockWhereUniqueInput
    data: XOR<StoreStockUpdateWithoutBatchInput, StoreStockUncheckedUpdateWithoutBatchInput>
  }

  export type StoreStockUpdateManyWithWhereWithoutBatchInput = {
    where: StoreStockScalarWhereInput
    data: XOR<StoreStockUpdateManyMutationInput, StoreStockUncheckedUpdateManyWithoutBatchInput>
  }

  export type StockLedgerUpsertWithWhereUniqueWithoutBatchInput = {
    where: StockLedgerWhereUniqueInput
    update: XOR<StockLedgerUpdateWithoutBatchInput, StockLedgerUncheckedUpdateWithoutBatchInput>
    create: XOR<StockLedgerCreateWithoutBatchInput, StockLedgerUncheckedCreateWithoutBatchInput>
  }

  export type StockLedgerUpdateWithWhereUniqueWithoutBatchInput = {
    where: StockLedgerWhereUniqueInput
    data: XOR<StockLedgerUpdateWithoutBatchInput, StockLedgerUncheckedUpdateWithoutBatchInput>
  }

  export type StockLedgerUpdateManyWithWhereWithoutBatchInput = {
    where: StockLedgerScalarWhereInput
    data: XOR<StockLedgerUpdateManyMutationInput, StockLedgerUncheckedUpdateManyWithoutBatchInput>
  }

  export type PurchaseItemUpsertWithWhereUniqueWithoutBatchInput = {
    where: PurchaseItemWhereUniqueInput
    update: XOR<PurchaseItemUpdateWithoutBatchInput, PurchaseItemUncheckedUpdateWithoutBatchInput>
    create: XOR<PurchaseItemCreateWithoutBatchInput, PurchaseItemUncheckedCreateWithoutBatchInput>
  }

  export type PurchaseItemUpdateWithWhereUniqueWithoutBatchInput = {
    where: PurchaseItemWhereUniqueInput
    data: XOR<PurchaseItemUpdateWithoutBatchInput, PurchaseItemUncheckedUpdateWithoutBatchInput>
  }

  export type PurchaseItemUpdateManyWithWhereWithoutBatchInput = {
    where: PurchaseItemScalarWhereInput
    data: XOR<PurchaseItemUpdateManyMutationInput, PurchaseItemUncheckedUpdateManyWithoutBatchInput>
  }

  export type TransferItemUpsertWithWhereUniqueWithoutBatchInput = {
    where: TransferItemWhereUniqueInput
    update: XOR<TransferItemUpdateWithoutBatchInput, TransferItemUncheckedUpdateWithoutBatchInput>
    create: XOR<TransferItemCreateWithoutBatchInput, TransferItemUncheckedCreateWithoutBatchInput>
  }

  export type TransferItemUpdateWithWhereUniqueWithoutBatchInput = {
    where: TransferItemWhereUniqueInput
    data: XOR<TransferItemUpdateWithoutBatchInput, TransferItemUncheckedUpdateWithoutBatchInput>
  }

  export type TransferItemUpdateManyWithWhereWithoutBatchInput = {
    where: TransferItemScalarWhereInput
    data: XOR<TransferItemUpdateManyMutationInput, TransferItemUncheckedUpdateManyWithoutBatchInput>
  }

  export type StockCorrectionItemUpsertWithWhereUniqueWithoutBatchInput = {
    where: StockCorrectionItemWhereUniqueInput
    update: XOR<StockCorrectionItemUpdateWithoutBatchInput, StockCorrectionItemUncheckedUpdateWithoutBatchInput>
    create: XOR<StockCorrectionItemCreateWithoutBatchInput, StockCorrectionItemUncheckedCreateWithoutBatchInput>
  }

  export type StockCorrectionItemUpdateWithWhereUniqueWithoutBatchInput = {
    where: StockCorrectionItemWhereUniqueInput
    data: XOR<StockCorrectionItemUpdateWithoutBatchInput, StockCorrectionItemUncheckedUpdateWithoutBatchInput>
  }

  export type StockCorrectionItemUpdateManyWithWhereWithoutBatchInput = {
    where: StockCorrectionItemScalarWhereInput
    data: XOR<StockCorrectionItemUpdateManyMutationInput, StockCorrectionItemUncheckedUpdateManyWithoutBatchInput>
  }

  export type SellItemBatchUpsertWithWhereUniqueWithoutBatchInput = {
    where: SellItemBatchWhereUniqueInput
    update: XOR<SellItemBatchUpdateWithoutBatchInput, SellItemBatchUncheckedUpdateWithoutBatchInput>
    create: XOR<SellItemBatchCreateWithoutBatchInput, SellItemBatchUncheckedCreateWithoutBatchInput>
  }

  export type SellItemBatchUpdateWithWhereUniqueWithoutBatchInput = {
    where: SellItemBatchWhereUniqueInput
    data: XOR<SellItemBatchUpdateWithoutBatchInput, SellItemBatchUncheckedUpdateWithoutBatchInput>
  }

  export type SellItemBatchUpdateManyWithWhereWithoutBatchInput = {
    where: SellItemBatchScalarWhereInput
    data: XOR<SellItemBatchUpdateManyMutationInput, SellItemBatchUncheckedUpdateManyWithoutBatchInput>
  }

  export type SellItemBatchScalarWhereInput = {
    AND?: SellItemBatchScalarWhereInput | SellItemBatchScalarWhereInput[]
    OR?: SellItemBatchScalarWhereInput[]
    NOT?: SellItemBatchScalarWhereInput | SellItemBatchScalarWhereInput[]
    id?: StringFilter<"SellItemBatch"> | string
    sellItemId?: StringFilter<"SellItemBatch"> | string
    batchId?: StringFilter<"SellItemBatch"> | string
    quantity?: IntFilter<"SellItemBatch"> | number
  }

  export type SellStockCorrectionBatchUpsertWithWhereUniqueWithoutBatchInput = {
    where: SellStockCorrectionBatchWhereUniqueInput
    update: XOR<SellStockCorrectionBatchUpdateWithoutBatchInput, SellStockCorrectionBatchUncheckedUpdateWithoutBatchInput>
    create: XOR<SellStockCorrectionBatchCreateWithoutBatchInput, SellStockCorrectionBatchUncheckedCreateWithoutBatchInput>
  }

  export type SellStockCorrectionBatchUpdateWithWhereUniqueWithoutBatchInput = {
    where: SellStockCorrectionBatchWhereUniqueInput
    data: XOR<SellStockCorrectionBatchUpdateWithoutBatchInput, SellStockCorrectionBatchUncheckedUpdateWithoutBatchInput>
  }

  export type SellStockCorrectionBatchUpdateManyWithWhereWithoutBatchInput = {
    where: SellStockCorrectionBatchScalarWhereInput
    data: XOR<SellStockCorrectionBatchUpdateManyMutationInput, SellStockCorrectionBatchUncheckedUpdateManyWithoutBatchInput>
  }

  export type SellStockCorrectionBatchScalarWhereInput = {
    AND?: SellStockCorrectionBatchScalarWhereInput | SellStockCorrectionBatchScalarWhereInput[]
    OR?: SellStockCorrectionBatchScalarWhereInput[]
    NOT?: SellStockCorrectionBatchScalarWhereInput | SellStockCorrectionBatchScalarWhereInput[]
    id?: StringFilter<"SellStockCorrectionBatch"> | string
    correctionItemId?: StringFilter<"SellStockCorrectionBatch"> | string
    batchId?: StringFilter<"SellStockCorrectionBatch"> | string
    quantity?: IntFilter<"SellStockCorrectionBatch"> | number
  }

  export type ProductCreateWithoutUnitOfMeasureInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    subCategory?: SubCategoryCreateNestedOneWithoutProductsInput
    batches?: ProductBatchCreateNestedManyWithoutProductInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutProductInput
    TransferItem?: TransferItemCreateNestedManyWithoutProductInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutProductInput
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    AdditionalPrice?: AdditionalPriceCreateNestedManyWithoutProductInput
    SellItem?: SellItemCreateNestedManyWithoutProductInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutProductInput
    waitlists?: WaitlistCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutUnitOfMeasureInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    categoryId: string
    subCategoryId?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: ProductBatchUncheckedCreateNestedManyWithoutProductInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutProductInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutProductInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    AdditionalPrice?: AdditionalPriceUncheckedCreateNestedManyWithoutProductInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutProductInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutProductInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutUnitOfMeasureInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutUnitOfMeasureInput, ProductUncheckedCreateWithoutUnitOfMeasureInput>
  }

  export type ProductCreateManyUnitOfMeasureInputEnvelope = {
    data: ProductCreateManyUnitOfMeasureInput | ProductCreateManyUnitOfMeasureInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseItemCreateWithoutUnitOfMeasureInput = {
    id?: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchase: PurchaseCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutPurchaseItemInput
    batch: ProductBatchCreateNestedOneWithoutPurchaseItemInput
  }

  export type PurchaseItemUncheckedCreateWithoutUnitOfMeasureInput = {
    id?: string
    purchaseId: string
    productId: string
    batchId: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseItemCreateOrConnectWithoutUnitOfMeasureInput = {
    where: PurchaseItemWhereUniqueInput
    create: XOR<PurchaseItemCreateWithoutUnitOfMeasureInput, PurchaseItemUncheckedCreateWithoutUnitOfMeasureInput>
  }

  export type PurchaseItemCreateManyUnitOfMeasureInputEnvelope = {
    data: PurchaseItemCreateManyUnitOfMeasureInput | PurchaseItemCreateManyUnitOfMeasureInput[]
    skipDuplicates?: boolean
  }

  export type TransferItemCreateWithoutUnitOfMeasureInput = {
    id?: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transfer: TransferCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutTransferItemInput
    batch: ProductBatchCreateNestedOneWithoutTransferItemInput
  }

  export type TransferItemUncheckedCreateWithoutUnitOfMeasureInput = {
    id?: string
    transferId: string
    productId: string
    batchId: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferItemCreateOrConnectWithoutUnitOfMeasureInput = {
    where: TransferItemWhereUniqueInput
    create: XOR<TransferItemCreateWithoutUnitOfMeasureInput, TransferItemUncheckedCreateWithoutUnitOfMeasureInput>
  }

  export type TransferItemCreateManyUnitOfMeasureInputEnvelope = {
    data: TransferItemCreateManyUnitOfMeasureInput | TransferItemCreateManyUnitOfMeasureInput[]
    skipDuplicates?: boolean
  }

  export type StockLedgerCreateWithoutUnitOfMeasureInput = {
    id?: string
    invoiceNo?: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    reference?: string | null
    notes?: string | null
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    batch: ProductBatchCreateNestedOneWithoutStockLedgerInput
    store?: StoreCreateNestedOneWithoutStockLedgerInput
    shop?: ShopCreateNestedOneWithoutStockLedgerInput
    user?: UserCreateNestedOneWithoutStockLedgerInput
  }

  export type StockLedgerUncheckedCreateWithoutUnitOfMeasureInput = {
    id?: string
    invoiceNo?: string | null
    batchId: string
    storeId?: string | null
    shopId?: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    reference?: string | null
    userId?: string | null
    notes?: string | null
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockLedgerCreateOrConnectWithoutUnitOfMeasureInput = {
    where: StockLedgerWhereUniqueInput
    create: XOR<StockLedgerCreateWithoutUnitOfMeasureInput, StockLedgerUncheckedCreateWithoutUnitOfMeasureInput>
  }

  export type StockLedgerCreateManyUnitOfMeasureInputEnvelope = {
    data: StockLedgerCreateManyUnitOfMeasureInput | StockLedgerCreateManyUnitOfMeasureInput[]
    skipDuplicates?: boolean
  }

  export type ShopStockCreateWithoutUnitOfMeasureInput = {
    id?: string
    quantity: number
    status?: $Enums.StockStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    shop: ShopCreateNestedOneWithoutShopStockInput
    batch: ProductBatchCreateNestedOneWithoutShopStockInput
  }

  export type ShopStockUncheckedCreateWithoutUnitOfMeasureInput = {
    id?: string
    shopId: string
    batchId: string
    quantity: number
    status?: $Enums.StockStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopStockCreateOrConnectWithoutUnitOfMeasureInput = {
    where: ShopStockWhereUniqueInput
    create: XOR<ShopStockCreateWithoutUnitOfMeasureInput, ShopStockUncheckedCreateWithoutUnitOfMeasureInput>
  }

  export type ShopStockCreateManyUnitOfMeasureInputEnvelope = {
    data: ShopStockCreateManyUnitOfMeasureInput | ShopStockCreateManyUnitOfMeasureInput[]
    skipDuplicates?: boolean
  }

  export type StoreStockCreateWithoutUnitOfMeasureInput = {
    id?: string
    quantity: number
    status?: $Enums.StockStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutStoreStockInput
    batch: ProductBatchCreateNestedOneWithoutStoreStockInput
  }

  export type StoreStockUncheckedCreateWithoutUnitOfMeasureInput = {
    id?: string
    storeId: string
    batchId: string
    quantity: number
    status?: $Enums.StockStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreStockCreateOrConnectWithoutUnitOfMeasureInput = {
    where: StoreStockWhereUniqueInput
    create: XOR<StoreStockCreateWithoutUnitOfMeasureInput, StoreStockUncheckedCreateWithoutUnitOfMeasureInput>
  }

  export type StoreStockCreateManyUnitOfMeasureInputEnvelope = {
    data: StoreStockCreateManyUnitOfMeasureInput | StoreStockCreateManyUnitOfMeasureInput[]
    skipDuplicates?: boolean
  }

  export type StockCorrectionItemCreateWithoutUnitOfMeasureInput = {
    id?: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    correction: StockCorrectionCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutStockCorrectionItemInput
    batch?: ProductBatchCreateNestedOneWithoutStockCorrectionItemInput
  }

  export type StockCorrectionItemUncheckedCreateWithoutUnitOfMeasureInput = {
    id?: string
    correctionId: string
    productId: string
    batchId?: string | null
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockCorrectionItemCreateOrConnectWithoutUnitOfMeasureInput = {
    where: StockCorrectionItemWhereUniqueInput
    create: XOR<StockCorrectionItemCreateWithoutUnitOfMeasureInput, StockCorrectionItemUncheckedCreateWithoutUnitOfMeasureInput>
  }

  export type StockCorrectionItemCreateManyUnitOfMeasureInputEnvelope = {
    data: StockCorrectionItemCreateManyUnitOfMeasureInput | StockCorrectionItemCreateManyUnitOfMeasureInput[]
    skipDuplicates?: boolean
  }

  export type SellItemCreateWithoutUnitOfMeasureInput = {
    id?: string
    itemSaleStatus?: $Enums.ItemSaleStatus
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sell: SellCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutSellItemInput
    shop: ShopCreateNestedOneWithoutSellItemInput
    batches?: SellItemBatchCreateNestedManyWithoutSellItemInput
  }

  export type SellItemUncheckedCreateWithoutUnitOfMeasureInput = {
    id?: string
    sellId: string
    productId: string
    shopId: string
    itemSaleStatus?: $Enums.ItemSaleStatus
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: SellItemBatchUncheckedCreateNestedManyWithoutSellItemInput
  }

  export type SellItemCreateOrConnectWithoutUnitOfMeasureInput = {
    where: SellItemWhereUniqueInput
    create: XOR<SellItemCreateWithoutUnitOfMeasureInput, SellItemUncheckedCreateWithoutUnitOfMeasureInput>
  }

  export type SellItemCreateManyUnitOfMeasureInputEnvelope = {
    data: SellItemCreateManyUnitOfMeasureInput | SellItemCreateManyUnitOfMeasureInput[]
    skipDuplicates?: boolean
  }

  export type SellStockCorrectionItemCreateWithoutUnitOfMeasureInput = {
    id?: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    correction: SellStockCorrectionCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutSellStockCorrectionItemInput
    shop?: ShopCreateNestedOneWithoutSellStockCorrectionItemInput
    batches?: SellStockCorrectionBatchCreateNestedManyWithoutCorrectionItemInput
  }

  export type SellStockCorrectionItemUncheckedCreateWithoutUnitOfMeasureInput = {
    id?: string
    correctionId: string
    productId: string
    shopId?: string | null
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: SellStockCorrectionBatchUncheckedCreateNestedManyWithoutCorrectionItemInput
  }

  export type SellStockCorrectionItemCreateOrConnectWithoutUnitOfMeasureInput = {
    where: SellStockCorrectionItemWhereUniqueInput
    create: XOR<SellStockCorrectionItemCreateWithoutUnitOfMeasureInput, SellStockCorrectionItemUncheckedCreateWithoutUnitOfMeasureInput>
  }

  export type SellStockCorrectionItemCreateManyUnitOfMeasureInputEnvelope = {
    data: SellStockCorrectionItemCreateManyUnitOfMeasureInput | SellStockCorrectionItemCreateManyUnitOfMeasureInput[]
    skipDuplicates?: boolean
  }

  export type CartItemCreateWithoutUnitOfMeasureInput = {
    id?: string
    isWaitlist?: boolean
    quantity: number
    unitPrice?: number
    totalPrice?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cart: AddToCartCreateNestedOneWithoutItemsInput
    shop: ShopCreateNestedOneWithoutCartItemInput
    product: ProductCreateNestedOneWithoutCartItemInput
    waitlists?: WaitlistCreateNestedManyWithoutCartItemInput
  }

  export type CartItemUncheckedCreateWithoutUnitOfMeasureInput = {
    id?: string
    cartId: string
    isWaitlist?: boolean
    shopId: string
    productId: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutCartItemInput
  }

  export type CartItemCreateOrConnectWithoutUnitOfMeasureInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutUnitOfMeasureInput, CartItemUncheckedCreateWithoutUnitOfMeasureInput>
  }

  export type CartItemCreateManyUnitOfMeasureInputEnvelope = {
    data: CartItemCreateManyUnitOfMeasureInput | CartItemCreateManyUnitOfMeasureInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutUnitOfMeasureInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutUnitOfMeasureInput, ProductUncheckedUpdateWithoutUnitOfMeasureInput>
    create: XOR<ProductCreateWithoutUnitOfMeasureInput, ProductUncheckedCreateWithoutUnitOfMeasureInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutUnitOfMeasureInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutUnitOfMeasureInput, ProductUncheckedUpdateWithoutUnitOfMeasureInput>
  }

  export type ProductUpdateManyWithWhereWithoutUnitOfMeasureInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutUnitOfMeasureInput>
  }

  export type PurchaseItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput = {
    where: PurchaseItemWhereUniqueInput
    update: XOR<PurchaseItemUpdateWithoutUnitOfMeasureInput, PurchaseItemUncheckedUpdateWithoutUnitOfMeasureInput>
    create: XOR<PurchaseItemCreateWithoutUnitOfMeasureInput, PurchaseItemUncheckedCreateWithoutUnitOfMeasureInput>
  }

  export type PurchaseItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput = {
    where: PurchaseItemWhereUniqueInput
    data: XOR<PurchaseItemUpdateWithoutUnitOfMeasureInput, PurchaseItemUncheckedUpdateWithoutUnitOfMeasureInput>
  }

  export type PurchaseItemUpdateManyWithWhereWithoutUnitOfMeasureInput = {
    where: PurchaseItemScalarWhereInput
    data: XOR<PurchaseItemUpdateManyMutationInput, PurchaseItemUncheckedUpdateManyWithoutUnitOfMeasureInput>
  }

  export type TransferItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput = {
    where: TransferItemWhereUniqueInput
    update: XOR<TransferItemUpdateWithoutUnitOfMeasureInput, TransferItemUncheckedUpdateWithoutUnitOfMeasureInput>
    create: XOR<TransferItemCreateWithoutUnitOfMeasureInput, TransferItemUncheckedCreateWithoutUnitOfMeasureInput>
  }

  export type TransferItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput = {
    where: TransferItemWhereUniqueInput
    data: XOR<TransferItemUpdateWithoutUnitOfMeasureInput, TransferItemUncheckedUpdateWithoutUnitOfMeasureInput>
  }

  export type TransferItemUpdateManyWithWhereWithoutUnitOfMeasureInput = {
    where: TransferItemScalarWhereInput
    data: XOR<TransferItemUpdateManyMutationInput, TransferItemUncheckedUpdateManyWithoutUnitOfMeasureInput>
  }

  export type StockLedgerUpsertWithWhereUniqueWithoutUnitOfMeasureInput = {
    where: StockLedgerWhereUniqueInput
    update: XOR<StockLedgerUpdateWithoutUnitOfMeasureInput, StockLedgerUncheckedUpdateWithoutUnitOfMeasureInput>
    create: XOR<StockLedgerCreateWithoutUnitOfMeasureInput, StockLedgerUncheckedCreateWithoutUnitOfMeasureInput>
  }

  export type StockLedgerUpdateWithWhereUniqueWithoutUnitOfMeasureInput = {
    where: StockLedgerWhereUniqueInput
    data: XOR<StockLedgerUpdateWithoutUnitOfMeasureInput, StockLedgerUncheckedUpdateWithoutUnitOfMeasureInput>
  }

  export type StockLedgerUpdateManyWithWhereWithoutUnitOfMeasureInput = {
    where: StockLedgerScalarWhereInput
    data: XOR<StockLedgerUpdateManyMutationInput, StockLedgerUncheckedUpdateManyWithoutUnitOfMeasureInput>
  }

  export type ShopStockUpsertWithWhereUniqueWithoutUnitOfMeasureInput = {
    where: ShopStockWhereUniqueInput
    update: XOR<ShopStockUpdateWithoutUnitOfMeasureInput, ShopStockUncheckedUpdateWithoutUnitOfMeasureInput>
    create: XOR<ShopStockCreateWithoutUnitOfMeasureInput, ShopStockUncheckedCreateWithoutUnitOfMeasureInput>
  }

  export type ShopStockUpdateWithWhereUniqueWithoutUnitOfMeasureInput = {
    where: ShopStockWhereUniqueInput
    data: XOR<ShopStockUpdateWithoutUnitOfMeasureInput, ShopStockUncheckedUpdateWithoutUnitOfMeasureInput>
  }

  export type ShopStockUpdateManyWithWhereWithoutUnitOfMeasureInput = {
    where: ShopStockScalarWhereInput
    data: XOR<ShopStockUpdateManyMutationInput, ShopStockUncheckedUpdateManyWithoutUnitOfMeasureInput>
  }

  export type StoreStockUpsertWithWhereUniqueWithoutUnitOfMeasureInput = {
    where: StoreStockWhereUniqueInput
    update: XOR<StoreStockUpdateWithoutUnitOfMeasureInput, StoreStockUncheckedUpdateWithoutUnitOfMeasureInput>
    create: XOR<StoreStockCreateWithoutUnitOfMeasureInput, StoreStockUncheckedCreateWithoutUnitOfMeasureInput>
  }

  export type StoreStockUpdateWithWhereUniqueWithoutUnitOfMeasureInput = {
    where: StoreStockWhereUniqueInput
    data: XOR<StoreStockUpdateWithoutUnitOfMeasureInput, StoreStockUncheckedUpdateWithoutUnitOfMeasureInput>
  }

  export type StoreStockUpdateManyWithWhereWithoutUnitOfMeasureInput = {
    where: StoreStockScalarWhereInput
    data: XOR<StoreStockUpdateManyMutationInput, StoreStockUncheckedUpdateManyWithoutUnitOfMeasureInput>
  }

  export type StockCorrectionItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput = {
    where: StockCorrectionItemWhereUniqueInput
    update: XOR<StockCorrectionItemUpdateWithoutUnitOfMeasureInput, StockCorrectionItemUncheckedUpdateWithoutUnitOfMeasureInput>
    create: XOR<StockCorrectionItemCreateWithoutUnitOfMeasureInput, StockCorrectionItemUncheckedCreateWithoutUnitOfMeasureInput>
  }

  export type StockCorrectionItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput = {
    where: StockCorrectionItemWhereUniqueInput
    data: XOR<StockCorrectionItemUpdateWithoutUnitOfMeasureInput, StockCorrectionItemUncheckedUpdateWithoutUnitOfMeasureInput>
  }

  export type StockCorrectionItemUpdateManyWithWhereWithoutUnitOfMeasureInput = {
    where: StockCorrectionItemScalarWhereInput
    data: XOR<StockCorrectionItemUpdateManyMutationInput, StockCorrectionItemUncheckedUpdateManyWithoutUnitOfMeasureInput>
  }

  export type SellItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput = {
    where: SellItemWhereUniqueInput
    update: XOR<SellItemUpdateWithoutUnitOfMeasureInput, SellItemUncheckedUpdateWithoutUnitOfMeasureInput>
    create: XOR<SellItemCreateWithoutUnitOfMeasureInput, SellItemUncheckedCreateWithoutUnitOfMeasureInput>
  }

  export type SellItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput = {
    where: SellItemWhereUniqueInput
    data: XOR<SellItemUpdateWithoutUnitOfMeasureInput, SellItemUncheckedUpdateWithoutUnitOfMeasureInput>
  }

  export type SellItemUpdateManyWithWhereWithoutUnitOfMeasureInput = {
    where: SellItemScalarWhereInput
    data: XOR<SellItemUpdateManyMutationInput, SellItemUncheckedUpdateManyWithoutUnitOfMeasureInput>
  }

  export type SellStockCorrectionItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput = {
    where: SellStockCorrectionItemWhereUniqueInput
    update: XOR<SellStockCorrectionItemUpdateWithoutUnitOfMeasureInput, SellStockCorrectionItemUncheckedUpdateWithoutUnitOfMeasureInput>
    create: XOR<SellStockCorrectionItemCreateWithoutUnitOfMeasureInput, SellStockCorrectionItemUncheckedCreateWithoutUnitOfMeasureInput>
  }

  export type SellStockCorrectionItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput = {
    where: SellStockCorrectionItemWhereUniqueInput
    data: XOR<SellStockCorrectionItemUpdateWithoutUnitOfMeasureInput, SellStockCorrectionItemUncheckedUpdateWithoutUnitOfMeasureInput>
  }

  export type SellStockCorrectionItemUpdateManyWithWhereWithoutUnitOfMeasureInput = {
    where: SellStockCorrectionItemScalarWhereInput
    data: XOR<SellStockCorrectionItemUpdateManyMutationInput, SellStockCorrectionItemUncheckedUpdateManyWithoutUnitOfMeasureInput>
  }

  export type CartItemUpsertWithWhereUniqueWithoutUnitOfMeasureInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutUnitOfMeasureInput, CartItemUncheckedUpdateWithoutUnitOfMeasureInput>
    create: XOR<CartItemCreateWithoutUnitOfMeasureInput, CartItemUncheckedCreateWithoutUnitOfMeasureInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutUnitOfMeasureInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutUnitOfMeasureInput, CartItemUncheckedUpdateWithoutUnitOfMeasureInput>
  }

  export type CartItemUpdateManyWithWhereWithoutUnitOfMeasureInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutUnitOfMeasureInput>
  }

  export type SupplierCreateWithoutPurchaseInput = {
    id?: string
    name: string
    contactName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    tinNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierUncheckedCreateWithoutPurchaseInput = {
    id?: string
    name: string
    contactName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    tinNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierCreateOrConnectWithoutPurchaseInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutPurchaseInput, SupplierUncheckedCreateWithoutPurchaseInput>
  }

  export type StoreCreateWithoutPurchaseInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutStoreInput
    ProductBatch?: ProductBatchCreateNestedManyWithoutStoreInput
    StoreStock?: StoreStockCreateNestedManyWithoutStoreInput
    StockLedger?: StockLedgerCreateNestedManyWithoutStoreInput
    SourceTransfer?: TransferCreateNestedManyWithoutSourceStoreInput
    DestinatTransfer?: TransferCreateNestedManyWithoutDestStoreInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutStoreInput
    User?: UserCreateNestedManyWithoutStoresInput
    notifications?: NotificationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutPurchaseInput = {
    id?: string
    name: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ProductBatch?: ProductBatchUncheckedCreateNestedManyWithoutStoreInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutStoreInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutStoreInput
    SourceTransfer?: TransferUncheckedCreateNestedManyWithoutSourceStoreInput
    DestinatTransfer?: TransferUncheckedCreateNestedManyWithoutDestStoreInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutStoreInput
    User?: UserUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutPurchaseInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutPurchaseInput, StoreUncheckedCreateWithoutPurchaseInput>
  }

  export type UserCreateWithoutCreatorPurchaseInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    branch?: BranchCreateNestedOneWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    shops?: ShopCreateNestedManyWithoutUserInput
    stores?: StoreCreateNestedManyWithoutUserInput
    Log?: LogCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUserInput
    UpdatedPurchase?: PurchaseCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionCreateNestedManyWithoutUpdatedByInput
    Sell?: SellCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutCreatorPurchaseInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    branchId?: string | null
    roleId: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    shops?: ShopUncheckedCreateNestedManyWithoutUserInput
    stores?: StoreUncheckedCreateNestedManyWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUserInput
    UpdatedPurchase?: PurchaseUncheckedCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferUncheckedCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    Sell?: SellUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellUncheckedCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartUncheckedCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartUncheckedCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistUncheckedCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutCreatorPurchaseInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatorPurchaseInput, UserUncheckedCreateWithoutCreatorPurchaseInput>
  }

  export type UserCreateWithoutUpdatedPurchaseInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    branch?: BranchCreateNestedOneWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    shops?: ShopCreateNestedManyWithoutUserInput
    stores?: StoreCreateNestedManyWithoutUserInput
    Log?: LogCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseCreateNestedManyWithoutCreatedByInput
    CreatedTransfer?: TransferCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionCreateNestedManyWithoutUpdatedByInput
    Sell?: SellCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutUpdatedPurchaseInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    branchId?: string | null
    roleId: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    shops?: ShopUncheckedCreateNestedManyWithoutUserInput
    stores?: StoreUncheckedCreateNestedManyWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseUncheckedCreateNestedManyWithoutCreatedByInput
    CreatedTransfer?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferUncheckedCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    Sell?: SellUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellUncheckedCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartUncheckedCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartUncheckedCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistUncheckedCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutUpdatedPurchaseInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedPurchaseInput, UserUncheckedCreateWithoutUpdatedPurchaseInput>
  }

  export type PurchaseItemCreateWithoutPurchaseInput = {
    id?: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutPurchaseItemInput
    batch: ProductBatchCreateNestedOneWithoutPurchaseItemInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutPurchaseItemInput
  }

  export type PurchaseItemUncheckedCreateWithoutPurchaseInput = {
    id?: string
    productId: string
    batchId: string
    unitOfMeasureId: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseItemCreateOrConnectWithoutPurchaseInput = {
    where: PurchaseItemWhereUniqueInput
    create: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput>
  }

  export type PurchaseItemCreateManyPurchaseInputEnvelope = {
    data: PurchaseItemCreateManyPurchaseInput | PurchaseItemCreateManyPurchaseInput[]
    skipDuplicates?: boolean
  }

  export type StockCorrectionCreateWithoutPurchaseInput = {
    id?: string
    shortCode: string
    reason: $Enums.StockCorrectionReason
    status?: $Enums.StockCorrectionStatus
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store?: StoreCreateNestedOneWithoutStockCorrectionInput
    shop?: ShopCreateNestedOneWithoutStockCorrectionInput
    transfer?: TransferCreateNestedOneWithoutStockCorrectionInput
    createdBy?: UserCreateNestedOneWithoutStockCorrectionInput
    updatedBy?: UserCreateNestedOneWithoutUpdateStockCorrectionInput
    items?: StockCorrectionItemCreateNestedManyWithoutCorrectionInput
  }

  export type StockCorrectionUncheckedCreateWithoutPurchaseInput = {
    id?: string
    shortCode: string
    storeId?: string | null
    shopId?: string | null
    reason: $Enums.StockCorrectionReason
    status?: $Enums.StockCorrectionStatus
    transferId?: string | null
    reference?: string | null
    notes?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: StockCorrectionItemUncheckedCreateNestedManyWithoutCorrectionInput
  }

  export type StockCorrectionCreateOrConnectWithoutPurchaseInput = {
    where: StockCorrectionWhereUniqueInput
    create: XOR<StockCorrectionCreateWithoutPurchaseInput, StockCorrectionUncheckedCreateWithoutPurchaseInput>
  }

  export type StockCorrectionCreateManyPurchaseInputEnvelope = {
    data: StockCorrectionCreateManyPurchaseInput | StockCorrectionCreateManyPurchaseInput[]
    skipDuplicates?: boolean
  }

  export type SupplierUpsertWithoutPurchaseInput = {
    update: XOR<SupplierUpdateWithoutPurchaseInput, SupplierUncheckedUpdateWithoutPurchaseInput>
    create: XOR<SupplierCreateWithoutPurchaseInput, SupplierUncheckedCreateWithoutPurchaseInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutPurchaseInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutPurchaseInput, SupplierUncheckedUpdateWithoutPurchaseInput>
  }

  export type SupplierUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    tinNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUncheckedUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    tinNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreUpsertWithoutPurchaseInput = {
    update: XOR<StoreUpdateWithoutPurchaseInput, StoreUncheckedUpdateWithoutPurchaseInput>
    create: XOR<StoreCreateWithoutPurchaseInput, StoreUncheckedCreateWithoutPurchaseInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutPurchaseInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutPurchaseInput, StoreUncheckedUpdateWithoutPurchaseInput>
  }

  export type StoreUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStoreNestedInput
    ProductBatch?: ProductBatchUpdateManyWithoutStoreNestedInput
    StoreStock?: StoreStockUpdateManyWithoutStoreNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutStoreNestedInput
    SourceTransfer?: TransferUpdateManyWithoutSourceStoreNestedInput
    DestinatTransfer?: TransferUpdateManyWithoutDestStoreNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutStoreNestedInput
    User?: UserUpdateManyWithoutStoresNestedInput
    notifications?: NotificationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductBatch?: ProductBatchUncheckedUpdateManyWithoutStoreNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutStoreNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutStoreNestedInput
    SourceTransfer?: TransferUncheckedUpdateManyWithoutSourceStoreNestedInput
    DestinatTransfer?: TransferUncheckedUpdateManyWithoutDestStoreNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutStoreNestedInput
    User?: UserUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type UserUpsertWithoutCreatorPurchaseInput = {
    update: XOR<UserUpdateWithoutCreatorPurchaseInput, UserUncheckedUpdateWithoutCreatorPurchaseInput>
    create: XOR<UserCreateWithoutCreatorPurchaseInput, UserUncheckedCreateWithoutCreatorPurchaseInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatorPurchaseInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatorPurchaseInput, UserUncheckedUpdateWithoutCreatorPurchaseInput>
  }

  export type UserUpdateWithoutCreatorPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: BranchUpdateOneWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    shops?: ShopUpdateManyWithoutUserNestedInput
    stores?: StoreUpdateManyWithoutUserNestedInput
    Log?: LogUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUserNestedInput
    UpdatedPurchase?: PurchaseUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatorPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shops?: ShopUncheckedUpdateManyWithoutUserNestedInput
    stores?: StoreUncheckedUpdateManyWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUserNestedInput
    UpdatedPurchase?: PurchaseUncheckedUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUncheckedUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUncheckedUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUncheckedUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUncheckedUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUncheckedUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUpsertWithoutUpdatedPurchaseInput = {
    update: XOR<UserUpdateWithoutUpdatedPurchaseInput, UserUncheckedUpdateWithoutUpdatedPurchaseInput>
    create: XOR<UserCreateWithoutUpdatedPurchaseInput, UserUncheckedCreateWithoutUpdatedPurchaseInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedPurchaseInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedPurchaseInput, UserUncheckedUpdateWithoutUpdatedPurchaseInput>
  }

  export type UserUpdateWithoutUpdatedPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: BranchUpdateOneWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    shops?: ShopUpdateManyWithoutUserNestedInput
    stores?: StoreUpdateManyWithoutUserNestedInput
    Log?: LogUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUpdateManyWithoutCreatedByNestedInput
    CreatedTransfer?: TransferUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shops?: ShopUncheckedUpdateManyWithoutUserNestedInput
    stores?: StoreUncheckedUpdateManyWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUncheckedUpdateManyWithoutCreatedByNestedInput
    CreatedTransfer?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUncheckedUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUncheckedUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUncheckedUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUncheckedUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUncheckedUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type PurchaseItemUpsertWithWhereUniqueWithoutPurchaseInput = {
    where: PurchaseItemWhereUniqueInput
    update: XOR<PurchaseItemUpdateWithoutPurchaseInput, PurchaseItemUncheckedUpdateWithoutPurchaseInput>
    create: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput>
  }

  export type PurchaseItemUpdateWithWhereUniqueWithoutPurchaseInput = {
    where: PurchaseItemWhereUniqueInput
    data: XOR<PurchaseItemUpdateWithoutPurchaseInput, PurchaseItemUncheckedUpdateWithoutPurchaseInput>
  }

  export type PurchaseItemUpdateManyWithWhereWithoutPurchaseInput = {
    where: PurchaseItemScalarWhereInput
    data: XOR<PurchaseItemUpdateManyMutationInput, PurchaseItemUncheckedUpdateManyWithoutPurchaseInput>
  }

  export type StockCorrectionUpsertWithWhereUniqueWithoutPurchaseInput = {
    where: StockCorrectionWhereUniqueInput
    update: XOR<StockCorrectionUpdateWithoutPurchaseInput, StockCorrectionUncheckedUpdateWithoutPurchaseInput>
    create: XOR<StockCorrectionCreateWithoutPurchaseInput, StockCorrectionUncheckedCreateWithoutPurchaseInput>
  }

  export type StockCorrectionUpdateWithWhereUniqueWithoutPurchaseInput = {
    where: StockCorrectionWhereUniqueInput
    data: XOR<StockCorrectionUpdateWithoutPurchaseInput, StockCorrectionUncheckedUpdateWithoutPurchaseInput>
  }

  export type StockCorrectionUpdateManyWithWhereWithoutPurchaseInput = {
    where: StockCorrectionScalarWhereInput
    data: XOR<StockCorrectionUpdateManyMutationInput, StockCorrectionUncheckedUpdateManyWithoutPurchaseInput>
  }

  export type PurchaseCreateWithoutItemsInput = {
    id?: string
    invoiceNo: string
    paymentStatus?: $Enums.PaymentStatus
    totalProducts?: number
    subTotal?: number
    grandTotal?: number
    notes?: string | null
    purchaseDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutPurchaseInput
    store: StoreCreateNestedOneWithoutPurchaseInput
    createdBy?: UserCreateNestedOneWithoutCreatorPurchaseInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedPurchaseInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutItemsInput = {
    id?: string
    invoiceNo: string
    supplierId: string
    storeId: string
    paymentStatus?: $Enums.PaymentStatus
    totalProducts?: number
    subTotal?: number
    grandTotal?: number
    notes?: string | null
    purchaseDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutItemsInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutItemsInput, PurchaseUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutPurchaseItemInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    subCategory?: SubCategoryCreateNestedOneWithoutProductsInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutProductsInput
    batches?: ProductBatchCreateNestedManyWithoutProductInput
    TransferItem?: TransferItemCreateNestedManyWithoutProductInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutProductInput
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    AdditionalPrice?: AdditionalPriceCreateNestedManyWithoutProductInput
    SellItem?: SellItemCreateNestedManyWithoutProductInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutProductInput
    waitlists?: WaitlistCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPurchaseItemInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    categoryId: string
    subCategoryId?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    unitOfMeasureId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: ProductBatchUncheckedCreateNestedManyWithoutProductInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutProductInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutProductInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    AdditionalPrice?: AdditionalPriceUncheckedCreateNestedManyWithoutProductInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutProductInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutProductInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPurchaseItemInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPurchaseItemInput, ProductUncheckedCreateWithoutPurchaseItemInput>
  }

  export type ProductBatchCreateWithoutPurchaseItemInput = {
    id?: string
    batchNumber: string
    expiryDate?: Date | string | null
    price?: number | null
    stock?: number | null
    warningQuantity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store?: StoreCreateNestedOneWithoutProductBatchInput
    product: ProductCreateNestedOneWithoutBatchesInput
    ShopStock?: ShopStockCreateNestedManyWithoutBatchInput
    StoreStock?: StoreStockCreateNestedManyWithoutBatchInput
    StockLedger?: StockLedgerCreateNestedManyWithoutBatchInput
    TransferItem?: TransferItemCreateNestedManyWithoutBatchInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutBatchInput
    SellItemBatch?: SellItemBatchCreateNestedManyWithoutBatchInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchCreateNestedManyWithoutBatchInput
  }

  export type ProductBatchUncheckedCreateWithoutPurchaseItemInput = {
    id?: string
    batchNumber: string
    expiryDate?: Date | string | null
    productId: string
    price?: number | null
    stock?: number | null
    warningQuantity?: number | null
    storeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutBatchInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutBatchInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutBatchInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutBatchInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutBatchInput
    SellItemBatch?: SellItemBatchUncheckedCreateNestedManyWithoutBatchInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUncheckedCreateNestedManyWithoutBatchInput
  }

  export type ProductBatchCreateOrConnectWithoutPurchaseItemInput = {
    where: ProductBatchWhereUniqueInput
    create: XOR<ProductBatchCreateWithoutPurchaseItemInput, ProductBatchUncheckedCreateWithoutPurchaseItemInput>
  }

  export type UnitOfMeasureCreateWithoutPurchaseItemInput = {
    id?: string
    name: string
    symbol?: string | null
    base?: boolean
    products?: ProductCreateNestedManyWithoutUnitOfMeasureInput
    TransferItem?: TransferItemCreateNestedManyWithoutUnitOfMeasureInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUnitOfMeasureInput
    ShopStock?: ShopStockCreateNestedManyWithoutUnitOfMeasureInput
    StoreStock?: StoreStockCreateNestedManyWithoutUnitOfMeasureInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutUnitOfMeasureInput
    SellItem?: SellItemCreateNestedManyWithoutUnitOfMeasureInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutUnitOfMeasureInput
    CartItem?: CartItemCreateNestedManyWithoutUnitOfMeasureInput
  }

  export type UnitOfMeasureUncheckedCreateWithoutPurchaseItemInput = {
    id?: string
    name: string
    symbol?: string | null
    base?: boolean
    products?: ProductUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
  }

  export type UnitOfMeasureCreateOrConnectWithoutPurchaseItemInput = {
    where: UnitOfMeasureWhereUniqueInput
    create: XOR<UnitOfMeasureCreateWithoutPurchaseItemInput, UnitOfMeasureUncheckedCreateWithoutPurchaseItemInput>
  }

  export type PurchaseUpsertWithoutItemsInput = {
    update: XOR<PurchaseUpdateWithoutItemsInput, PurchaseUncheckedUpdateWithoutItemsInput>
    create: XOR<PurchaseCreateWithoutItemsInput, PurchaseUncheckedCreateWithoutItemsInput>
    where?: PurchaseWhereInput
  }

  export type PurchaseUpdateToOneWithWhereWithoutItemsInput = {
    where?: PurchaseWhereInput
    data: XOR<PurchaseUpdateWithoutItemsInput, PurchaseUncheckedUpdateWithoutItemsInput>
  }

  export type PurchaseUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseNestedInput
    store?: StoreUpdateOneRequiredWithoutPurchaseNestedInput
    createdBy?: UserUpdateOneWithoutCreatorPurchaseNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedPurchaseNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type ProductUpsertWithoutPurchaseItemInput = {
    update: XOR<ProductUpdateWithoutPurchaseItemInput, ProductUncheckedUpdateWithoutPurchaseItemInput>
    create: XOR<ProductCreateWithoutPurchaseItemInput, ProductUncheckedCreateWithoutPurchaseItemInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPurchaseItemInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPurchaseItemInput, ProductUncheckedUpdateWithoutPurchaseItemInput>
  }

  export type ProductUpdateWithoutPurchaseItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    subCategory?: SubCategoryUpdateOneWithoutProductsNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutProductsNestedInput
    batches?: ProductBatchUpdateManyWithoutProductNestedInput
    TransferItem?: TransferItemUpdateManyWithoutProductNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    AdditionalPrice?: AdditionalPriceUpdateManyWithoutProductNestedInput
    SellItem?: SellItemUpdateManyWithoutProductNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutProductNestedInput
    waitlists?: WaitlistUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPurchaseItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    subCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: ProductBatchUncheckedUpdateManyWithoutProductNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    AdditionalPrice?: AdditionalPriceUncheckedUpdateManyWithoutProductNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutProductNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutProductNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductBatchUpsertWithoutPurchaseItemInput = {
    update: XOR<ProductBatchUpdateWithoutPurchaseItemInput, ProductBatchUncheckedUpdateWithoutPurchaseItemInput>
    create: XOR<ProductBatchCreateWithoutPurchaseItemInput, ProductBatchUncheckedCreateWithoutPurchaseItemInput>
    where?: ProductBatchWhereInput
  }

  export type ProductBatchUpdateToOneWithWhereWithoutPurchaseItemInput = {
    where?: ProductBatchWhereInput
    data: XOR<ProductBatchUpdateWithoutPurchaseItemInput, ProductBatchUncheckedUpdateWithoutPurchaseItemInput>
  }

  export type ProductBatchUpdateWithoutPurchaseItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    warningQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneWithoutProductBatchNestedInput
    product?: ProductUpdateOneRequiredWithoutBatchesNestedInput
    ShopStock?: ShopStockUpdateManyWithoutBatchNestedInput
    StoreStock?: StoreStockUpdateManyWithoutBatchNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutBatchNestedInput
    TransferItem?: TransferItemUpdateManyWithoutBatchNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutBatchNestedInput
    SellItemBatch?: SellItemBatchUpdateManyWithoutBatchNestedInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUpdateManyWithoutBatchNestedInput
  }

  export type ProductBatchUncheckedUpdateWithoutPurchaseItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productId?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    warningQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopStock?: ShopStockUncheckedUpdateManyWithoutBatchNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutBatchNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutBatchNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutBatchNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutBatchNestedInput
    SellItemBatch?: SellItemBatchUncheckedUpdateManyWithoutBatchNestedInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type UnitOfMeasureUpsertWithoutPurchaseItemInput = {
    update: XOR<UnitOfMeasureUpdateWithoutPurchaseItemInput, UnitOfMeasureUncheckedUpdateWithoutPurchaseItemInput>
    create: XOR<UnitOfMeasureCreateWithoutPurchaseItemInput, UnitOfMeasureUncheckedCreateWithoutPurchaseItemInput>
    where?: UnitOfMeasureWhereInput
  }

  export type UnitOfMeasureUpdateToOneWithWhereWithoutPurchaseItemInput = {
    where?: UnitOfMeasureWhereInput
    data: XOR<UnitOfMeasureUpdateWithoutPurchaseItemInput, UnitOfMeasureUncheckedUpdateWithoutPurchaseItemInput>
  }

  export type UnitOfMeasureUpdateWithoutPurchaseItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    base?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductUpdateManyWithoutUnitOfMeasureNestedInput
    TransferItem?: TransferItemUpdateManyWithoutUnitOfMeasureNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUnitOfMeasureNestedInput
    ShopStock?: ShopStockUpdateManyWithoutUnitOfMeasureNestedInput
    StoreStock?: StoreStockUpdateManyWithoutUnitOfMeasureNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutUnitOfMeasureNestedInput
    SellItem?: SellItemUpdateManyWithoutUnitOfMeasureNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutUnitOfMeasureNestedInput
    CartItem?: CartItemUpdateManyWithoutUnitOfMeasureNestedInput
  }

  export type UnitOfMeasureUncheckedUpdateWithoutPurchaseItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    base?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    ShopStock?: ShopStockUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
  }

  export type StoreCreateWithoutSourceTransferInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutStoreInput
    ProductBatch?: ProductBatchCreateNestedManyWithoutStoreInput
    StoreStock?: StoreStockCreateNestedManyWithoutStoreInput
    StockLedger?: StockLedgerCreateNestedManyWithoutStoreInput
    Purchase?: PurchaseCreateNestedManyWithoutStoreInput
    DestinatTransfer?: TransferCreateNestedManyWithoutDestStoreInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutStoreInput
    User?: UserCreateNestedManyWithoutStoresInput
    notifications?: NotificationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutSourceTransferInput = {
    id?: string
    name: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ProductBatch?: ProductBatchUncheckedCreateNestedManyWithoutStoreInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutStoreInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutStoreInput
    Purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    DestinatTransfer?: TransferUncheckedCreateNestedManyWithoutDestStoreInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutStoreInput
    User?: UserUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutSourceTransferInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutSourceTransferInput, StoreUncheckedCreateWithoutSourceTransferInput>
  }

  export type ShopCreateWithoutSourceTransferInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutShopInput
    ShopStock?: ShopStockCreateNestedManyWithoutShopInput
    StockLedger?: StockLedgerCreateNestedManyWithoutShopInput
    DestinatTransfer?: TransferCreateNestedManyWithoutDestShopInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutShopInput
    AdditionalPrice?: AdditionalPriceCreateNestedManyWithoutShopInput
    SellItem?: SellItemCreateNestedManyWithoutShopInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutShopInput
    User?: UserCreateNestedManyWithoutShopsInput
    CartItem?: CartItemCreateNestedManyWithoutShopInput
    waitlists?: WaitlistCreateNestedManyWithoutShopInput
    notifications?: NotificationCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutSourceTransferInput = {
    id?: string
    name: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutShopInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutShopInput
    DestinatTransfer?: TransferUncheckedCreateNestedManyWithoutDestShopInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutShopInput
    AdditionalPrice?: AdditionalPriceUncheckedCreateNestedManyWithoutShopInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutShopInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutShopInput
    User?: UserUncheckedCreateNestedManyWithoutShopsInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutShopInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutShopInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutSourceTransferInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutSourceTransferInput, ShopUncheckedCreateWithoutSourceTransferInput>
  }

  export type StoreCreateWithoutDestinatTransferInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutStoreInput
    ProductBatch?: ProductBatchCreateNestedManyWithoutStoreInput
    StoreStock?: StoreStockCreateNestedManyWithoutStoreInput
    StockLedger?: StockLedgerCreateNestedManyWithoutStoreInput
    Purchase?: PurchaseCreateNestedManyWithoutStoreInput
    SourceTransfer?: TransferCreateNestedManyWithoutSourceStoreInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutStoreInput
    User?: UserCreateNestedManyWithoutStoresInput
    notifications?: NotificationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutDestinatTransferInput = {
    id?: string
    name: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ProductBatch?: ProductBatchUncheckedCreateNestedManyWithoutStoreInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutStoreInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutStoreInput
    Purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    SourceTransfer?: TransferUncheckedCreateNestedManyWithoutSourceStoreInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutStoreInput
    User?: UserUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutDestinatTransferInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutDestinatTransferInput, StoreUncheckedCreateWithoutDestinatTransferInput>
  }

  export type ShopCreateWithoutDestinatTransferInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutShopInput
    ShopStock?: ShopStockCreateNestedManyWithoutShopInput
    StockLedger?: StockLedgerCreateNestedManyWithoutShopInput
    SourceTransfer?: TransferCreateNestedManyWithoutSourceShopInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutShopInput
    AdditionalPrice?: AdditionalPriceCreateNestedManyWithoutShopInput
    SellItem?: SellItemCreateNestedManyWithoutShopInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutShopInput
    User?: UserCreateNestedManyWithoutShopsInput
    CartItem?: CartItemCreateNestedManyWithoutShopInput
    waitlists?: WaitlistCreateNestedManyWithoutShopInput
    notifications?: NotificationCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutDestinatTransferInput = {
    id?: string
    name: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutShopInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutShopInput
    SourceTransfer?: TransferUncheckedCreateNestedManyWithoutSourceShopInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutShopInput
    AdditionalPrice?: AdditionalPriceUncheckedCreateNestedManyWithoutShopInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutShopInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutShopInput
    User?: UserUncheckedCreateNestedManyWithoutShopsInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutShopInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutShopInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutDestinatTransferInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutDestinatTransferInput, ShopUncheckedCreateWithoutDestinatTransferInput>
  }

  export type UserCreateWithoutCreatedTransferInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    branch?: BranchCreateNestedOneWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    shops?: ShopCreateNestedManyWithoutUserInput
    stores?: StoreCreateNestedManyWithoutUserInput
    Log?: LogCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseCreateNestedManyWithoutUpdatedByInput
    UpdatedTransfer?: TransferCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionCreateNestedManyWithoutUpdatedByInput
    Sell?: SellCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutCreatedTransferInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    branchId?: string | null
    roleId: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    shops?: ShopUncheckedCreateNestedManyWithoutUserInput
    stores?: StoreUncheckedCreateNestedManyWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseUncheckedCreateNestedManyWithoutUpdatedByInput
    UpdatedTransfer?: TransferUncheckedCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    Sell?: SellUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellUncheckedCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartUncheckedCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartUncheckedCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistUncheckedCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutCreatedTransferInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTransferInput, UserUncheckedCreateWithoutCreatedTransferInput>
  }

  export type UserCreateWithoutUpdatedTransferInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    branch?: BranchCreateNestedOneWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    shops?: ShopCreateNestedManyWithoutUserInput
    stores?: StoreCreateNestedManyWithoutUserInput
    Log?: LogCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferCreateNestedManyWithoutCreatedByInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionCreateNestedManyWithoutUpdatedByInput
    Sell?: SellCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutUpdatedTransferInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    branchId?: string | null
    roleId: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    shops?: ShopUncheckedCreateNestedManyWithoutUserInput
    stores?: StoreUncheckedCreateNestedManyWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseUncheckedCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    Sell?: SellUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellUncheckedCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartUncheckedCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartUncheckedCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistUncheckedCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutUpdatedTransferInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedTransferInput, UserUncheckedCreateWithoutUpdatedTransferInput>
  }

  export type TransferItemCreateWithoutTransferInput = {
    id?: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutTransferItemInput
    batch: ProductBatchCreateNestedOneWithoutTransferItemInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutTransferItemInput
  }

  export type TransferItemUncheckedCreateWithoutTransferInput = {
    id?: string
    productId: string
    batchId: string
    unitOfMeasureId: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferItemCreateOrConnectWithoutTransferInput = {
    where: TransferItemWhereUniqueInput
    create: XOR<TransferItemCreateWithoutTransferInput, TransferItemUncheckedCreateWithoutTransferInput>
  }

  export type TransferItemCreateManyTransferInputEnvelope = {
    data: TransferItemCreateManyTransferInput | TransferItemCreateManyTransferInput[]
    skipDuplicates?: boolean
  }

  export type StockCorrectionCreateWithoutTransferInput = {
    id?: string
    shortCode: string
    reason: $Enums.StockCorrectionReason
    status?: $Enums.StockCorrectionStatus
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store?: StoreCreateNestedOneWithoutStockCorrectionInput
    shop?: ShopCreateNestedOneWithoutStockCorrectionInput
    purchase?: PurchaseCreateNestedOneWithoutStockCorrectionInput
    createdBy?: UserCreateNestedOneWithoutStockCorrectionInput
    updatedBy?: UserCreateNestedOneWithoutUpdateStockCorrectionInput
    items?: StockCorrectionItemCreateNestedManyWithoutCorrectionInput
  }

  export type StockCorrectionUncheckedCreateWithoutTransferInput = {
    id?: string
    shortCode: string
    storeId?: string | null
    shopId?: string | null
    reason: $Enums.StockCorrectionReason
    status?: $Enums.StockCorrectionStatus
    purchaseId?: string | null
    reference?: string | null
    notes?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: StockCorrectionItemUncheckedCreateNestedManyWithoutCorrectionInput
  }

  export type StockCorrectionCreateOrConnectWithoutTransferInput = {
    where: StockCorrectionWhereUniqueInput
    create: XOR<StockCorrectionCreateWithoutTransferInput, StockCorrectionUncheckedCreateWithoutTransferInput>
  }

  export type StockCorrectionCreateManyTransferInputEnvelope = {
    data: StockCorrectionCreateManyTransferInput | StockCorrectionCreateManyTransferInput[]
    skipDuplicates?: boolean
  }

  export type StoreUpsertWithoutSourceTransferInput = {
    update: XOR<StoreUpdateWithoutSourceTransferInput, StoreUncheckedUpdateWithoutSourceTransferInput>
    create: XOR<StoreCreateWithoutSourceTransferInput, StoreUncheckedCreateWithoutSourceTransferInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutSourceTransferInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutSourceTransferInput, StoreUncheckedUpdateWithoutSourceTransferInput>
  }

  export type StoreUpdateWithoutSourceTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStoreNestedInput
    ProductBatch?: ProductBatchUpdateManyWithoutStoreNestedInput
    StoreStock?: StoreStockUpdateManyWithoutStoreNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutStoreNestedInput
    Purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    DestinatTransfer?: TransferUpdateManyWithoutDestStoreNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutStoreNestedInput
    User?: UserUpdateManyWithoutStoresNestedInput
    notifications?: NotificationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutSourceTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductBatch?: ProductBatchUncheckedUpdateManyWithoutStoreNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutStoreNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutStoreNestedInput
    Purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    DestinatTransfer?: TransferUncheckedUpdateManyWithoutDestStoreNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutStoreNestedInput
    User?: UserUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type ShopUpsertWithoutSourceTransferInput = {
    update: XOR<ShopUpdateWithoutSourceTransferInput, ShopUncheckedUpdateWithoutSourceTransferInput>
    create: XOR<ShopCreateWithoutSourceTransferInput, ShopUncheckedCreateWithoutSourceTransferInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutSourceTransferInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutSourceTransferInput, ShopUncheckedUpdateWithoutSourceTransferInput>
  }

  export type ShopUpdateWithoutSourceTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutShopNestedInput
    ShopStock?: ShopStockUpdateManyWithoutShopNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutShopNestedInput
    DestinatTransfer?: TransferUpdateManyWithoutDestShopNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutShopNestedInput
    AdditionalPrice?: AdditionalPriceUpdateManyWithoutShopNestedInput
    SellItem?: SellItemUpdateManyWithoutShopNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutShopNestedInput
    User?: UserUpdateManyWithoutShopsNestedInput
    CartItem?: CartItemUpdateManyWithoutShopNestedInput
    waitlists?: WaitlistUpdateManyWithoutShopNestedInput
    notifications?: NotificationUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutSourceTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopStock?: ShopStockUncheckedUpdateManyWithoutShopNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutShopNestedInput
    DestinatTransfer?: TransferUncheckedUpdateManyWithoutDestShopNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutShopNestedInput
    AdditionalPrice?: AdditionalPriceUncheckedUpdateManyWithoutShopNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutShopNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutShopNestedInput
    User?: UserUncheckedUpdateManyWithoutShopsNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutShopNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutShopNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutShopNestedInput
  }

  export type StoreUpsertWithoutDestinatTransferInput = {
    update: XOR<StoreUpdateWithoutDestinatTransferInput, StoreUncheckedUpdateWithoutDestinatTransferInput>
    create: XOR<StoreCreateWithoutDestinatTransferInput, StoreUncheckedCreateWithoutDestinatTransferInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutDestinatTransferInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutDestinatTransferInput, StoreUncheckedUpdateWithoutDestinatTransferInput>
  }

  export type StoreUpdateWithoutDestinatTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStoreNestedInput
    ProductBatch?: ProductBatchUpdateManyWithoutStoreNestedInput
    StoreStock?: StoreStockUpdateManyWithoutStoreNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutStoreNestedInput
    Purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    SourceTransfer?: TransferUpdateManyWithoutSourceStoreNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutStoreNestedInput
    User?: UserUpdateManyWithoutStoresNestedInput
    notifications?: NotificationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutDestinatTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductBatch?: ProductBatchUncheckedUpdateManyWithoutStoreNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutStoreNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutStoreNestedInput
    Purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    SourceTransfer?: TransferUncheckedUpdateManyWithoutSourceStoreNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutStoreNestedInput
    User?: UserUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type ShopUpsertWithoutDestinatTransferInput = {
    update: XOR<ShopUpdateWithoutDestinatTransferInput, ShopUncheckedUpdateWithoutDestinatTransferInput>
    create: XOR<ShopCreateWithoutDestinatTransferInput, ShopUncheckedCreateWithoutDestinatTransferInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutDestinatTransferInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutDestinatTransferInput, ShopUncheckedUpdateWithoutDestinatTransferInput>
  }

  export type ShopUpdateWithoutDestinatTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutShopNestedInput
    ShopStock?: ShopStockUpdateManyWithoutShopNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutShopNestedInput
    SourceTransfer?: TransferUpdateManyWithoutSourceShopNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutShopNestedInput
    AdditionalPrice?: AdditionalPriceUpdateManyWithoutShopNestedInput
    SellItem?: SellItemUpdateManyWithoutShopNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutShopNestedInput
    User?: UserUpdateManyWithoutShopsNestedInput
    CartItem?: CartItemUpdateManyWithoutShopNestedInput
    waitlists?: WaitlistUpdateManyWithoutShopNestedInput
    notifications?: NotificationUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutDestinatTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopStock?: ShopStockUncheckedUpdateManyWithoutShopNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutShopNestedInput
    SourceTransfer?: TransferUncheckedUpdateManyWithoutSourceShopNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutShopNestedInput
    AdditionalPrice?: AdditionalPriceUncheckedUpdateManyWithoutShopNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutShopNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutShopNestedInput
    User?: UserUncheckedUpdateManyWithoutShopsNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutShopNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutShopNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutShopNestedInput
  }

  export type UserUpsertWithoutCreatedTransferInput = {
    update: XOR<UserUpdateWithoutCreatedTransferInput, UserUncheckedUpdateWithoutCreatedTransferInput>
    create: XOR<UserCreateWithoutCreatedTransferInput, UserUncheckedCreateWithoutCreatedTransferInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedTransferInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedTransferInput, UserUncheckedUpdateWithoutCreatedTransferInput>
  }

  export type UserUpdateWithoutCreatedTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: BranchUpdateOneWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    shops?: ShopUpdateManyWithoutUserNestedInput
    stores?: StoreUpdateManyWithoutUserNestedInput
    Log?: LogUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUpdateManyWithoutUpdatedByNestedInput
    UpdatedTransfer?: TransferUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shops?: ShopUncheckedUpdateManyWithoutUserNestedInput
    stores?: StoreUncheckedUpdateManyWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUncheckedUpdateManyWithoutUpdatedByNestedInput
    UpdatedTransfer?: TransferUncheckedUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUncheckedUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUncheckedUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUncheckedUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUncheckedUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUpsertWithoutUpdatedTransferInput = {
    update: XOR<UserUpdateWithoutUpdatedTransferInput, UserUncheckedUpdateWithoutUpdatedTransferInput>
    create: XOR<UserCreateWithoutUpdatedTransferInput, UserUncheckedCreateWithoutUpdatedTransferInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedTransferInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedTransferInput, UserUncheckedUpdateWithoutUpdatedTransferInput>
  }

  export type UserUpdateWithoutUpdatedTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: BranchUpdateOneWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    shops?: ShopUpdateManyWithoutUserNestedInput
    stores?: StoreUpdateManyWithoutUserNestedInput
    Log?: LogUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUpdateManyWithoutCreatedByNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shops?: ShopUncheckedUpdateManyWithoutUserNestedInput
    stores?: StoreUncheckedUpdateManyWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUncheckedUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUncheckedUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUncheckedUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUncheckedUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUncheckedUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type TransferItemUpsertWithWhereUniqueWithoutTransferInput = {
    where: TransferItemWhereUniqueInput
    update: XOR<TransferItemUpdateWithoutTransferInput, TransferItemUncheckedUpdateWithoutTransferInput>
    create: XOR<TransferItemCreateWithoutTransferInput, TransferItemUncheckedCreateWithoutTransferInput>
  }

  export type TransferItemUpdateWithWhereUniqueWithoutTransferInput = {
    where: TransferItemWhereUniqueInput
    data: XOR<TransferItemUpdateWithoutTransferInput, TransferItemUncheckedUpdateWithoutTransferInput>
  }

  export type TransferItemUpdateManyWithWhereWithoutTransferInput = {
    where: TransferItemScalarWhereInput
    data: XOR<TransferItemUpdateManyMutationInput, TransferItemUncheckedUpdateManyWithoutTransferInput>
  }

  export type StockCorrectionUpsertWithWhereUniqueWithoutTransferInput = {
    where: StockCorrectionWhereUniqueInput
    update: XOR<StockCorrectionUpdateWithoutTransferInput, StockCorrectionUncheckedUpdateWithoutTransferInput>
    create: XOR<StockCorrectionCreateWithoutTransferInput, StockCorrectionUncheckedCreateWithoutTransferInput>
  }

  export type StockCorrectionUpdateWithWhereUniqueWithoutTransferInput = {
    where: StockCorrectionWhereUniqueInput
    data: XOR<StockCorrectionUpdateWithoutTransferInput, StockCorrectionUncheckedUpdateWithoutTransferInput>
  }

  export type StockCorrectionUpdateManyWithWhereWithoutTransferInput = {
    where: StockCorrectionScalarWhereInput
    data: XOR<StockCorrectionUpdateManyMutationInput, StockCorrectionUncheckedUpdateManyWithoutTransferInput>
  }

  export type TransferCreateWithoutItemsInput = {
    id?: string
    shortCode: string
    sourceType: $Enums.TransferEntityType
    destinationType: $Enums.TransferEntityType
    reference?: string | null
    notes?: string | null
    status?: $Enums.TransferStatus
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceStore?: StoreCreateNestedOneWithoutSourceTransferInput
    sourceShop?: ShopCreateNestedOneWithoutSourceTransferInput
    destStore?: StoreCreateNestedOneWithoutDestinatTransferInput
    destShop?: ShopCreateNestedOneWithoutDestinatTransferInput
    createdBy?: UserCreateNestedOneWithoutCreatedTransferInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedTransferInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutItemsInput = {
    id?: string
    shortCode: string
    sourceType: $Enums.TransferEntityType
    sourceStoreId?: string | null
    sourceShopId?: string | null
    destinationType: $Enums.TransferEntityType
    destStoreId?: string | null
    destShopId?: string | null
    reference?: string | null
    notes?: string | null
    status?: $Enums.TransferStatus
    movementDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutItemsInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutItemsInput, TransferUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutTransferItemInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    subCategory?: SubCategoryCreateNestedOneWithoutProductsInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutProductsInput
    batches?: ProductBatchCreateNestedManyWithoutProductInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutProductInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutProductInput
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    AdditionalPrice?: AdditionalPriceCreateNestedManyWithoutProductInput
    SellItem?: SellItemCreateNestedManyWithoutProductInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutProductInput
    waitlists?: WaitlistCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutTransferItemInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    categoryId: string
    subCategoryId?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    unitOfMeasureId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: ProductBatchUncheckedCreateNestedManyWithoutProductInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutProductInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    AdditionalPrice?: AdditionalPriceUncheckedCreateNestedManyWithoutProductInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutProductInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutProductInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutTransferItemInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTransferItemInput, ProductUncheckedCreateWithoutTransferItemInput>
  }

  export type ProductBatchCreateWithoutTransferItemInput = {
    id?: string
    batchNumber: string
    expiryDate?: Date | string | null
    price?: number | null
    stock?: number | null
    warningQuantity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store?: StoreCreateNestedOneWithoutProductBatchInput
    product: ProductCreateNestedOneWithoutBatchesInput
    ShopStock?: ShopStockCreateNestedManyWithoutBatchInput
    StoreStock?: StoreStockCreateNestedManyWithoutBatchInput
    StockLedger?: StockLedgerCreateNestedManyWithoutBatchInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutBatchInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutBatchInput
    SellItemBatch?: SellItemBatchCreateNestedManyWithoutBatchInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchCreateNestedManyWithoutBatchInput
  }

  export type ProductBatchUncheckedCreateWithoutTransferItemInput = {
    id?: string
    batchNumber: string
    expiryDate?: Date | string | null
    productId: string
    price?: number | null
    stock?: number | null
    warningQuantity?: number | null
    storeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutBatchInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutBatchInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutBatchInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutBatchInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutBatchInput
    SellItemBatch?: SellItemBatchUncheckedCreateNestedManyWithoutBatchInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUncheckedCreateNestedManyWithoutBatchInput
  }

  export type ProductBatchCreateOrConnectWithoutTransferItemInput = {
    where: ProductBatchWhereUniqueInput
    create: XOR<ProductBatchCreateWithoutTransferItemInput, ProductBatchUncheckedCreateWithoutTransferItemInput>
  }

  export type UnitOfMeasureCreateWithoutTransferItemInput = {
    id?: string
    name: string
    symbol?: string | null
    base?: boolean
    products?: ProductCreateNestedManyWithoutUnitOfMeasureInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutUnitOfMeasureInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUnitOfMeasureInput
    ShopStock?: ShopStockCreateNestedManyWithoutUnitOfMeasureInput
    StoreStock?: StoreStockCreateNestedManyWithoutUnitOfMeasureInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutUnitOfMeasureInput
    SellItem?: SellItemCreateNestedManyWithoutUnitOfMeasureInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutUnitOfMeasureInput
    CartItem?: CartItemCreateNestedManyWithoutUnitOfMeasureInput
  }

  export type UnitOfMeasureUncheckedCreateWithoutTransferItemInput = {
    id?: string
    name: string
    symbol?: string | null
    base?: boolean
    products?: ProductUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
  }

  export type UnitOfMeasureCreateOrConnectWithoutTransferItemInput = {
    where: UnitOfMeasureWhereUniqueInput
    create: XOR<UnitOfMeasureCreateWithoutTransferItemInput, UnitOfMeasureUncheckedCreateWithoutTransferItemInput>
  }

  export type TransferUpsertWithoutItemsInput = {
    update: XOR<TransferUpdateWithoutItemsInput, TransferUncheckedUpdateWithoutItemsInput>
    create: XOR<TransferCreateWithoutItemsInput, TransferUncheckedCreateWithoutItemsInput>
    where?: TransferWhereInput
  }

  export type TransferUpdateToOneWithWhereWithoutItemsInput = {
    where?: TransferWhereInput
    data: XOR<TransferUpdateWithoutItemsInput, TransferUncheckedUpdateWithoutItemsInput>
  }

  export type TransferUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    destinationType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceStore?: StoreUpdateOneWithoutSourceTransferNestedInput
    sourceShop?: ShopUpdateOneWithoutSourceTransferNestedInput
    destStore?: StoreUpdateOneWithoutDestinatTransferNestedInput
    destShop?: ShopUpdateOneWithoutDestinatTransferNestedInput
    createdBy?: UserUpdateOneWithoutCreatedTransferNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedTransferNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceShopId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    destStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destShopId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type ProductUpsertWithoutTransferItemInput = {
    update: XOR<ProductUpdateWithoutTransferItemInput, ProductUncheckedUpdateWithoutTransferItemInput>
    create: XOR<ProductCreateWithoutTransferItemInput, ProductUncheckedCreateWithoutTransferItemInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutTransferItemInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutTransferItemInput, ProductUncheckedUpdateWithoutTransferItemInput>
  }

  export type ProductUpdateWithoutTransferItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    subCategory?: SubCategoryUpdateOneWithoutProductsNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutProductsNestedInput
    batches?: ProductBatchUpdateManyWithoutProductNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutProductNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    AdditionalPrice?: AdditionalPriceUpdateManyWithoutProductNestedInput
    SellItem?: SellItemUpdateManyWithoutProductNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutProductNestedInput
    waitlists?: WaitlistUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutTransferItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    subCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: ProductBatchUncheckedUpdateManyWithoutProductNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    AdditionalPrice?: AdditionalPriceUncheckedUpdateManyWithoutProductNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutProductNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutProductNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductBatchUpsertWithoutTransferItemInput = {
    update: XOR<ProductBatchUpdateWithoutTransferItemInput, ProductBatchUncheckedUpdateWithoutTransferItemInput>
    create: XOR<ProductBatchCreateWithoutTransferItemInput, ProductBatchUncheckedCreateWithoutTransferItemInput>
    where?: ProductBatchWhereInput
  }

  export type ProductBatchUpdateToOneWithWhereWithoutTransferItemInput = {
    where?: ProductBatchWhereInput
    data: XOR<ProductBatchUpdateWithoutTransferItemInput, ProductBatchUncheckedUpdateWithoutTransferItemInput>
  }

  export type ProductBatchUpdateWithoutTransferItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    warningQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneWithoutProductBatchNestedInput
    product?: ProductUpdateOneRequiredWithoutBatchesNestedInput
    ShopStock?: ShopStockUpdateManyWithoutBatchNestedInput
    StoreStock?: StoreStockUpdateManyWithoutBatchNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutBatchNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutBatchNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutBatchNestedInput
    SellItemBatch?: SellItemBatchUpdateManyWithoutBatchNestedInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUpdateManyWithoutBatchNestedInput
  }

  export type ProductBatchUncheckedUpdateWithoutTransferItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productId?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    warningQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopStock?: ShopStockUncheckedUpdateManyWithoutBatchNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutBatchNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutBatchNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutBatchNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutBatchNestedInput
    SellItemBatch?: SellItemBatchUncheckedUpdateManyWithoutBatchNestedInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type UnitOfMeasureUpsertWithoutTransferItemInput = {
    update: XOR<UnitOfMeasureUpdateWithoutTransferItemInput, UnitOfMeasureUncheckedUpdateWithoutTransferItemInput>
    create: XOR<UnitOfMeasureCreateWithoutTransferItemInput, UnitOfMeasureUncheckedCreateWithoutTransferItemInput>
    where?: UnitOfMeasureWhereInput
  }

  export type UnitOfMeasureUpdateToOneWithWhereWithoutTransferItemInput = {
    where?: UnitOfMeasureWhereInput
    data: XOR<UnitOfMeasureUpdateWithoutTransferItemInput, UnitOfMeasureUncheckedUpdateWithoutTransferItemInput>
  }

  export type UnitOfMeasureUpdateWithoutTransferItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    base?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductUpdateManyWithoutUnitOfMeasureNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutUnitOfMeasureNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUnitOfMeasureNestedInput
    ShopStock?: ShopStockUpdateManyWithoutUnitOfMeasureNestedInput
    StoreStock?: StoreStockUpdateManyWithoutUnitOfMeasureNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutUnitOfMeasureNestedInput
    SellItem?: SellItemUpdateManyWithoutUnitOfMeasureNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutUnitOfMeasureNestedInput
    CartItem?: CartItemUpdateManyWithoutUnitOfMeasureNestedInput
  }

  export type UnitOfMeasureUncheckedUpdateWithoutTransferItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    base?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    ShopStock?: ShopStockUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
  }

  export type StoreCreateWithoutStockCorrectionInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutStoreInput
    ProductBatch?: ProductBatchCreateNestedManyWithoutStoreInput
    StoreStock?: StoreStockCreateNestedManyWithoutStoreInput
    StockLedger?: StockLedgerCreateNestedManyWithoutStoreInput
    Purchase?: PurchaseCreateNestedManyWithoutStoreInput
    SourceTransfer?: TransferCreateNestedManyWithoutSourceStoreInput
    DestinatTransfer?: TransferCreateNestedManyWithoutDestStoreInput
    User?: UserCreateNestedManyWithoutStoresInput
    notifications?: NotificationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutStockCorrectionInput = {
    id?: string
    name: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ProductBatch?: ProductBatchUncheckedCreateNestedManyWithoutStoreInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutStoreInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutStoreInput
    Purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    SourceTransfer?: TransferUncheckedCreateNestedManyWithoutSourceStoreInput
    DestinatTransfer?: TransferUncheckedCreateNestedManyWithoutDestStoreInput
    User?: UserUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutStockCorrectionInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutStockCorrectionInput, StoreUncheckedCreateWithoutStockCorrectionInput>
  }

  export type ShopCreateWithoutStockCorrectionInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutShopInput
    ShopStock?: ShopStockCreateNestedManyWithoutShopInput
    StockLedger?: StockLedgerCreateNestedManyWithoutShopInput
    SourceTransfer?: TransferCreateNestedManyWithoutSourceShopInput
    DestinatTransfer?: TransferCreateNestedManyWithoutDestShopInput
    AdditionalPrice?: AdditionalPriceCreateNestedManyWithoutShopInput
    SellItem?: SellItemCreateNestedManyWithoutShopInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutShopInput
    User?: UserCreateNestedManyWithoutShopsInput
    CartItem?: CartItemCreateNestedManyWithoutShopInput
    waitlists?: WaitlistCreateNestedManyWithoutShopInput
    notifications?: NotificationCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutStockCorrectionInput = {
    id?: string
    name: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutShopInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutShopInput
    SourceTransfer?: TransferUncheckedCreateNestedManyWithoutSourceShopInput
    DestinatTransfer?: TransferUncheckedCreateNestedManyWithoutDestShopInput
    AdditionalPrice?: AdditionalPriceUncheckedCreateNestedManyWithoutShopInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutShopInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutShopInput
    User?: UserUncheckedCreateNestedManyWithoutShopsInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutShopInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutShopInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutStockCorrectionInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutStockCorrectionInput, ShopUncheckedCreateWithoutStockCorrectionInput>
  }

  export type PurchaseCreateWithoutStockCorrectionInput = {
    id?: string
    invoiceNo: string
    paymentStatus?: $Enums.PaymentStatus
    totalProducts?: number
    subTotal?: number
    grandTotal?: number
    notes?: string | null
    purchaseDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutPurchaseInput
    store: StoreCreateNestedOneWithoutPurchaseInput
    createdBy?: UserCreateNestedOneWithoutCreatorPurchaseInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedPurchaseInput
    items?: PurchaseItemCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutStockCorrectionInput = {
    id?: string
    invoiceNo: string
    supplierId: string
    storeId: string
    paymentStatus?: $Enums.PaymentStatus
    totalProducts?: number
    subTotal?: number
    grandTotal?: number
    notes?: string | null
    purchaseDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseItemUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutStockCorrectionInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutStockCorrectionInput, PurchaseUncheckedCreateWithoutStockCorrectionInput>
  }

  export type TransferCreateWithoutStockCorrectionInput = {
    id?: string
    shortCode: string
    sourceType: $Enums.TransferEntityType
    destinationType: $Enums.TransferEntityType
    reference?: string | null
    notes?: string | null
    status?: $Enums.TransferStatus
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceStore?: StoreCreateNestedOneWithoutSourceTransferInput
    sourceShop?: ShopCreateNestedOneWithoutSourceTransferInput
    destStore?: StoreCreateNestedOneWithoutDestinatTransferInput
    destShop?: ShopCreateNestedOneWithoutDestinatTransferInput
    createdBy?: UserCreateNestedOneWithoutCreatedTransferInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedTransferInput
    items?: TransferItemCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutStockCorrectionInput = {
    id?: string
    shortCode: string
    sourceType: $Enums.TransferEntityType
    sourceStoreId?: string | null
    sourceShopId?: string | null
    destinationType: $Enums.TransferEntityType
    destStoreId?: string | null
    destShopId?: string | null
    reference?: string | null
    notes?: string | null
    status?: $Enums.TransferStatus
    movementDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferItemUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutStockCorrectionInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutStockCorrectionInput, TransferUncheckedCreateWithoutStockCorrectionInput>
  }

  export type UserCreateWithoutStockCorrectionInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    branch?: BranchCreateNestedOneWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    shops?: ShopCreateNestedManyWithoutUserInput
    stores?: StoreCreateNestedManyWithoutUserInput
    Log?: LogCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferCreateNestedManyWithoutUpdatedByInput
    UpdateStockCorrection?: StockCorrectionCreateNestedManyWithoutUpdatedByInput
    Sell?: SellCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutStockCorrectionInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    branchId?: string | null
    roleId: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    shops?: ShopUncheckedCreateNestedManyWithoutUserInput
    stores?: StoreUncheckedCreateNestedManyWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseUncheckedCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferUncheckedCreateNestedManyWithoutUpdatedByInput
    UpdateStockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    Sell?: SellUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellUncheckedCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartUncheckedCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartUncheckedCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistUncheckedCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutStockCorrectionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStockCorrectionInput, UserUncheckedCreateWithoutStockCorrectionInput>
  }

  export type UserCreateWithoutUpdateStockCorrectionInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    branch?: BranchCreateNestedOneWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    shops?: ShopCreateNestedManyWithoutUserInput
    stores?: StoreCreateNestedManyWithoutUserInput
    Log?: LogCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutCreatedByInput
    Sell?: SellCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutUpdateStockCorrectionInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    branchId?: string | null
    roleId: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    shops?: ShopUncheckedCreateNestedManyWithoutUserInput
    stores?: StoreUncheckedCreateNestedManyWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseUncheckedCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferUncheckedCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    Sell?: SellUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellUncheckedCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartUncheckedCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartUncheckedCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistUncheckedCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutUpdateStockCorrectionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdateStockCorrectionInput, UserUncheckedCreateWithoutUpdateStockCorrectionInput>
  }

  export type StockCorrectionItemCreateWithoutCorrectionInput = {
    id?: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutStockCorrectionItemInput
    batch?: ProductBatchCreateNestedOneWithoutStockCorrectionItemInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutStockCorrectionItemInput
  }

  export type StockCorrectionItemUncheckedCreateWithoutCorrectionInput = {
    id?: string
    productId: string
    batchId?: string | null
    unitOfMeasureId: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockCorrectionItemCreateOrConnectWithoutCorrectionInput = {
    where: StockCorrectionItemWhereUniqueInput
    create: XOR<StockCorrectionItemCreateWithoutCorrectionInput, StockCorrectionItemUncheckedCreateWithoutCorrectionInput>
  }

  export type StockCorrectionItemCreateManyCorrectionInputEnvelope = {
    data: StockCorrectionItemCreateManyCorrectionInput | StockCorrectionItemCreateManyCorrectionInput[]
    skipDuplicates?: boolean
  }

  export type StoreUpsertWithoutStockCorrectionInput = {
    update: XOR<StoreUpdateWithoutStockCorrectionInput, StoreUncheckedUpdateWithoutStockCorrectionInput>
    create: XOR<StoreCreateWithoutStockCorrectionInput, StoreUncheckedCreateWithoutStockCorrectionInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutStockCorrectionInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutStockCorrectionInput, StoreUncheckedUpdateWithoutStockCorrectionInput>
  }

  export type StoreUpdateWithoutStockCorrectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStoreNestedInput
    ProductBatch?: ProductBatchUpdateManyWithoutStoreNestedInput
    StoreStock?: StoreStockUpdateManyWithoutStoreNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutStoreNestedInput
    Purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    SourceTransfer?: TransferUpdateManyWithoutSourceStoreNestedInput
    DestinatTransfer?: TransferUpdateManyWithoutDestStoreNestedInput
    User?: UserUpdateManyWithoutStoresNestedInput
    notifications?: NotificationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutStockCorrectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductBatch?: ProductBatchUncheckedUpdateManyWithoutStoreNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutStoreNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutStoreNestedInput
    Purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    SourceTransfer?: TransferUncheckedUpdateManyWithoutSourceStoreNestedInput
    DestinatTransfer?: TransferUncheckedUpdateManyWithoutDestStoreNestedInput
    User?: UserUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type ShopUpsertWithoutStockCorrectionInput = {
    update: XOR<ShopUpdateWithoutStockCorrectionInput, ShopUncheckedUpdateWithoutStockCorrectionInput>
    create: XOR<ShopCreateWithoutStockCorrectionInput, ShopUncheckedCreateWithoutStockCorrectionInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutStockCorrectionInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutStockCorrectionInput, ShopUncheckedUpdateWithoutStockCorrectionInput>
  }

  export type ShopUpdateWithoutStockCorrectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutShopNestedInput
    ShopStock?: ShopStockUpdateManyWithoutShopNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutShopNestedInput
    SourceTransfer?: TransferUpdateManyWithoutSourceShopNestedInput
    DestinatTransfer?: TransferUpdateManyWithoutDestShopNestedInput
    AdditionalPrice?: AdditionalPriceUpdateManyWithoutShopNestedInput
    SellItem?: SellItemUpdateManyWithoutShopNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutShopNestedInput
    User?: UserUpdateManyWithoutShopsNestedInput
    CartItem?: CartItemUpdateManyWithoutShopNestedInput
    waitlists?: WaitlistUpdateManyWithoutShopNestedInput
    notifications?: NotificationUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutStockCorrectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopStock?: ShopStockUncheckedUpdateManyWithoutShopNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutShopNestedInput
    SourceTransfer?: TransferUncheckedUpdateManyWithoutSourceShopNestedInput
    DestinatTransfer?: TransferUncheckedUpdateManyWithoutDestShopNestedInput
    AdditionalPrice?: AdditionalPriceUncheckedUpdateManyWithoutShopNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutShopNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutShopNestedInput
    User?: UserUncheckedUpdateManyWithoutShopsNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutShopNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutShopNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutShopNestedInput
  }

  export type PurchaseUpsertWithoutStockCorrectionInput = {
    update: XOR<PurchaseUpdateWithoutStockCorrectionInput, PurchaseUncheckedUpdateWithoutStockCorrectionInput>
    create: XOR<PurchaseCreateWithoutStockCorrectionInput, PurchaseUncheckedCreateWithoutStockCorrectionInput>
    where?: PurchaseWhereInput
  }

  export type PurchaseUpdateToOneWithWhereWithoutStockCorrectionInput = {
    where?: PurchaseWhereInput
    data: XOR<PurchaseUpdateWithoutStockCorrectionInput, PurchaseUncheckedUpdateWithoutStockCorrectionInput>
  }

  export type PurchaseUpdateWithoutStockCorrectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseNestedInput
    store?: StoreUpdateOneRequiredWithoutPurchaseNestedInput
    createdBy?: UserUpdateOneWithoutCreatorPurchaseNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedPurchaseNestedInput
    items?: PurchaseItemUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutStockCorrectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseItemUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type TransferUpsertWithoutStockCorrectionInput = {
    update: XOR<TransferUpdateWithoutStockCorrectionInput, TransferUncheckedUpdateWithoutStockCorrectionInput>
    create: XOR<TransferCreateWithoutStockCorrectionInput, TransferUncheckedCreateWithoutStockCorrectionInput>
    where?: TransferWhereInput
  }

  export type TransferUpdateToOneWithWhereWithoutStockCorrectionInput = {
    where?: TransferWhereInput
    data: XOR<TransferUpdateWithoutStockCorrectionInput, TransferUncheckedUpdateWithoutStockCorrectionInput>
  }

  export type TransferUpdateWithoutStockCorrectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    destinationType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceStore?: StoreUpdateOneWithoutSourceTransferNestedInput
    sourceShop?: ShopUpdateOneWithoutSourceTransferNestedInput
    destStore?: StoreUpdateOneWithoutDestinatTransferNestedInput
    destShop?: ShopUpdateOneWithoutDestinatTransferNestedInput
    createdBy?: UserUpdateOneWithoutCreatedTransferNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedTransferNestedInput
    items?: TransferItemUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutStockCorrectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceShopId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    destStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destShopId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferItemUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type UserUpsertWithoutStockCorrectionInput = {
    update: XOR<UserUpdateWithoutStockCorrectionInput, UserUncheckedUpdateWithoutStockCorrectionInput>
    create: XOR<UserCreateWithoutStockCorrectionInput, UserUncheckedCreateWithoutStockCorrectionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStockCorrectionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStockCorrectionInput, UserUncheckedUpdateWithoutStockCorrectionInput>
  }

  export type UserUpdateWithoutStockCorrectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: BranchUpdateOneWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    shops?: ShopUpdateManyWithoutUserNestedInput
    stores?: StoreUpdateManyWithoutUserNestedInput
    Log?: LogUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUpdateManyWithoutUpdatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutStockCorrectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shops?: ShopUncheckedUpdateManyWithoutUserNestedInput
    stores?: StoreUncheckedUpdateManyWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUncheckedUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUncheckedUpdateManyWithoutUpdatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUncheckedUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUncheckedUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUncheckedUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUncheckedUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUpsertWithoutUpdateStockCorrectionInput = {
    update: XOR<UserUpdateWithoutUpdateStockCorrectionInput, UserUncheckedUpdateWithoutUpdateStockCorrectionInput>
    create: XOR<UserCreateWithoutUpdateStockCorrectionInput, UserUncheckedCreateWithoutUpdateStockCorrectionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdateStockCorrectionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdateStockCorrectionInput, UserUncheckedUpdateWithoutUpdateStockCorrectionInput>
  }

  export type UserUpdateWithoutUpdateStockCorrectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: BranchUpdateOneWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    shops?: ShopUpdateManyWithoutUserNestedInput
    stores?: StoreUpdateManyWithoutUserNestedInput
    Log?: LogUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutCreatedByNestedInput
    Sell?: SellUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdateStockCorrectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shops?: ShopUncheckedUpdateManyWithoutUserNestedInput
    stores?: StoreUncheckedUpdateManyWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUncheckedUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUncheckedUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    Sell?: SellUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUncheckedUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUncheckedUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUncheckedUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUncheckedUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type StockCorrectionItemUpsertWithWhereUniqueWithoutCorrectionInput = {
    where: StockCorrectionItemWhereUniqueInput
    update: XOR<StockCorrectionItemUpdateWithoutCorrectionInput, StockCorrectionItemUncheckedUpdateWithoutCorrectionInput>
    create: XOR<StockCorrectionItemCreateWithoutCorrectionInput, StockCorrectionItemUncheckedCreateWithoutCorrectionInput>
  }

  export type StockCorrectionItemUpdateWithWhereUniqueWithoutCorrectionInput = {
    where: StockCorrectionItemWhereUniqueInput
    data: XOR<StockCorrectionItemUpdateWithoutCorrectionInput, StockCorrectionItemUncheckedUpdateWithoutCorrectionInput>
  }

  export type StockCorrectionItemUpdateManyWithWhereWithoutCorrectionInput = {
    where: StockCorrectionItemScalarWhereInput
    data: XOR<StockCorrectionItemUpdateManyMutationInput, StockCorrectionItemUncheckedUpdateManyWithoutCorrectionInput>
  }

  export type StockCorrectionCreateWithoutItemsInput = {
    id?: string
    shortCode: string
    reason: $Enums.StockCorrectionReason
    status?: $Enums.StockCorrectionStatus
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store?: StoreCreateNestedOneWithoutStockCorrectionInput
    shop?: ShopCreateNestedOneWithoutStockCorrectionInput
    purchase?: PurchaseCreateNestedOneWithoutStockCorrectionInput
    transfer?: TransferCreateNestedOneWithoutStockCorrectionInput
    createdBy?: UserCreateNestedOneWithoutStockCorrectionInput
    updatedBy?: UserCreateNestedOneWithoutUpdateStockCorrectionInput
  }

  export type StockCorrectionUncheckedCreateWithoutItemsInput = {
    id?: string
    shortCode: string
    storeId?: string | null
    shopId?: string | null
    reason: $Enums.StockCorrectionReason
    status?: $Enums.StockCorrectionStatus
    purchaseId?: string | null
    transferId?: string | null
    reference?: string | null
    notes?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockCorrectionCreateOrConnectWithoutItemsInput = {
    where: StockCorrectionWhereUniqueInput
    create: XOR<StockCorrectionCreateWithoutItemsInput, StockCorrectionUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutStockCorrectionItemInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    subCategory?: SubCategoryCreateNestedOneWithoutProductsInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutProductsInput
    batches?: ProductBatchCreateNestedManyWithoutProductInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutProductInput
    TransferItem?: TransferItemCreateNestedManyWithoutProductInput
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    AdditionalPrice?: AdditionalPriceCreateNestedManyWithoutProductInput
    SellItem?: SellItemCreateNestedManyWithoutProductInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutProductInput
    waitlists?: WaitlistCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutStockCorrectionItemInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    categoryId: string
    subCategoryId?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    unitOfMeasureId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: ProductBatchUncheckedCreateNestedManyWithoutProductInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutProductInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    AdditionalPrice?: AdditionalPriceUncheckedCreateNestedManyWithoutProductInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutProductInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutProductInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutStockCorrectionItemInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStockCorrectionItemInput, ProductUncheckedCreateWithoutStockCorrectionItemInput>
  }

  export type ProductBatchCreateWithoutStockCorrectionItemInput = {
    id?: string
    batchNumber: string
    expiryDate?: Date | string | null
    price?: number | null
    stock?: number | null
    warningQuantity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store?: StoreCreateNestedOneWithoutProductBatchInput
    product: ProductCreateNestedOneWithoutBatchesInput
    ShopStock?: ShopStockCreateNestedManyWithoutBatchInput
    StoreStock?: StoreStockCreateNestedManyWithoutBatchInput
    StockLedger?: StockLedgerCreateNestedManyWithoutBatchInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutBatchInput
    TransferItem?: TransferItemCreateNestedManyWithoutBatchInput
    SellItemBatch?: SellItemBatchCreateNestedManyWithoutBatchInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchCreateNestedManyWithoutBatchInput
  }

  export type ProductBatchUncheckedCreateWithoutStockCorrectionItemInput = {
    id?: string
    batchNumber: string
    expiryDate?: Date | string | null
    productId: string
    price?: number | null
    stock?: number | null
    warningQuantity?: number | null
    storeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutBatchInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutBatchInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutBatchInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutBatchInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutBatchInput
    SellItemBatch?: SellItemBatchUncheckedCreateNestedManyWithoutBatchInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUncheckedCreateNestedManyWithoutBatchInput
  }

  export type ProductBatchCreateOrConnectWithoutStockCorrectionItemInput = {
    where: ProductBatchWhereUniqueInput
    create: XOR<ProductBatchCreateWithoutStockCorrectionItemInput, ProductBatchUncheckedCreateWithoutStockCorrectionItemInput>
  }

  export type UnitOfMeasureCreateWithoutStockCorrectionItemInput = {
    id?: string
    name: string
    symbol?: string | null
    base?: boolean
    products?: ProductCreateNestedManyWithoutUnitOfMeasureInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutUnitOfMeasureInput
    TransferItem?: TransferItemCreateNestedManyWithoutUnitOfMeasureInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUnitOfMeasureInput
    ShopStock?: ShopStockCreateNestedManyWithoutUnitOfMeasureInput
    StoreStock?: StoreStockCreateNestedManyWithoutUnitOfMeasureInput
    SellItem?: SellItemCreateNestedManyWithoutUnitOfMeasureInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutUnitOfMeasureInput
    CartItem?: CartItemCreateNestedManyWithoutUnitOfMeasureInput
  }

  export type UnitOfMeasureUncheckedCreateWithoutStockCorrectionItemInput = {
    id?: string
    name: string
    symbol?: string | null
    base?: boolean
    products?: ProductUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
  }

  export type UnitOfMeasureCreateOrConnectWithoutStockCorrectionItemInput = {
    where: UnitOfMeasureWhereUniqueInput
    create: XOR<UnitOfMeasureCreateWithoutStockCorrectionItemInput, UnitOfMeasureUncheckedCreateWithoutStockCorrectionItemInput>
  }

  export type StockCorrectionUpsertWithoutItemsInput = {
    update: XOR<StockCorrectionUpdateWithoutItemsInput, StockCorrectionUncheckedUpdateWithoutItemsInput>
    create: XOR<StockCorrectionCreateWithoutItemsInput, StockCorrectionUncheckedCreateWithoutItemsInput>
    where?: StockCorrectionWhereInput
  }

  export type StockCorrectionUpdateToOneWithWhereWithoutItemsInput = {
    where?: StockCorrectionWhereInput
    data: XOR<StockCorrectionUpdateWithoutItemsInput, StockCorrectionUncheckedUpdateWithoutItemsInput>
  }

  export type StockCorrectionUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    reason?: EnumStockCorrectionReasonFieldUpdateOperationsInput | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFieldUpdateOperationsInput | $Enums.StockCorrectionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneWithoutStockCorrectionNestedInput
    shop?: ShopUpdateOneWithoutStockCorrectionNestedInput
    purchase?: PurchaseUpdateOneWithoutStockCorrectionNestedInput
    transfer?: TransferUpdateOneWithoutStockCorrectionNestedInput
    createdBy?: UserUpdateOneWithoutStockCorrectionNestedInput
    updatedBy?: UserUpdateOneWithoutUpdateStockCorrectionNestedInput
  }

  export type StockCorrectionUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: EnumStockCorrectionReasonFieldUpdateOperationsInput | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFieldUpdateOperationsInput | $Enums.StockCorrectionStatus
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    transferId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutStockCorrectionItemInput = {
    update: XOR<ProductUpdateWithoutStockCorrectionItemInput, ProductUncheckedUpdateWithoutStockCorrectionItemInput>
    create: XOR<ProductCreateWithoutStockCorrectionItemInput, ProductUncheckedCreateWithoutStockCorrectionItemInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutStockCorrectionItemInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutStockCorrectionItemInput, ProductUncheckedUpdateWithoutStockCorrectionItemInput>
  }

  export type ProductUpdateWithoutStockCorrectionItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    subCategory?: SubCategoryUpdateOneWithoutProductsNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutProductsNestedInput
    batches?: ProductBatchUpdateManyWithoutProductNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutProductNestedInput
    TransferItem?: TransferItemUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    AdditionalPrice?: AdditionalPriceUpdateManyWithoutProductNestedInput
    SellItem?: SellItemUpdateManyWithoutProductNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutProductNestedInput
    waitlists?: WaitlistUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutStockCorrectionItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    subCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: ProductBatchUncheckedUpdateManyWithoutProductNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    AdditionalPrice?: AdditionalPriceUncheckedUpdateManyWithoutProductNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutProductNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutProductNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductBatchUpsertWithoutStockCorrectionItemInput = {
    update: XOR<ProductBatchUpdateWithoutStockCorrectionItemInput, ProductBatchUncheckedUpdateWithoutStockCorrectionItemInput>
    create: XOR<ProductBatchCreateWithoutStockCorrectionItemInput, ProductBatchUncheckedCreateWithoutStockCorrectionItemInput>
    where?: ProductBatchWhereInput
  }

  export type ProductBatchUpdateToOneWithWhereWithoutStockCorrectionItemInput = {
    where?: ProductBatchWhereInput
    data: XOR<ProductBatchUpdateWithoutStockCorrectionItemInput, ProductBatchUncheckedUpdateWithoutStockCorrectionItemInput>
  }

  export type ProductBatchUpdateWithoutStockCorrectionItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    warningQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneWithoutProductBatchNestedInput
    product?: ProductUpdateOneRequiredWithoutBatchesNestedInput
    ShopStock?: ShopStockUpdateManyWithoutBatchNestedInput
    StoreStock?: StoreStockUpdateManyWithoutBatchNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutBatchNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutBatchNestedInput
    TransferItem?: TransferItemUpdateManyWithoutBatchNestedInput
    SellItemBatch?: SellItemBatchUpdateManyWithoutBatchNestedInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUpdateManyWithoutBatchNestedInput
  }

  export type ProductBatchUncheckedUpdateWithoutStockCorrectionItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productId?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    warningQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopStock?: ShopStockUncheckedUpdateManyWithoutBatchNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutBatchNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutBatchNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutBatchNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutBatchNestedInput
    SellItemBatch?: SellItemBatchUncheckedUpdateManyWithoutBatchNestedInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type UnitOfMeasureUpsertWithoutStockCorrectionItemInput = {
    update: XOR<UnitOfMeasureUpdateWithoutStockCorrectionItemInput, UnitOfMeasureUncheckedUpdateWithoutStockCorrectionItemInput>
    create: XOR<UnitOfMeasureCreateWithoutStockCorrectionItemInput, UnitOfMeasureUncheckedCreateWithoutStockCorrectionItemInput>
    where?: UnitOfMeasureWhereInput
  }

  export type UnitOfMeasureUpdateToOneWithWhereWithoutStockCorrectionItemInput = {
    where?: UnitOfMeasureWhereInput
    data: XOR<UnitOfMeasureUpdateWithoutStockCorrectionItemInput, UnitOfMeasureUncheckedUpdateWithoutStockCorrectionItemInput>
  }

  export type UnitOfMeasureUpdateWithoutStockCorrectionItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    base?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductUpdateManyWithoutUnitOfMeasureNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutUnitOfMeasureNestedInput
    TransferItem?: TransferItemUpdateManyWithoutUnitOfMeasureNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUnitOfMeasureNestedInput
    ShopStock?: ShopStockUpdateManyWithoutUnitOfMeasureNestedInput
    StoreStock?: StoreStockUpdateManyWithoutUnitOfMeasureNestedInput
    SellItem?: SellItemUpdateManyWithoutUnitOfMeasureNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutUnitOfMeasureNestedInput
    CartItem?: CartItemUpdateManyWithoutUnitOfMeasureNestedInput
  }

  export type UnitOfMeasureUncheckedUpdateWithoutStockCorrectionItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    base?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    ShopStock?: ShopStockUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
  }

  export type BranchCreateWithoutSellInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Shop?: ShopCreateNestedManyWithoutBranchInput
    Store?: StoreCreateNestedManyWithoutBranchInput
    User?: UserCreateNestedManyWithoutBranchInput
    AddToCart?: AddToCartCreateNestedManyWithoutBranchInput
    waitlists?: WaitlistCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutSellInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Shop?: ShopUncheckedCreateNestedManyWithoutBranchInput
    Store?: StoreUncheckedCreateNestedManyWithoutBranchInput
    User?: UserUncheckedCreateNestedManyWithoutBranchInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutBranchInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutSellInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutSellInput, BranchUncheckedCreateWithoutSellInput>
  }

  export type CustomerCreateWithoutSellInput = {
    id?: string
    name: string
    companyName?: string | null
    phone1: string
    phone2?: string | null
    tinNumber?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AddToCart?: AddToCartCreateNestedManyWithoutCustomerInput
    waitlists?: WaitlistCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSellInput = {
    id?: string
    name: string
    companyName?: string | null
    phone1: string
    phone2?: string | null
    tinNumber?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutCustomerInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSellInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSellInput, CustomerUncheckedCreateWithoutSellInput>
  }

  export type UserCreateWithoutSellInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    branch?: BranchCreateNestedOneWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    shops?: ShopCreateNestedManyWithoutUserInput
    stores?: StoreCreateNestedManyWithoutUserInput
    Log?: LogCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionCreateNestedManyWithoutUpdatedByInput
    UpdateSell?: SellCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutSellInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    branchId?: string | null
    roleId: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    shops?: ShopUncheckedCreateNestedManyWithoutUserInput
    stores?: StoreUncheckedCreateNestedManyWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseUncheckedCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferUncheckedCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    UpdateSell?: SellUncheckedCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartUncheckedCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartUncheckedCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistUncheckedCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutSellInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSellInput, UserUncheckedCreateWithoutSellInput>
  }

  export type UserCreateWithoutUpdateSellInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    branch?: BranchCreateNestedOneWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    shops?: ShopCreateNestedManyWithoutUserInput
    stores?: StoreCreateNestedManyWithoutUserInput
    Log?: LogCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionCreateNestedManyWithoutUpdatedByInput
    Sell?: SellCreateNestedManyWithoutCreatedByInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutUpdateSellInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    branchId?: string | null
    roleId: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    shops?: ShopUncheckedCreateNestedManyWithoutUserInput
    stores?: StoreUncheckedCreateNestedManyWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseUncheckedCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferUncheckedCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    Sell?: SellUncheckedCreateNestedManyWithoutCreatedByInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartUncheckedCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartUncheckedCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistUncheckedCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutUpdateSellInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdateSellInput, UserUncheckedCreateWithoutUpdateSellInput>
  }

  export type SellItemCreateWithoutSellInput = {
    id?: string
    itemSaleStatus?: $Enums.ItemSaleStatus
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutSellItemInput
    shop: ShopCreateNestedOneWithoutSellItemInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutSellItemInput
    batches?: SellItemBatchCreateNestedManyWithoutSellItemInput
  }

  export type SellItemUncheckedCreateWithoutSellInput = {
    id?: string
    productId: string
    shopId: string
    unitOfMeasureId: string
    itemSaleStatus?: $Enums.ItemSaleStatus
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: SellItemBatchUncheckedCreateNestedManyWithoutSellItemInput
  }

  export type SellItemCreateOrConnectWithoutSellInput = {
    where: SellItemWhereUniqueInput
    create: XOR<SellItemCreateWithoutSellInput, SellItemUncheckedCreateWithoutSellInput>
  }

  export type SellItemCreateManySellInputEnvelope = {
    data: SellItemCreateManySellInput | SellItemCreateManySellInput[]
    skipDuplicates?: boolean
  }

  export type SellStockCorrectionCreateWithoutSellInput = {
    id?: string
    status?: $Enums.SellStockCorrectionStatus
    reference?: string | null
    notes?: string | null
    total?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutSellStockCorrectionInput
    updatedBy?: UserCreateNestedOneWithoutUpdateSellStockCorrectionInput
    items?: SellStockCorrectionItemCreateNestedManyWithoutCorrectionInput
  }

  export type SellStockCorrectionUncheckedCreateWithoutSellInput = {
    id?: string
    status?: $Enums.SellStockCorrectionStatus
    reference?: string | null
    notes?: string | null
    createdById?: string | null
    updatedById?: string | null
    total?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutCorrectionInput
  }

  export type SellStockCorrectionCreateOrConnectWithoutSellInput = {
    where: SellStockCorrectionWhereUniqueInput
    create: XOR<SellStockCorrectionCreateWithoutSellInput, SellStockCorrectionUncheckedCreateWithoutSellInput>
  }

  export type SellStockCorrectionCreateManySellInputEnvelope = {
    data: SellStockCorrectionCreateManySellInput | SellStockCorrectionCreateManySellInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutSellInput = {
    update: XOR<BranchUpdateWithoutSellInput, BranchUncheckedUpdateWithoutSellInput>
    create: XOR<BranchCreateWithoutSellInput, BranchUncheckedCreateWithoutSellInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutSellInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutSellInput, BranchUncheckedUpdateWithoutSellInput>
  }

  export type BranchUpdateWithoutSellInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Shop?: ShopUpdateManyWithoutBranchNestedInput
    Store?: StoreUpdateManyWithoutBranchNestedInput
    User?: UserUpdateManyWithoutBranchNestedInput
    AddToCart?: AddToCartUpdateManyWithoutBranchNestedInput
    waitlists?: WaitlistUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutSellInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Shop?: ShopUncheckedUpdateManyWithoutBranchNestedInput
    Store?: StoreUncheckedUpdateManyWithoutBranchNestedInput
    User?: UserUncheckedUpdateManyWithoutBranchNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutBranchNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type CustomerUpsertWithoutSellInput = {
    update: XOR<CustomerUpdateWithoutSellInput, CustomerUncheckedUpdateWithoutSellInput>
    create: XOR<CustomerCreateWithoutSellInput, CustomerUncheckedCreateWithoutSellInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSellInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSellInput, CustomerUncheckedUpdateWithoutSellInput>
  }

  export type CustomerUpdateWithoutSellInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    phone1?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    tinNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AddToCart?: AddToCartUpdateManyWithoutCustomerNestedInput
    waitlists?: WaitlistUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSellInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    phone1?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    tinNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AddToCart?: AddToCartUncheckedUpdateManyWithoutCustomerNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type UserUpsertWithoutSellInput = {
    update: XOR<UserUpdateWithoutSellInput, UserUncheckedUpdateWithoutSellInput>
    create: XOR<UserCreateWithoutSellInput, UserUncheckedCreateWithoutSellInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSellInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSellInput, UserUncheckedUpdateWithoutSellInput>
  }

  export type UserUpdateWithoutSellInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: BranchUpdateOneWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    shops?: ShopUpdateManyWithoutUserNestedInput
    stores?: StoreUpdateManyWithoutUserNestedInput
    Log?: LogUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUpdateManyWithoutUpdatedByNestedInput
    UpdateSell?: SellUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSellInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shops?: ShopUncheckedUpdateManyWithoutUserNestedInput
    stores?: StoreUncheckedUpdateManyWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUncheckedUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUncheckedUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    UpdateSell?: SellUncheckedUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUncheckedUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUncheckedUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUncheckedUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUpsertWithoutUpdateSellInput = {
    update: XOR<UserUpdateWithoutUpdateSellInput, UserUncheckedUpdateWithoutUpdateSellInput>
    create: XOR<UserCreateWithoutUpdateSellInput, UserUncheckedCreateWithoutUpdateSellInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdateSellInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdateSellInput, UserUncheckedUpdateWithoutUpdateSellInput>
  }

  export type UserUpdateWithoutUpdateSellInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: BranchUpdateOneWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    shops?: ShopUpdateManyWithoutUserNestedInput
    stores?: StoreUpdateManyWithoutUserNestedInput
    Log?: LogUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUpdateManyWithoutCreatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdateSellInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shops?: ShopUncheckedUpdateManyWithoutUserNestedInput
    stores?: StoreUncheckedUpdateManyWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUncheckedUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUncheckedUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUncheckedUpdateManyWithoutCreatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUncheckedUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUncheckedUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUncheckedUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type SellItemUpsertWithWhereUniqueWithoutSellInput = {
    where: SellItemWhereUniqueInput
    update: XOR<SellItemUpdateWithoutSellInput, SellItemUncheckedUpdateWithoutSellInput>
    create: XOR<SellItemCreateWithoutSellInput, SellItemUncheckedCreateWithoutSellInput>
  }

  export type SellItemUpdateWithWhereUniqueWithoutSellInput = {
    where: SellItemWhereUniqueInput
    data: XOR<SellItemUpdateWithoutSellInput, SellItemUncheckedUpdateWithoutSellInput>
  }

  export type SellItemUpdateManyWithWhereWithoutSellInput = {
    where: SellItemScalarWhereInput
    data: XOR<SellItemUpdateManyMutationInput, SellItemUncheckedUpdateManyWithoutSellInput>
  }

  export type SellStockCorrectionUpsertWithWhereUniqueWithoutSellInput = {
    where: SellStockCorrectionWhereUniqueInput
    update: XOR<SellStockCorrectionUpdateWithoutSellInput, SellStockCorrectionUncheckedUpdateWithoutSellInput>
    create: XOR<SellStockCorrectionCreateWithoutSellInput, SellStockCorrectionUncheckedCreateWithoutSellInput>
  }

  export type SellStockCorrectionUpdateWithWhereUniqueWithoutSellInput = {
    where: SellStockCorrectionWhereUniqueInput
    data: XOR<SellStockCorrectionUpdateWithoutSellInput, SellStockCorrectionUncheckedUpdateWithoutSellInput>
  }

  export type SellStockCorrectionUpdateManyWithWhereWithoutSellInput = {
    where: SellStockCorrectionScalarWhereInput
    data: XOR<SellStockCorrectionUpdateManyMutationInput, SellStockCorrectionUncheckedUpdateManyWithoutSellInput>
  }

  export type SellCreateWithoutItemsInput = {
    id?: string
    invoiceNo: string
    saleStatus?: $Enums.SaleStatus
    locked?: boolean
    lockedAt?: Date | string | null
    totalProducts?: number
    subTotal?: number
    discount?: number
    vat?: number
    grandTotal?: number
    NetTotal?: number
    notes?: string | null
    saleDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutSellInput
    customer?: CustomerCreateNestedOneWithoutSellInput
    createdBy?: UserCreateNestedOneWithoutSellInput
    updatedBy?: UserCreateNestedOneWithoutUpdateSellInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutSellInput
  }

  export type SellUncheckedCreateWithoutItemsInput = {
    id?: string
    invoiceNo: string
    saleStatus?: $Enums.SaleStatus
    locked?: boolean
    lockedAt?: Date | string | null
    branchId?: string | null
    customerId?: string | null
    totalProducts?: number
    subTotal?: number
    discount?: number
    vat?: number
    grandTotal?: number
    NetTotal?: number
    notes?: string | null
    saleDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutSellInput
  }

  export type SellCreateOrConnectWithoutItemsInput = {
    where: SellWhereUniqueInput
    create: XOR<SellCreateWithoutItemsInput, SellUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutSellItemInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    subCategory?: SubCategoryCreateNestedOneWithoutProductsInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutProductsInput
    batches?: ProductBatchCreateNestedManyWithoutProductInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutProductInput
    TransferItem?: TransferItemCreateNestedManyWithoutProductInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutProductInput
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    AdditionalPrice?: AdditionalPriceCreateNestedManyWithoutProductInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutProductInput
    waitlists?: WaitlistCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSellItemInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    categoryId: string
    subCategoryId?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    unitOfMeasureId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: ProductBatchUncheckedCreateNestedManyWithoutProductInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutProductInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutProductInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    AdditionalPrice?: AdditionalPriceUncheckedCreateNestedManyWithoutProductInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutProductInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSellItemInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSellItemInput, ProductUncheckedCreateWithoutSellItemInput>
  }

  export type ShopCreateWithoutSellItemInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutShopInput
    ShopStock?: ShopStockCreateNestedManyWithoutShopInput
    StockLedger?: StockLedgerCreateNestedManyWithoutShopInput
    SourceTransfer?: TransferCreateNestedManyWithoutSourceShopInput
    DestinatTransfer?: TransferCreateNestedManyWithoutDestShopInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutShopInput
    AdditionalPrice?: AdditionalPriceCreateNestedManyWithoutShopInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutShopInput
    User?: UserCreateNestedManyWithoutShopsInput
    CartItem?: CartItemCreateNestedManyWithoutShopInput
    waitlists?: WaitlistCreateNestedManyWithoutShopInput
    notifications?: NotificationCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutSellItemInput = {
    id?: string
    name: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutShopInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutShopInput
    SourceTransfer?: TransferUncheckedCreateNestedManyWithoutSourceShopInput
    DestinatTransfer?: TransferUncheckedCreateNestedManyWithoutDestShopInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutShopInput
    AdditionalPrice?: AdditionalPriceUncheckedCreateNestedManyWithoutShopInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutShopInput
    User?: UserUncheckedCreateNestedManyWithoutShopsInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutShopInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutShopInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutSellItemInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutSellItemInput, ShopUncheckedCreateWithoutSellItemInput>
  }

  export type UnitOfMeasureCreateWithoutSellItemInput = {
    id?: string
    name: string
    symbol?: string | null
    base?: boolean
    products?: ProductCreateNestedManyWithoutUnitOfMeasureInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutUnitOfMeasureInput
    TransferItem?: TransferItemCreateNestedManyWithoutUnitOfMeasureInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUnitOfMeasureInput
    ShopStock?: ShopStockCreateNestedManyWithoutUnitOfMeasureInput
    StoreStock?: StoreStockCreateNestedManyWithoutUnitOfMeasureInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutUnitOfMeasureInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutUnitOfMeasureInput
    CartItem?: CartItemCreateNestedManyWithoutUnitOfMeasureInput
  }

  export type UnitOfMeasureUncheckedCreateWithoutSellItemInput = {
    id?: string
    name: string
    symbol?: string | null
    base?: boolean
    products?: ProductUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
  }

  export type UnitOfMeasureCreateOrConnectWithoutSellItemInput = {
    where: UnitOfMeasureWhereUniqueInput
    create: XOR<UnitOfMeasureCreateWithoutSellItemInput, UnitOfMeasureUncheckedCreateWithoutSellItemInput>
  }

  export type SellItemBatchCreateWithoutSellItemInput = {
    id?: string
    quantity?: number
    batch: ProductBatchCreateNestedOneWithoutSellItemBatchInput
  }

  export type SellItemBatchUncheckedCreateWithoutSellItemInput = {
    id?: string
    batchId: string
    quantity?: number
  }

  export type SellItemBatchCreateOrConnectWithoutSellItemInput = {
    where: SellItemBatchWhereUniqueInput
    create: XOR<SellItemBatchCreateWithoutSellItemInput, SellItemBatchUncheckedCreateWithoutSellItemInput>
  }

  export type SellItemBatchCreateManySellItemInputEnvelope = {
    data: SellItemBatchCreateManySellItemInput | SellItemBatchCreateManySellItemInput[]
    skipDuplicates?: boolean
  }

  export type SellUpsertWithoutItemsInput = {
    update: XOR<SellUpdateWithoutItemsInput, SellUncheckedUpdateWithoutItemsInput>
    create: XOR<SellCreateWithoutItemsInput, SellUncheckedCreateWithoutItemsInput>
    where?: SellWhereInput
  }

  export type SellUpdateToOneWithWhereWithoutItemsInput = {
    where?: SellWhereInput
    data: XOR<SellUpdateWithoutItemsInput, SellUncheckedUpdateWithoutItemsInput>
  }

  export type SellUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleStatus?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    locked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutSellNestedInput
    customer?: CustomerUpdateOneWithoutSellNestedInput
    createdBy?: UserUpdateOneWithoutSellNestedInput
    updatedBy?: UserUpdateOneWithoutUpdateSellNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutSellNestedInput
  }

  export type SellUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleStatus?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    locked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutSellNestedInput
  }

  export type ProductUpsertWithoutSellItemInput = {
    update: XOR<ProductUpdateWithoutSellItemInput, ProductUncheckedUpdateWithoutSellItemInput>
    create: XOR<ProductCreateWithoutSellItemInput, ProductUncheckedCreateWithoutSellItemInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSellItemInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSellItemInput, ProductUncheckedUpdateWithoutSellItemInput>
  }

  export type ProductUpdateWithoutSellItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    subCategory?: SubCategoryUpdateOneWithoutProductsNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutProductsNestedInput
    batches?: ProductBatchUpdateManyWithoutProductNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutProductNestedInput
    TransferItem?: TransferItemUpdateManyWithoutProductNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    AdditionalPrice?: AdditionalPriceUpdateManyWithoutProductNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutProductNestedInput
    waitlists?: WaitlistUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSellItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    subCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: ProductBatchUncheckedUpdateManyWithoutProductNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    AdditionalPrice?: AdditionalPriceUncheckedUpdateManyWithoutProductNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutProductNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ShopUpsertWithoutSellItemInput = {
    update: XOR<ShopUpdateWithoutSellItemInput, ShopUncheckedUpdateWithoutSellItemInput>
    create: XOR<ShopCreateWithoutSellItemInput, ShopUncheckedCreateWithoutSellItemInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutSellItemInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutSellItemInput, ShopUncheckedUpdateWithoutSellItemInput>
  }

  export type ShopUpdateWithoutSellItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutShopNestedInput
    ShopStock?: ShopStockUpdateManyWithoutShopNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutShopNestedInput
    SourceTransfer?: TransferUpdateManyWithoutSourceShopNestedInput
    DestinatTransfer?: TransferUpdateManyWithoutDestShopNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutShopNestedInput
    AdditionalPrice?: AdditionalPriceUpdateManyWithoutShopNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutShopNestedInput
    User?: UserUpdateManyWithoutShopsNestedInput
    CartItem?: CartItemUpdateManyWithoutShopNestedInput
    waitlists?: WaitlistUpdateManyWithoutShopNestedInput
    notifications?: NotificationUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutSellItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopStock?: ShopStockUncheckedUpdateManyWithoutShopNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutShopNestedInput
    SourceTransfer?: TransferUncheckedUpdateManyWithoutSourceShopNestedInput
    DestinatTransfer?: TransferUncheckedUpdateManyWithoutDestShopNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutShopNestedInput
    AdditionalPrice?: AdditionalPriceUncheckedUpdateManyWithoutShopNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutShopNestedInput
    User?: UserUncheckedUpdateManyWithoutShopsNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutShopNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutShopNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutShopNestedInput
  }

  export type UnitOfMeasureUpsertWithoutSellItemInput = {
    update: XOR<UnitOfMeasureUpdateWithoutSellItemInput, UnitOfMeasureUncheckedUpdateWithoutSellItemInput>
    create: XOR<UnitOfMeasureCreateWithoutSellItemInput, UnitOfMeasureUncheckedCreateWithoutSellItemInput>
    where?: UnitOfMeasureWhereInput
  }

  export type UnitOfMeasureUpdateToOneWithWhereWithoutSellItemInput = {
    where?: UnitOfMeasureWhereInput
    data: XOR<UnitOfMeasureUpdateWithoutSellItemInput, UnitOfMeasureUncheckedUpdateWithoutSellItemInput>
  }

  export type UnitOfMeasureUpdateWithoutSellItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    base?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductUpdateManyWithoutUnitOfMeasureNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutUnitOfMeasureNestedInput
    TransferItem?: TransferItemUpdateManyWithoutUnitOfMeasureNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUnitOfMeasureNestedInput
    ShopStock?: ShopStockUpdateManyWithoutUnitOfMeasureNestedInput
    StoreStock?: StoreStockUpdateManyWithoutUnitOfMeasureNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutUnitOfMeasureNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutUnitOfMeasureNestedInput
    CartItem?: CartItemUpdateManyWithoutUnitOfMeasureNestedInput
  }

  export type UnitOfMeasureUncheckedUpdateWithoutSellItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    base?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    ShopStock?: ShopStockUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
  }

  export type SellItemBatchUpsertWithWhereUniqueWithoutSellItemInput = {
    where: SellItemBatchWhereUniqueInput
    update: XOR<SellItemBatchUpdateWithoutSellItemInput, SellItemBatchUncheckedUpdateWithoutSellItemInput>
    create: XOR<SellItemBatchCreateWithoutSellItemInput, SellItemBatchUncheckedCreateWithoutSellItemInput>
  }

  export type SellItemBatchUpdateWithWhereUniqueWithoutSellItemInput = {
    where: SellItemBatchWhereUniqueInput
    data: XOR<SellItemBatchUpdateWithoutSellItemInput, SellItemBatchUncheckedUpdateWithoutSellItemInput>
  }

  export type SellItemBatchUpdateManyWithWhereWithoutSellItemInput = {
    where: SellItemBatchScalarWhereInput
    data: XOR<SellItemBatchUpdateManyMutationInput, SellItemBatchUncheckedUpdateManyWithoutSellItemInput>
  }

  export type SellItemCreateWithoutBatchesInput = {
    id?: string
    itemSaleStatus?: $Enums.ItemSaleStatus
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sell: SellCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutSellItemInput
    shop: ShopCreateNestedOneWithoutSellItemInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutSellItemInput
  }

  export type SellItemUncheckedCreateWithoutBatchesInput = {
    id?: string
    sellId: string
    productId: string
    shopId: string
    unitOfMeasureId: string
    itemSaleStatus?: $Enums.ItemSaleStatus
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellItemCreateOrConnectWithoutBatchesInput = {
    where: SellItemWhereUniqueInput
    create: XOR<SellItemCreateWithoutBatchesInput, SellItemUncheckedCreateWithoutBatchesInput>
  }

  export type ProductBatchCreateWithoutSellItemBatchInput = {
    id?: string
    batchNumber: string
    expiryDate?: Date | string | null
    price?: number | null
    stock?: number | null
    warningQuantity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store?: StoreCreateNestedOneWithoutProductBatchInput
    product: ProductCreateNestedOneWithoutBatchesInput
    ShopStock?: ShopStockCreateNestedManyWithoutBatchInput
    StoreStock?: StoreStockCreateNestedManyWithoutBatchInput
    StockLedger?: StockLedgerCreateNestedManyWithoutBatchInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutBatchInput
    TransferItem?: TransferItemCreateNestedManyWithoutBatchInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutBatchInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchCreateNestedManyWithoutBatchInput
  }

  export type ProductBatchUncheckedCreateWithoutSellItemBatchInput = {
    id?: string
    batchNumber: string
    expiryDate?: Date | string | null
    productId: string
    price?: number | null
    stock?: number | null
    warningQuantity?: number | null
    storeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutBatchInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutBatchInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutBatchInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutBatchInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutBatchInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutBatchInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUncheckedCreateNestedManyWithoutBatchInput
  }

  export type ProductBatchCreateOrConnectWithoutSellItemBatchInput = {
    where: ProductBatchWhereUniqueInput
    create: XOR<ProductBatchCreateWithoutSellItemBatchInput, ProductBatchUncheckedCreateWithoutSellItemBatchInput>
  }

  export type SellItemUpsertWithoutBatchesInput = {
    update: XOR<SellItemUpdateWithoutBatchesInput, SellItemUncheckedUpdateWithoutBatchesInput>
    create: XOR<SellItemCreateWithoutBatchesInput, SellItemUncheckedCreateWithoutBatchesInput>
    where?: SellItemWhereInput
  }

  export type SellItemUpdateToOneWithWhereWithoutBatchesInput = {
    where?: SellItemWhereInput
    data: XOR<SellItemUpdateWithoutBatchesInput, SellItemUncheckedUpdateWithoutBatchesInput>
  }

  export type SellItemUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemSaleStatus?: EnumItemSaleStatusFieldUpdateOperationsInput | $Enums.ItemSaleStatus
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sell?: SellUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutSellItemNestedInput
    shop?: ShopUpdateOneRequiredWithoutSellItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutSellItemNestedInput
  }

  export type SellItemUncheckedUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    itemSaleStatus?: EnumItemSaleStatusFieldUpdateOperationsInput | $Enums.ItemSaleStatus
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductBatchUpsertWithoutSellItemBatchInput = {
    update: XOR<ProductBatchUpdateWithoutSellItemBatchInput, ProductBatchUncheckedUpdateWithoutSellItemBatchInput>
    create: XOR<ProductBatchCreateWithoutSellItemBatchInput, ProductBatchUncheckedCreateWithoutSellItemBatchInput>
    where?: ProductBatchWhereInput
  }

  export type ProductBatchUpdateToOneWithWhereWithoutSellItemBatchInput = {
    where?: ProductBatchWhereInput
    data: XOR<ProductBatchUpdateWithoutSellItemBatchInput, ProductBatchUncheckedUpdateWithoutSellItemBatchInput>
  }

  export type ProductBatchUpdateWithoutSellItemBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    warningQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneWithoutProductBatchNestedInput
    product?: ProductUpdateOneRequiredWithoutBatchesNestedInput
    ShopStock?: ShopStockUpdateManyWithoutBatchNestedInput
    StoreStock?: StoreStockUpdateManyWithoutBatchNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutBatchNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutBatchNestedInput
    TransferItem?: TransferItemUpdateManyWithoutBatchNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutBatchNestedInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUpdateManyWithoutBatchNestedInput
  }

  export type ProductBatchUncheckedUpdateWithoutSellItemBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productId?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    warningQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopStock?: ShopStockUncheckedUpdateManyWithoutBatchNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutBatchNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutBatchNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutBatchNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutBatchNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutBatchNestedInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type UserCreateWithoutAllAddToCartInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    branch?: BranchCreateNestedOneWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    shops?: ShopCreateNestedManyWithoutUserInput
    stores?: StoreCreateNestedManyWithoutUserInput
    Log?: LogCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionCreateNestedManyWithoutUpdatedByInput
    Sell?: SellCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutUpdatedByInput
    CreatedAddToCart?: AddToCartCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutAllAddToCartInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    branchId?: string | null
    roleId: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    shops?: ShopUncheckedCreateNestedManyWithoutUserInput
    stores?: StoreUncheckedCreateNestedManyWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseUncheckedCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferUncheckedCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    Sell?: SellUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellUncheckedCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    CreatedAddToCart?: AddToCartUncheckedCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistUncheckedCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutAllAddToCartInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAllAddToCartInput, UserUncheckedCreateWithoutAllAddToCartInput>
  }

  export type BranchCreateWithoutAddToCartInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Shop?: ShopCreateNestedManyWithoutBranchInput
    Store?: StoreCreateNestedManyWithoutBranchInput
    User?: UserCreateNestedManyWithoutBranchInput
    Sell?: SellCreateNestedManyWithoutBranchInput
    waitlists?: WaitlistCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutAddToCartInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Shop?: ShopUncheckedCreateNestedManyWithoutBranchInput
    Store?: StoreUncheckedCreateNestedManyWithoutBranchInput
    User?: UserUncheckedCreateNestedManyWithoutBranchInput
    Sell?: SellUncheckedCreateNestedManyWithoutBranchInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutAddToCartInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutAddToCartInput, BranchUncheckedCreateWithoutAddToCartInput>
  }

  export type CustomerCreateWithoutAddToCartInput = {
    id?: string
    name: string
    companyName?: string | null
    phone1: string
    phone2?: string | null
    tinNumber?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Sell?: SellCreateNestedManyWithoutCustomerInput
    waitlists?: WaitlistCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutAddToCartInput = {
    id?: string
    name: string
    companyName?: string | null
    phone1: string
    phone2?: string | null
    tinNumber?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Sell?: SellUncheckedCreateNestedManyWithoutCustomerInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutAddToCartInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutAddToCartInput, CustomerUncheckedCreateWithoutAddToCartInput>
  }

  export type UserCreateWithoutCreatedAddToCartInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    branch?: BranchCreateNestedOneWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    shops?: ShopCreateNestedManyWithoutUserInput
    stores?: StoreCreateNestedManyWithoutUserInput
    Log?: LogCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionCreateNestedManyWithoutUpdatedByInput
    Sell?: SellCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartCreateNestedManyWithoutUserInput
    AddToCart?: AddToCartCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutCreatedAddToCartInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    branchId?: string | null
    roleId: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    shops?: ShopUncheckedCreateNestedManyWithoutUserInput
    stores?: StoreUncheckedCreateNestedManyWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseUncheckedCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferUncheckedCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    Sell?: SellUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellUncheckedCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartUncheckedCreateNestedManyWithoutUserInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistUncheckedCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutCreatedAddToCartInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedAddToCartInput, UserUncheckedCreateWithoutCreatedAddToCartInput>
  }

  export type UserCreateWithoutAddToCartInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    branch?: BranchCreateNestedOneWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    shops?: ShopCreateNestedManyWithoutUserInput
    stores?: StoreCreateNestedManyWithoutUserInput
    Log?: LogCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionCreateNestedManyWithoutUpdatedByInput
    Sell?: SellCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartCreateNestedManyWithoutCreatedByInput
    waitlists?: WaitlistCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutAddToCartInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    branchId?: string | null
    roleId: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    shops?: ShopUncheckedCreateNestedManyWithoutUserInput
    stores?: StoreUncheckedCreateNestedManyWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseUncheckedCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferUncheckedCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    Sell?: SellUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellUncheckedCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartUncheckedCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartUncheckedCreateNestedManyWithoutCreatedByInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistUncheckedCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutAddToCartInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddToCartInput, UserUncheckedCreateWithoutAddToCartInput>
  }

  export type CartItemCreateWithoutCartInput = {
    id?: string
    isWaitlist?: boolean
    quantity: number
    unitPrice?: number
    totalPrice?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shop: ShopCreateNestedOneWithoutCartItemInput
    product: ProductCreateNestedOneWithoutCartItemInput
    unitOfMeasure?: UnitOfMeasureCreateNestedOneWithoutCartItemInput
    waitlists?: WaitlistCreateNestedManyWithoutCartItemInput
  }

  export type CartItemUncheckedCreateWithoutCartInput = {
    id?: string
    isWaitlist?: boolean
    shopId: string
    productId: string
    unitOfMeasureId?: string | null
    quantity: number
    unitPrice?: number
    totalPrice?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutCartItemInput
  }

  export type CartItemCreateOrConnectWithoutCartInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput>
  }

  export type CartItemCreateManyCartInputEnvelope = {
    data: CartItemCreateManyCartInput | CartItemCreateManyCartInput[]
    skipDuplicates?: boolean
  }

  export type WaitlistCreateWithoutCartInput = {
    id?: string
    quantity?: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutWaitlistsInput
    customer?: CustomerCreateNestedOneWithoutWaitlistsInput
    branch?: BranchCreateNestedOneWithoutWaitlistsInput
    cartItem?: CartItemCreateNestedOneWithoutWaitlistsInput
    product?: ProductCreateNestedOneWithoutWaitlistsInput
    shop?: ShopCreateNestedOneWithoutWaitlistsInput
    createdBy?: UserCreateNestedOneWithoutWaitlistsCreatedInput
    updatedBy?: UserCreateNestedOneWithoutWaitlistsUpdatedInput
  }

  export type WaitlistUncheckedCreateWithoutCartInput = {
    id?: string
    userId?: string | null
    customerId?: string | null
    branchId?: string | null
    cartItemId?: string | null
    productId?: string | null
    quantity?: number
    note?: string | null
    shopId?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaitlistCreateOrConnectWithoutCartInput = {
    where: WaitlistWhereUniqueInput
    create: XOR<WaitlistCreateWithoutCartInput, WaitlistUncheckedCreateWithoutCartInput>
  }

  export type WaitlistCreateManyCartInputEnvelope = {
    data: WaitlistCreateManyCartInput | WaitlistCreateManyCartInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAllAddToCartInput = {
    update: XOR<UserUpdateWithoutAllAddToCartInput, UserUncheckedUpdateWithoutAllAddToCartInput>
    create: XOR<UserCreateWithoutAllAddToCartInput, UserUncheckedCreateWithoutAllAddToCartInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAllAddToCartInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAllAddToCartInput, UserUncheckedUpdateWithoutAllAddToCartInput>
  }

  export type UserUpdateWithoutAllAddToCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: BranchUpdateOneWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    shops?: ShopUpdateManyWithoutUserNestedInput
    stores?: StoreUpdateManyWithoutUserNestedInput
    Log?: LogUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUpdateManyWithoutUpdatedByNestedInput
    CreatedAddToCart?: AddToCartUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAllAddToCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shops?: ShopUncheckedUpdateManyWithoutUserNestedInput
    stores?: StoreUncheckedUpdateManyWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUncheckedUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUncheckedUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUncheckedUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    CreatedAddToCart?: AddToCartUncheckedUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUncheckedUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type BranchUpsertWithoutAddToCartInput = {
    update: XOR<BranchUpdateWithoutAddToCartInput, BranchUncheckedUpdateWithoutAddToCartInput>
    create: XOR<BranchCreateWithoutAddToCartInput, BranchUncheckedCreateWithoutAddToCartInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutAddToCartInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutAddToCartInput, BranchUncheckedUpdateWithoutAddToCartInput>
  }

  export type BranchUpdateWithoutAddToCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Shop?: ShopUpdateManyWithoutBranchNestedInput
    Store?: StoreUpdateManyWithoutBranchNestedInput
    User?: UserUpdateManyWithoutBranchNestedInput
    Sell?: SellUpdateManyWithoutBranchNestedInput
    waitlists?: WaitlistUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutAddToCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Shop?: ShopUncheckedUpdateManyWithoutBranchNestedInput
    Store?: StoreUncheckedUpdateManyWithoutBranchNestedInput
    User?: UserUncheckedUpdateManyWithoutBranchNestedInput
    Sell?: SellUncheckedUpdateManyWithoutBranchNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type CustomerUpsertWithoutAddToCartInput = {
    update: XOR<CustomerUpdateWithoutAddToCartInput, CustomerUncheckedUpdateWithoutAddToCartInput>
    create: XOR<CustomerCreateWithoutAddToCartInput, CustomerUncheckedCreateWithoutAddToCartInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutAddToCartInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutAddToCartInput, CustomerUncheckedUpdateWithoutAddToCartInput>
  }

  export type CustomerUpdateWithoutAddToCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    phone1?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    tinNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Sell?: SellUpdateManyWithoutCustomerNestedInput
    waitlists?: WaitlistUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutAddToCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    phone1?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    tinNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Sell?: SellUncheckedUpdateManyWithoutCustomerNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type UserUpsertWithoutCreatedAddToCartInput = {
    update: XOR<UserUpdateWithoutCreatedAddToCartInput, UserUncheckedUpdateWithoutCreatedAddToCartInput>
    create: XOR<UserCreateWithoutCreatedAddToCartInput, UserUncheckedCreateWithoutCreatedAddToCartInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedAddToCartInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedAddToCartInput, UserUncheckedUpdateWithoutCreatedAddToCartInput>
  }

  export type UserUpdateWithoutCreatedAddToCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: BranchUpdateOneWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    shops?: ShopUpdateManyWithoutUserNestedInput
    stores?: StoreUpdateManyWithoutUserNestedInput
    Log?: LogUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUpdateManyWithoutUserNestedInput
    AddToCart?: AddToCartUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedAddToCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shops?: ShopUncheckedUpdateManyWithoutUserNestedInput
    stores?: StoreUncheckedUpdateManyWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUncheckedUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUncheckedUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUncheckedUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUncheckedUpdateManyWithoutUserNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUncheckedUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUpsertWithoutAddToCartInput = {
    update: XOR<UserUpdateWithoutAddToCartInput, UserUncheckedUpdateWithoutAddToCartInput>
    create: XOR<UserCreateWithoutAddToCartInput, UserUncheckedCreateWithoutAddToCartInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAddToCartInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAddToCartInput, UserUncheckedUpdateWithoutAddToCartInput>
  }

  export type UserUpdateWithoutAddToCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: BranchUpdateOneWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    shops?: ShopUpdateManyWithoutUserNestedInput
    stores?: StoreUpdateManyWithoutUserNestedInput
    Log?: LogUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUpdateManyWithoutCreatedByNestedInput
    waitlists?: WaitlistUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAddToCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shops?: ShopUncheckedUpdateManyWithoutUserNestedInput
    stores?: StoreUncheckedUpdateManyWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUncheckedUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUncheckedUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUncheckedUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUncheckedUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUncheckedUpdateManyWithoutCreatedByNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUncheckedUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type CartItemUpsertWithWhereUniqueWithoutCartInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutCartInput, CartItemUncheckedUpdateWithoutCartInput>
    create: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutCartInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutCartInput, CartItemUncheckedUpdateWithoutCartInput>
  }

  export type CartItemUpdateManyWithWhereWithoutCartInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutCartInput>
  }

  export type WaitlistUpsertWithWhereUniqueWithoutCartInput = {
    where: WaitlistWhereUniqueInput
    update: XOR<WaitlistUpdateWithoutCartInput, WaitlistUncheckedUpdateWithoutCartInput>
    create: XOR<WaitlistCreateWithoutCartInput, WaitlistUncheckedCreateWithoutCartInput>
  }

  export type WaitlistUpdateWithWhereUniqueWithoutCartInput = {
    where: WaitlistWhereUniqueInput
    data: XOR<WaitlistUpdateWithoutCartInput, WaitlistUncheckedUpdateWithoutCartInput>
  }

  export type WaitlistUpdateManyWithWhereWithoutCartInput = {
    where: WaitlistScalarWhereInput
    data: XOR<WaitlistUpdateManyMutationInput, WaitlistUncheckedUpdateManyWithoutCartInput>
  }

  export type AddToCartCreateWithoutItemsInput = {
    id?: string
    isCheckedOut?: boolean
    isWaitlist?: boolean
    totalItems?: number
    totalAmount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAllAddToCartInput
    branch?: BranchCreateNestedOneWithoutAddToCartInput
    customer?: CustomerCreateNestedOneWithoutAddToCartInput
    createdBy?: UserCreateNestedOneWithoutCreatedAddToCartInput
    updatedBy?: UserCreateNestedOneWithoutAddToCartInput
    waitlists?: WaitlistCreateNestedManyWithoutCartInput
  }

  export type AddToCartUncheckedCreateWithoutItemsInput = {
    id?: string
    userId: string
    branchId?: string | null
    isCheckedOut?: boolean
    isWaitlist?: boolean
    customerId?: string | null
    totalItems?: number
    totalAmount?: number
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutCartInput
  }

  export type AddToCartCreateOrConnectWithoutItemsInput = {
    where: AddToCartWhereUniqueInput
    create: XOR<AddToCartCreateWithoutItemsInput, AddToCartUncheckedCreateWithoutItemsInput>
  }

  export type ShopCreateWithoutCartItemInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutShopInput
    ShopStock?: ShopStockCreateNestedManyWithoutShopInput
    StockLedger?: StockLedgerCreateNestedManyWithoutShopInput
    SourceTransfer?: TransferCreateNestedManyWithoutSourceShopInput
    DestinatTransfer?: TransferCreateNestedManyWithoutDestShopInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutShopInput
    AdditionalPrice?: AdditionalPriceCreateNestedManyWithoutShopInput
    SellItem?: SellItemCreateNestedManyWithoutShopInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutShopInput
    User?: UserCreateNestedManyWithoutShopsInput
    waitlists?: WaitlistCreateNestedManyWithoutShopInput
    notifications?: NotificationCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutCartItemInput = {
    id?: string
    name: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutShopInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutShopInput
    SourceTransfer?: TransferUncheckedCreateNestedManyWithoutSourceShopInput
    DestinatTransfer?: TransferUncheckedCreateNestedManyWithoutDestShopInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutShopInput
    AdditionalPrice?: AdditionalPriceUncheckedCreateNestedManyWithoutShopInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutShopInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutShopInput
    User?: UserUncheckedCreateNestedManyWithoutShopsInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutShopInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutCartItemInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutCartItemInput, ShopUncheckedCreateWithoutCartItemInput>
  }

  export type ProductCreateWithoutCartItemInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    subCategory?: SubCategoryCreateNestedOneWithoutProductsInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutProductsInput
    batches?: ProductBatchCreateNestedManyWithoutProductInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutProductInput
    TransferItem?: TransferItemCreateNestedManyWithoutProductInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutProductInput
    AdditionalPrice?: AdditionalPriceCreateNestedManyWithoutProductInput
    SellItem?: SellItemCreateNestedManyWithoutProductInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutProductInput
    waitlists?: WaitlistCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCartItemInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    categoryId: string
    subCategoryId?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    unitOfMeasureId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: ProductBatchUncheckedCreateNestedManyWithoutProductInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutProductInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutProductInput
    AdditionalPrice?: AdditionalPriceUncheckedCreateNestedManyWithoutProductInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutProductInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutProductInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCartItemInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCartItemInput, ProductUncheckedCreateWithoutCartItemInput>
  }

  export type UnitOfMeasureCreateWithoutCartItemInput = {
    id?: string
    name: string
    symbol?: string | null
    base?: boolean
    products?: ProductCreateNestedManyWithoutUnitOfMeasureInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutUnitOfMeasureInput
    TransferItem?: TransferItemCreateNestedManyWithoutUnitOfMeasureInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUnitOfMeasureInput
    ShopStock?: ShopStockCreateNestedManyWithoutUnitOfMeasureInput
    StoreStock?: StoreStockCreateNestedManyWithoutUnitOfMeasureInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutUnitOfMeasureInput
    SellItem?: SellItemCreateNestedManyWithoutUnitOfMeasureInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutUnitOfMeasureInput
  }

  export type UnitOfMeasureUncheckedCreateWithoutCartItemInput = {
    id?: string
    name: string
    symbol?: string | null
    base?: boolean
    products?: ProductUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
  }

  export type UnitOfMeasureCreateOrConnectWithoutCartItemInput = {
    where: UnitOfMeasureWhereUniqueInput
    create: XOR<UnitOfMeasureCreateWithoutCartItemInput, UnitOfMeasureUncheckedCreateWithoutCartItemInput>
  }

  export type WaitlistCreateWithoutCartItemInput = {
    id?: string
    quantity?: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutWaitlistsInput
    customer?: CustomerCreateNestedOneWithoutWaitlistsInput
    branch?: BranchCreateNestedOneWithoutWaitlistsInput
    cart?: AddToCartCreateNestedOneWithoutWaitlistsInput
    product?: ProductCreateNestedOneWithoutWaitlistsInput
    shop?: ShopCreateNestedOneWithoutWaitlistsInput
    createdBy?: UserCreateNestedOneWithoutWaitlistsCreatedInput
    updatedBy?: UserCreateNestedOneWithoutWaitlistsUpdatedInput
  }

  export type WaitlistUncheckedCreateWithoutCartItemInput = {
    id?: string
    userId?: string | null
    customerId?: string | null
    branchId?: string | null
    cartId?: string | null
    productId?: string | null
    quantity?: number
    note?: string | null
    shopId?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaitlistCreateOrConnectWithoutCartItemInput = {
    where: WaitlistWhereUniqueInput
    create: XOR<WaitlistCreateWithoutCartItemInput, WaitlistUncheckedCreateWithoutCartItemInput>
  }

  export type WaitlistCreateManyCartItemInputEnvelope = {
    data: WaitlistCreateManyCartItemInput | WaitlistCreateManyCartItemInput[]
    skipDuplicates?: boolean
  }

  export type AddToCartUpsertWithoutItemsInput = {
    update: XOR<AddToCartUpdateWithoutItemsInput, AddToCartUncheckedUpdateWithoutItemsInput>
    create: XOR<AddToCartCreateWithoutItemsInput, AddToCartUncheckedCreateWithoutItemsInput>
    where?: AddToCartWhereInput
  }

  export type AddToCartUpdateToOneWithWhereWithoutItemsInput = {
    where?: AddToCartWhereInput
    data: XOR<AddToCartUpdateWithoutItemsInput, AddToCartUncheckedUpdateWithoutItemsInput>
  }

  export type AddToCartUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    totalItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAllAddToCartNestedInput
    branch?: BranchUpdateOneWithoutAddToCartNestedInput
    customer?: CustomerUpdateOneWithoutAddToCartNestedInput
    createdBy?: UserUpdateOneWithoutCreatedAddToCartNestedInput
    updatedBy?: UserUpdateOneWithoutAddToCartNestedInput
    waitlists?: WaitlistUpdateManyWithoutCartNestedInput
  }

  export type AddToCartUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    waitlists?: WaitlistUncheckedUpdateManyWithoutCartNestedInput
  }

  export type ShopUpsertWithoutCartItemInput = {
    update: XOR<ShopUpdateWithoutCartItemInput, ShopUncheckedUpdateWithoutCartItemInput>
    create: XOR<ShopCreateWithoutCartItemInput, ShopUncheckedCreateWithoutCartItemInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutCartItemInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutCartItemInput, ShopUncheckedUpdateWithoutCartItemInput>
  }

  export type ShopUpdateWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutShopNestedInput
    ShopStock?: ShopStockUpdateManyWithoutShopNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutShopNestedInput
    SourceTransfer?: TransferUpdateManyWithoutSourceShopNestedInput
    DestinatTransfer?: TransferUpdateManyWithoutDestShopNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutShopNestedInput
    AdditionalPrice?: AdditionalPriceUpdateManyWithoutShopNestedInput
    SellItem?: SellItemUpdateManyWithoutShopNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutShopNestedInput
    User?: UserUpdateManyWithoutShopsNestedInput
    waitlists?: WaitlistUpdateManyWithoutShopNestedInput
    notifications?: NotificationUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopStock?: ShopStockUncheckedUpdateManyWithoutShopNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutShopNestedInput
    SourceTransfer?: TransferUncheckedUpdateManyWithoutSourceShopNestedInput
    DestinatTransfer?: TransferUncheckedUpdateManyWithoutDestShopNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutShopNestedInput
    AdditionalPrice?: AdditionalPriceUncheckedUpdateManyWithoutShopNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutShopNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutShopNestedInput
    User?: UserUncheckedUpdateManyWithoutShopsNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutShopNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ProductUpsertWithoutCartItemInput = {
    update: XOR<ProductUpdateWithoutCartItemInput, ProductUncheckedUpdateWithoutCartItemInput>
    create: XOR<ProductCreateWithoutCartItemInput, ProductUncheckedCreateWithoutCartItemInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCartItemInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCartItemInput, ProductUncheckedUpdateWithoutCartItemInput>
  }

  export type ProductUpdateWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    subCategory?: SubCategoryUpdateOneWithoutProductsNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutProductsNestedInput
    batches?: ProductBatchUpdateManyWithoutProductNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutProductNestedInput
    TransferItem?: TransferItemUpdateManyWithoutProductNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutProductNestedInput
    AdditionalPrice?: AdditionalPriceUpdateManyWithoutProductNestedInput
    SellItem?: SellItemUpdateManyWithoutProductNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutProductNestedInput
    waitlists?: WaitlistUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    subCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: ProductBatchUncheckedUpdateManyWithoutProductNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutProductNestedInput
    AdditionalPrice?: AdditionalPriceUncheckedUpdateManyWithoutProductNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutProductNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutProductNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UnitOfMeasureUpsertWithoutCartItemInput = {
    update: XOR<UnitOfMeasureUpdateWithoutCartItemInput, UnitOfMeasureUncheckedUpdateWithoutCartItemInput>
    create: XOR<UnitOfMeasureCreateWithoutCartItemInput, UnitOfMeasureUncheckedCreateWithoutCartItemInput>
    where?: UnitOfMeasureWhereInput
  }

  export type UnitOfMeasureUpdateToOneWithWhereWithoutCartItemInput = {
    where?: UnitOfMeasureWhereInput
    data: XOR<UnitOfMeasureUpdateWithoutCartItemInput, UnitOfMeasureUncheckedUpdateWithoutCartItemInput>
  }

  export type UnitOfMeasureUpdateWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    base?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductUpdateManyWithoutUnitOfMeasureNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutUnitOfMeasureNestedInput
    TransferItem?: TransferItemUpdateManyWithoutUnitOfMeasureNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUnitOfMeasureNestedInput
    ShopStock?: ShopStockUpdateManyWithoutUnitOfMeasureNestedInput
    StoreStock?: StoreStockUpdateManyWithoutUnitOfMeasureNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutUnitOfMeasureNestedInput
    SellItem?: SellItemUpdateManyWithoutUnitOfMeasureNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutUnitOfMeasureNestedInput
  }

  export type UnitOfMeasureUncheckedUpdateWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    base?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    ShopStock?: ShopStockUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
  }

  export type WaitlistUpsertWithWhereUniqueWithoutCartItemInput = {
    where: WaitlistWhereUniqueInput
    update: XOR<WaitlistUpdateWithoutCartItemInput, WaitlistUncheckedUpdateWithoutCartItemInput>
    create: XOR<WaitlistCreateWithoutCartItemInput, WaitlistUncheckedCreateWithoutCartItemInput>
  }

  export type WaitlistUpdateWithWhereUniqueWithoutCartItemInput = {
    where: WaitlistWhereUniqueInput
    data: XOR<WaitlistUpdateWithoutCartItemInput, WaitlistUncheckedUpdateWithoutCartItemInput>
  }

  export type WaitlistUpdateManyWithWhereWithoutCartItemInput = {
    where: WaitlistScalarWhereInput
    data: XOR<WaitlistUpdateManyMutationInput, WaitlistUncheckedUpdateManyWithoutCartItemInput>
  }

  export type UserCreateWithoutWaitlistsInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    branch?: BranchCreateNestedOneWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    shops?: ShopCreateNestedManyWithoutUserInput
    stores?: StoreCreateNestedManyWithoutUserInput
    Log?: LogCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionCreateNestedManyWithoutUpdatedByInput
    Sell?: SellCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartCreateNestedManyWithoutUpdatedByInput
    waitlistsCreated?: WaitlistCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutWaitlistsInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    branchId?: string | null
    roleId: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    shops?: ShopUncheckedCreateNestedManyWithoutUserInput
    stores?: StoreUncheckedCreateNestedManyWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseUncheckedCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferUncheckedCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    Sell?: SellUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellUncheckedCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartUncheckedCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartUncheckedCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutUpdatedByInput
    waitlistsCreated?: WaitlistUncheckedCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutWaitlistsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWaitlistsInput, UserUncheckedCreateWithoutWaitlistsInput>
  }

  export type CustomerCreateWithoutWaitlistsInput = {
    id?: string
    name: string
    companyName?: string | null
    phone1: string
    phone2?: string | null
    tinNumber?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Sell?: SellCreateNestedManyWithoutCustomerInput
    AddToCart?: AddToCartCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutWaitlistsInput = {
    id?: string
    name: string
    companyName?: string | null
    phone1: string
    phone2?: string | null
    tinNumber?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Sell?: SellUncheckedCreateNestedManyWithoutCustomerInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutWaitlistsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutWaitlistsInput, CustomerUncheckedCreateWithoutWaitlistsInput>
  }

  export type BranchCreateWithoutWaitlistsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Shop?: ShopCreateNestedManyWithoutBranchInput
    Store?: StoreCreateNestedManyWithoutBranchInput
    User?: UserCreateNestedManyWithoutBranchInput
    Sell?: SellCreateNestedManyWithoutBranchInput
    AddToCart?: AddToCartCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutWaitlistsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Shop?: ShopUncheckedCreateNestedManyWithoutBranchInput
    Store?: StoreUncheckedCreateNestedManyWithoutBranchInput
    User?: UserUncheckedCreateNestedManyWithoutBranchInput
    Sell?: SellUncheckedCreateNestedManyWithoutBranchInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutWaitlistsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutWaitlistsInput, BranchUncheckedCreateWithoutWaitlistsInput>
  }

  export type AddToCartCreateWithoutWaitlistsInput = {
    id?: string
    isCheckedOut?: boolean
    isWaitlist?: boolean
    totalItems?: number
    totalAmount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAllAddToCartInput
    branch?: BranchCreateNestedOneWithoutAddToCartInput
    customer?: CustomerCreateNestedOneWithoutAddToCartInput
    createdBy?: UserCreateNestedOneWithoutCreatedAddToCartInput
    updatedBy?: UserCreateNestedOneWithoutAddToCartInput
    items?: CartItemCreateNestedManyWithoutCartInput
  }

  export type AddToCartUncheckedCreateWithoutWaitlistsInput = {
    id?: string
    userId: string
    branchId?: string | null
    isCheckedOut?: boolean
    isWaitlist?: boolean
    customerId?: string | null
    totalItems?: number
    totalAmount?: number
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemUncheckedCreateNestedManyWithoutCartInput
  }

  export type AddToCartCreateOrConnectWithoutWaitlistsInput = {
    where: AddToCartWhereUniqueInput
    create: XOR<AddToCartCreateWithoutWaitlistsInput, AddToCartUncheckedCreateWithoutWaitlistsInput>
  }

  export type CartItemCreateWithoutWaitlistsInput = {
    id?: string
    isWaitlist?: boolean
    quantity: number
    unitPrice?: number
    totalPrice?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cart: AddToCartCreateNestedOneWithoutItemsInput
    shop: ShopCreateNestedOneWithoutCartItemInput
    product: ProductCreateNestedOneWithoutCartItemInput
    unitOfMeasure?: UnitOfMeasureCreateNestedOneWithoutCartItemInput
  }

  export type CartItemUncheckedCreateWithoutWaitlistsInput = {
    id?: string
    cartId: string
    isWaitlist?: boolean
    shopId: string
    productId: string
    unitOfMeasureId?: string | null
    quantity: number
    unitPrice?: number
    totalPrice?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemCreateOrConnectWithoutWaitlistsInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutWaitlistsInput, CartItemUncheckedCreateWithoutWaitlistsInput>
  }

  export type ProductCreateWithoutWaitlistsInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    subCategory?: SubCategoryCreateNestedOneWithoutProductsInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutProductsInput
    batches?: ProductBatchCreateNestedManyWithoutProductInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutProductInput
    TransferItem?: TransferItemCreateNestedManyWithoutProductInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutProductInput
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    AdditionalPrice?: AdditionalPriceCreateNestedManyWithoutProductInput
    SellItem?: SellItemCreateNestedManyWithoutProductInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutWaitlistsInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    categoryId: string
    subCategoryId?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    unitOfMeasureId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: ProductBatchUncheckedCreateNestedManyWithoutProductInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutProductInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutProductInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    AdditionalPrice?: AdditionalPriceUncheckedCreateNestedManyWithoutProductInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutProductInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutWaitlistsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutWaitlistsInput, ProductUncheckedCreateWithoutWaitlistsInput>
  }

  export type ShopCreateWithoutWaitlistsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutShopInput
    ShopStock?: ShopStockCreateNestedManyWithoutShopInput
    StockLedger?: StockLedgerCreateNestedManyWithoutShopInput
    SourceTransfer?: TransferCreateNestedManyWithoutSourceShopInput
    DestinatTransfer?: TransferCreateNestedManyWithoutDestShopInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutShopInput
    AdditionalPrice?: AdditionalPriceCreateNestedManyWithoutShopInput
    SellItem?: SellItemCreateNestedManyWithoutShopInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutShopInput
    User?: UserCreateNestedManyWithoutShopsInput
    CartItem?: CartItemCreateNestedManyWithoutShopInput
    notifications?: NotificationCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutWaitlistsInput = {
    id?: string
    name: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutShopInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutShopInput
    SourceTransfer?: TransferUncheckedCreateNestedManyWithoutSourceShopInput
    DestinatTransfer?: TransferUncheckedCreateNestedManyWithoutDestShopInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutShopInput
    AdditionalPrice?: AdditionalPriceUncheckedCreateNestedManyWithoutShopInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutShopInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutShopInput
    User?: UserUncheckedCreateNestedManyWithoutShopsInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutShopInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutWaitlistsInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutWaitlistsInput, ShopUncheckedCreateWithoutWaitlistsInput>
  }

  export type UserCreateWithoutWaitlistsCreatedInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    branch?: BranchCreateNestedOneWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    shops?: ShopCreateNestedManyWithoutUserInput
    stores?: StoreCreateNestedManyWithoutUserInput
    Log?: LogCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionCreateNestedManyWithoutUpdatedByInput
    Sell?: SellCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistCreateNestedManyWithoutUserInput
    waitlistsUpdated?: WaitlistCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutWaitlistsCreatedInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    branchId?: string | null
    roleId: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    shops?: ShopUncheckedCreateNestedManyWithoutUserInput
    stores?: StoreUncheckedCreateNestedManyWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseUncheckedCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferUncheckedCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    Sell?: SellUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellUncheckedCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartUncheckedCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartUncheckedCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutUserInput
    waitlistsUpdated?: WaitlistUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutWaitlistsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWaitlistsCreatedInput, UserUncheckedCreateWithoutWaitlistsCreatedInput>
  }

  export type UserCreateWithoutWaitlistsUpdatedInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    branch?: BranchCreateNestedOneWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    shops?: ShopCreateNestedManyWithoutUserInput
    stores?: StoreCreateNestedManyWithoutUserInput
    Log?: LogCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionCreateNestedManyWithoutUpdatedByInput
    Sell?: SellCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutWaitlistsUpdatedInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    branchId?: string | null
    roleId: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    shops?: ShopUncheckedCreateNestedManyWithoutUserInput
    stores?: StoreUncheckedCreateNestedManyWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseUncheckedCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferUncheckedCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    Sell?: SellUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellUncheckedCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartUncheckedCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartUncheckedCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutWaitlistsUpdatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWaitlistsUpdatedInput, UserUncheckedCreateWithoutWaitlistsUpdatedInput>
  }

  export type UserUpsertWithoutWaitlistsInput = {
    update: XOR<UserUpdateWithoutWaitlistsInput, UserUncheckedUpdateWithoutWaitlistsInput>
    create: XOR<UserCreateWithoutWaitlistsInput, UserUncheckedCreateWithoutWaitlistsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWaitlistsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWaitlistsInput, UserUncheckedUpdateWithoutWaitlistsInput>
  }

  export type UserUpdateWithoutWaitlistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: BranchUpdateOneWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    shops?: ShopUpdateManyWithoutUserNestedInput
    stores?: StoreUpdateManyWithoutUserNestedInput
    Log?: LogUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUpdateManyWithoutUpdatedByNestedInput
    waitlistsCreated?: WaitlistUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutWaitlistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shops?: ShopUncheckedUpdateManyWithoutUserNestedInput
    stores?: StoreUncheckedUpdateManyWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUncheckedUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUncheckedUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUncheckedUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUncheckedUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUncheckedUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutUpdatedByNestedInput
    waitlistsCreated?: WaitlistUncheckedUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type CustomerUpsertWithoutWaitlistsInput = {
    update: XOR<CustomerUpdateWithoutWaitlistsInput, CustomerUncheckedUpdateWithoutWaitlistsInput>
    create: XOR<CustomerCreateWithoutWaitlistsInput, CustomerUncheckedCreateWithoutWaitlistsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutWaitlistsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutWaitlistsInput, CustomerUncheckedUpdateWithoutWaitlistsInput>
  }

  export type CustomerUpdateWithoutWaitlistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    phone1?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    tinNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Sell?: SellUpdateManyWithoutCustomerNestedInput
    AddToCart?: AddToCartUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutWaitlistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    phone1?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    tinNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Sell?: SellUncheckedUpdateManyWithoutCustomerNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type BranchUpsertWithoutWaitlistsInput = {
    update: XOR<BranchUpdateWithoutWaitlistsInput, BranchUncheckedUpdateWithoutWaitlistsInput>
    create: XOR<BranchCreateWithoutWaitlistsInput, BranchUncheckedCreateWithoutWaitlistsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutWaitlistsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutWaitlistsInput, BranchUncheckedUpdateWithoutWaitlistsInput>
  }

  export type BranchUpdateWithoutWaitlistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Shop?: ShopUpdateManyWithoutBranchNestedInput
    Store?: StoreUpdateManyWithoutBranchNestedInput
    User?: UserUpdateManyWithoutBranchNestedInput
    Sell?: SellUpdateManyWithoutBranchNestedInput
    AddToCart?: AddToCartUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutWaitlistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Shop?: ShopUncheckedUpdateManyWithoutBranchNestedInput
    Store?: StoreUncheckedUpdateManyWithoutBranchNestedInput
    User?: UserUncheckedUpdateManyWithoutBranchNestedInput
    Sell?: SellUncheckedUpdateManyWithoutBranchNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type AddToCartUpsertWithoutWaitlistsInput = {
    update: XOR<AddToCartUpdateWithoutWaitlistsInput, AddToCartUncheckedUpdateWithoutWaitlistsInput>
    create: XOR<AddToCartCreateWithoutWaitlistsInput, AddToCartUncheckedCreateWithoutWaitlistsInput>
    where?: AddToCartWhereInput
  }

  export type AddToCartUpdateToOneWithWhereWithoutWaitlistsInput = {
    where?: AddToCartWhereInput
    data: XOR<AddToCartUpdateWithoutWaitlistsInput, AddToCartUncheckedUpdateWithoutWaitlistsInput>
  }

  export type AddToCartUpdateWithoutWaitlistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    totalItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAllAddToCartNestedInput
    branch?: BranchUpdateOneWithoutAddToCartNestedInput
    customer?: CustomerUpdateOneWithoutAddToCartNestedInput
    createdBy?: UserUpdateOneWithoutCreatedAddToCartNestedInput
    updatedBy?: UserUpdateOneWithoutAddToCartNestedInput
    items?: CartItemUpdateManyWithoutCartNestedInput
  }

  export type AddToCartUncheckedUpdateWithoutWaitlistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUncheckedUpdateManyWithoutCartNestedInput
  }

  export type CartItemUpsertWithoutWaitlistsInput = {
    update: XOR<CartItemUpdateWithoutWaitlistsInput, CartItemUncheckedUpdateWithoutWaitlistsInput>
    create: XOR<CartItemCreateWithoutWaitlistsInput, CartItemUncheckedCreateWithoutWaitlistsInput>
    where?: CartItemWhereInput
  }

  export type CartItemUpdateToOneWithWhereWithoutWaitlistsInput = {
    where?: CartItemWhereInput
    data: XOR<CartItemUpdateWithoutWaitlistsInput, CartItemUncheckedUpdateWithoutWaitlistsInput>
  }

  export type CartItemUpdateWithoutWaitlistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cart?: AddToCartUpdateOneRequiredWithoutItemsNestedInput
    shop?: ShopUpdateOneRequiredWithoutCartItemNestedInput
    product?: ProductUpdateOneRequiredWithoutCartItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateWithoutWaitlistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    shopId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutWaitlistsInput = {
    update: XOR<ProductUpdateWithoutWaitlistsInput, ProductUncheckedUpdateWithoutWaitlistsInput>
    create: XOR<ProductCreateWithoutWaitlistsInput, ProductUncheckedCreateWithoutWaitlistsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutWaitlistsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutWaitlistsInput, ProductUncheckedUpdateWithoutWaitlistsInput>
  }

  export type ProductUpdateWithoutWaitlistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    subCategory?: SubCategoryUpdateOneWithoutProductsNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutProductsNestedInput
    batches?: ProductBatchUpdateManyWithoutProductNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutProductNestedInput
    TransferItem?: TransferItemUpdateManyWithoutProductNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    AdditionalPrice?: AdditionalPriceUpdateManyWithoutProductNestedInput
    SellItem?: SellItemUpdateManyWithoutProductNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutWaitlistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    subCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: ProductBatchUncheckedUpdateManyWithoutProductNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    AdditionalPrice?: AdditionalPriceUncheckedUpdateManyWithoutProductNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutProductNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ShopUpsertWithoutWaitlistsInput = {
    update: XOR<ShopUpdateWithoutWaitlistsInput, ShopUncheckedUpdateWithoutWaitlistsInput>
    create: XOR<ShopCreateWithoutWaitlistsInput, ShopUncheckedCreateWithoutWaitlistsInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutWaitlistsInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutWaitlistsInput, ShopUncheckedUpdateWithoutWaitlistsInput>
  }

  export type ShopUpdateWithoutWaitlistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutShopNestedInput
    ShopStock?: ShopStockUpdateManyWithoutShopNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutShopNestedInput
    SourceTransfer?: TransferUpdateManyWithoutSourceShopNestedInput
    DestinatTransfer?: TransferUpdateManyWithoutDestShopNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutShopNestedInput
    AdditionalPrice?: AdditionalPriceUpdateManyWithoutShopNestedInput
    SellItem?: SellItemUpdateManyWithoutShopNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutShopNestedInput
    User?: UserUpdateManyWithoutShopsNestedInput
    CartItem?: CartItemUpdateManyWithoutShopNestedInput
    notifications?: NotificationUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutWaitlistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopStock?: ShopStockUncheckedUpdateManyWithoutShopNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutShopNestedInput
    SourceTransfer?: TransferUncheckedUpdateManyWithoutSourceShopNestedInput
    DestinatTransfer?: TransferUncheckedUpdateManyWithoutDestShopNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutShopNestedInput
    AdditionalPrice?: AdditionalPriceUncheckedUpdateManyWithoutShopNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutShopNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutShopNestedInput
    User?: UserUncheckedUpdateManyWithoutShopsNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutShopNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutShopNestedInput
  }

  export type UserUpsertWithoutWaitlistsCreatedInput = {
    update: XOR<UserUpdateWithoutWaitlistsCreatedInput, UserUncheckedUpdateWithoutWaitlistsCreatedInput>
    create: XOR<UserCreateWithoutWaitlistsCreatedInput, UserUncheckedCreateWithoutWaitlistsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWaitlistsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWaitlistsCreatedInput, UserUncheckedUpdateWithoutWaitlistsCreatedInput>
  }

  export type UserUpdateWithoutWaitlistsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: BranchUpdateOneWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    shops?: ShopUpdateManyWithoutUserNestedInput
    stores?: StoreUpdateManyWithoutUserNestedInput
    Log?: LogUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUpdateManyWithoutUserNestedInput
    waitlistsUpdated?: WaitlistUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutWaitlistsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shops?: ShopUncheckedUpdateManyWithoutUserNestedInput
    stores?: StoreUncheckedUpdateManyWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUncheckedUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUncheckedUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUncheckedUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUncheckedUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUncheckedUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutUserNestedInput
    waitlistsUpdated?: WaitlistUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUpsertWithoutWaitlistsUpdatedInput = {
    update: XOR<UserUpdateWithoutWaitlistsUpdatedInput, UserUncheckedUpdateWithoutWaitlistsUpdatedInput>
    create: XOR<UserCreateWithoutWaitlistsUpdatedInput, UserUncheckedCreateWithoutWaitlistsUpdatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWaitlistsUpdatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWaitlistsUpdatedInput, UserUncheckedUpdateWithoutWaitlistsUpdatedInput>
  }

  export type UserUpdateWithoutWaitlistsUpdatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: BranchUpdateOneWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    shops?: ShopUpdateManyWithoutUserNestedInput
    stores?: StoreUpdateManyWithoutUserNestedInput
    Log?: LogUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutWaitlistsUpdatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shops?: ShopUncheckedUpdateManyWithoutUserNestedInput
    stores?: StoreUncheckedUpdateManyWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUncheckedUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUncheckedUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUncheckedUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUncheckedUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUncheckedUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type SellCreateWithoutSellStockCorrectionInput = {
    id?: string
    invoiceNo: string
    saleStatus?: $Enums.SaleStatus
    locked?: boolean
    lockedAt?: Date | string | null
    totalProducts?: number
    subTotal?: number
    discount?: number
    vat?: number
    grandTotal?: number
    NetTotal?: number
    notes?: string | null
    saleDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutSellInput
    customer?: CustomerCreateNestedOneWithoutSellInput
    createdBy?: UserCreateNestedOneWithoutSellInput
    updatedBy?: UserCreateNestedOneWithoutUpdateSellInput
    items?: SellItemCreateNestedManyWithoutSellInput
  }

  export type SellUncheckedCreateWithoutSellStockCorrectionInput = {
    id?: string
    invoiceNo: string
    saleStatus?: $Enums.SaleStatus
    locked?: boolean
    lockedAt?: Date | string | null
    branchId?: string | null
    customerId?: string | null
    totalProducts?: number
    subTotal?: number
    discount?: number
    vat?: number
    grandTotal?: number
    NetTotal?: number
    notes?: string | null
    saleDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SellItemUncheckedCreateNestedManyWithoutSellInput
  }

  export type SellCreateOrConnectWithoutSellStockCorrectionInput = {
    where: SellWhereUniqueInput
    create: XOR<SellCreateWithoutSellStockCorrectionInput, SellUncheckedCreateWithoutSellStockCorrectionInput>
  }

  export type UserCreateWithoutSellStockCorrectionInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    branch?: BranchCreateNestedOneWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    shops?: ShopCreateNestedManyWithoutUserInput
    stores?: StoreCreateNestedManyWithoutUserInput
    Log?: LogCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionCreateNestedManyWithoutUpdatedByInput
    Sell?: SellCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellCreateNestedManyWithoutUpdatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutSellStockCorrectionInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    branchId?: string | null
    roleId: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    shops?: ShopUncheckedCreateNestedManyWithoutUserInput
    stores?: StoreUncheckedCreateNestedManyWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseUncheckedCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferUncheckedCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    Sell?: SellUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellUncheckedCreateNestedManyWithoutUpdatedByInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    AllAddToCart?: AddToCartUncheckedCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartUncheckedCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistUncheckedCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutSellStockCorrectionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSellStockCorrectionInput, UserUncheckedCreateWithoutSellStockCorrectionInput>
  }

  export type UserCreateWithoutUpdateSellStockCorrectionInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    branch?: BranchCreateNestedOneWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    shops?: ShopCreateNestedManyWithoutUserInput
    stores?: StoreCreateNestedManyWithoutUserInput
    Log?: LogCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionCreateNestedManyWithoutUpdatedByInput
    Sell?: SellCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionCreateNestedManyWithoutCreatedByInput
    AllAddToCart?: AddToCartCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutUpdateSellStockCorrectionInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    branchId?: string | null
    roleId: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    shops?: ShopUncheckedCreateNestedManyWithoutUserInput
    stores?: StoreUncheckedCreateNestedManyWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutUserInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUserInput
    CreatorPurchase?: PurchaseUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedPurchase?: PurchaseUncheckedCreateNestedManyWithoutUpdatedByInput
    CreatedTransfer?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    UpdatedTransfer?: TransferUncheckedCreateNestedManyWithoutUpdatedByInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateStockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutUpdatedByInput
    Sell?: SellUncheckedCreateNestedManyWithoutCreatedByInput
    UpdateSell?: SellUncheckedCreateNestedManyWithoutUpdatedByInput
    SellStockCorrection?: SellStockCorrectionUncheckedCreateNestedManyWithoutCreatedByInput
    AllAddToCart?: AddToCartUncheckedCreateNestedManyWithoutUserInput
    CreatedAddToCart?: AddToCartUncheckedCreateNestedManyWithoutCreatedByInput
    AddToCart?: AddToCartUncheckedCreateNestedManyWithoutUpdatedByInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutUserInput
    waitlistsCreated?: WaitlistUncheckedCreateNestedManyWithoutCreatedByInput
    waitlistsUpdated?: WaitlistUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutUpdateSellStockCorrectionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdateSellStockCorrectionInput, UserUncheckedCreateWithoutUpdateSellStockCorrectionInput>
  }

  export type SellStockCorrectionItemCreateWithoutCorrectionInput = {
    id?: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutSellStockCorrectionItemInput
    shop?: ShopCreateNestedOneWithoutSellStockCorrectionItemInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutSellStockCorrectionItemInput
    batches?: SellStockCorrectionBatchCreateNestedManyWithoutCorrectionItemInput
  }

  export type SellStockCorrectionItemUncheckedCreateWithoutCorrectionInput = {
    id?: string
    productId: string
    shopId?: string | null
    unitOfMeasureId: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: SellStockCorrectionBatchUncheckedCreateNestedManyWithoutCorrectionItemInput
  }

  export type SellStockCorrectionItemCreateOrConnectWithoutCorrectionInput = {
    where: SellStockCorrectionItemWhereUniqueInput
    create: XOR<SellStockCorrectionItemCreateWithoutCorrectionInput, SellStockCorrectionItemUncheckedCreateWithoutCorrectionInput>
  }

  export type SellStockCorrectionItemCreateManyCorrectionInputEnvelope = {
    data: SellStockCorrectionItemCreateManyCorrectionInput | SellStockCorrectionItemCreateManyCorrectionInput[]
    skipDuplicates?: boolean
  }

  export type SellUpsertWithoutSellStockCorrectionInput = {
    update: XOR<SellUpdateWithoutSellStockCorrectionInput, SellUncheckedUpdateWithoutSellStockCorrectionInput>
    create: XOR<SellCreateWithoutSellStockCorrectionInput, SellUncheckedCreateWithoutSellStockCorrectionInput>
    where?: SellWhereInput
  }

  export type SellUpdateToOneWithWhereWithoutSellStockCorrectionInput = {
    where?: SellWhereInput
    data: XOR<SellUpdateWithoutSellStockCorrectionInput, SellUncheckedUpdateWithoutSellStockCorrectionInput>
  }

  export type SellUpdateWithoutSellStockCorrectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleStatus?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    locked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutSellNestedInput
    customer?: CustomerUpdateOneWithoutSellNestedInput
    createdBy?: UserUpdateOneWithoutSellNestedInput
    updatedBy?: UserUpdateOneWithoutUpdateSellNestedInput
    items?: SellItemUpdateManyWithoutSellNestedInput
  }

  export type SellUncheckedUpdateWithoutSellStockCorrectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleStatus?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    locked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SellItemUncheckedUpdateManyWithoutSellNestedInput
  }

  export type UserUpsertWithoutSellStockCorrectionInput = {
    update: XOR<UserUpdateWithoutSellStockCorrectionInput, UserUncheckedUpdateWithoutSellStockCorrectionInput>
    create: XOR<UserCreateWithoutSellStockCorrectionInput, UserUncheckedCreateWithoutSellStockCorrectionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSellStockCorrectionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSellStockCorrectionInput, UserUncheckedUpdateWithoutSellStockCorrectionInput>
  }

  export type UserUpdateWithoutSellStockCorrectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: BranchUpdateOneWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    shops?: ShopUpdateManyWithoutUserNestedInput
    stores?: StoreUpdateManyWithoutUserNestedInput
    Log?: LogUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUpdateManyWithoutUpdatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSellStockCorrectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shops?: ShopUncheckedUpdateManyWithoutUserNestedInput
    stores?: StoreUncheckedUpdateManyWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUncheckedUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUncheckedUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUncheckedUpdateManyWithoutUpdatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUncheckedUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUncheckedUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUncheckedUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUpsertWithoutUpdateSellStockCorrectionInput = {
    update: XOR<UserUpdateWithoutUpdateSellStockCorrectionInput, UserUncheckedUpdateWithoutUpdateSellStockCorrectionInput>
    create: XOR<UserCreateWithoutUpdateSellStockCorrectionInput, UserUncheckedCreateWithoutUpdateSellStockCorrectionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdateSellStockCorrectionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdateSellStockCorrectionInput, UserUncheckedUpdateWithoutUpdateSellStockCorrectionInput>
  }

  export type UserUpdateWithoutUpdateSellStockCorrectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: BranchUpdateOneWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    shops?: ShopUpdateManyWithoutUserNestedInput
    stores?: StoreUpdateManyWithoutUserNestedInput
    Log?: LogUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutCreatedByNestedInput
    AllAddToCart?: AddToCartUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdateSellStockCorrectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shops?: ShopUncheckedUpdateManyWithoutUserNestedInput
    stores?: StoreUncheckedUpdateManyWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUncheckedUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUncheckedUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUncheckedUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    AllAddToCart?: AddToCartUncheckedUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUncheckedUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUncheckedUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type SellStockCorrectionItemUpsertWithWhereUniqueWithoutCorrectionInput = {
    where: SellStockCorrectionItemWhereUniqueInput
    update: XOR<SellStockCorrectionItemUpdateWithoutCorrectionInput, SellStockCorrectionItemUncheckedUpdateWithoutCorrectionInput>
    create: XOR<SellStockCorrectionItemCreateWithoutCorrectionInput, SellStockCorrectionItemUncheckedCreateWithoutCorrectionInput>
  }

  export type SellStockCorrectionItemUpdateWithWhereUniqueWithoutCorrectionInput = {
    where: SellStockCorrectionItemWhereUniqueInput
    data: XOR<SellStockCorrectionItemUpdateWithoutCorrectionInput, SellStockCorrectionItemUncheckedUpdateWithoutCorrectionInput>
  }

  export type SellStockCorrectionItemUpdateManyWithWhereWithoutCorrectionInput = {
    where: SellStockCorrectionItemScalarWhereInput
    data: XOR<SellStockCorrectionItemUpdateManyMutationInput, SellStockCorrectionItemUncheckedUpdateManyWithoutCorrectionInput>
  }

  export type SellStockCorrectionCreateWithoutItemsInput = {
    id?: string
    status?: $Enums.SellStockCorrectionStatus
    reference?: string | null
    notes?: string | null
    total?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sell?: SellCreateNestedOneWithoutSellStockCorrectionInput
    createdBy?: UserCreateNestedOneWithoutSellStockCorrectionInput
    updatedBy?: UserCreateNestedOneWithoutUpdateSellStockCorrectionInput
  }

  export type SellStockCorrectionUncheckedCreateWithoutItemsInput = {
    id?: string
    sellId?: string | null
    status?: $Enums.SellStockCorrectionStatus
    reference?: string | null
    notes?: string | null
    createdById?: string | null
    updatedById?: string | null
    total?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellStockCorrectionCreateOrConnectWithoutItemsInput = {
    where: SellStockCorrectionWhereUniqueInput
    create: XOR<SellStockCorrectionCreateWithoutItemsInput, SellStockCorrectionUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutSellStockCorrectionItemInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    subCategory?: SubCategoryCreateNestedOneWithoutProductsInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutProductsInput
    batches?: ProductBatchCreateNestedManyWithoutProductInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutProductInput
    TransferItem?: TransferItemCreateNestedManyWithoutProductInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutProductInput
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    AdditionalPrice?: AdditionalPriceCreateNestedManyWithoutProductInput
    SellItem?: SellItemCreateNestedManyWithoutProductInput
    waitlists?: WaitlistCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSellStockCorrectionItemInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    categoryId: string
    subCategoryId?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    unitOfMeasureId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: ProductBatchUncheckedCreateNestedManyWithoutProductInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutProductInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutProductInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    AdditionalPrice?: AdditionalPriceUncheckedCreateNestedManyWithoutProductInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutProductInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSellStockCorrectionItemInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSellStockCorrectionItemInput, ProductUncheckedCreateWithoutSellStockCorrectionItemInput>
  }

  export type ShopCreateWithoutSellStockCorrectionItemInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutShopInput
    ShopStock?: ShopStockCreateNestedManyWithoutShopInput
    StockLedger?: StockLedgerCreateNestedManyWithoutShopInput
    SourceTransfer?: TransferCreateNestedManyWithoutSourceShopInput
    DestinatTransfer?: TransferCreateNestedManyWithoutDestShopInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutShopInput
    AdditionalPrice?: AdditionalPriceCreateNestedManyWithoutShopInput
    SellItem?: SellItemCreateNestedManyWithoutShopInput
    User?: UserCreateNestedManyWithoutShopsInput
    CartItem?: CartItemCreateNestedManyWithoutShopInput
    waitlists?: WaitlistCreateNestedManyWithoutShopInput
    notifications?: NotificationCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutSellStockCorrectionItemInput = {
    id?: string
    name: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutShopInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutShopInput
    SourceTransfer?: TransferUncheckedCreateNestedManyWithoutSourceShopInput
    DestinatTransfer?: TransferUncheckedCreateNestedManyWithoutDestShopInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutShopInput
    AdditionalPrice?: AdditionalPriceUncheckedCreateNestedManyWithoutShopInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutShopInput
    User?: UserUncheckedCreateNestedManyWithoutShopsInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutShopInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutShopInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutSellStockCorrectionItemInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutSellStockCorrectionItemInput, ShopUncheckedCreateWithoutSellStockCorrectionItemInput>
  }

  export type UnitOfMeasureCreateWithoutSellStockCorrectionItemInput = {
    id?: string
    name: string
    symbol?: string | null
    base?: boolean
    products?: ProductCreateNestedManyWithoutUnitOfMeasureInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutUnitOfMeasureInput
    TransferItem?: TransferItemCreateNestedManyWithoutUnitOfMeasureInput
    StockLedger?: StockLedgerCreateNestedManyWithoutUnitOfMeasureInput
    ShopStock?: ShopStockCreateNestedManyWithoutUnitOfMeasureInput
    StoreStock?: StoreStockCreateNestedManyWithoutUnitOfMeasureInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutUnitOfMeasureInput
    SellItem?: SellItemCreateNestedManyWithoutUnitOfMeasureInput
    CartItem?: CartItemCreateNestedManyWithoutUnitOfMeasureInput
  }

  export type UnitOfMeasureUncheckedCreateWithoutSellStockCorrectionItemInput = {
    id?: string
    name: string
    symbol?: string | null
    base?: boolean
    products?: ProductUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUnitOfMeasureInput
  }

  export type UnitOfMeasureCreateOrConnectWithoutSellStockCorrectionItemInput = {
    where: UnitOfMeasureWhereUniqueInput
    create: XOR<UnitOfMeasureCreateWithoutSellStockCorrectionItemInput, UnitOfMeasureUncheckedCreateWithoutSellStockCorrectionItemInput>
  }

  export type SellStockCorrectionBatchCreateWithoutCorrectionItemInput = {
    id?: string
    quantity?: number
    batch: ProductBatchCreateNestedOneWithoutSellStockCorrectionBatchInput
  }

  export type SellStockCorrectionBatchUncheckedCreateWithoutCorrectionItemInput = {
    id?: string
    batchId: string
    quantity?: number
  }

  export type SellStockCorrectionBatchCreateOrConnectWithoutCorrectionItemInput = {
    where: SellStockCorrectionBatchWhereUniqueInput
    create: XOR<SellStockCorrectionBatchCreateWithoutCorrectionItemInput, SellStockCorrectionBatchUncheckedCreateWithoutCorrectionItemInput>
  }

  export type SellStockCorrectionBatchCreateManyCorrectionItemInputEnvelope = {
    data: SellStockCorrectionBatchCreateManyCorrectionItemInput | SellStockCorrectionBatchCreateManyCorrectionItemInput[]
    skipDuplicates?: boolean
  }

  export type SellStockCorrectionUpsertWithoutItemsInput = {
    update: XOR<SellStockCorrectionUpdateWithoutItemsInput, SellStockCorrectionUncheckedUpdateWithoutItemsInput>
    create: XOR<SellStockCorrectionCreateWithoutItemsInput, SellStockCorrectionUncheckedCreateWithoutItemsInput>
    where?: SellStockCorrectionWhereInput
  }

  export type SellStockCorrectionUpdateToOneWithWhereWithoutItemsInput = {
    where?: SellStockCorrectionWhereInput
    data: XOR<SellStockCorrectionUpdateWithoutItemsInput, SellStockCorrectionUncheckedUpdateWithoutItemsInput>
  }

  export type SellStockCorrectionUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSellStockCorrectionStatusFieldUpdateOperationsInput | $Enums.SellStockCorrectionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sell?: SellUpdateOneWithoutSellStockCorrectionNestedInput
    createdBy?: UserUpdateOneWithoutSellStockCorrectionNestedInput
    updatedBy?: UserUpdateOneWithoutUpdateSellStockCorrectionNestedInput
  }

  export type SellStockCorrectionUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSellStockCorrectionStatusFieldUpdateOperationsInput | $Enums.SellStockCorrectionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutSellStockCorrectionItemInput = {
    update: XOR<ProductUpdateWithoutSellStockCorrectionItemInput, ProductUncheckedUpdateWithoutSellStockCorrectionItemInput>
    create: XOR<ProductCreateWithoutSellStockCorrectionItemInput, ProductUncheckedCreateWithoutSellStockCorrectionItemInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSellStockCorrectionItemInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSellStockCorrectionItemInput, ProductUncheckedUpdateWithoutSellStockCorrectionItemInput>
  }

  export type ProductUpdateWithoutSellStockCorrectionItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    subCategory?: SubCategoryUpdateOneWithoutProductsNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutProductsNestedInput
    batches?: ProductBatchUpdateManyWithoutProductNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutProductNestedInput
    TransferItem?: TransferItemUpdateManyWithoutProductNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    AdditionalPrice?: AdditionalPriceUpdateManyWithoutProductNestedInput
    SellItem?: SellItemUpdateManyWithoutProductNestedInput
    waitlists?: WaitlistUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSellStockCorrectionItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    subCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: ProductBatchUncheckedUpdateManyWithoutProductNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    AdditionalPrice?: AdditionalPriceUncheckedUpdateManyWithoutProductNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutProductNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ShopUpsertWithoutSellStockCorrectionItemInput = {
    update: XOR<ShopUpdateWithoutSellStockCorrectionItemInput, ShopUncheckedUpdateWithoutSellStockCorrectionItemInput>
    create: XOR<ShopCreateWithoutSellStockCorrectionItemInput, ShopUncheckedCreateWithoutSellStockCorrectionItemInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutSellStockCorrectionItemInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutSellStockCorrectionItemInput, ShopUncheckedUpdateWithoutSellStockCorrectionItemInput>
  }

  export type ShopUpdateWithoutSellStockCorrectionItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutShopNestedInput
    ShopStock?: ShopStockUpdateManyWithoutShopNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutShopNestedInput
    SourceTransfer?: TransferUpdateManyWithoutSourceShopNestedInput
    DestinatTransfer?: TransferUpdateManyWithoutDestShopNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutShopNestedInput
    AdditionalPrice?: AdditionalPriceUpdateManyWithoutShopNestedInput
    SellItem?: SellItemUpdateManyWithoutShopNestedInput
    User?: UserUpdateManyWithoutShopsNestedInput
    CartItem?: CartItemUpdateManyWithoutShopNestedInput
    waitlists?: WaitlistUpdateManyWithoutShopNestedInput
    notifications?: NotificationUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutSellStockCorrectionItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopStock?: ShopStockUncheckedUpdateManyWithoutShopNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutShopNestedInput
    SourceTransfer?: TransferUncheckedUpdateManyWithoutSourceShopNestedInput
    DestinatTransfer?: TransferUncheckedUpdateManyWithoutDestShopNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutShopNestedInput
    AdditionalPrice?: AdditionalPriceUncheckedUpdateManyWithoutShopNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutShopNestedInput
    User?: UserUncheckedUpdateManyWithoutShopsNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutShopNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutShopNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutShopNestedInput
  }

  export type UnitOfMeasureUpsertWithoutSellStockCorrectionItemInput = {
    update: XOR<UnitOfMeasureUpdateWithoutSellStockCorrectionItemInput, UnitOfMeasureUncheckedUpdateWithoutSellStockCorrectionItemInput>
    create: XOR<UnitOfMeasureCreateWithoutSellStockCorrectionItemInput, UnitOfMeasureUncheckedCreateWithoutSellStockCorrectionItemInput>
    where?: UnitOfMeasureWhereInput
  }

  export type UnitOfMeasureUpdateToOneWithWhereWithoutSellStockCorrectionItemInput = {
    where?: UnitOfMeasureWhereInput
    data: XOR<UnitOfMeasureUpdateWithoutSellStockCorrectionItemInput, UnitOfMeasureUncheckedUpdateWithoutSellStockCorrectionItemInput>
  }

  export type UnitOfMeasureUpdateWithoutSellStockCorrectionItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    base?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductUpdateManyWithoutUnitOfMeasureNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutUnitOfMeasureNestedInput
    TransferItem?: TransferItemUpdateManyWithoutUnitOfMeasureNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUnitOfMeasureNestedInput
    ShopStock?: ShopStockUpdateManyWithoutUnitOfMeasureNestedInput
    StoreStock?: StoreStockUpdateManyWithoutUnitOfMeasureNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutUnitOfMeasureNestedInput
    SellItem?: SellItemUpdateManyWithoutUnitOfMeasureNestedInput
    CartItem?: CartItemUpdateManyWithoutUnitOfMeasureNestedInput
  }

  export type UnitOfMeasureUncheckedUpdateWithoutSellStockCorrectionItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    base?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    ShopStock?: ShopStockUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUnitOfMeasureNestedInput
  }

  export type SellStockCorrectionBatchUpsertWithWhereUniqueWithoutCorrectionItemInput = {
    where: SellStockCorrectionBatchWhereUniqueInput
    update: XOR<SellStockCorrectionBatchUpdateWithoutCorrectionItemInput, SellStockCorrectionBatchUncheckedUpdateWithoutCorrectionItemInput>
    create: XOR<SellStockCorrectionBatchCreateWithoutCorrectionItemInput, SellStockCorrectionBatchUncheckedCreateWithoutCorrectionItemInput>
  }

  export type SellStockCorrectionBatchUpdateWithWhereUniqueWithoutCorrectionItemInput = {
    where: SellStockCorrectionBatchWhereUniqueInput
    data: XOR<SellStockCorrectionBatchUpdateWithoutCorrectionItemInput, SellStockCorrectionBatchUncheckedUpdateWithoutCorrectionItemInput>
  }

  export type SellStockCorrectionBatchUpdateManyWithWhereWithoutCorrectionItemInput = {
    where: SellStockCorrectionBatchScalarWhereInput
    data: XOR<SellStockCorrectionBatchUpdateManyMutationInput, SellStockCorrectionBatchUncheckedUpdateManyWithoutCorrectionItemInput>
  }

  export type SellStockCorrectionItemCreateWithoutBatchesInput = {
    id?: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    correction: SellStockCorrectionCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutSellStockCorrectionItemInput
    shop?: ShopCreateNestedOneWithoutSellStockCorrectionItemInput
    unitOfMeasure: UnitOfMeasureCreateNestedOneWithoutSellStockCorrectionItemInput
  }

  export type SellStockCorrectionItemUncheckedCreateWithoutBatchesInput = {
    id?: string
    correctionId: string
    productId: string
    shopId?: string | null
    unitOfMeasureId: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellStockCorrectionItemCreateOrConnectWithoutBatchesInput = {
    where: SellStockCorrectionItemWhereUniqueInput
    create: XOR<SellStockCorrectionItemCreateWithoutBatchesInput, SellStockCorrectionItemUncheckedCreateWithoutBatchesInput>
  }

  export type ProductBatchCreateWithoutSellStockCorrectionBatchInput = {
    id?: string
    batchNumber: string
    expiryDate?: Date | string | null
    price?: number | null
    stock?: number | null
    warningQuantity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store?: StoreCreateNestedOneWithoutProductBatchInput
    product: ProductCreateNestedOneWithoutBatchesInput
    ShopStock?: ShopStockCreateNestedManyWithoutBatchInput
    StoreStock?: StoreStockCreateNestedManyWithoutBatchInput
    StockLedger?: StockLedgerCreateNestedManyWithoutBatchInput
    PurchaseItem?: PurchaseItemCreateNestedManyWithoutBatchInput
    TransferItem?: TransferItemCreateNestedManyWithoutBatchInput
    StockCorrectionItem?: StockCorrectionItemCreateNestedManyWithoutBatchInput
    SellItemBatch?: SellItemBatchCreateNestedManyWithoutBatchInput
  }

  export type ProductBatchUncheckedCreateWithoutSellStockCorrectionBatchInput = {
    id?: string
    batchNumber: string
    expiryDate?: Date | string | null
    productId: string
    price?: number | null
    stock?: number | null
    warningQuantity?: number | null
    storeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutBatchInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutBatchInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutBatchInput
    PurchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutBatchInput
    TransferItem?: TransferItemUncheckedCreateNestedManyWithoutBatchInput
    StockCorrectionItem?: StockCorrectionItemUncheckedCreateNestedManyWithoutBatchInput
    SellItemBatch?: SellItemBatchUncheckedCreateNestedManyWithoutBatchInput
  }

  export type ProductBatchCreateOrConnectWithoutSellStockCorrectionBatchInput = {
    where: ProductBatchWhereUniqueInput
    create: XOR<ProductBatchCreateWithoutSellStockCorrectionBatchInput, ProductBatchUncheckedCreateWithoutSellStockCorrectionBatchInput>
  }

  export type SellStockCorrectionItemUpsertWithoutBatchesInput = {
    update: XOR<SellStockCorrectionItemUpdateWithoutBatchesInput, SellStockCorrectionItemUncheckedUpdateWithoutBatchesInput>
    create: XOR<SellStockCorrectionItemCreateWithoutBatchesInput, SellStockCorrectionItemUncheckedCreateWithoutBatchesInput>
    where?: SellStockCorrectionItemWhereInput
  }

  export type SellStockCorrectionItemUpdateToOneWithWhereWithoutBatchesInput = {
    where?: SellStockCorrectionItemWhereInput
    data: XOR<SellStockCorrectionItemUpdateWithoutBatchesInput, SellStockCorrectionItemUncheckedUpdateWithoutBatchesInput>
  }

  export type SellStockCorrectionItemUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    correction?: SellStockCorrectionUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutSellStockCorrectionItemNestedInput
    shop?: ShopUpdateOneWithoutSellStockCorrectionItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutSellStockCorrectionItemNestedInput
  }

  export type SellStockCorrectionItemUncheckedUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    correctionId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductBatchUpsertWithoutSellStockCorrectionBatchInput = {
    update: XOR<ProductBatchUpdateWithoutSellStockCorrectionBatchInput, ProductBatchUncheckedUpdateWithoutSellStockCorrectionBatchInput>
    create: XOR<ProductBatchCreateWithoutSellStockCorrectionBatchInput, ProductBatchUncheckedCreateWithoutSellStockCorrectionBatchInput>
    where?: ProductBatchWhereInput
  }

  export type ProductBatchUpdateToOneWithWhereWithoutSellStockCorrectionBatchInput = {
    where?: ProductBatchWhereInput
    data: XOR<ProductBatchUpdateWithoutSellStockCorrectionBatchInput, ProductBatchUncheckedUpdateWithoutSellStockCorrectionBatchInput>
  }

  export type ProductBatchUpdateWithoutSellStockCorrectionBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    warningQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneWithoutProductBatchNestedInput
    product?: ProductUpdateOneRequiredWithoutBatchesNestedInput
    ShopStock?: ShopStockUpdateManyWithoutBatchNestedInput
    StoreStock?: StoreStockUpdateManyWithoutBatchNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutBatchNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutBatchNestedInput
    TransferItem?: TransferItemUpdateManyWithoutBatchNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutBatchNestedInput
    SellItemBatch?: SellItemBatchUpdateManyWithoutBatchNestedInput
  }

  export type ProductBatchUncheckedUpdateWithoutSellStockCorrectionBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productId?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    warningQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopStock?: ShopStockUncheckedUpdateManyWithoutBatchNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutBatchNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutBatchNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutBatchNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutBatchNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutBatchNestedInput
    SellItemBatch?: SellItemBatchUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type StoreCreateWithoutNotificationsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutStoreInput
    ProductBatch?: ProductBatchCreateNestedManyWithoutStoreInput
    StoreStock?: StoreStockCreateNestedManyWithoutStoreInput
    StockLedger?: StockLedgerCreateNestedManyWithoutStoreInput
    Purchase?: PurchaseCreateNestedManyWithoutStoreInput
    SourceTransfer?: TransferCreateNestedManyWithoutSourceStoreInput
    DestinatTransfer?: TransferCreateNestedManyWithoutDestStoreInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutStoreInput
    User?: UserCreateNestedManyWithoutStoresInput
  }

  export type StoreUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ProductBatch?: ProductBatchUncheckedCreateNestedManyWithoutStoreInput
    StoreStock?: StoreStockUncheckedCreateNestedManyWithoutStoreInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutStoreInput
    Purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    SourceTransfer?: TransferUncheckedCreateNestedManyWithoutSourceStoreInput
    DestinatTransfer?: TransferUncheckedCreateNestedManyWithoutDestStoreInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutStoreInput
    User?: UserUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoreCreateOrConnectWithoutNotificationsInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutNotificationsInput, StoreUncheckedCreateWithoutNotificationsInput>
  }

  export type ShopCreateWithoutNotificationsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutShopInput
    ShopStock?: ShopStockCreateNestedManyWithoutShopInput
    StockLedger?: StockLedgerCreateNestedManyWithoutShopInput
    SourceTransfer?: TransferCreateNestedManyWithoutSourceShopInput
    DestinatTransfer?: TransferCreateNestedManyWithoutDestShopInput
    StockCorrection?: StockCorrectionCreateNestedManyWithoutShopInput
    AdditionalPrice?: AdditionalPriceCreateNestedManyWithoutShopInput
    SellItem?: SellItemCreateNestedManyWithoutShopInput
    SellStockCorrectionItem?: SellStockCorrectionItemCreateNestedManyWithoutShopInput
    User?: UserCreateNestedManyWithoutShopsInput
    CartItem?: CartItemCreateNestedManyWithoutShopInput
    waitlists?: WaitlistCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    branchId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopStock?: ShopStockUncheckedCreateNestedManyWithoutShopInput
    StockLedger?: StockLedgerUncheckedCreateNestedManyWithoutShopInput
    SourceTransfer?: TransferUncheckedCreateNestedManyWithoutSourceShopInput
    DestinatTransfer?: TransferUncheckedCreateNestedManyWithoutDestShopInput
    StockCorrection?: StockCorrectionUncheckedCreateNestedManyWithoutShopInput
    AdditionalPrice?: AdditionalPriceUncheckedCreateNestedManyWithoutShopInput
    SellItem?: SellItemUncheckedCreateNestedManyWithoutShopInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedCreateNestedManyWithoutShopInput
    User?: UserUncheckedCreateNestedManyWithoutShopsInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutShopInput
    waitlists?: WaitlistUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutNotificationsInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutNotificationsInput, ShopUncheckedCreateWithoutNotificationsInput>
  }

  export type StoreUpsertWithoutNotificationsInput = {
    update: XOR<StoreUpdateWithoutNotificationsInput, StoreUncheckedUpdateWithoutNotificationsInput>
    create: XOR<StoreCreateWithoutNotificationsInput, StoreUncheckedCreateWithoutNotificationsInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutNotificationsInput, StoreUncheckedUpdateWithoutNotificationsInput>
  }

  export type StoreUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStoreNestedInput
    ProductBatch?: ProductBatchUpdateManyWithoutStoreNestedInput
    StoreStock?: StoreStockUpdateManyWithoutStoreNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutStoreNestedInput
    Purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    SourceTransfer?: TransferUpdateManyWithoutSourceStoreNestedInput
    DestinatTransfer?: TransferUpdateManyWithoutDestStoreNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutStoreNestedInput
    User?: UserUpdateManyWithoutStoresNestedInput
  }

  export type StoreUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductBatch?: ProductBatchUncheckedUpdateManyWithoutStoreNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutStoreNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutStoreNestedInput
    Purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    SourceTransfer?: TransferUncheckedUpdateManyWithoutSourceStoreNestedInput
    DestinatTransfer?: TransferUncheckedUpdateManyWithoutDestStoreNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutStoreNestedInput
    User?: UserUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type ShopUpsertWithoutNotificationsInput = {
    update: XOR<ShopUpdateWithoutNotificationsInput, ShopUncheckedUpdateWithoutNotificationsInput>
    create: XOR<ShopCreateWithoutNotificationsInput, ShopUncheckedCreateWithoutNotificationsInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutNotificationsInput, ShopUncheckedUpdateWithoutNotificationsInput>
  }

  export type ShopUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutShopNestedInput
    ShopStock?: ShopStockUpdateManyWithoutShopNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutShopNestedInput
    SourceTransfer?: TransferUpdateManyWithoutSourceShopNestedInput
    DestinatTransfer?: TransferUpdateManyWithoutDestShopNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutShopNestedInput
    AdditionalPrice?: AdditionalPriceUpdateManyWithoutShopNestedInput
    SellItem?: SellItemUpdateManyWithoutShopNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutShopNestedInput
    User?: UserUpdateManyWithoutShopsNestedInput
    CartItem?: CartItemUpdateManyWithoutShopNestedInput
    waitlists?: WaitlistUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopStock?: ShopStockUncheckedUpdateManyWithoutShopNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutShopNestedInput
    SourceTransfer?: TransferUncheckedUpdateManyWithoutSourceShopNestedInput
    DestinatTransfer?: TransferUncheckedUpdateManyWithoutDestShopNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutShopNestedInput
    AdditionalPrice?: AdditionalPriceUncheckedUpdateManyWithoutShopNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutShopNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutShopNestedInput
    User?: UserUncheckedUpdateManyWithoutShopsNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutShopNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutShopNestedInput
  }

  export type LogCreateManyUserInput = {
    id?: string
    action: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockLedgerCreateManyUserInput = {
    id?: string
    invoiceNo?: string | null
    batchId: string
    storeId?: string | null
    shopId?: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    unitOfMeasureId: string
    reference?: string | null
    notes?: string | null
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseCreateManyCreatedByInput = {
    id?: string
    invoiceNo: string
    supplierId: string
    storeId: string
    paymentStatus?: $Enums.PaymentStatus
    totalProducts?: number
    subTotal?: number
    grandTotal?: number
    notes?: string | null
    purchaseDate?: Date | string
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseCreateManyUpdatedByInput = {
    id?: string
    invoiceNo: string
    supplierId: string
    storeId: string
    paymentStatus?: $Enums.PaymentStatus
    totalProducts?: number
    subTotal?: number
    grandTotal?: number
    notes?: string | null
    purchaseDate?: Date | string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateManyCreatedByInput = {
    id?: string
    shortCode: string
    sourceType: $Enums.TransferEntityType
    sourceStoreId?: string | null
    sourceShopId?: string | null
    destinationType: $Enums.TransferEntityType
    destStoreId?: string | null
    destShopId?: string | null
    reference?: string | null
    notes?: string | null
    status?: $Enums.TransferStatus
    movementDate?: Date | string
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateManyUpdatedByInput = {
    id?: string
    shortCode: string
    sourceType: $Enums.TransferEntityType
    sourceStoreId?: string | null
    sourceShopId?: string | null
    destinationType: $Enums.TransferEntityType
    destStoreId?: string | null
    destShopId?: string | null
    reference?: string | null
    notes?: string | null
    status?: $Enums.TransferStatus
    movementDate?: Date | string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockCorrectionCreateManyCreatedByInput = {
    id?: string
    shortCode: string
    storeId?: string | null
    shopId?: string | null
    reason: $Enums.StockCorrectionReason
    status?: $Enums.StockCorrectionStatus
    purchaseId?: string | null
    transferId?: string | null
    reference?: string | null
    notes?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockCorrectionCreateManyUpdatedByInput = {
    id?: string
    shortCode: string
    storeId?: string | null
    shopId?: string | null
    reason: $Enums.StockCorrectionReason
    status?: $Enums.StockCorrectionStatus
    purchaseId?: string | null
    transferId?: string | null
    reference?: string | null
    notes?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellCreateManyCreatedByInput = {
    id?: string
    invoiceNo: string
    saleStatus?: $Enums.SaleStatus
    locked?: boolean
    lockedAt?: Date | string | null
    branchId?: string | null
    customerId?: string | null
    totalProducts?: number
    subTotal?: number
    discount?: number
    vat?: number
    grandTotal?: number
    NetTotal?: number
    notes?: string | null
    saleDate?: Date | string
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellCreateManyUpdatedByInput = {
    id?: string
    invoiceNo: string
    saleStatus?: $Enums.SaleStatus
    locked?: boolean
    lockedAt?: Date | string | null
    branchId?: string | null
    customerId?: string | null
    totalProducts?: number
    subTotal?: number
    discount?: number
    vat?: number
    grandTotal?: number
    NetTotal?: number
    notes?: string | null
    saleDate?: Date | string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellStockCorrectionCreateManyCreatedByInput = {
    id?: string
    sellId?: string | null
    status?: $Enums.SellStockCorrectionStatus
    reference?: string | null
    notes?: string | null
    updatedById?: string | null
    total?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellStockCorrectionCreateManyUpdatedByInput = {
    id?: string
    sellId?: string | null
    status?: $Enums.SellStockCorrectionStatus
    reference?: string | null
    notes?: string | null
    createdById?: string | null
    total?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddToCartCreateManyUserInput = {
    id?: string
    branchId?: string | null
    isCheckedOut?: boolean
    isWaitlist?: boolean
    customerId?: string | null
    totalItems?: number
    totalAmount?: number
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddToCartCreateManyCreatedByInput = {
    id?: string
    userId: string
    branchId?: string | null
    isCheckedOut?: boolean
    isWaitlist?: boolean
    customerId?: string | null
    totalItems?: number
    totalAmount?: number
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddToCartCreateManyUpdatedByInput = {
    id?: string
    userId: string
    branchId?: string | null
    isCheckedOut?: boolean
    isWaitlist?: boolean
    customerId?: string | null
    totalItems?: number
    totalAmount?: number
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaitlistCreateManyUserInput = {
    id?: string
    customerId?: string | null
    branchId?: string | null
    cartId?: string | null
    cartItemId?: string | null
    productId?: string | null
    quantity?: number
    note?: string | null
    shopId?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaitlistCreateManyCreatedByInput = {
    id?: string
    userId?: string | null
    customerId?: string | null
    branchId?: string | null
    cartId?: string | null
    cartItemId?: string | null
    productId?: string | null
    quantity?: number
    note?: string | null
    shopId?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaitlistCreateManyUpdatedByInput = {
    id?: string
    userId?: string | null
    customerId?: string | null
    branchId?: string | null
    cartId?: string | null
    cartItemId?: string | null
    productId?: string | null
    quantity?: number
    note?: string | null
    shopId?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutShopNestedInput
    ShopStock?: ShopStockUpdateManyWithoutShopNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutShopNestedInput
    SourceTransfer?: TransferUpdateManyWithoutSourceShopNestedInput
    DestinatTransfer?: TransferUpdateManyWithoutDestShopNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutShopNestedInput
    AdditionalPrice?: AdditionalPriceUpdateManyWithoutShopNestedInput
    SellItem?: SellItemUpdateManyWithoutShopNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutShopNestedInput
    CartItem?: CartItemUpdateManyWithoutShopNestedInput
    waitlists?: WaitlistUpdateManyWithoutShopNestedInput
    notifications?: NotificationUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopStock?: ShopStockUncheckedUpdateManyWithoutShopNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutShopNestedInput
    SourceTransfer?: TransferUncheckedUpdateManyWithoutSourceShopNestedInput
    DestinatTransfer?: TransferUncheckedUpdateManyWithoutDestShopNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutShopNestedInput
    AdditionalPrice?: AdditionalPriceUncheckedUpdateManyWithoutShopNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutShopNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutShopNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutShopNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutShopNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStoreNestedInput
    ProductBatch?: ProductBatchUpdateManyWithoutStoreNestedInput
    StoreStock?: StoreStockUpdateManyWithoutStoreNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutStoreNestedInput
    Purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    SourceTransfer?: TransferUpdateManyWithoutSourceStoreNestedInput
    DestinatTransfer?: TransferUpdateManyWithoutDestStoreNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutStoreNestedInput
    notifications?: NotificationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductBatch?: ProductBatchUncheckedUpdateManyWithoutStoreNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutStoreNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutStoreNestedInput
    Purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    SourceTransfer?: TransferUncheckedUpdateManyWithoutSourceStoreNestedInput
    DestinatTransfer?: TransferUncheckedUpdateManyWithoutDestStoreNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutStoreNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLedgerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: ProductBatchUpdateOneRequiredWithoutStockLedgerNestedInput
    store?: StoreUpdateOneWithoutStockLedgerNestedInput
    shop?: ShopUpdateOneWithoutStockLedgerNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutStockLedgerNestedInput
  }

  export type StockLedgerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    batchId?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLedgerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    batchId?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseNestedInput
    store?: StoreUpdateOneRequiredWithoutPurchaseNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedPurchaseNestedInput
    items?: PurchaseItemUpdateManyWithoutPurchaseNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseItemUncheckedUpdateManyWithoutPurchaseNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseNestedInput
    store?: StoreUpdateOneRequiredWithoutPurchaseNestedInput
    createdBy?: UserUpdateOneWithoutCreatorPurchaseNestedInput
    items?: PurchaseItemUpdateManyWithoutPurchaseNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseItemUncheckedUpdateManyWithoutPurchaseNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    destinationType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceStore?: StoreUpdateOneWithoutSourceTransferNestedInput
    sourceShop?: ShopUpdateOneWithoutSourceTransferNestedInput
    destStore?: StoreUpdateOneWithoutDestinatTransferNestedInput
    destShop?: ShopUpdateOneWithoutDestinatTransferNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedTransferNestedInput
    items?: TransferItemUpdateManyWithoutTransferNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceShopId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    destStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destShopId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferItemUncheckedUpdateManyWithoutTransferNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceShopId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    destStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destShopId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    destinationType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceStore?: StoreUpdateOneWithoutSourceTransferNestedInput
    sourceShop?: ShopUpdateOneWithoutSourceTransferNestedInput
    destStore?: StoreUpdateOneWithoutDestinatTransferNestedInput
    destShop?: ShopUpdateOneWithoutDestinatTransferNestedInput
    createdBy?: UserUpdateOneWithoutCreatedTransferNestedInput
    items?: TransferItemUpdateManyWithoutTransferNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceShopId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    destStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destShopId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferItemUncheckedUpdateManyWithoutTransferNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceShopId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    destStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destShopId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCorrectionUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    reason?: EnumStockCorrectionReasonFieldUpdateOperationsInput | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFieldUpdateOperationsInput | $Enums.StockCorrectionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneWithoutStockCorrectionNestedInput
    shop?: ShopUpdateOneWithoutStockCorrectionNestedInput
    purchase?: PurchaseUpdateOneWithoutStockCorrectionNestedInput
    transfer?: TransferUpdateOneWithoutStockCorrectionNestedInput
    updatedBy?: UserUpdateOneWithoutUpdateStockCorrectionNestedInput
    items?: StockCorrectionItemUpdateManyWithoutCorrectionNestedInput
  }

  export type StockCorrectionUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: EnumStockCorrectionReasonFieldUpdateOperationsInput | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFieldUpdateOperationsInput | $Enums.StockCorrectionStatus
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    transferId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: StockCorrectionItemUncheckedUpdateManyWithoutCorrectionNestedInput
  }

  export type StockCorrectionUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: EnumStockCorrectionReasonFieldUpdateOperationsInput | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFieldUpdateOperationsInput | $Enums.StockCorrectionStatus
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    transferId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCorrectionUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    reason?: EnumStockCorrectionReasonFieldUpdateOperationsInput | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFieldUpdateOperationsInput | $Enums.StockCorrectionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneWithoutStockCorrectionNestedInput
    shop?: ShopUpdateOneWithoutStockCorrectionNestedInput
    purchase?: PurchaseUpdateOneWithoutStockCorrectionNestedInput
    transfer?: TransferUpdateOneWithoutStockCorrectionNestedInput
    createdBy?: UserUpdateOneWithoutStockCorrectionNestedInput
    items?: StockCorrectionItemUpdateManyWithoutCorrectionNestedInput
  }

  export type StockCorrectionUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: EnumStockCorrectionReasonFieldUpdateOperationsInput | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFieldUpdateOperationsInput | $Enums.StockCorrectionStatus
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    transferId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: StockCorrectionItemUncheckedUpdateManyWithoutCorrectionNestedInput
  }

  export type StockCorrectionUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: EnumStockCorrectionReasonFieldUpdateOperationsInput | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFieldUpdateOperationsInput | $Enums.StockCorrectionStatus
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    transferId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleStatus?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    locked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutSellNestedInput
    customer?: CustomerUpdateOneWithoutSellNestedInput
    updatedBy?: UserUpdateOneWithoutUpdateSellNestedInput
    items?: SellItemUpdateManyWithoutSellNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutSellNestedInput
  }

  export type SellUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleStatus?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    locked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SellItemUncheckedUpdateManyWithoutSellNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutSellNestedInput
  }

  export type SellUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleStatus?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    locked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleStatus?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    locked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutSellNestedInput
    customer?: CustomerUpdateOneWithoutSellNestedInput
    createdBy?: UserUpdateOneWithoutSellNestedInput
    items?: SellItemUpdateManyWithoutSellNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutSellNestedInput
  }

  export type SellUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleStatus?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    locked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SellItemUncheckedUpdateManyWithoutSellNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutSellNestedInput
  }

  export type SellUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleStatus?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    locked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellStockCorrectionUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSellStockCorrectionStatusFieldUpdateOperationsInput | $Enums.SellStockCorrectionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sell?: SellUpdateOneWithoutSellStockCorrectionNestedInput
    updatedBy?: UserUpdateOneWithoutUpdateSellStockCorrectionNestedInput
    items?: SellStockCorrectionItemUpdateManyWithoutCorrectionNestedInput
  }

  export type SellStockCorrectionUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSellStockCorrectionStatusFieldUpdateOperationsInput | $Enums.SellStockCorrectionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SellStockCorrectionItemUncheckedUpdateManyWithoutCorrectionNestedInput
  }

  export type SellStockCorrectionUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSellStockCorrectionStatusFieldUpdateOperationsInput | $Enums.SellStockCorrectionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellStockCorrectionUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSellStockCorrectionStatusFieldUpdateOperationsInput | $Enums.SellStockCorrectionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sell?: SellUpdateOneWithoutSellStockCorrectionNestedInput
    createdBy?: UserUpdateOneWithoutSellStockCorrectionNestedInput
    items?: SellStockCorrectionItemUpdateManyWithoutCorrectionNestedInput
  }

  export type SellStockCorrectionUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSellStockCorrectionStatusFieldUpdateOperationsInput | $Enums.SellStockCorrectionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SellStockCorrectionItemUncheckedUpdateManyWithoutCorrectionNestedInput
  }

  export type SellStockCorrectionUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSellStockCorrectionStatusFieldUpdateOperationsInput | $Enums.SellStockCorrectionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddToCartUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    totalItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutAddToCartNestedInput
    customer?: CustomerUpdateOneWithoutAddToCartNestedInput
    createdBy?: UserUpdateOneWithoutCreatedAddToCartNestedInput
    updatedBy?: UserUpdateOneWithoutAddToCartNestedInput
    items?: CartItemUpdateManyWithoutCartNestedInput
    waitlists?: WaitlistUpdateManyWithoutCartNestedInput
  }

  export type AddToCartUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUncheckedUpdateManyWithoutCartNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutCartNestedInput
  }

  export type AddToCartUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddToCartUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    totalItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAllAddToCartNestedInput
    branch?: BranchUpdateOneWithoutAddToCartNestedInput
    customer?: CustomerUpdateOneWithoutAddToCartNestedInput
    updatedBy?: UserUpdateOneWithoutAddToCartNestedInput
    items?: CartItemUpdateManyWithoutCartNestedInput
    waitlists?: WaitlistUpdateManyWithoutCartNestedInput
  }

  export type AddToCartUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUncheckedUpdateManyWithoutCartNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutCartNestedInput
  }

  export type AddToCartUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddToCartUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    totalItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAllAddToCartNestedInput
    branch?: BranchUpdateOneWithoutAddToCartNestedInput
    customer?: CustomerUpdateOneWithoutAddToCartNestedInput
    createdBy?: UserUpdateOneWithoutCreatedAddToCartNestedInput
    items?: CartItemUpdateManyWithoutCartNestedInput
    waitlists?: WaitlistUpdateManyWithoutCartNestedInput
  }

  export type AddToCartUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUncheckedUpdateManyWithoutCartNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutCartNestedInput
  }

  export type AddToCartUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitlistUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutWaitlistsNestedInput
    branch?: BranchUpdateOneWithoutWaitlistsNestedInput
    cart?: AddToCartUpdateOneWithoutWaitlistsNestedInput
    cartItem?: CartItemUpdateOneWithoutWaitlistsNestedInput
    product?: ProductUpdateOneWithoutWaitlistsNestedInput
    shop?: ShopUpdateOneWithoutWaitlistsNestedInput
    createdBy?: UserUpdateOneWithoutWaitlistsCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutWaitlistsUpdatedNestedInput
  }

  export type WaitlistUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    cartId?: NullableStringFieldUpdateOperationsInput | string | null
    cartItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitlistUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    cartId?: NullableStringFieldUpdateOperationsInput | string | null
    cartItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitlistUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutWaitlistsNestedInput
    customer?: CustomerUpdateOneWithoutWaitlistsNestedInput
    branch?: BranchUpdateOneWithoutWaitlistsNestedInput
    cart?: AddToCartUpdateOneWithoutWaitlistsNestedInput
    cartItem?: CartItemUpdateOneWithoutWaitlistsNestedInput
    product?: ProductUpdateOneWithoutWaitlistsNestedInput
    shop?: ShopUpdateOneWithoutWaitlistsNestedInput
    updatedBy?: UserUpdateOneWithoutWaitlistsUpdatedNestedInput
  }

  export type WaitlistUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    cartId?: NullableStringFieldUpdateOperationsInput | string | null
    cartItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitlistUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    cartId?: NullableStringFieldUpdateOperationsInput | string | null
    cartItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitlistUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutWaitlistsNestedInput
    customer?: CustomerUpdateOneWithoutWaitlistsNestedInput
    branch?: BranchUpdateOneWithoutWaitlistsNestedInput
    cart?: AddToCartUpdateOneWithoutWaitlistsNestedInput
    cartItem?: CartItemUpdateOneWithoutWaitlistsNestedInput
    product?: ProductUpdateOneWithoutWaitlistsNestedInput
    shop?: ShopUpdateOneWithoutWaitlistsNestedInput
    createdBy?: UserUpdateOneWithoutWaitlistsCreatedNestedInput
  }

  export type WaitlistUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    cartId?: NullableStringFieldUpdateOperationsInput | string | null
    cartItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitlistUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    cartId?: NullableStringFieldUpdateOperationsInput | string | null
    cartItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyRoleInput = {
    id?: string
    permissionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyRoleInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    branchId?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type RolePermissionUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: BranchUpdateOneWithoutUserNestedInput
    shops?: ShopUpdateManyWithoutUserNestedInput
    stores?: StoreUpdateManyWithoutUserNestedInput
    Log?: LogUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shops?: ShopUncheckedUpdateManyWithoutUserNestedInput
    stores?: StoreUncheckedUpdateManyWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUncheckedUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUncheckedUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUncheckedUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUncheckedUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUncheckedUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUncheckedUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RolePermissionCreateManyPermissionInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopCreateManyBranchInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreCreateManyBranchInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyBranchInput = {
    id?: string
    name: string
    phone?: string | null
    userCode?: string | null
    email: string
    admin?: boolean
    password: string
    roleId: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type SellCreateManyBranchInput = {
    id?: string
    invoiceNo: string
    saleStatus?: $Enums.SaleStatus
    locked?: boolean
    lockedAt?: Date | string | null
    customerId?: string | null
    totalProducts?: number
    subTotal?: number
    discount?: number
    vat?: number
    grandTotal?: number
    NetTotal?: number
    notes?: string | null
    saleDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddToCartCreateManyBranchInput = {
    id?: string
    userId: string
    isCheckedOut?: boolean
    isWaitlist?: boolean
    customerId?: string | null
    totalItems?: number
    totalAmount?: number
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaitlistCreateManyBranchInput = {
    id?: string
    userId?: string | null
    customerId?: string | null
    cartId?: string | null
    cartItemId?: string | null
    productId?: string | null
    quantity?: number
    note?: string | null
    shopId?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopStock?: ShopStockUpdateManyWithoutShopNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutShopNestedInput
    SourceTransfer?: TransferUpdateManyWithoutSourceShopNestedInput
    DestinatTransfer?: TransferUpdateManyWithoutDestShopNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutShopNestedInput
    AdditionalPrice?: AdditionalPriceUpdateManyWithoutShopNestedInput
    SellItem?: SellItemUpdateManyWithoutShopNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutShopNestedInput
    User?: UserUpdateManyWithoutShopsNestedInput
    CartItem?: CartItemUpdateManyWithoutShopNestedInput
    waitlists?: WaitlistUpdateManyWithoutShopNestedInput
    notifications?: NotificationUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopStock?: ShopStockUncheckedUpdateManyWithoutShopNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutShopNestedInput
    SourceTransfer?: TransferUncheckedUpdateManyWithoutSourceShopNestedInput
    DestinatTransfer?: TransferUncheckedUpdateManyWithoutDestShopNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutShopNestedInput
    AdditionalPrice?: AdditionalPriceUncheckedUpdateManyWithoutShopNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutShopNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutShopNestedInput
    User?: UserUncheckedUpdateManyWithoutShopsNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutShopNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutShopNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductBatch?: ProductBatchUpdateManyWithoutStoreNestedInput
    StoreStock?: StoreStockUpdateManyWithoutStoreNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutStoreNestedInput
    Purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    SourceTransfer?: TransferUpdateManyWithoutSourceStoreNestedInput
    DestinatTransfer?: TransferUpdateManyWithoutDestStoreNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutStoreNestedInput
    User?: UserUpdateManyWithoutStoresNestedInput
    notifications?: NotificationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductBatch?: ProductBatchUncheckedUpdateManyWithoutStoreNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutStoreNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutStoreNestedInput
    Purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    SourceTransfer?: TransferUncheckedUpdateManyWithoutSourceStoreNestedInput
    DestinatTransfer?: TransferUncheckedUpdateManyWithoutDestStoreNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutStoreNestedInput
    User?: UserUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    shops?: ShopUpdateManyWithoutUserNestedInput
    stores?: StoreUpdateManyWithoutUserNestedInput
    Log?: LogUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shops?: ShopUncheckedUpdateManyWithoutUserNestedInput
    stores?: StoreUncheckedUpdateManyWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUncheckedUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUncheckedUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUncheckedUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUncheckedUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUncheckedUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUncheckedUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SellUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleStatus?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    locked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutSellNestedInput
    createdBy?: UserUpdateOneWithoutSellNestedInput
    updatedBy?: UserUpdateOneWithoutUpdateSellNestedInput
    items?: SellItemUpdateManyWithoutSellNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutSellNestedInput
  }

  export type SellUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleStatus?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    locked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SellItemUncheckedUpdateManyWithoutSellNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutSellNestedInput
  }

  export type SellUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleStatus?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    locked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddToCartUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    totalItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAllAddToCartNestedInput
    customer?: CustomerUpdateOneWithoutAddToCartNestedInput
    createdBy?: UserUpdateOneWithoutCreatedAddToCartNestedInput
    updatedBy?: UserUpdateOneWithoutAddToCartNestedInput
    items?: CartItemUpdateManyWithoutCartNestedInput
    waitlists?: WaitlistUpdateManyWithoutCartNestedInput
  }

  export type AddToCartUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUncheckedUpdateManyWithoutCartNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutCartNestedInput
  }

  export type AddToCartUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitlistUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutWaitlistsNestedInput
    customer?: CustomerUpdateOneWithoutWaitlistsNestedInput
    cart?: AddToCartUpdateOneWithoutWaitlistsNestedInput
    cartItem?: CartItemUpdateOneWithoutWaitlistsNestedInput
    product?: ProductUpdateOneWithoutWaitlistsNestedInput
    shop?: ShopUpdateOneWithoutWaitlistsNestedInput
    createdBy?: UserUpdateOneWithoutWaitlistsCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutWaitlistsUpdatedNestedInput
  }

  export type WaitlistUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    cartId?: NullableStringFieldUpdateOperationsInput | string | null
    cartItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitlistUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    cartId?: NullableStringFieldUpdateOperationsInput | string | null
    cartItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopStockCreateManyShopInput = {
    id?: string
    batchId: string
    unitOfMeasureId: string
    quantity: number
    status?: $Enums.StockStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockLedgerCreateManyShopInput = {
    id?: string
    invoiceNo?: string | null
    batchId: string
    storeId?: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    unitOfMeasureId: string
    reference?: string | null
    userId?: string | null
    notes?: string | null
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateManySourceShopInput = {
    id?: string
    shortCode: string
    sourceType: $Enums.TransferEntityType
    sourceStoreId?: string | null
    destinationType: $Enums.TransferEntityType
    destStoreId?: string | null
    destShopId?: string | null
    reference?: string | null
    notes?: string | null
    status?: $Enums.TransferStatus
    movementDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateManyDestShopInput = {
    id?: string
    shortCode: string
    sourceType: $Enums.TransferEntityType
    sourceStoreId?: string | null
    sourceShopId?: string | null
    destinationType: $Enums.TransferEntityType
    destStoreId?: string | null
    reference?: string | null
    notes?: string | null
    status?: $Enums.TransferStatus
    movementDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockCorrectionCreateManyShopInput = {
    id?: string
    shortCode: string
    storeId?: string | null
    reason: $Enums.StockCorrectionReason
    status?: $Enums.StockCorrectionStatus
    purchaseId?: string | null
    transferId?: string | null
    reference?: string | null
    notes?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdditionalPriceCreateManyShopInput = {
    id?: string
    label?: string | null
    price: number
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellItemCreateManyShopInput = {
    id?: string
    sellId: string
    productId: string
    unitOfMeasureId: string
    itemSaleStatus?: $Enums.ItemSaleStatus
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellStockCorrectionItemCreateManyShopInput = {
    id?: string
    correctionId: string
    productId: string
    unitOfMeasureId: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemCreateManyShopInput = {
    id?: string
    cartId: string
    isWaitlist?: boolean
    productId: string
    unitOfMeasureId?: string | null
    quantity: number
    unitPrice?: number
    totalPrice?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaitlistCreateManyShopInput = {
    id?: string
    userId?: string | null
    customerId?: string | null
    branchId?: string | null
    cartId?: string | null
    cartItemId?: string | null
    productId?: string | null
    quantity?: number
    note?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyShopInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    read?: boolean
    relatedEntityType?: $Enums.RelatedEntityType | null
    relatedEntityId?: string | null
    createdAt?: Date | string
    readAt?: Date | string | null
    storeId?: string | null
  }

  export type ShopStockUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: ProductBatchUpdateOneRequiredWithoutShopStockNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutShopStockNestedInput
  }

  export type ShopStockUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopStockUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLedgerUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: ProductBatchUpdateOneRequiredWithoutStockLedgerNestedInput
    store?: StoreUpdateOneWithoutStockLedgerNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutStockLedgerNestedInput
    user?: UserUpdateOneWithoutStockLedgerNestedInput
  }

  export type StockLedgerUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    batchId?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLedgerUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    batchId?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutSourceShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    destinationType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceStore?: StoreUpdateOneWithoutSourceTransferNestedInput
    destStore?: StoreUpdateOneWithoutDestinatTransferNestedInput
    destShop?: ShopUpdateOneWithoutDestinatTransferNestedInput
    createdBy?: UserUpdateOneWithoutCreatedTransferNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedTransferNestedInput
    items?: TransferItemUpdateManyWithoutTransferNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutSourceShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    destStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destShopId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferItemUncheckedUpdateManyWithoutTransferNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutSourceShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    destStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destShopId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutDestShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    destinationType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceStore?: StoreUpdateOneWithoutSourceTransferNestedInput
    sourceShop?: ShopUpdateOneWithoutSourceTransferNestedInput
    destStore?: StoreUpdateOneWithoutDestinatTransferNestedInput
    createdBy?: UserUpdateOneWithoutCreatedTransferNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedTransferNestedInput
    items?: TransferItemUpdateManyWithoutTransferNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutDestShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceShopId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    destStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferItemUncheckedUpdateManyWithoutTransferNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutDestShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceShopId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    destStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCorrectionUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    reason?: EnumStockCorrectionReasonFieldUpdateOperationsInput | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFieldUpdateOperationsInput | $Enums.StockCorrectionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneWithoutStockCorrectionNestedInput
    purchase?: PurchaseUpdateOneWithoutStockCorrectionNestedInput
    transfer?: TransferUpdateOneWithoutStockCorrectionNestedInput
    createdBy?: UserUpdateOneWithoutStockCorrectionNestedInput
    updatedBy?: UserUpdateOneWithoutUpdateStockCorrectionNestedInput
    items?: StockCorrectionItemUpdateManyWithoutCorrectionNestedInput
  }

  export type StockCorrectionUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: EnumStockCorrectionReasonFieldUpdateOperationsInput | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFieldUpdateOperationsInput | $Enums.StockCorrectionStatus
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    transferId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: StockCorrectionItemUncheckedUpdateManyWithoutCorrectionNestedInput
  }

  export type StockCorrectionUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: EnumStockCorrectionReasonFieldUpdateOperationsInput | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFieldUpdateOperationsInput | $Enums.StockCorrectionStatus
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    transferId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdditionalPriceUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutAdditionalPriceNestedInput
  }

  export type AdditionalPriceUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdditionalPriceUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellItemUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemSaleStatus?: EnumItemSaleStatusFieldUpdateOperationsInput | $Enums.ItemSaleStatus
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sell?: SellUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutSellItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutSellItemNestedInput
    batches?: SellItemBatchUpdateManyWithoutSellItemNestedInput
  }

  export type SellItemUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    itemSaleStatus?: EnumItemSaleStatusFieldUpdateOperationsInput | $Enums.ItemSaleStatus
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: SellItemBatchUncheckedUpdateManyWithoutSellItemNestedInput
  }

  export type SellItemUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    itemSaleStatus?: EnumItemSaleStatusFieldUpdateOperationsInput | $Enums.ItemSaleStatus
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellStockCorrectionItemUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    correction?: SellStockCorrectionUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutSellStockCorrectionItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutSellStockCorrectionItemNestedInput
    batches?: SellStockCorrectionBatchUpdateManyWithoutCorrectionItemNestedInput
  }

  export type SellStockCorrectionItemUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    correctionId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: SellStockCorrectionBatchUncheckedUpdateManyWithoutCorrectionItemNestedInput
  }

  export type SellStockCorrectionItemUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    correctionId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutShopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: BranchUpdateOneWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    stores?: StoreUpdateManyWithoutUserNestedInput
    Log?: LogUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutShopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stores?: StoreUncheckedUpdateManyWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUncheckedUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUncheckedUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUncheckedUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUncheckedUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUncheckedUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUncheckedUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutShopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CartItemUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cart?: AddToCartUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutCartItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneWithoutCartItemNestedInput
    waitlists?: WaitlistUpdateManyWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    productId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    waitlists?: WaitlistUncheckedUpdateManyWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    productId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitlistUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutWaitlistsNestedInput
    customer?: CustomerUpdateOneWithoutWaitlistsNestedInput
    branch?: BranchUpdateOneWithoutWaitlistsNestedInput
    cart?: AddToCartUpdateOneWithoutWaitlistsNestedInput
    cartItem?: CartItemUpdateOneWithoutWaitlistsNestedInput
    product?: ProductUpdateOneWithoutWaitlistsNestedInput
    createdBy?: UserUpdateOneWithoutWaitlistsCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutWaitlistsUpdatedNestedInput
  }

  export type WaitlistUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    cartId?: NullableStringFieldUpdateOperationsInput | string | null
    cartItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitlistUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    cartId?: NullableStringFieldUpdateOperationsInput | string | null
    cartItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    relatedEntityType?: NullableEnumRelatedEntityTypeFieldUpdateOperationsInput | $Enums.RelatedEntityType | null
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    store?: StoreUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    relatedEntityType?: NullableEnumRelatedEntityTypeFieldUpdateOperationsInput | $Enums.RelatedEntityType | null
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    relatedEntityType?: NullableEnumRelatedEntityTypeFieldUpdateOperationsInput | $Enums.RelatedEntityType | null
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductBatchCreateManyStoreInput = {
    id?: string
    batchNumber: string
    expiryDate?: Date | string | null
    productId: string
    price?: number | null
    stock?: number | null
    warningQuantity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreStockCreateManyStoreInput = {
    id?: string
    batchId: string
    quantity: number
    status?: $Enums.StockStatus
    unitOfMeasureId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockLedgerCreateManyStoreInput = {
    id?: string
    invoiceNo?: string | null
    batchId: string
    shopId?: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    unitOfMeasureId: string
    reference?: string | null
    userId?: string | null
    notes?: string | null
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseCreateManyStoreInput = {
    id?: string
    invoiceNo: string
    supplierId: string
    paymentStatus?: $Enums.PaymentStatus
    totalProducts?: number
    subTotal?: number
    grandTotal?: number
    notes?: string | null
    purchaseDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateManySourceStoreInput = {
    id?: string
    shortCode: string
    sourceType: $Enums.TransferEntityType
    sourceShopId?: string | null
    destinationType: $Enums.TransferEntityType
    destStoreId?: string | null
    destShopId?: string | null
    reference?: string | null
    notes?: string | null
    status?: $Enums.TransferStatus
    movementDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateManyDestStoreInput = {
    id?: string
    shortCode: string
    sourceType: $Enums.TransferEntityType
    sourceStoreId?: string | null
    sourceShopId?: string | null
    destinationType: $Enums.TransferEntityType
    destShopId?: string | null
    reference?: string | null
    notes?: string | null
    status?: $Enums.TransferStatus
    movementDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockCorrectionCreateManyStoreInput = {
    id?: string
    shortCode: string
    shopId?: string | null
    reason: $Enums.StockCorrectionReason
    status?: $Enums.StockCorrectionStatus
    purchaseId?: string | null
    transferId?: string | null
    reference?: string | null
    notes?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyStoreInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    read?: boolean
    relatedEntityType?: $Enums.RelatedEntityType | null
    relatedEntityId?: string | null
    createdAt?: Date | string
    readAt?: Date | string | null
    shopId?: string | null
  }

  export type ProductBatchUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    warningQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutBatchesNestedInput
    ShopStock?: ShopStockUpdateManyWithoutBatchNestedInput
    StoreStock?: StoreStockUpdateManyWithoutBatchNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutBatchNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutBatchNestedInput
    TransferItem?: TransferItemUpdateManyWithoutBatchNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutBatchNestedInput
    SellItemBatch?: SellItemBatchUpdateManyWithoutBatchNestedInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUpdateManyWithoutBatchNestedInput
  }

  export type ProductBatchUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productId?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    warningQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopStock?: ShopStockUncheckedUpdateManyWithoutBatchNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutBatchNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutBatchNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutBatchNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutBatchNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutBatchNestedInput
    SellItemBatch?: SellItemBatchUncheckedUpdateManyWithoutBatchNestedInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type ProductBatchUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productId?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    warningQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreStockUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: ProductBatchUpdateOneRequiredWithoutStoreStockNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutStoreStockNestedInput
  }

  export type StoreStockUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreStockUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLedgerUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: ProductBatchUpdateOneRequiredWithoutStockLedgerNestedInput
    shop?: ShopUpdateOneWithoutStockLedgerNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutStockLedgerNestedInput
    user?: UserUpdateOneWithoutStockLedgerNestedInput
  }

  export type StockLedgerUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    batchId?: StringFieldUpdateOperationsInput | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLedgerUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    batchId?: StringFieldUpdateOperationsInput | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseNestedInput
    createdBy?: UserUpdateOneWithoutCreatorPurchaseNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedPurchaseNestedInput
    items?: PurchaseItemUpdateManyWithoutPurchaseNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseItemUncheckedUpdateManyWithoutPurchaseNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutSourceStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    destinationType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceShop?: ShopUpdateOneWithoutSourceTransferNestedInput
    destStore?: StoreUpdateOneWithoutDestinatTransferNestedInput
    destShop?: ShopUpdateOneWithoutDestinatTransferNestedInput
    createdBy?: UserUpdateOneWithoutCreatedTransferNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedTransferNestedInput
    items?: TransferItemUpdateManyWithoutTransferNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutSourceStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    sourceShopId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    destStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destShopId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferItemUncheckedUpdateManyWithoutTransferNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutSourceStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    sourceShopId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    destStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destShopId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutDestStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    destinationType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceStore?: StoreUpdateOneWithoutSourceTransferNestedInput
    sourceShop?: ShopUpdateOneWithoutSourceTransferNestedInput
    destShop?: ShopUpdateOneWithoutDestinatTransferNestedInput
    createdBy?: UserUpdateOneWithoutCreatedTransferNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedTransferNestedInput
    items?: TransferItemUpdateManyWithoutTransferNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutDestStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceShopId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    destShopId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferItemUncheckedUpdateManyWithoutTransferNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutDestStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceShopId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationType?: EnumTransferEntityTypeFieldUpdateOperationsInput | $Enums.TransferEntityType
    destShopId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCorrectionUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    reason?: EnumStockCorrectionReasonFieldUpdateOperationsInput | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFieldUpdateOperationsInput | $Enums.StockCorrectionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shop?: ShopUpdateOneWithoutStockCorrectionNestedInput
    purchase?: PurchaseUpdateOneWithoutStockCorrectionNestedInput
    transfer?: TransferUpdateOneWithoutStockCorrectionNestedInput
    createdBy?: UserUpdateOneWithoutStockCorrectionNestedInput
    updatedBy?: UserUpdateOneWithoutUpdateStockCorrectionNestedInput
    items?: StockCorrectionItemUpdateManyWithoutCorrectionNestedInput
  }

  export type StockCorrectionUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: EnumStockCorrectionReasonFieldUpdateOperationsInput | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFieldUpdateOperationsInput | $Enums.StockCorrectionStatus
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    transferId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: StockCorrectionItemUncheckedUpdateManyWithoutCorrectionNestedInput
  }

  export type StockCorrectionUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: EnumStockCorrectionReasonFieldUpdateOperationsInput | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFieldUpdateOperationsInput | $Enums.StockCorrectionStatus
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    transferId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutStoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: BranchUpdateOneWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    shops?: ShopUpdateManyWithoutUserNestedInput
    Log?: LogUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutStoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shops?: ShopUncheckedUpdateManyWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutUserNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutUserNestedInput
    CreatorPurchase?: PurchaseUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedPurchase?: PurchaseUncheckedUpdateManyWithoutUpdatedByNestedInput
    CreatedTransfer?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdatedTransfer?: TransferUncheckedUpdateManyWithoutUpdatedByNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateStockCorrection?: StockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    Sell?: SellUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSell?: SellUncheckedUpdateManyWithoutUpdatedByNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutCreatedByNestedInput
    UpdateSellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutUpdatedByNestedInput
    AllAddToCart?: AddToCartUncheckedUpdateManyWithoutUserNestedInput
    CreatedAddToCart?: AddToCartUncheckedUpdateManyWithoutCreatedByNestedInput
    AddToCart?: AddToCartUncheckedUpdateManyWithoutUpdatedByNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutUserNestedInput
    waitlistsCreated?: WaitlistUncheckedUpdateManyWithoutCreatedByNestedInput
    waitlistsUpdated?: WaitlistUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutStoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    relatedEntityType?: NullableEnumRelatedEntityTypeFieldUpdateOperationsInput | $Enums.RelatedEntityType | null
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shop?: ShopUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    relatedEntityType?: NullableEnumRelatedEntityTypeFieldUpdateOperationsInput | $Enums.RelatedEntityType | null
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    relatedEntityType?: NullableEnumRelatedEntityTypeFieldUpdateOperationsInput | $Enums.RelatedEntityType | null
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SellCreateManyCustomerInput = {
    id?: string
    invoiceNo: string
    saleStatus?: $Enums.SaleStatus
    locked?: boolean
    lockedAt?: Date | string | null
    branchId?: string | null
    totalProducts?: number
    subTotal?: number
    discount?: number
    vat?: number
    grandTotal?: number
    NetTotal?: number
    notes?: string | null
    saleDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddToCartCreateManyCustomerInput = {
    id?: string
    userId: string
    branchId?: string | null
    isCheckedOut?: boolean
    isWaitlist?: boolean
    totalItems?: number
    totalAmount?: number
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaitlistCreateManyCustomerInput = {
    id?: string
    userId?: string | null
    branchId?: string | null
    cartId?: string | null
    cartItemId?: string | null
    productId?: string | null
    quantity?: number
    note?: string | null
    shopId?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleStatus?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    locked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutSellNestedInput
    createdBy?: UserUpdateOneWithoutSellNestedInput
    updatedBy?: UserUpdateOneWithoutUpdateSellNestedInput
    items?: SellItemUpdateManyWithoutSellNestedInput
    SellStockCorrection?: SellStockCorrectionUpdateManyWithoutSellNestedInput
  }

  export type SellUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleStatus?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    locked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SellItemUncheckedUpdateManyWithoutSellNestedInput
    SellStockCorrection?: SellStockCorrectionUncheckedUpdateManyWithoutSellNestedInput
  }

  export type SellUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    saleStatus?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    locked?: BoolFieldUpdateOperationsInput | boolean
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddToCartUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    totalItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAllAddToCartNestedInput
    branch?: BranchUpdateOneWithoutAddToCartNestedInput
    createdBy?: UserUpdateOneWithoutCreatedAddToCartNestedInput
    updatedBy?: UserUpdateOneWithoutAddToCartNestedInput
    items?: CartItemUpdateManyWithoutCartNestedInput
    waitlists?: WaitlistUpdateManyWithoutCartNestedInput
  }

  export type AddToCartUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    totalItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUncheckedUpdateManyWithoutCartNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutCartNestedInput
  }

  export type AddToCartUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    totalItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitlistUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutWaitlistsNestedInput
    branch?: BranchUpdateOneWithoutWaitlistsNestedInput
    cart?: AddToCartUpdateOneWithoutWaitlistsNestedInput
    cartItem?: CartItemUpdateOneWithoutWaitlistsNestedInput
    product?: ProductUpdateOneWithoutWaitlistsNestedInput
    shop?: ShopUpdateOneWithoutWaitlistsNestedInput
    createdBy?: UserUpdateOneWithoutWaitlistsCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutWaitlistsUpdatedNestedInput
  }

  export type WaitlistUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    cartId?: NullableStringFieldUpdateOperationsInput | string | null
    cartItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitlistUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    cartId?: NullableStringFieldUpdateOperationsInput | string | null
    cartItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseCreateManySupplierInput = {
    id?: string
    invoiceNo: string
    storeId: string
    paymentStatus?: $Enums.PaymentStatus
    totalProducts?: number
    subTotal?: number
    grandTotal?: number
    notes?: string | null
    purchaseDate?: Date | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutPurchaseNestedInput
    createdBy?: UserUpdateOneWithoutCreatorPurchaseNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedPurchaseNestedInput
    items?: PurchaseItemUpdateManyWithoutPurchaseNestedInput
    StockCorrection?: StockCorrectionUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseItemUncheckedUpdateManyWithoutPurchaseNestedInput
    StockCorrection?: StockCorrectionUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalProducts?: IntFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyCategoryInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    subCategoryId?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    unitOfMeasureId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubCategoryCreateManyCategoryInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCategory?: SubCategoryUpdateOneWithoutProductsNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutProductsNestedInput
    batches?: ProductBatchUpdateManyWithoutProductNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutProductNestedInput
    TransferItem?: TransferItemUpdateManyWithoutProductNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    AdditionalPrice?: AdditionalPriceUpdateManyWithoutProductNestedInput
    SellItem?: SellItemUpdateManyWithoutProductNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutProductNestedInput
    waitlists?: WaitlistUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: ProductBatchUncheckedUpdateManyWithoutProductNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    AdditionalPrice?: AdditionalPriceUncheckedUpdateManyWithoutProductNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutProductNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutProductNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubCategoryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutSubCategoryNestedInput
  }

  export type SubCategoryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutSubCategoryNestedInput
  }

  export type SubCategoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManySubCategoryInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    categoryId: string
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    unitOfMeasureId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutSubCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutProductsNestedInput
    batches?: ProductBatchUpdateManyWithoutProductNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutProductNestedInput
    TransferItem?: TransferItemUpdateManyWithoutProductNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    AdditionalPrice?: AdditionalPriceUpdateManyWithoutProductNestedInput
    SellItem?: SellItemUpdateManyWithoutProductNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutProductNestedInput
    waitlists?: WaitlistUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSubCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: ProductBatchUncheckedUpdateManyWithoutProductNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    AdditionalPrice?: AdditionalPriceUncheckedUpdateManyWithoutProductNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutProductNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutProductNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutSubCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductBatchCreateManyProductInput = {
    id?: string
    batchNumber: string
    expiryDate?: Date | string | null
    price?: number | null
    stock?: number | null
    warningQuantity?: number | null
    storeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseItemCreateManyProductInput = {
    id?: string
    purchaseId: string
    batchId: string
    unitOfMeasureId: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferItemCreateManyProductInput = {
    id?: string
    transferId: string
    batchId: string
    unitOfMeasureId: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockCorrectionItemCreateManyProductInput = {
    id?: string
    correctionId: string
    batchId?: string | null
    unitOfMeasureId: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemCreateManyProductInput = {
    id?: string
    cartId: string
    isWaitlist?: boolean
    shopId: string
    unitOfMeasureId?: string | null
    quantity: number
    unitPrice?: number
    totalPrice?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdditionalPriceCreateManyProductInput = {
    id?: string
    label?: string | null
    price: number
    shopId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellItemCreateManyProductInput = {
    id?: string
    sellId: string
    shopId: string
    unitOfMeasureId: string
    itemSaleStatus?: $Enums.ItemSaleStatus
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellStockCorrectionItemCreateManyProductInput = {
    id?: string
    correctionId: string
    shopId?: string | null
    unitOfMeasureId: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaitlistCreateManyProductInput = {
    id?: string
    userId?: string | null
    customerId?: string | null
    branchId?: string | null
    cartId?: string | null
    cartItemId?: string | null
    quantity?: number
    note?: string | null
    shopId?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductBatchUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    warningQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneWithoutProductBatchNestedInput
    ShopStock?: ShopStockUpdateManyWithoutBatchNestedInput
    StoreStock?: StoreStockUpdateManyWithoutBatchNestedInput
    StockLedger?: StockLedgerUpdateManyWithoutBatchNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutBatchNestedInput
    TransferItem?: TransferItemUpdateManyWithoutBatchNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutBatchNestedInput
    SellItemBatch?: SellItemBatchUpdateManyWithoutBatchNestedInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUpdateManyWithoutBatchNestedInput
  }

  export type ProductBatchUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    warningQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopStock?: ShopStockUncheckedUpdateManyWithoutBatchNestedInput
    StoreStock?: StoreStockUncheckedUpdateManyWithoutBatchNestedInput
    StockLedger?: StockLedgerUncheckedUpdateManyWithoutBatchNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutBatchNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutBatchNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutBatchNestedInput
    SellItemBatch?: SellItemBatchUncheckedUpdateManyWithoutBatchNestedInput
    SellStockCorrectionBatch?: SellStockCorrectionBatchUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type ProductBatchUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    warningQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutItemsNestedInput
    batch?: ProductBatchUpdateOneRequiredWithoutPurchaseItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutPurchaseItemNestedInput
  }

  export type PurchaseItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transfer?: TransferUpdateOneRequiredWithoutItemsNestedInput
    batch?: ProductBatchUpdateOneRequiredWithoutTransferItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutTransferItemNestedInput
  }

  export type TransferItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCorrectionItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    correction?: StockCorrectionUpdateOneRequiredWithoutItemsNestedInput
    batch?: ProductBatchUpdateOneWithoutStockCorrectionItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutStockCorrectionItemNestedInput
  }

  export type StockCorrectionItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    correctionId?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCorrectionItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    correctionId?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cart?: AddToCartUpdateOneRequiredWithoutItemsNestedInput
    shop?: ShopUpdateOneRequiredWithoutCartItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneWithoutCartItemNestedInput
    waitlists?: WaitlistUpdateManyWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    shopId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    waitlists?: WaitlistUncheckedUpdateManyWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    shopId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdditionalPriceUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shop?: ShopUpdateOneWithoutAdditionalPriceNestedInput
  }

  export type AdditionalPriceUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdditionalPriceUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemSaleStatus?: EnumItemSaleStatusFieldUpdateOperationsInput | $Enums.ItemSaleStatus
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sell?: SellUpdateOneRequiredWithoutItemsNestedInput
    shop?: ShopUpdateOneRequiredWithoutSellItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutSellItemNestedInput
    batches?: SellItemBatchUpdateManyWithoutSellItemNestedInput
  }

  export type SellItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    itemSaleStatus?: EnumItemSaleStatusFieldUpdateOperationsInput | $Enums.ItemSaleStatus
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: SellItemBatchUncheckedUpdateManyWithoutSellItemNestedInput
  }

  export type SellItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    itemSaleStatus?: EnumItemSaleStatusFieldUpdateOperationsInput | $Enums.ItemSaleStatus
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellStockCorrectionItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    correction?: SellStockCorrectionUpdateOneRequiredWithoutItemsNestedInput
    shop?: ShopUpdateOneWithoutSellStockCorrectionItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutSellStockCorrectionItemNestedInput
    batches?: SellStockCorrectionBatchUpdateManyWithoutCorrectionItemNestedInput
  }

  export type SellStockCorrectionItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    correctionId?: StringFieldUpdateOperationsInput | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: SellStockCorrectionBatchUncheckedUpdateManyWithoutCorrectionItemNestedInput
  }

  export type SellStockCorrectionItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    correctionId?: StringFieldUpdateOperationsInput | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitlistUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutWaitlistsNestedInput
    customer?: CustomerUpdateOneWithoutWaitlistsNestedInput
    branch?: BranchUpdateOneWithoutWaitlistsNestedInput
    cart?: AddToCartUpdateOneWithoutWaitlistsNestedInput
    cartItem?: CartItemUpdateOneWithoutWaitlistsNestedInput
    shop?: ShopUpdateOneWithoutWaitlistsNestedInput
    createdBy?: UserUpdateOneWithoutWaitlistsCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutWaitlistsUpdatedNestedInput
  }

  export type WaitlistUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    cartId?: NullableStringFieldUpdateOperationsInput | string | null
    cartItemId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitlistUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    cartId?: NullableStringFieldUpdateOperationsInput | string | null
    cartItemId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopStockCreateManyBatchInput = {
    id?: string
    shopId: string
    unitOfMeasureId: string
    quantity: number
    status?: $Enums.StockStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreStockCreateManyBatchInput = {
    id?: string
    storeId: string
    quantity: number
    status?: $Enums.StockStatus
    unitOfMeasureId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockLedgerCreateManyBatchInput = {
    id?: string
    invoiceNo?: string | null
    storeId?: string | null
    shopId?: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    unitOfMeasureId: string
    reference?: string | null
    userId?: string | null
    notes?: string | null
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseItemCreateManyBatchInput = {
    id?: string
    purchaseId: string
    productId: string
    unitOfMeasureId: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferItemCreateManyBatchInput = {
    id?: string
    transferId: string
    productId: string
    unitOfMeasureId: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockCorrectionItemCreateManyBatchInput = {
    id?: string
    correctionId: string
    productId: string
    unitOfMeasureId: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellItemBatchCreateManyBatchInput = {
    id?: string
    sellItemId: string
    quantity?: number
  }

  export type SellStockCorrectionBatchCreateManyBatchInput = {
    id?: string
    correctionItemId: string
    quantity?: number
  }

  export type ShopStockUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shop?: ShopUpdateOneRequiredWithoutShopStockNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutShopStockNestedInput
  }

  export type ShopStockUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopStockUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreStockUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutStoreStockNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutStoreStockNestedInput
  }

  export type StoreStockUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreStockUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLedgerUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneWithoutStockLedgerNestedInput
    shop?: ShopUpdateOneWithoutStockLedgerNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutStockLedgerNestedInput
    user?: UserUpdateOneWithoutStockLedgerNestedInput
  }

  export type StockLedgerUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLedgerUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchaseItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutPurchaseItemNestedInput
  }

  export type PurchaseItemUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transfer?: TransferUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutTransferItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutTransferItemNestedInput
  }

  export type TransferItemUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCorrectionItemUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    correction?: StockCorrectionUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutStockCorrectionItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutStockCorrectionItemNestedInput
  }

  export type StockCorrectionItemUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    correctionId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCorrectionItemUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    correctionId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellItemBatchUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    sellItem?: SellItemUpdateOneRequiredWithoutBatchesNestedInput
  }

  export type SellItemBatchUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type SellItemBatchUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type SellStockCorrectionBatchUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    correctionItem?: SellStockCorrectionItemUpdateOneRequiredWithoutBatchesNestedInput
  }

  export type SellStockCorrectionBatchUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    correctionItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type SellStockCorrectionBatchUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    correctionItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductCreateManyUnitOfMeasureInput = {
    id?: string
    productCode: string
    name: string
    generic?: string | null
    description?: string | null
    categoryId: string
    subCategoryId?: string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    imageUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseItemCreateManyUnitOfMeasureInput = {
    id?: string
    purchaseId: string
    productId: string
    batchId: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferItemCreateManyUnitOfMeasureInput = {
    id?: string
    transferId: string
    productId: string
    batchId: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockLedgerCreateManyUnitOfMeasureInput = {
    id?: string
    invoiceNo?: string | null
    batchId: string
    storeId?: string | null
    shopId?: string | null
    movementType: $Enums.StockMovementType
    quantity: number
    reference?: string | null
    userId?: string | null
    notes?: string | null
    movementDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopStockCreateManyUnitOfMeasureInput = {
    id?: string
    shopId: string
    batchId: string
    quantity: number
    status?: $Enums.StockStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreStockCreateManyUnitOfMeasureInput = {
    id?: string
    storeId: string
    batchId: string
    quantity: number
    status?: $Enums.StockStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockCorrectionItemCreateManyUnitOfMeasureInput = {
    id?: string
    correctionId: string
    productId: string
    batchId?: string | null
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellItemCreateManyUnitOfMeasureInput = {
    id?: string
    sellId: string
    productId: string
    shopId: string
    itemSaleStatus?: $Enums.ItemSaleStatus
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellStockCorrectionItemCreateManyUnitOfMeasureInput = {
    id?: string
    correctionId: string
    productId: string
    shopId?: string | null
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemCreateManyUnitOfMeasureInput = {
    id?: string
    cartId: string
    isWaitlist?: boolean
    shopId: string
    productId: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    subCategory?: SubCategoryUpdateOneWithoutProductsNestedInput
    batches?: ProductBatchUpdateManyWithoutProductNestedInput
    PurchaseItem?: PurchaseItemUpdateManyWithoutProductNestedInput
    TransferItem?: TransferItemUpdateManyWithoutProductNestedInput
    StockCorrectionItem?: StockCorrectionItemUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    AdditionalPrice?: AdditionalPriceUpdateManyWithoutProductNestedInput
    SellItem?: SellItemUpdateManyWithoutProductNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUpdateManyWithoutProductNestedInput
    waitlists?: WaitlistUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    subCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: ProductBatchUncheckedUpdateManyWithoutProductNestedInput
    PurchaseItem?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    TransferItem?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
    StockCorrectionItem?: StockCorrectionItemUncheckedUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    AdditionalPrice?: AdditionalPriceUncheckedUpdateManyWithoutProductNestedInput
    SellItem?: SellItemUncheckedUpdateManyWithoutProductNestedInput
    SellStockCorrectionItem?: SellStockCorrectionItemUncheckedUpdateManyWithoutProductNestedInput
    waitlists?: WaitlistUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generic?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    subCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemUpdateWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchaseItemNestedInput
    batch?: ProductBatchUpdateOneRequiredWithoutPurchaseItemNestedInput
  }

  export type PurchaseItemUncheckedUpdateWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemUncheckedUpdateManyWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemUpdateWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transfer?: TransferUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutTransferItemNestedInput
    batch?: ProductBatchUpdateOneRequiredWithoutTransferItemNestedInput
  }

  export type TransferItemUncheckedUpdateWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemUncheckedUpdateManyWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLedgerUpdateWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: ProductBatchUpdateOneRequiredWithoutStockLedgerNestedInput
    store?: StoreUpdateOneWithoutStockLedgerNestedInput
    shop?: ShopUpdateOneWithoutStockLedgerNestedInput
    user?: UserUpdateOneWithoutStockLedgerNestedInput
  }

  export type StockLedgerUncheckedUpdateWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    batchId?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLedgerUncheckedUpdateManyWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    batchId?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopStockUpdateWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shop?: ShopUpdateOneRequiredWithoutShopStockNestedInput
    batch?: ProductBatchUpdateOneRequiredWithoutShopStockNestedInput
  }

  export type ShopStockUncheckedUpdateWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopStockUncheckedUpdateManyWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreStockUpdateWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutStoreStockNestedInput
    batch?: ProductBatchUpdateOneRequiredWithoutStoreStockNestedInput
  }

  export type StoreStockUncheckedUpdateWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreStockUncheckedUpdateManyWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStockStatusFieldUpdateOperationsInput | $Enums.StockStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCorrectionItemUpdateWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    correction?: StockCorrectionUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutStockCorrectionItemNestedInput
    batch?: ProductBatchUpdateOneWithoutStockCorrectionItemNestedInput
  }

  export type StockCorrectionItemUncheckedUpdateWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    correctionId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCorrectionItemUncheckedUpdateManyWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    correctionId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellItemUpdateWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemSaleStatus?: EnumItemSaleStatusFieldUpdateOperationsInput | $Enums.ItemSaleStatus
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sell?: SellUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutSellItemNestedInput
    shop?: ShopUpdateOneRequiredWithoutSellItemNestedInput
    batches?: SellItemBatchUpdateManyWithoutSellItemNestedInput
  }

  export type SellItemUncheckedUpdateWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    itemSaleStatus?: EnumItemSaleStatusFieldUpdateOperationsInput | $Enums.ItemSaleStatus
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: SellItemBatchUncheckedUpdateManyWithoutSellItemNestedInput
  }

  export type SellItemUncheckedUpdateManyWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    itemSaleStatus?: EnumItemSaleStatusFieldUpdateOperationsInput | $Enums.ItemSaleStatus
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellStockCorrectionItemUpdateWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    correction?: SellStockCorrectionUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutSellStockCorrectionItemNestedInput
    shop?: ShopUpdateOneWithoutSellStockCorrectionItemNestedInput
    batches?: SellStockCorrectionBatchUpdateManyWithoutCorrectionItemNestedInput
  }

  export type SellStockCorrectionItemUncheckedUpdateWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    correctionId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: SellStockCorrectionBatchUncheckedUpdateManyWithoutCorrectionItemNestedInput
  }

  export type SellStockCorrectionItemUncheckedUpdateManyWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    correctionId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUpdateWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cart?: AddToCartUpdateOneRequiredWithoutItemsNestedInput
    shop?: ShopUpdateOneRequiredWithoutCartItemNestedInput
    product?: ProductUpdateOneRequiredWithoutCartItemNestedInput
    waitlists?: WaitlistUpdateManyWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    shopId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    waitlists?: WaitlistUncheckedUpdateManyWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateManyWithoutUnitOfMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    shopId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemCreateManyPurchaseInput = {
    id?: string
    productId: string
    batchId: string
    unitOfMeasureId: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockCorrectionCreateManyPurchaseInput = {
    id?: string
    shortCode: string
    storeId?: string | null
    shopId?: string | null
    reason: $Enums.StockCorrectionReason
    status?: $Enums.StockCorrectionStatus
    transferId?: string | null
    reference?: string | null
    notes?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseItemUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutPurchaseItemNestedInput
    batch?: ProductBatchUpdateOneRequiredWithoutPurchaseItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutPurchaseItemNestedInput
  }

  export type PurchaseItemUncheckedUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemUncheckedUpdateManyWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCorrectionUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    reason?: EnumStockCorrectionReasonFieldUpdateOperationsInput | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFieldUpdateOperationsInput | $Enums.StockCorrectionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneWithoutStockCorrectionNestedInput
    shop?: ShopUpdateOneWithoutStockCorrectionNestedInput
    transfer?: TransferUpdateOneWithoutStockCorrectionNestedInput
    createdBy?: UserUpdateOneWithoutStockCorrectionNestedInput
    updatedBy?: UserUpdateOneWithoutUpdateStockCorrectionNestedInput
    items?: StockCorrectionItemUpdateManyWithoutCorrectionNestedInput
  }

  export type StockCorrectionUncheckedUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: EnumStockCorrectionReasonFieldUpdateOperationsInput | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFieldUpdateOperationsInput | $Enums.StockCorrectionStatus
    transferId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: StockCorrectionItemUncheckedUpdateManyWithoutCorrectionNestedInput
  }

  export type StockCorrectionUncheckedUpdateManyWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: EnumStockCorrectionReasonFieldUpdateOperationsInput | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFieldUpdateOperationsInput | $Enums.StockCorrectionStatus
    transferId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemCreateManyTransferInput = {
    id?: string
    productId: string
    batchId: string
    unitOfMeasureId: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockCorrectionCreateManyTransferInput = {
    id?: string
    shortCode: string
    storeId?: string | null
    shopId?: string | null
    reason: $Enums.StockCorrectionReason
    status?: $Enums.StockCorrectionStatus
    purchaseId?: string | null
    reference?: string | null
    notes?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferItemUpdateWithoutTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutTransferItemNestedInput
    batch?: ProductBatchUpdateOneRequiredWithoutTransferItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutTransferItemNestedInput
  }

  export type TransferItemUncheckedUpdateWithoutTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemUncheckedUpdateManyWithoutTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCorrectionUpdateWithoutTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    reason?: EnumStockCorrectionReasonFieldUpdateOperationsInput | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFieldUpdateOperationsInput | $Enums.StockCorrectionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneWithoutStockCorrectionNestedInput
    shop?: ShopUpdateOneWithoutStockCorrectionNestedInput
    purchase?: PurchaseUpdateOneWithoutStockCorrectionNestedInput
    createdBy?: UserUpdateOneWithoutStockCorrectionNestedInput
    updatedBy?: UserUpdateOneWithoutUpdateStockCorrectionNestedInput
    items?: StockCorrectionItemUpdateManyWithoutCorrectionNestedInput
  }

  export type StockCorrectionUncheckedUpdateWithoutTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: EnumStockCorrectionReasonFieldUpdateOperationsInput | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFieldUpdateOperationsInput | $Enums.StockCorrectionStatus
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: StockCorrectionItemUncheckedUpdateManyWithoutCorrectionNestedInput
  }

  export type StockCorrectionUncheckedUpdateManyWithoutTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: EnumStockCorrectionReasonFieldUpdateOperationsInput | $Enums.StockCorrectionReason
    status?: EnumStockCorrectionStatusFieldUpdateOperationsInput | $Enums.StockCorrectionStatus
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCorrectionItemCreateManyCorrectionInput = {
    id?: string
    productId: string
    batchId?: string | null
    unitOfMeasureId: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockCorrectionItemUpdateWithoutCorrectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStockCorrectionItemNestedInput
    batch?: ProductBatchUpdateOneWithoutStockCorrectionItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutStockCorrectionItemNestedInput
  }

  export type StockCorrectionItemUncheckedUpdateWithoutCorrectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCorrectionItemUncheckedUpdateManyWithoutCorrectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellItemCreateManySellInput = {
    id?: string
    productId: string
    shopId: string
    unitOfMeasureId: string
    itemSaleStatus?: $Enums.ItemSaleStatus
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellStockCorrectionCreateManySellInput = {
    id?: string
    status?: $Enums.SellStockCorrectionStatus
    reference?: string | null
    notes?: string | null
    createdById?: string | null
    updatedById?: string | null
    total?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellItemUpdateWithoutSellInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemSaleStatus?: EnumItemSaleStatusFieldUpdateOperationsInput | $Enums.ItemSaleStatus
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutSellItemNestedInput
    shop?: ShopUpdateOneRequiredWithoutSellItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutSellItemNestedInput
    batches?: SellItemBatchUpdateManyWithoutSellItemNestedInput
  }

  export type SellItemUncheckedUpdateWithoutSellInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    itemSaleStatus?: EnumItemSaleStatusFieldUpdateOperationsInput | $Enums.ItemSaleStatus
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: SellItemBatchUncheckedUpdateManyWithoutSellItemNestedInput
  }

  export type SellItemUncheckedUpdateManyWithoutSellInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    itemSaleStatus?: EnumItemSaleStatusFieldUpdateOperationsInput | $Enums.ItemSaleStatus
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellStockCorrectionUpdateWithoutSellInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSellStockCorrectionStatusFieldUpdateOperationsInput | $Enums.SellStockCorrectionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutSellStockCorrectionNestedInput
    updatedBy?: UserUpdateOneWithoutUpdateSellStockCorrectionNestedInput
    items?: SellStockCorrectionItemUpdateManyWithoutCorrectionNestedInput
  }

  export type SellStockCorrectionUncheckedUpdateWithoutSellInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSellStockCorrectionStatusFieldUpdateOperationsInput | $Enums.SellStockCorrectionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SellStockCorrectionItemUncheckedUpdateManyWithoutCorrectionNestedInput
  }

  export type SellStockCorrectionUncheckedUpdateManyWithoutSellInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSellStockCorrectionStatusFieldUpdateOperationsInput | $Enums.SellStockCorrectionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellItemBatchCreateManySellItemInput = {
    id?: string
    batchId: string
    quantity?: number
  }

  export type SellItemBatchUpdateWithoutSellItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    batch?: ProductBatchUpdateOneRequiredWithoutSellItemBatchNestedInput
  }

  export type SellItemBatchUncheckedUpdateWithoutSellItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type SellItemBatchUncheckedUpdateManyWithoutSellItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type CartItemCreateManyCartInput = {
    id?: string
    isWaitlist?: boolean
    shopId: string
    productId: string
    unitOfMeasureId?: string | null
    quantity: number
    unitPrice?: number
    totalPrice?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaitlistCreateManyCartInput = {
    id?: string
    userId?: string | null
    customerId?: string | null
    branchId?: string | null
    cartItemId?: string | null
    productId?: string | null
    quantity?: number
    note?: string | null
    shopId?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shop?: ShopUpdateOneRequiredWithoutCartItemNestedInput
    product?: ProductUpdateOneRequiredWithoutCartItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneWithoutCartItemNestedInput
    waitlists?: WaitlistUpdateManyWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    shopId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    waitlists?: WaitlistUncheckedUpdateManyWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateManyWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    isWaitlist?: BoolFieldUpdateOperationsInput | boolean
    shopId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    unitOfMeasureId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitlistUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutWaitlistsNestedInput
    customer?: CustomerUpdateOneWithoutWaitlistsNestedInput
    branch?: BranchUpdateOneWithoutWaitlistsNestedInput
    cartItem?: CartItemUpdateOneWithoutWaitlistsNestedInput
    product?: ProductUpdateOneWithoutWaitlistsNestedInput
    shop?: ShopUpdateOneWithoutWaitlistsNestedInput
    createdBy?: UserUpdateOneWithoutWaitlistsCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutWaitlistsUpdatedNestedInput
  }

  export type WaitlistUncheckedUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    cartItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitlistUncheckedUpdateManyWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    cartItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitlistCreateManyCartItemInput = {
    id?: string
    userId?: string | null
    customerId?: string | null
    branchId?: string | null
    cartId?: string | null
    productId?: string | null
    quantity?: number
    note?: string | null
    shopId?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaitlistUpdateWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutWaitlistsNestedInput
    customer?: CustomerUpdateOneWithoutWaitlistsNestedInput
    branch?: BranchUpdateOneWithoutWaitlistsNestedInput
    cart?: AddToCartUpdateOneWithoutWaitlistsNestedInput
    product?: ProductUpdateOneWithoutWaitlistsNestedInput
    shop?: ShopUpdateOneWithoutWaitlistsNestedInput
    createdBy?: UserUpdateOneWithoutWaitlistsCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutWaitlistsUpdatedNestedInput
  }

  export type WaitlistUncheckedUpdateWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    cartId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitlistUncheckedUpdateManyWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    cartId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellStockCorrectionItemCreateManyCorrectionInput = {
    id?: string
    productId: string
    shopId?: string | null
    unitOfMeasureId: string
    quantity: number
    unitPrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellStockCorrectionItemUpdateWithoutCorrectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutSellStockCorrectionItemNestedInput
    shop?: ShopUpdateOneWithoutSellStockCorrectionItemNestedInput
    unitOfMeasure?: UnitOfMeasureUpdateOneRequiredWithoutSellStockCorrectionItemNestedInput
    batches?: SellStockCorrectionBatchUpdateManyWithoutCorrectionItemNestedInput
  }

  export type SellStockCorrectionItemUncheckedUpdateWithoutCorrectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: SellStockCorrectionBatchUncheckedUpdateManyWithoutCorrectionItemNestedInput
  }

  export type SellStockCorrectionItemUncheckedUpdateManyWithoutCorrectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasureId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellStockCorrectionBatchCreateManyCorrectionItemInput = {
    id?: string
    batchId: string
    quantity?: number
  }

  export type SellStockCorrectionBatchUpdateWithoutCorrectionItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    batch?: ProductBatchUpdateOneRequiredWithoutSellStockCorrectionBatchNestedInput
  }

  export type SellStockCorrectionBatchUncheckedUpdateWithoutCorrectionItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type SellStockCorrectionBatchUncheckedUpdateManyWithoutCorrectionItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}